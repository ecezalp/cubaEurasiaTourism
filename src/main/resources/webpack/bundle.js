/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 42);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(43);
} else {
  module.exports = __webpack_require__(44);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(56)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(57)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__ = __webpack_require__(55);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__HashRouter__ = __webpack_require__(59);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return __WEBPACK_IMPORTED_MODULE_1__HashRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Link__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return __WEBPACK_IMPORTED_MODULE_2__Link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__ = __webpack_require__(61);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NavLink__ = __webpack_require__(64);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return __WEBPACK_IMPORTED_MODULE_4__NavLink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Prompt__ = __webpack_require__(67);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return __WEBPACK_IMPORTED_MODULE_5__Prompt__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Redirect__ = __webpack_require__(69);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return __WEBPACK_IMPORTED_MODULE_6__Redirect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Route__ = __webpack_require__(32);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return __WEBPACK_IMPORTED_MODULE_7__Route__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Router__ = __webpack_require__(18);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return __WEBPACK_IMPORTED_MODULE_8__Router__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__StaticRouter__ = __webpack_require__(75);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return __WEBPACK_IMPORTED_MODULE_9__StaticRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Switch__ = __webpack_require__(77);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return __WEBPACK_IMPORTED_MODULE_10__Switch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__matchPath__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return __WEBPACK_IMPORTED_MODULE_11__matchPath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__withRouter__ = __webpack_require__(80);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return __WEBPACK_IMPORTED_MODULE_12__withRouter__["a"]; });



























/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(5);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return locationsAreEqual; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_resolve_pathname__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_value_equal__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PathUtils__ = __webpack_require__(10);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(__WEBPACK_IMPORTED_MODULE_2__PathUtils__["d" /* parsePath */])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(__WEBPACK_IMPORTED_MODULE_0_resolve_pathname__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(__WEBPACK_IMPORTED_MODULE_1_value_equal__["default"])(a.state, b.state);
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(7);
  var warning = __webpack_require__(12);
  var ReactPropTypesSecret = __webpack_require__(15);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__(28);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(29);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__ = __webpack_require__(19);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__["a" /* default */]);

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(children == null || __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null;
  };

  return Router;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Router.propTypes = {
  history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node
};
Router.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Router.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Router);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ __webpack_exports__["a"] = (matchPath);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["a"] = (createTransitionManager);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(5);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(47);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Link.propTypes = {
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired,
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      createHref: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Link);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__ = __webpack_require__(33);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__["a" /* default */]);

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(20);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var isEmptyChildren = function isEmptyChildren(children) {
  return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null : null;
  };

  return Route;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Route.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object, // private, from <Switch>
  path: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  exact: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  sensitive: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  component: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  render: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node]),
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Route.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    route: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
  })
};
Route.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Route);

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/4RCgRXhpZgAATU0AKgAAAAgABAE7AAIAAAAPAAAISodpAAQAAAABAAAIWpydAAEAAAAeAAAQeuocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGF1dGhvcml6ZWR1c2VyAAAAAeocAAcAAAgMAAAIbAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYQB1AHQAaABvAHIAaQB6AGUAZAB1AHMAZQByAAAA/+EKZ2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iLz48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+PGRjOmNyZWF0b3I+PHJkZjpTZXEgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOmxpPmF1dGhvcml6ZWR1c2VyPC9yZGY6bGk+PC9yZGY6U2VxPg0KCQkJPC9kYzpjcmVhdG9yPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMABwUFBgUEBwYFBggHBwgKEQsKCQkKFQ8QDBEYFRoZGBUYFxseJyEbHSUdFxgiLiIlKCkrLCsaIC8zLyoyJyorKv/bAEMBBwgICgkKFAsLFCocGBwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKv/AABEIAv4EqwMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUm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"

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/4RD4RXhpZgAATU0AKgAAAAgABAE7AAIAAAAPAAAISodpAAQAAAABAAAIWpydAAEAAAAeAAAQ0uocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGF1dGhvcml6ZWR1c2VyAAAABZADAAIAAAAUAAAQqJAEAAIAAAAUAAAQvJKRAAIAAAADNTYAAJKSAAIAAAADNTYAAOocAAcAAAgMAAAInAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMTg6MDE6MDcgMTQ6MzA6MzUAMjAxODowMTowNyAxNDozMDozNQAAAGEAdQB0AGgAbwByAGkAegBlAGQAdQBzAGUAcgAAAP/hCyFodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDE4LTAxLTA3VDE0OjMwOjM1LjU1NzwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5hdXRob3JpemVkdXNlcjwvcmRmOmxpPjwvcmRmOlNlcT4NCgkJCTwvZGM6Y3JlYXRvcj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/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UgNIop1JigaG0Zp2KMUD0G5op2KQigBBRSgUEUAJSY9aXFGKAEwKMClooATAo2ilooATbRgUtGKBiYFG30pcUYoAZRmn4oxQAzNGafijFADM0Zp+KNtADaSlNJQAUUUUAFFFFABQBRRQAUEZoooATbRtpaKAAcUEZoooATbRtpaKAE20baWigBNtG2nUlACbaKWigDXoooqyAoxRRQAUHpRRQA2inYoxQA2inYpMUAJRS4oxQAlFFFACUvFFJmgBeKOKTNGaAAjim4p2aKAG4NHSn00rQA2il2mjaaAEopaKAExQfaiigBMUYpaKAG0UuKMUAJQaXFIeKACiiigAxRRRSAaQc0mDT8UYoAZiinGk20AJRRiigApMUtFADSKMU6iiwDaKdSEZoASilxSYoASiiigAxRiiigAIpuKdRwfakA3BpKfgetIV9KQDaKcFoIoGNopdtG00AJRS7aMUDEooooAMCkIpaKBiYoNLRQA3FJin4ooENop1GKAG0U7FGKBjaKUijFACUUuKMUAJRS4oxQAlJinYoxQA3FGKdtpCMUAJijFLRQAmKMUUtACYoxS0UAJijFLRQAmKMUtFACHpTcGn0n40ANxSilx70UANwd1Oo/GloATFFLRQBq7aCMCnUmKogZRTsUYoAbRTsUYpgNop2KMUANzRSkc0mKACiiigAIzSbaWigBCMU3PtT+tJigBufajPtTsUYoAbn2op2KMUAJRRRQAn5flR+X5UtFACEUm2nUUAMpKfijFADKKcwpKAEopaSgApCM0tFACFcUn4U6jFADM+1Gfan4oxQA3NFLikoAKP89KKKAA03bTqKAG7PekIxT6QjNADaKdijFADaKcRTaACiiigBu3NG2nUUAN20badRQA3bik/Cn0mKlgN/CinYoxSAbminEU2gAox/nFFFABQRS0YoAbto206koGhNtG2looGIVptPoxQMZRT8UYoAZRTsUYoENop+KMUDGUU/bTTQAlFGKMUAFFGKMUAFFGKMUAFIRmlxRigBNtLRijFACYo20uKMUAJto207FJQAm2jbS0YoATbRtpaKAE20baWigBNtG2looATbRtpaKAE20UtFAGpijFLijFMgTFGKXFG2gBMUYpcUnFK4BijFHFHFFwDFFHFHFFwGgHNKRS/jRRcBuDRg0+incCPHtRTyM03aaYCUUuKSgAooxRimAYoxRiigBuKTFPoIoAbRSgUEUANzS0YooASilooASm4PpTqWgBmKKfTSKAG0UuKMe9ACUUuPejFACUYpaMUAJijFLSUAIRRilooAbRTsUmKAEopcUYoASkx6UtFACYNGDS0UAJg0hFOoxQAzB9KMH0p9FADMH0oxT6QjNADaKXbRt9xUAJRxS7aQjFABxRxRRQAUhpaKAG4oxTqKBjcUYpaKBiYoxTqKAGEUU6jFAriUlOxSbaAEopcUYoGJRS4oxQMSilxRQISiiigYUUUUAFFFFABRRRQAUUUUAFNxzTqXigBuKWiigBCtJg+lOo/GgBmD6UYPpT/AMaPxoAZg+lGD6U/8aPxoAZg+lKAc9Kd+NH40AGKKKKANSiiiggKKKKAEIzSbadRQA3bRtp1FADdtG2nUUANxRilxS4oAbikxT8UmKAG4oxRijFMApCuaXFFACbaNtLijFFwE20mKdigihAMop2KMUwG0U5hTaACk20tFMBNtG2looAZilp1GKAG0U7FNNACYoxS0UAJiggGlpMUAJtoxilooAbSU7FGKAG0U7FBHFADaKKKACgiiloAbto206koATbSdKdRigBtFOxRigBtFOxRigBtFO7U2gAoxRRUgFBGaKKAGlaNvvTutJSATb70bfelooATb70baWlFAxhpBUmKTFADaKdijFAhtFOxRigBtGKdijFADMUU/FMPWgoKKMUUAHSkxS0YoATFGKXFGKBiYo20uKMYoATbRtpaKBCbaNtOpKAE20baWloGN20badRQIbto206igBu2jbTqKBjcUbaXFFACYo20tHNACbaMUtGKAE20U6igDUxRiiiggKKKKAGkUYp1FADcUYp1FADOlFKRmjaaAEopdpo2mgBKKXaaNpoATijiiigA4phHpT6TFADcUuKXFBFACUUbaNtMAoo20baAEoxRiigBMUmKfikxTAbijFOxRigBuKMYp2KCMimAyil2mjaaQCYoxRRQAYpCPSlopgMxRin4oxQAylHSlIpNtABijFG2jbQAbaTFLtoxigBMUYpaKAGYoxT6TFADcUYp2KKAG4pKfTcUAFGKMUuKAExRilxRikA3FGKUikoAMUYoooAMUhFLRSAaRRinYoxSAbijBp2KMUANwaOnWnYoIoAbRS7aTbQAUUbaNtABRRto20AFJinbaTbQNCYFGKXbRjFAxMUuKKKADFGKKKBhijFFFACYoxS0UCGEelOApaKAEI4poFPoxQAzFGKfRQIZiin4pdpoGhgFOxRilwTQMSkp+00bcUBZjdtGDTwM0baLlpDNtJipNtJtqLj5RuKKdtopXDlZobaNtOorQwG7aNtOooAYeKM04jNJtoATNGaXbRtoATIopdtJigAooooAKKKKAGlfejb706igBu33pKfSEUANop2B6UYHpQA2inbaaRigAooooATFJtp1FACbaQjFOoxmgBlFOxRimA2inYpDxQAlFHFFACYpNnvTqKAG7Pejb706ihAMxRTse1GB6UwG0U7A9KMD0pgNooPWikAUEUUUAJtpNtOopgN20badRQA3GKQ04ijbQA2inbaNtADaKdtpCMUAJRS0UgExmk2+9OooAbt96NvvTqKQDdvvRt96dRSAbt96QinGigBtFKRRj2/WgBKKXHt+tGPb9aAEopce360Y9v1oASilx7frRj2/WgBKKMUoFAxtFKRzRQAlIRmlooGJto206igY3bRtp1JQAm2jbS0tADdtG2lopgJto20tFMQm2jbTgM0u2oukUk2M20bakCetLsqXUSL5GRhaXBqYJRsrN1DRUyILmnAYFSBcUYpe0KVMjxSFc1Ltox7UucagRBKXbUmBRtqua4cqGYoxT8D0pMUcyDkG4opaKLi5WXMUU/8AGjFbnEMopSCaTaaAEopcNRtagAoowRRQAUmKWkxQAYFGBRijFABgUmBS4ooAbS4pfwoxQAmKMUuKMUANxRijbRtoAKMZo20UAJtHpRtHpS0UAMI9KKdj3ox70ANop2PegigBtFLg0YNACUhxTsGk2tQA3ApcCl2mkIxQAYFBHpS4pcUAR0Yp+KMUAMxRinYpe1O4DMUYpdtG007gNIHpRgelOwaMGlcBu0elG0elOwaTGKAE2j0o28cUtFO4DcGjFOo/Gi4DcUYp340fjRcBuKMGnfjRRcBlGKcRzxSbTSuAmBRgUu00bTRcBMCkwKdtNGPWgBuBS4FGKKQCEUmKdijFACYpMU7FGKAG4pcUuKMUAJijFLxRxQAmKSnEelNxQAuKQijbRtoGIRQKUrRsoAQgUmB6U7bRtoCw3A9KMD0p200mKB2EwKMClooGIRSYp1H40wG4NL2p2KNhPvUuSirsFFt6EdKBmrKWzOuKlWzx1rlqYulD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"

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/4RD4RXhpZgAATU0AKgAAAAgABAE7AAIAAAAPAAAISodpAAQAAAABAAAIWpydAAEAAAAeAAAQ0uocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGF1dGhvcml6ZWR1c2VyAAAABZADAAIAAAAUAAAQqJAEAAIAAAAUAAAQvJKRAAIAAAADNDYAAJKSAAIAAAADNDYAAOocAAcAAAgMAAAInAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMTg6MDE6MDcgMTQ6Mjk6NDEAMjAxODowMTowNyAxNDoyOTo0MQAAAGEAdQB0AGgAbwByAGkAegBlAGQAdQBzAGUAcgAAAP/hCyFodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDE4LTAxLTA3VDE0OjI5OjQxLjQ2MTwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5hdXRob3JpemVkdXNlcjwvcmRmOmxpPjwvcmRmOlNlcT4NCgkJCTwvZGM6Y3JlYXRvcj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/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"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/4RD4RXhpZgAATU0AKgAAAAgABAE7AAIAAAAPAAAISodpAAQAAAABAAAIWpydAAEAAAAeAAAQ0uocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGF1dGhvcml6ZWR1c2VyAAAABZADAAIAAAAUAAAQqJAEAAIAAAAUAAAQvJKRAAIAAAADMzQAAJKSAAIAAAADMzQAAOocAAcAAAgMAAAInAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMTg6MDE6MDcgMTQ6MzA6MTIAMjAxODowMTowNyAxNDozMDoxMgAAAGEAdQB0AGgAbwByAGkAegBlAGQAdQBzAGUAcgAAAP/hCyFodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDE4LTAxLTA3VDE0OjMwOjEyLjMzNjwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5hdXRob3JpemVkdXNlcjwvcmRmOmxpPjwvcmRmOlNlcT4NCgkJCTwvZGM6Y3JlYXRvcj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9J3cnPz7/2wBDAAcFBQYFBAcGBQYIBwcIChELCgkJChUPEAwRGBUaGRgVGBcbHichGx0lHRcYIi4iJSgpKywrGiAvMy8qMicqKyr/2wBDAQcICAoJChQLCxQqHBgcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKir/wAARCAJzA7wDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDXpaQU6vuD5cKWjFFABS0UtACUYoxRQAtFFFABRRiigAopaKBhRRRigQUYpaKAEpaKKACiiloASiloxQAlLijFFABiiiigAooooAKKKKACiiigAoxRRQAUUUUAGKMUUUAFFFFABRiiigAxRiiigAxRiiigAooooAKKKKACiiigAoooxQAUUUUAFIaWigBKKWjFACUUuKMUAJRRRQAUUUUAFFFFABSUtFABSUtFABSYpaKACkpaKAEoopaAEopaSgApKXFFABRRRQIKKKKACkpaKACkpaKAEoxRRQAYopaSgYUUYoxQAUUYooAKKKKACkxS0UAJijFLSUAFFFFACUUuKKAExRS0lABSUtFACYpDS0YoASilpKACkpaKAClFFKKAFooFLQAUUUUAFGKKWgBKKWigYUUUtACUtFFAgooooAKKWigBKKWigBBS0UUAFFFLQAlFLRQAlFLRQAlLRRQAUlLRQAlFLRQISilooASilooASilooAKTFLRQMSilooASlxRRQIKKKKACiiigApKWigAopcUYoGJRS4oxQISiilxQAlFFFAxKKXFFACUUuKSgAooooAKKKKAEopaKAEopaKBCUUtJQAUUUUAFFFFAwooooAKKKKACiiigApKWigApKWigQlFLSUDCiiigAooooAKKKKACiiigApKWigBKKWkoAKKKKACiiigAooooASilpKACiiigBKKWigBKSlooASilpKADFJS0UAKKWkpRQAtFFFAAKKKKACloxRg+tABRS0UAJRS0UAFFLRQAUUUUAFFKKKAEpaKKACiiigAooooAKKKKACiiigAoopaBCUUtFAxKKU0lABRRRQIKKKKACiiigAooooAKKWjFACUUtFACUtFFABRRS4oGJRS4oxQISilooGJS0tFAhtFLRQAlFLijFAxKKMUUCEopaSgAooooASilooASiiloASiiigAooooAKKKKACiiigYlFLRQISilpKACiiigYUUUUAFFFFABRRRQIKKKKACiiigYlFLRQAlFLRQAlFLRQAlFFFABRRRQAlLRRQAlFLRQAlFLSUAFFFFACUUtJQAGkpcUUAJRS0lACUUppKAHClpBS0AFFLRQAUUUUALRSUuKAClxRiigAooooAKKWigAooooAKKKWgBKKWigBKKWigAooooAKKKKACiiigQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFLQAlFLRQAUUUtACUUtFABS1G8ipwx5PTmqLa5p6XX2eS5jEvpnFRKpCOly4wk1exo0YpEcOAQQQemKdirROwUUUGgQlHXpT7VVnkkLMBHEMtz1rifEvjZ9L1gw2kKtCp+bf3+lck8XShPke51Rw05R5js6KxvD3iO21+1MsI8uReGTPStqumMlJXRzyi4uzEpKdRVEjKKXFFACUlLRQAlFLikoAKKKKACiiigApKWigBKKWigBKKWkoAKKKKACiiigAooooAKKKKACiiigBKKWigBKKWigYlFLSd6BBRRRQMKKKKBBRRRQMKKKKACiiigBKKWigBKKKKBBRRRQMKSlpKACiiigBKKWigBKKKKACkpaKAFoopaAClpKWgAoxRS0AJS0UUAFFFLQAUUUUAFFLijFACUtFFABRRRQAUUUtACUUtFACUdKWigBKKWjFACUUtFAhKKWigBKKWigBKKXFGKAEopaKAEpaKKACiiigYUUUUCCiiigAopaKAClpKWgBKKXFGKBo5Lxlcz2AjuYGwScY7V5Heau8l1I8nzOW+93Fe4eMYVGgHfty6sMEcjgc/ka8DltmNw465Y18zWrc9Z2PfpU3Gkro9U+G2vy30E1lO5cxnKknkCvQq8++FFjFHpN3cMg84y7C3ooXP9a9CA9ete7hm3STZ41f8AiNBTWGQ304p1I5CoS3CgZJ9q3b0MlucXrGp6hpskiwS7VBJOO/1ry7VtXnurp97eYSxJOKt65rl7dandMkzNDJIxVSegzWUsPmMOK+Wq/wAWTfc+ghpTSO++Fqs9xcN8+Bj6V6hiuX+HunpZeF4nC4aZizH17V1NfRYeNqSPFru9RiUUtJXSc4UlLiigBtGKWigBtFLRQAlGKKKAEopaSgAopaKAEooooAKKMUUAFFFFABRRRQAmKKWigBMUUtFACUUYoxQAUUUtAxKKDRQIKKKKACkpaKBhSUtFACUUtFACUUtJQAUUUUAFFFFABRRRQISilooGJRRRQAUUUUAJRRS0AJSUtFACUUtJigB1FLRQAUUUtABRRRigApaSloAKKKWgBKWiigAoopaAEopaKACiiigAxRRRQAUUUUAFFFFABRRRQAUUUtACUUtJQIKKKWgBKKWkoAKKKKACiiigAooooAKKWigAopaKACiiigAopaKACpLaLzZ1XGRyTUdSyGWHSbiaH72MA+lcmMq+yoyl1OrCUvaVlFmF4zuYJrdVBU8EMoP3c8f0FeIzRCK5YehOM12mtT3F1c3GW/cxLlnz3/ziuKkJeU5OT618fRk3qfTV0k7I9R+F8itot0ndZ8n8VH/xJruAK85+FswE17bk/fCsB9Mj+tejj1r67Bu9FHzGKVqrCsXxXf8A9neG7ybozIUX6sMfyzW2a86+J2qjbBpqH7v7yTH6VtiKnJTbFRhzVEmecsFaQk1NEqgrx3quw+fg1bhXcMd818pzXldn0FtD2bwkuPC1nj+6T+prZrD8Glj4bt1b+HIH51vYr6vD600fO1v4jG0mKfikIrcxG0hp2KQigBtLRiigBKSnUlADaKWigBKKWkoAKKKKACiiigAooooAKKKKAEopaKAEopaKAEopaSgAooooAKKKKAExS0UUAFFFFAxKKWigBKKWigBKKKWgBKKKKACiiigApMUtFAhKWiigYlFLSUAFFFFACUUtJQAUUUUAJRS0UAJRRRQAtLRQKAFoooxQAUtFFABRS0YoAKKKKACiilxQAYooooAKKKXFACUUuKMUAJRS4oxQAlFLRQAlLijFGKACiiloASiiigQUYoooAMUUUUDCiiigQUUUUAGKKKWgBKMUUUAFFLiigAoopks0cH+vcR56bjjNTKUY7lRi5bD6KgS7t36Txn/gQqRbiBjgTRE+m8VDqwXUr2ciSilwSMrgj1BzRj1q1JS2JcWtwqxc4TwtdM2SzOAuPpVfHNaEiLL4RuwR8ytx+VeZmn+7NHfl2mITPDtcu3S3lt4gV3E+YoH3sEGuWCMjfMDx6iuoKPHqU8t4CQm7Yvqf8iseaG/vpmaO3bbk9BwK+ZpWWh71XV3LnhXXRoWsx3MnMZ+WQf7Jr2qzvLe9t1mtZlljYZDA9a+fLvS7yCPzJIyB65pNLudWhnxpktwjekbYr2sNjFSjZnlV8M6ruj3nW9atND057m7dVIB2rnljXiGratNquoy3c/3pG49hViXT9TvVM+q3uHUEhZXJJ/CsgttbZ1x3qcTivbaLYdDD+y33G7juFalgpfoKzGAZuOM1r2CFCpB71wLdHZfQ9k8LxeX4etSQQSua18VneHW3+H7M/wDTMCtI19ZR0po+cq61GNNJSmkNamYhpDS0hphZiUhpTRigBKKMUUAJSUpooASilpKAEopaMUAJRS4oxQAlFLijFACUUYooAKKKKADFFFFABRRRQAlFLRQAUlLRQAUlLijFACUUuKTFABRRijFABRRijFABRRRQAUhpaMUAJiilxSGgYUUUUCCijFFAwooooAKSlooASijFGKACijFFACUUtJQAlFLRQA6iijFABS0YoxQAUUtFABiiiloASlxRiigAooooAKKKWgAooxS0AFFFFABRRRQAUUUUAFJS0UAFFFFABRRRQISloooAKKKKACiiigAooooAKKKKACiiigAoxRS0AAHI71x/ioO2tXG4naMFQOwxXX1j+JbE3Nmt3CuXhUhx6r615uYU5ShddDvwVSMZ2fU89uJSvIBwO4PS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oASilpKACiiigAooooAKKKKACiiigApKWigBKKWigBKKWkoAKKKKACkpaKAEopaKAEopaKAEooooAKKKKACiiigAooooAKSlooGJRRRQIKKWigBMUUUUABpKWkoGFJS0UALS0UUgClFFFABS0UUwCigUtABQKKKACiiloAKKKKACiiloASilooASilooASilooASlxRRQAlFLRQISilooASilooASilooASilooASilooASilooASilooAKKKKACiiloAKKKBQAtKKSloAXv9a7Tw1OJtHKMfmjOB9DXF4rpPCcih7mNj95QcV5uYw5qL8juwUuWqvMTxHfiztBGrbW6sPr/APqrxfx7M0Fvvdm/eZYYPftXo3iO5t5dUuTJMCyHoG7dq8q8aCV4UeVhJHk7GB6V8hCPvH0rl7pwCNkEt1JzS7z/AA8c012G7HpSqU3DBzXckcdzodGfdFh8cVNLEN5A6KeMVU0h1V8dcjmtMQMQc9SevvVAWLaNpl2/dIqLUL2azLRxrwsZJNX4mjtky33ugrL1ibN8YyAAEycd+lOQkYexjbBpG5diTnqTWfqsjqIlycBRWizCS5YNwF4FZmqHzIxIB93IqGV0GxS+bb4BO8VNBezW7Bgc4PfiqmmY+0hW6EVO8XlzENwOxxQr3uhpnovhbxgEKxTJJ04KtkV6VZ30d3ErJ+Oa8C0/yfOQl+c9xivUfC07eWqgrIv+xJk/lXrYStN+hxYmlGSudqRSEUIdyZ5/GlNe3E8SSsxlNIp5FNNUIYaKcabQAlJS0UAJRRRQAlFLSUAFFFFABRRRQAUUUUAFFFFACUUtFACUUtFACUUUYoAKKKKACiiigBKKWigBKKWigBKKWkoAKKWigBKKKKAEopaKAEopaSgYUUUUAFFFFABRRRQAUUUUAJRS0UANopaSgB1LSUtIAopaKAClpKWmAlLRRQAUUtFABRRRigApaKKACiiigAoopaAEopaKAEopaKAEopaQ0CCilpMUAFFFFABRRS0AJRRRQAUUUUAFFFLQAlFLSUAFFAFFABRRS0AFFFFABS0lLQAUtJS0AKKcL9rCGR0lMZZSue9NrP1edIIBJMQI1y759BXHjf4Mjqwv8VHL6sky+bdvM2MEgt3NcQ2px3sbw6hKwIcsEXpW9H4kPjb7RoUGy3kZy1uT/EuRx9etcRr9jP4e1mS1uDukQA59a+Sp22e59FO+6IXgW6uJmB8tEG4KB1qukexhkED3qZtUkTDrGsa7eeOtV4743RYPgf3fauhGLRq6dOI7uIsflB5x3rqUmVkaULwBkiuKsWJnGOeK6uylI0uQ9Ttx9KBlT7W814MnvxUk0yeZKZTmV+mfSoLMb79VPbk0SwfbNSBiyUUAMT0GKhjK9zbCDYR/ESaxrw7bEg9zXXaokf2LKkEqMA1y1xHujbI6DihgUdOU+du7AVqSmOZTDuxIBkYqjZp5W7Pfiop5dt5vQ9DQBIk7wvkcMK6Xw74mS1nVbtVYdmPBH4iueuYxIizR9H/Q1Uwd3FaU6koPQGk1Zn0bo1/Fe2qvBIHB/wBrNawr578N+IbjSLxG3uEzyAcCva9C1221W0R45BuI5Gea97C4lVFZ7nj4rDOPvLY1zTTT855pCK9E88jIpCKcRSEUwGmkpxFJigBKSlNFACUUUUAFFFFACGilooASig0UAFFLSYoAKKWk70AFFBooAKKKKACiiigApKWigBKKWkoAKKKKACiiigAooooAKSlpKACiiigAopaSgYUGiigBKKWigBKKWg0AJRRRQAUUUUAIaKDRQA6iilpAFFFLTAKKMUtIBMUtFFMAoooFABS0UUAFFFFABS0UUAFFFFABRRRQAUUUUAFFFFAgooooAKKKKAEpaKKADFGKKKADFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFLQAoooooAM1yfjHzbqxngiLYSMkhTya6qRtqE+1crq7SQuJe757dsV5GaV1Tgo9z1MvoucnLseV+HNOuIPHGmrhlzcKcjj5QcmnfEO7ivfG17LC++IPgMPrXrfhvTrK7kiuzArSwo+CBxmvP/ABvplvHqR8lUVR2UV8zGrF1LHtunLkucLqG5vJSPoUpkMWw4PU9fatK6iVQjLj5FOapoCzZz97jArrOcsWhCzIe27muqgurcKYlI2t71zcdowQY7da0tNsvOmQs20ZyxPRQO9JjRsQRQxXcjseMDHtUF3dxRR+XbfKGPLViXWsGS4eC0UlScAnvSSu0lxBC3JHzN7CpuOxoXk3lWW0nPGa5k3xYlW6E1p6vdD7NweWOK57rTA0RJ+73CqjNuOfWpYsm1PtUGeKBGjZP5trJEeo5FQSDDEqMcUunOFuQD0YYp8i4d0PVTxQMbDM0UisQHA7HvXong7WtNV1WYtbS8f7przb7pHNbei3MQnRXkVTngSD5T+NdOHm4yM6keaNj6Dt5454gyOGHqO9SYrmPDM4MKKI2Q+z5U/SuozmvpaU+ZXPn6sOWVhpppp5pprYyG0hpxppoASkp2KSgBKKMUUAIaKWigBKKDRQAUUUUAFFFFABRRRQAhopaKAEopaKAEopaKAEooNFABiiiigAooooAKSlooAKSiloASilpKACiiigAooooASiloxQMSilooEJRRRQMKDRRQAlFLQaAEooooAXFKKKKQC0YopaYCUtFFABRijFGKAFooooAKMUUuKACiiigAooooAKKKKACjFFFABijFLRigBKKWigQlFFGKADFFLijFACUUUtACUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAKKKKKAFooFB60AS20Inuoo2xtZx1ql400byoZHxjjjFWclSCvXqCK15pY9a0vyJGAnUYwe9fOZzQnJKpHZHuZXWjFuD3OG0KT7BoBkjP+sDA+1eYeJr37Tq0oByoJx7c16Z4jgk03THhiXywuc4ryC7Zmu2JOck5JFfO0INzcme1WkuTlRSnUtExFS6fZ78EjNWYrcMOasRtHbfKOT6CvQ6HFbW5OYPLT1OOBWJNcXszNBGWSPOMAYzXqvgLw6t/DLdXxRXcYhWQcNx0rmPE1nHpGpTK0axDdwAOtS207FJXVzA03SlQeYwy/epdRijs7aSUf6xhgH2p1tqKyyCNVw5+6vpVbxE52xovOPvH1NNEs5+eZpFXccjtUAq9Na7LVHGSW4pILF9671wvWqEOhTFp061RPDGt5oAIwFHFZM9uyykqOKBhaHbcIeuDVi+LR3m715qGzTM4LdutLfy75voKNwFlUZ3DoaZGxV+eQadbuHQxnrTHGGovZgeg+CtYNvMsfnsq/3TyK9dtJhPApDBs+lfOGlaj9hukkYFlB6ZxXtnhLxDZ6jaKsb7X/univdwVaLVm9TycZTle51JppFP7cU0ivVR5Y002nmmmqASmnrTjSYoASkxTiKSgYmKKWkNABRRRQAYpMUtFABijFFFABikxS0mKADFGKMUYoAKKKKACiiigAooooAQ0YpaKAExRilpMUAGKMUYpaAExRijFFABRRRQAUUUUAJRS0UAJijFFGKADFGKMUYoGGKMUUUAFJS0UCEx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looxTAKKKKACiijFIBKMUtFACUUtFMBKKWikAUUUUwEpaKMUgCkpcUUAJRS0UAJRS0UAFFJS0wEpaKKQBRRRTAKWkxS0CClpKWgBaWkFLSAUcYIrjPG9i3necqhlkUN9eea7Oqet6b/aOju648y2O8e46f8A168vMKanS5ux6WAqONXl7nzz4gsmSZmXOM/rWj4Ju/N1O3s2zuY7Uz7mrPiOzZ5Mp8u1sN71m+ClMXjjTuek47V889YXPa+2eneMLNdNsVgVgsir0IHzZrzCdd0hzzk17j4/top9HaUDDbQc14jLKryH7oOe1ZUXdGlXRmXfWwClkHPes7GGromUOhz0xVCWxBZDGOAea6LmJJp1uFjz1zVu4byomI5wKkt49gGOPas/VZSuEHQ9aQFP7Y/2kODt7GtSVVuLcjqCM1gHrxxWhp12VkET8qeKAKEi+W5U9jQj4OPWrepW5Sbev3TVHpVboRO3tVi1upLeQOueOw71CoDR0+IDdycD3qoNqWgNJrU9N8H+L4VkWK6Xy2PHtXqVtcpdQh4juUivFfDFszOhVYpATxkcg165ozuLcLIm3FfRYaTcdTxMTFJ3RqEU0inGkNdhwjO1JTjTe1UAlIaXFFAxtFLRQITFJS0YoGAoNFBoASiiigAooooAKMUUUAFFFFACGiloxQAlFLijFACUUuKMUAJRRiigAooooAKKKKACkNLRQACkxS0YoASilooASig0UAFIaWkNMAooopALS0UUAFKKMUUAFLSUuKBhRRS0AFJS0lAC0tJRQAtFJS0hBRRRQAUUYpaAExRS0UAFJilooATFGKWigBMUYpaKACiiigBKKWkxQAUUYpaAEoopaAEopaKAEoopaAEooxRigAooxRQAUUtJigAooxRigAooxRigAooxRigAooxS0AFJS0UCClpKWmAopaSlpAKBU9syq7K+dkiGNse/H/16gFOFZVYKcHFmlKbhNSR5Vr+mS2mozxSKWCsRjHOaxND0iTTfENveXKlE835d/H1r2HV9AfVNXgmMeYZEDSEAduK5bxZYm2QFfkVc/NjGK+KqScZuB9dGKlBTNzxdMD4ZeSPBO3jJr58uo5YpJHZsANXsOpaolz4PhaM7z918nOK8q1hyzMhA45B9eaVFaCqlW0vy58uTj3q+mGzg1z4D544rS02R2Vw3augwNIuEUknn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w8w9Aeg9K7rXHW+82SKTfknaTzxXnl6nMmBgLyM11Uo21MarXKrFWxuGFwUIG088nrWlu7gY9awJfkZWBOa17NnkiVnrpOQtqA/UYoO0HGRmkI2xkg89qxZryTzHG7rxTA2WkCsA3OabJbJIhz3rAa4lfBZidvSrsGrFVUSDOOCaAKt3YNC528r1+lU8V06FLmLIIIaqVzpgPzJ8tFwMmGIyPgVYnUxgHtV2ytsKd459aW+iXytvftQBlknqOvuKvWVyIH+eOKVepUgj/P61noSeD1qRWCNnBq6cuWQmro9Z8FajCZECWQRv73UV6hEweMEY/CvAPDmtS21zGkZXr0yRXs+g6k93brv2j2BzX0OGnzI8XE07M2TSYp9Ia7TgGEU2nmm0xiY4pppxpDTASigiigBDRS0UAJRQaKACiiigAooooAKSlooASilooASiiigAooooAKSlooASilopgJRRRQAUUUUABpKWigBKKU0lABSGlooASilpDQA4UUUopAFLRRQAUtFFAwoopaAEopaKACiiikAUUUtACUUtFAhKWiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkpaKACiiigApaKKBBThSUooGKKcrFXDL1BzmmiioaTTTGm000ZfinXbtXaMMFGM5x94V5LqahtT88Alicn2r07xXDuiikzzgjivONRidpT5Rwc7QM9T1r46tR9nWkfWUantKSLKx+ZaYA+gzXJakpgu3WYbeR178V1lhOhWXIY+WBnjrXO67ppMgeYt8zHaPaojboOSfU5i7P75lP4Vp6W4a3245zVJ7LM5RSSvZjWhp9uYI2B6k8YrQyJLubyoTnuMVgsck55roLuLzbYr0OM1z7dTnmmAykpTSGgC3ZXhtn7le4retZ0uoQR+VcuDirdhe/ZXJbJU/pQBvJEsbsAODzWPqs+JlUdq245RNb+YuDxxXMX7H7S/OeaQEUoAkDryrU8AEZ6UkGJFaNuvUUoX5SPSnsBdsLpYJVPmshB6FAy16x4N1uJwq+ba/VV2V4yG2kcCt7QL3ybpcM4HfaAa78LWcZWOXEUlKN0fR0UgljDKQfcdKdXO+GNQSe2RQZWO0ffXFdJivfjK6PCnHlZGaTFSGmkVaJGYpKdjikNUA00UvakoAQ0UtIaACiiigAooooAQ0UtIaACiiigAooooAKKKKACiiigBKKWigBKKWkoAKKKKACkpaKAEopaSgANJS0YpgJRS0GgBKQ0tFAxaWkpaQhaWkpaACiiigYCloooAKKKWkAlLRRQAUUUUAFFFFABRRS0AJRS0lAgopaKACiiigBKKWigBKKWigApKWigBKKWigBKKWigBKKWigBKKWigApKWigBKKWigApKWigBKKXFFACUUtFACUUtFACUUuKKAEopaKACkpaKACiiigBRS0gpaAFpfrSUtJ7AZuu2xn0tyrYKGvMtWRtxXq3ZcdvWvYPKW4jkhP8akD615nrlr5czb/lbJANfN5guStfufQ4B89G3Yx4EEulyFOZY+cDuOtMmtv7WkRXDY25Yjse1anhqxa+1OWJflG35vbFdFPoxsNPnX5RI5DKR+grybqMnY9LWUdTzTWNNjsLkRhBnGc+tU0T1HGK2fEilL4bwytt6E1kx8Hj7vrW0djnluVrxW+ysFGSe1YDZHXrXUkDnoTWVfacAC8QO6qJMdqSpGQjrUdUAZpRSUZxSEdFpkyvZBR1XrWHfpsvHB9au6RKPMZGOARSaxAARIO/FCGZaOY5Awq2CGXeB1qjU0DkNtzwabEh75U5H8qs2ksaSASRgjPXoarsMNg05ANw3NgfWqhJxegNJo9V8E6xZJKsa+YH6ZLf/Xr1WJt8YPqK+ePDs0UV0ji+EJzzuz/hXt2galFc2qqblZSB1FfQYWpzRPFxUNbm2RTccU6kNdpwjSKbinGkNMBDTadig1QDMUUtIaACkNLRQAlFBooAKKQ0CgBaKKKACkNLRQAlFLRQAlFLSGgAooxRQAUUUUAFFFFACUUtFACUUtIaAEooooAKDRRQAlFLQaACnCkFKKAClopaQCUtFFAwpaKKACiiigAopaKAEpaKKACiiigAooxRQAUUUUCCiiigAooooAKKWkoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooopAFFFFMAoHWiikAUUUUwCiiloABS0lLQIWlpBS0mA6Ntkit6EGuS8a6aIdadVBWOUB1+hrqx1z3p2taemrabZzquZLdwkn0rws3jaCqLoe3lU/fcH1OH8M6ZNZ6i07qwXbz7iuz1KEfYfNfB3A59sClu4Us1LnIXbzxinXcol0wDsF5HtXzN7u572lrHh3iZGt7qSSRtykkgmuXl1Ta37scetdV4xvrd5LiJVLIfuY7H1rz9j83pXfDY457nQ2E5uY9zcnODVwLvBDcmsXSJXWZkB+UjNazTFW/wDr1ZBS1S0Bg3oMFeuKwiK6y4Bns2C9x1rl3UqxB6g0ARYpDTzTaAJLaQxTq4OMH8629QjWex3JycZrAre06TzrPa3bigDnW60ZI6Vav7cwTnHQnNVsc0xFgDzEVh170pXAqdEH2VSOtQOTu25pDJLeSJW/eKSPUV6L4O1bT4ZECb/MJ4wDXmR4qzZX8lpIGjYV1UK/s3qY1aXtI6H1DZzrNArCpyK8x8DeL1l2wXD89BhTXpyMJEDDoRmvoKVRVI3R4NWn7N2EIpuKfTTWyMhppMcU4im1QhMUlKaKAEpDSmigYlFBooAQ0UtFACUUtIaACiijFABRRRQAUUUUwCkNLRQAgoNLSGgAooooAKKKKACkpaKAExRS0lABRRRQAmKKKKAFpRUM84gQMysw77RnFPimSaMPE25T3qbq9irO1yQUtFKKYhMUtFGKACjFLiigBMUuKKKACiloxQAlLijFFABijFFFABijFFFAgxRiiigAxRiiigAxRRRSAMUYoooAMUYoooATFLiiigAxRiiigQYoxRijFAwxSYpaKAExRilxRigBMUYpcUYoAMUYoxRigAxRijFGKAExRS4oxQAlGKWigBMUYpcUYoATFGKWjFACYopcUlIAoopaYBRRRQAUtJS0xCiigUYzSAcK1NHYP5sDHAYbhmssU+Kdra5glUZ/eAH6HivPx9Pnw8kdmCny10xdfIW2dFOQoOa5G411RpflQlZHdCrew6VseN76SzVo4iA8gy3NeZ6Vcv58kUrHeCf1r46nC59bJ2Oa8QLIZCmzAHU+9cpOhWT5uvWu6159xl4xx1ribvhyCxNdsNjjnuTaY4W5HPXitC+m2DjOe1Y1uxWZCOoNbk8IkVTjtVkC6bM0sPzdajvdN8wtJH970q1ZxeUPSpnnjWQRu2CaAOWkQqxBGCO1MxXQXNgk6syH5j3rGkhZGw67aQFfbWlpPmrIQuSh61JY2Aubd94IxyDWvZ2qxxDaMHvQBnapaGWLcOSvIrCKFThhzXaSRKxPt2rJv9MEis6D5gKAKsYDWYK/SsudsSnmtezjK2jhhjBrGl/1jfWmA4MCuKmhjZ5MIM/WqgOCKn3HAIzT0T1DdHY+HLO4juI5Ekw2f4f/ANde06FO/wBlVZ2JbH8Rr5vtL0wOCJHUjpg16B4W8awWxVbuVifVsmvYwteC93Y83FUZSV0e0fSmkVU0vU4dTtFlg5XHXGKumvVTPIatoRmkp5FJjirENNJinEU2mAGm07FJQMSg0GigBAKMUtGKAEooNFABSYpaKAExS0UUAJiilooASilxRigBKKDRQAUUUUAIaMUtJigAxRRiimAUUUUAJiiijFABSUtFADJXaKQ7Y1mAxjBpY4lViy9xzTgOMU4VnGKTu9y3JvQUClpKcKskMUUUc+lIBcUUgYMMjB+lLQAUYpaKYCUtITgZPTOKWlcBKWilpiG0uKWkoAMUYoopAGKMUUUAGKKKMUAFFFFIAxSUtFABRRiigBKWijFAhKKWigBKKWkoAKKWigYlFFFMAopcUlAC0lLSUgCiiigQUUUtMYlFFFIAooooEFFFFABRiiigYYooooAKKKKYC0UUUCFpRSUooAKXpg/3SG/KgUvtWNRc0HE0pytNPzOS+IyONTWQFsFQTzXn9u2273E5YnH616n49h85bWQc7o8E15a6izv2OMcDP1r4uC5W0z6+esUyPX4mMO5V4bA5rj763VLcMo5z19K7+6t2u7bdJkHHGK5O7sJpbjyoELIT6VrGSIlFmDb27StlR0NdDGhEag84qO3tBbZwOc1aX7taGIEhU54rB1OY/aOO3Q5rXunMcZYcgVz90XlYvtwtAF7T9U8obJfwrYe2ivYMkc9jXNWMPnXAB6CuttU2RjHpQA2yt/It/LPOKsAbYjQWOOTTCflyMUgKF3M8FwsjH910I96mM6nGT1FZOoX2fMiYdOlZpvpSq/N92gDoZFUghe9c5f27RXDHHFalhO08bGT0oLR3KsODjimBz9SxNnKmrFzZbTlKZDbd2oBDSpFW7K4ltpg0XBz1qGRRjio1YqeKcW07hZNWPY/A2v3cm2O4OVHfNemRuJUDDvXzdod88NyrbjsB5G/Fe4+FtXS8slUsOBwFFfQYWrzRseJi6XLK6OiIpCKdQRXcmcJHSEU8im4qhDaQinUUwGUYpxppoGJRS0mKACiiigAxSGlooASilpDQAUUUUAFFFFABRRRQAYpDS0UAJRQaKACkxS0UAJRQaKACiiigBKSnUUxgKdjGPcZrnv8AhIbby3ivpCrK2N0ILD8x0pYdXnKlImYJ0juJEO0r7f8A165ZVmnZK5rGkmrs6EU4Vm6fOIrULdXaSy5yz9P0q2t3C2Cjbwe681vF3V2ZtWZPTJG2qeccGlzuAIPFBAZju7DqaGOK1uR2iFIQGOanPAyelNiBCc49iKSUbkZT/EMcUbIm12ODAj5Tn6UuKrwQfZkCICOeS3JqfOVNJO6uPlsQsGe5A+YIvPB4JqxTUQqvJyafiiKsDdxKKWkqhBRS0UCEoxS0UAJijFLRQAmKMUtFIBMUYpaSgApKWloASiiigAooxRQAUlLRQAlFLRQISilooGJRS0UCEopaKAEopaSgAoxRRQAYooooAKKKMUDCjFFFAgooooAKKKKAEpaKKBhRRRQIKWkpRQAUoooFACinU0U6k9hp2dzP8VW/neH4ZBk7HIPFeU6rBiYbhlick+lez6ihl8LXSnBCsCBXlupafLMriLLN14HQ18ZibU60kfX4a9ShFlrT9Oa/WNYxkhMk07V9NitI2mgVQyrnJrsvBuleRpMQlQCQjDE1geM9trbSHjbg8jsa5VJ81jeSXIeX3rj7QxUcVTlukhBDnDY6VFrOqB7r/R1AAA59TWJJMZX3Oc12nGdCki3MHyjrVW8tf3Y2j61BpV2I28t+B2rVcbxnOc9KYjFtQsF3tbgMcV0UC9DnNZi2qyXCl8cHNa8KCNc9qAJWAxzWbeXy2jYB3ZpNQ1MQHYh7Vz00zSsSTxSAS4fzJWb1NV6kJyKiPWmBtaQhMLGs6ZmtrtgCRzmrejyESlN2M9qj1mPbMGAxupANW+R/vj86m+QplOTWRUkM5ibJ5FMB85YSc0qHPNTSRi4XcpqGONlbDfdpAW4L2SIhVfao7V3/AIM8Ti3kCXMjsCeBkYrzVlwasW1w0Mu5eorroYhweplVpKpE+nbDUIryIGN1Jx0Bq7jNeReCvEDQsgeWEA9S716va3SXUIeJgwx2r36dRVFdHg1qThImNMNPxTSK2MBtJinYpMVQCU004ikxTASkNLRQMSjFLSGgBKKWigBKKDRQAUUUUAFJS0UAJRS0hoAKKKKACiiigBDRS0hoAKKKKBiGig0UCCkpaKBleG0hUPiNdrnONtWREojChV2+mKbGMjPbsKlFTHYptla4soLmF0kiU7lx0p9lCkNnHGqhQqgDA6VNkAjNICFXC80NK9w6WI5I9pzG20k9OxpYWLBlkAVx19x60SxF4ySxyORz0qIv5kKygfOo496iTSLjHmLMH3B6DjNKJYxIU3DeBnFULHUxIGVlYbWwc8YqO8kWHU45tpwy7d2eKzlWShzIpU3zWZeaZ3uh5p5xkH2oaeNFkkJ+RMZ/GqN7NI0kRiQkL6HrTYVD+ajNgvkgOevtWbq20iaKnfVmtG3mKGHGeadVW2n/AHKqE3MByM8ClklI6uN39xf8a6Iu6OeUXcnDdcmoYZJGuHRlIQfdb1qNYJfMBdz83UA1YIaJc7i3sTTeoWRJS01H3Dpg+hpTIFUljgDrVGaVxaKakiSfcYH6HOKdSTuGwUUd6KYCUYp2KMUAJSYpcUUAJijFLiigBMUYpaQ0AFFANLQAlFGKWgBKKKKBBRRijFABRRiigApM0tJQMKKWigBKMUtFAhKKKWgBKKWigYlFLSUAFJS0UAJRS0lAgoopcUAJS0UUAFFFLQAUUCloAUdKWkpaTA1NKgW7t7iCQAhgDzWSdIhgZzsUbvlJrR0i6FveDcflf5TVnVosRuijls8ivj81jyV79z6nLJ3o2MKwkEd40KMPLA656V5n8SdU86NoUygViGwetbusaz9kvTBBKcn77ZrgPGdwZpNo5JAP1rghH3rndJ+6cFK2ZDjpmo80rffOfWkFd5xD0JDV0tgzSWa7hzisKxtTcPg/drorePyYVVaAFjjHm5p17N9ns2Kk5PFPVlDc8ZpLiP7VCUU4B70DOWlYuxLc1EauX9q1vKQASOxqiRQIQ0wjmnnNJTEWLBtl5GT64q/ra5hU479azITtmU+hzWtqCGe0BX0zSGYFIaUgg8jBpMUxE9q5EmAePSrrqoGelZ0Q/eCtJ496c0hlUyK7FaQId3UVDMvlS8VIkgfgimBo6XLFBcK00pVQf4a9c8K+LrUxpbQ5xnBdzXi4l8v7oWr2mm+uJj9nfywvVicAfjXZh67g7JHNWoqotT6Ztr2C64hdXPcA1PXkvhLWk00bGnaaVjgDPevRrLVVlCqxBkPXHb2r3KdRSWp41Si4SNPFIRThSEVvcwGUlPxSEUxDaQinUlMBtGKUijFAxtFLRigBKMUUUAGKSlooASilxRigBKKKKYBSGlooASilpKACiiigApDS0hoGFFFFACGilpDQARtkZAwMce9E0ohUM3HOPrWbb6kZAp81DkZwOOankuop42Lhtq8Ae/rXPGqnE25GnqWY5RK/YAdB61M7COIvjOBnFY7XZ8oeUu4E/Mf7tSXcp8pI4pD8xAOGqHWWxaou5X/t2OWaSPleMcevvVldQSCWBRGHRkwxzwDWbNpSbyPN2tIeqjpVNnaJpLUf61TjcehHXNcM5VIp8zudcYx3ib87RwS+e+0I/wB4Dkj0NRz3ltcLH8m/d/CpwR7kVHp91bvCUmUGTG3LdDWfPAm91kkMM0akA564rSpUfIuW2pNOKd20WtRhmSNXt59gAO0EVWtHuIow17/pEm3K7f4fQZqmtzeTokaoZuMB+gxSx3BtyscxAcfwnPJHvXO6ivztWNvZtrlLsN/cSltw+zqAdx/pWzpbxXEG6EKecbs9a5ya/N1dKF2jJyw6KK3LCaPgQNGFXqFHGa1w1Xmna9zCvT5Y7GuwVI+TjHNCfvMNjrUccJnIeQnHYVaChVGO1ene5waLQjLYfDd+lV5yVkCsuY5D19ParMwGATwM1AXMoaIpvHrnApsaJYokjX5FC0SPs57DrUUEhTckx5T9RTGPnyANkL1xnrS5khKLbuyVJC5JA47c1KpJ6jFQDMU2cYToADU4bjuKoTQpHWkXoKN4701WXcRmgmw+jFJvHbmnUAJRSkUUwEpp4H4U/FIRkfhQIanKU7FMh+7UmKBsbijFLijFAhKKXFFACUUtFAxKKWigQ3FGKXFGKAEopcUUgEopaKAEopaTFABSUuKMUAFFGKKBhRRRQAlFLSYpiDFLRRSAKKSimAtFFFAAKWkpaAFpaQUtIEKnDrn+8Kt67di2hZi2PlDc9xVQdf1qp43R59CtZovvFdrH0r57OKd0pHvZRPWUGeUeIbzGptJjKMSSR2FctqNz9oVnd9zKOB7Vp+JZPsqmLcWl2/hisOxt3uLaVnTdtXkivIha1z1p/FYwZwBL8vSn28JlkA7E8mpJ4SZyAOelaVna+Woz1roWxzMsWtssI2qKujjlqYowvPFUNTvTEAIm560CNPIZhjGacowwHaufsdQllvkDNgE9K6PA9cUDIby2W4gKnr2rnJrKWFm3KSB3rqQMH5TSyW6zRMrDqOtAHFEYFMrWvtJkhJaP5lrMZCOxpiGg4IrordRLaA+1c6qndxXRaaD9lCmkBz11E0c7Bu9RKpZgAOtdFfWAlViB8x6GqNvp7JIC3P8ASmBFb2PRm4qwyg/KDj8aszjyovQ4rEeY+aWzQBLcWuAWyc1RGVPFbEciTQjcQDUU1qpGQKQFSNgR83WrYuZRGIYyVUnJrPOUbFTLJuGDx71Sk0HTU3dN1A2dwBbktIerHsK7XQPFPlXCRhwzk8k/wivNEdkBWLgnqa0dGt57y7WG1GCW+dycAD3NddGtJOxhUpRlqz6N0q9W9g3Icr/e9av4rj/CV/DtFnbSeasfDyjoT7V2OPSvehLmR4NWPLLQbSGnUhFaIyGUhp2KTFUA2kNOxQRTGN7UlLjijFACUUuKSkAUhpaKAEooNFMApDS0UAJRS0mKACiiigBDRS0hoGFFGKKYCGilpDQAUUUUAchBPBbEi7xsY/I6/wAP1rXvphHpcKWex5WGBg5BUjkn3zXJafcQ29rLFfyMVL4Xbzketaqabb482yu2iO0YdTxn37V8zGo5yUU7I95wUU21qNs5ZbaByXLNyGizzmqtvffZ9QVJGk8zGfpnrms7UdPvI5kaa5d33Bi6cYWrUJjkVrpZlQxjblhkyfhVVJLm5QjF8rfc6ZnkM0MkkgeMYIwO3rWZrJSXVHZZSPLAw/oKjh1me0t2Z7PbvGI+c/jjr70XSu9qzQhXlmbkseg9cUVq0eVRQqVKT95ixSNJGkaxFIt2S47imSMl5f3H2VGm8pQWBbGB/WqyPdWsYjLIZXIRT2UUt5cpp5JTCCSMKSpzuNS6keTzKjCSk2i3aX0z30dtsWKIDgDn9fWo9TlA1gJApdsZ56LTdK1B2tmWbEKsCokABI+g+lNhtbdtQaUyvLnrubJrOfPNLXQI+7exauJYpNNW28hmml5UxjJPtWpYNOLaK2VIo9w+fHLCqq3AS3WOxUZjPyjuefWtSxGy7Lsg37c5/pXRhYOE1LozKu4yhrua1vAbdfmkZif7xqZ5lj+9/KqM2ox4Ck5J5I7ioWuTcYL7hF0BHWvZ5lsjzOR7yLxdZXDOW29gaFlOWMaE89+KqXGq2tnHGm5m7bsZxn3q6J4RbqwkBDdCO9NSV7EuNilGJbjUsMo2he3XrUy2cLXXnBm3pwQDgflUNvL/AMTGcoMLgAMPWtREAX3pJK9ypSaGOAfl79RSBhtyabcHbg5wBzmqq3CtIu2TK7ulaXSM+VtXL/UVHIihgxFSMyr3qGeTauCOCeDTJSJCwVcnpTh92oi4dQB83NTDpQAgweRRTU+8y0+gkiYsvIGR6UqMGHFSVBMjKQ8XUdR60D0CHhnX3qbFVYZ0eVyOuOR3FWA2egouDQ6kxS0m9QcZ5oEFFBIHehTmmAdKbklvaiTsPU06gApMUE4+tAHegAxRQTjqaQHPQcUCFoooxQAmKKWigBKKWigBKKMUUAFFFFAxKKWigQlGKWigBKKWigYlFLRQITFFLRQAUtJS0AApaBR3oABT9RtXvvDcygcwtuFIK09IUT+fbSfckXmvNzGHNh35HoZfPlxC8zwfV9HR5pGf5mIOST3qtpVrDFI8KJnccV61r3hW2+0SsFwrVyVppJsLjgKSSckjPfivkoz92x9VKK5rnEa9oSWl15iIBx09TWd5Xln5hivUdU0OK6RZJcMFG849K811Nkiu5D/BuIUmuqnK6OWpHUoXtyIID6npWC5Lnk5q1qF15rbRggelVAa1Mh9kuL1PrXWgAr17VytvJ5c6P6GunVw8IPYikBQutRNrPsxkcUsWuoWIfgdqytSZxdEOc+hqjmmB18V5DdrsQg5HIpkmmQN0XHHSuWineFsxttPtW9p2reaoilb5vU96BDV0cRzh85XNaKQiNcjpU+4bTjpVe5mVU+dsDFADGdSSM0w7dmR1Nc7PdSec5VzjPHNXNNvi8gSU9utAEeqTOvydAe9ZWa2dUiDRlgKxvrTAcrFelX4b1WTbJxWdS0AaZtopgWGCaqSWjRvgDOafZuwkwDxWi+FGT1pAUBGyIAetXI7147f7Pbfukb77DqagluYRwOagNwm7iqjJxYpJPc9C8J+I7PQ4V85mZieFHf3r1XSNbGowLIV2hugzzXzbBOY33pgn1Pau00HxbcWvyPdLGmOXYcj6V62HxS2kefiMPfWJ7rkHpRXB6P45tLqQRJKzEdWbvXb29wlzCHRs5Ga9OM1LY8udOUdyQikp1BFaGYw0hFOxxSY4qgG0mKdSEUAJSUtFACUGlpDQAlIaWigBKKWkNMAooooAQ0UtFACUUGigYUhpaKAEooNFACGilpDQB5LNH9l+UyqwY5znO0elbiQHTtOcyXMc0MoXaEbkE89PasG3ks5VaS4UYJKqM4z71tWdva27W93cQ703/wCqJ4PpXxUqjjLmifVciasxDPPaKA7x3C3UZXyyeVFVbUIsMaGJSuSXAPOatQXEb6rK5iQJKzRiMdU9xVW5017aRrm0eSRxKFwvIx6EURm+a7G4q1jV0oq984fMkka/ex90VVmy10ywOWkaQHOeAM85rLh1C5h1N4ncRMSd+OMgdquaVqA/tGSO1gDyTttDP0HvW7lGbs9jLllFXRo3nmRKkAsN8sjH5lbI/wDrCk/sVbexN2buGeaE5dWfgA+g9qLy0dWZYNQxdv8ALMuMBfofSs+bSiqoqSBoyD5j4JyB3rKdSPOrOxcYNxta5YNxaxxMUiaScg7gpyB70umOsaCdYmkct8wPcVDbrFHcBIiFQrjPf2rRSFZbWWO2mCyIwKIowWGOa6pVY2VzGNN3sieO7tILmaVGKjjagH3T3Fa2lObm5WUEhSSGH8q4FrmWJple3kWViSHzkDHWtTR9Y+yxZvJ5IBtBUN0Y1tSqxjKz0RhVpSlHQ7TVIlivIFTcS3UD0qzG0e0JwoX+I965ZddWeRHEnzA8uzZB7Vdh1SDYuwmWTHzEnoa7I4mPNds55UZcqsh2o28tzcMlso2qMhumTmi1eS3uDFdBgycgkcfSr41GK2sT9q2hMZ3AZyax7i/aRo/LnjlDHOzo2KVWUL86eo4KVuVo3bG4EsikpjnJPrWq1zGuMkjvyK56xulgUEOpPYL2q5NLNcuFU8g9F/xrpo1G4+Zz1aa5i3eXkJUISCOprMjlh8mUKBlHyABzV5rKOVUe4HK9dv8AWqN1IllNIcqImXAU96dSThFykVCKdoxNRJ22ghMLjq3ekuZB5MfBBY1krLezSBWlVY41Byo6itG2ZL1c+aWCcDtzTp1XUV9jOdNQZZjXygCM/wC0KlVhKTg5A71VuLkwMkZPz4xmp498kAEeY1PJatua60MeXuMdtjHByy9QO4qxGSy59apcWtxljvWTgZqaGfDGMqc9R2zV3IcWTGUK+D1pdwHvWPezBbhvnMTMPkyc81ctWcW8azYMh6kVlGopNpGkqLikxEU/bZmiHPcetW4XDg+o6j0rN3GG+mUSEArkN6VJaTu8jMcn0IHWrTd7ClHS5eZijc9D3qK6KCIknntjrSFXnYglkBHNVHsZUmVY5i2ecvzVERSL0RTygWPbvT/NTsfyFZpke3uUjvEBRm+Vx0FaDlVClTj+VJS7hKNnoMaZN+4nhaa14BjCHHYnjNVHuUW+JChm29R0qSRTIAyfvGHPsKV77FcvcifUi1wkQQgnpnpV2MTOMuQuPSoPMgZck5cdPY0kV4AAJ2wAaiEns9y5xVrouqo9d31qSmK6MPlYH6Gn1sjme4lFBOKUUwEopaKAG0UtFACUUtJQAUlLRQAlFLRQAlGKWigYlFGKKACiiigAoopaACiiigQCnCkpRQAvermmyeXeqScA5FUu9SISsgZTyDmsKseeDXdG1KfJOMizq95DdW8iwgbowd3tXGXEwV32jbubg49ataveHSdakDHMMw3Y9QRXJ6lrrBQ8eFET8D+8K+F5XCTiz7OL5opnYGPNs2RlPKI5rw/xnOv9pNHGAFB5AHSvZra/S68KG5iI3MmRjnBrxHxbGyag7yHLSHc2O1a0XZ2Mqi0uc4xz1oBxSE0ma7DlJUb5ga6i0YNaISecVyanmt7Rpi8ZjJzt6UDKuswhJlK9DWVXRaxEDab8ZINc8RQIO1WbJS11GB6+lVsVp6LGWudw7UAdIoCx8jPFc3q10ZJiinAFdFdkx2rMMbgM1xszl5GY8kmgCJjSxPskDDsaaetJ3pgb8Ui3cJz6Vk3tp5Lbl+7T7C58mcAn5TW2YEnjyygigDmB05petaF7p/kKXXpnpVArigB8BKzKRniteXBt9x4rNsv9fgjPFaN18tucjtSAxJOHODkZpuaU/eNJtJPHNUIkhk2Nz3q+V3rkVWtrVnfLDir0jLBD+PagZLY38lhKHjHPrXb6B8Q7mCVYnXeTxk9BXnP2pZD6VJDIUcMCR64renXnBmVSjCaPpHRteh1KENvG7oa2K8J8J695F2pkdhFH0BPU17HpmtQ3sAJYZK9c9K9yhWVRHi16Lps0zTccU4HIBoIrqOUZikp1IRVANNJTsUmKAExRS0lACGkp1JQAlFKaSgApDS0UAJRQaKACkNLRigYlFFFABSGloNMBKKDRQB4nqJN9dbrBBGmAdp7Yq7YsRZo13cEKrMqnqGx/+vFVdK024uhPIssKKhH+sfb+OO9XXbbJa2Mnlt5bbAyDg5Oc/rXw901sfUok1R7cJbyWokBDfvCD15rQn8XXGjWqpYWMNt0O513M3HvUMFi9zC+mKjMy3bPvPG2PJH41Nbafa2+qu+sSiSHyj5R67R2B96HoiuZMzNGnk1O7murraJpmLF8Zxmtmy02XTpZLmVAwRDISRjjt/OqFpfW1lDevCfm3AR7EHQ5zU+rahbmyjeRppX8iPepyuflPH06Gk3JtNCuZ8dyJpmLlgsjfKzfxHvW9I6W729tHO5VQTJkfKBXHWlzcSRonLBX3KCvC1tmUlFE021JEIkZR6dqcoWaKUnqQrdKl1NcFG8tPuMvOOe9a1qYbfVLTUQokt5QAEDfMCfWsPZAZBaWBdVlxuz82cc1chWaWR7SwXaAoYnHcela8yUWmRyu90y7c6hNLqElvN5UUTTEKSMnBPQVja/PMbw20aiOGNuuckGnFxp5ZrlyskbhgoGdxz1rN1LUhfB0SN0Vn3M7dzUNOSTvcduXQt3ew26L5+HCjJQcGtTSL6O0+aaMs5XjPT8arWroLOG2nRZGdvkO3+dXkurZZHhltCHI2b8dD6VtBNrQzk+jOntdWH9ni1ntxIsh3AgZzj0rlmu7eTWJmhjeIrkbWGQDVaM6hcTObNt6Rg4UjGMUy2M0kZheVEdzhyBgitudSjyp2ZCi07vYt29+WvCC5CAjKr3+ldvp2q2YttsT5UrxngjHrXny295bskkTbhG3Bxy1XfNvL9TbsNkjHPyjBrpw1VU0+ZnPXoubTid+LpPJWRWVhJ1weBWE1v9uvGaOVfLhyx3Nxx2rBW/mhtHScMEQbS27BB+lU4r11s/s0LbpJn4GME08TiHJJIMPRcW22dSt7M8hNvKg3LtIHYVKtzcW8kUdrNA5ZsYJ5zWTDa3WnIPtUe2Zlz9BSIiW7eek+8MeW67TWSqVJaRexo6cEryWrLl9dXdteN58iO4flmbgVu2XiBNkdvMFaYrwUOQawGvbdo1FzAXSRCPMPQmqOkxWsV4WjdgrcLv6j6V1U6lSNtdzmqQpzv5HXXNzHMvkyvskByFB+YVK0+6JYyxMwGEOPmrFuLRbW4jmtgss5HIY9R61GNViguVZi0kq9ef0rs52o+8c3Lr7pPe211Dc/vn3yYyMip7fU5bZFW9RkyP8AW47VTa6murhpCwVscK3UA1pLLbwwBZG8yeUbfm5wKxpe63Y2qu9kxlveJc+dMjEwgcHHLVp2lzGyHbzjnb6Vi3U6x2rW9iq7j8rNjgVJo6SWis8ily3Df41vGXvWRhKF4nQCSZkJhQZ/2qZEXluDvYfKO1JBeRtCz5woGBmixHlwmRjncSc1sndnPbQlmiVwEkGVPSsm9t50u4UkmIt84GP5Gtd3WaPIPA6YqhqgWaKJXbG05I9TTla12OHNewy4tWSc/ZNqoB82etV7S6iIeMPISpwc8CoEvjbx+XdSDY3Icfyq3Y28NxJ5qAFVOetZJ3ehrpGPvFeVGtbeWSYMoc5GBVjTWkuY2eSErGo+XePvVpXU1v8AZyJGXBHSsyxuJVyqZkQH5QfSnaz1Yc3NG5oPAiIjxR4H8WDSNNBFGCXY56AGkVZpJDvbYjdAtR21pBDezAHPHRjmtElFaGLvJ3ZKk0jrkRnb71aV84qi85SQxJlkJ+9U8IO7axO70FVGwpLuTK2WIp5pqDDEUkjYwByT+lUZ2Atg4606kVNvXk06mAlFLRigQlFGKKADFJS0YoGJRS4oxQAlFLikxSAKKMUUAFFFApgFL0oooEFLSUopAKKXvSU4UmBi+KtNF5psU4O142259RXnOoaTmPMsrbeuB3r1rUkEmhXI/iTDAV5HrN05ZVG4EMQwHpXyOOp8uIZ9dgavNh0dNoRitfCd1bxttBAOWrzPxVsnlY4AKnIHrXdWsgl0NkQgYXBFef6xERJI8oG/cVyOi1x001LU6ajXLocs4wfemZqxOwaQ4GKgxXYcQoOK09GlC3Qz3GKzBVi0JS4Qj1oGdNcoJYiG6YrmJk2Ssvoa6nqg3dcVSfTY3kLv3NAHP49K6TR40S3VlHPeohpMayKw6VowQiKPaOg6UCKGu3bBRGhwG61zbdTW7rrZaMBeOuawzTAZSU6jbmgBB1FbFhqBJWNvpWXFA8rBY1LH6VsWGkMrh5xjHSkMt3cJmgwO44rIm06QSKqc56n0romCgAZziopWjRdxwKBGFb20kN0Ay5HqKt36uYQqL9ati4gLYQgmnsm7k+lAGJDpjsMvwKsR2KQ8k5+tLcaj5YKKnIPWqUmoyuD70wLM9wkSkL1rOluGkPJpjuWYkmm0xBn0qaGUjhjUNAoA1ILkxAFT0ORiugsfFN5DsiSVkTOSRXIxSbOvSraHK/LWkKkobMmUIzWqPoXwp4lj1SyRHPzjgZ710g5FeDeENWks7gszbYo1y3Net+F9fj1u1cq3zIf0r3cPWU467ni4ig4O62N40lOoIrrTOMZSGnGm9qsBDSU6kNACUUUUAJRilpKAEopaDQAlIaWjFACUUUUDDtSUtGKAEooooAKQ0tJigDwmewuY7G0LyITMpYEA52A9f0rols7W5msb24unVxIEWJEwQijlj+lYQvWkvpbhFGxE2wxk4wvpVWTWbrfJJfZSZT8uOPkPXHtXxb2sj6pWR1uraFeOYJ7HUGufPBwyHj8cVkXS3AmiN7vjTygTErYLheC36E1Y8Gams15+8u2hjj+ZRu6mrmoCS+1A3RKmBIjH8/sTx+NYc3K2mXZMy7W+RY57S3XyllUsHfvjotPL3VxYvf30oZgQnlt06Y/l/Kq15LcvOZ1iCiNw21V+VTUFwENncXS3AUM3ERPrVqXMhWsddoOjpc2tpMnkEI26Tc+DIuegBqhfX0t5JdQDy0t4ZGcoq4bGcYrl9LvJCw8yRiIx8g3YxWreTSC3STyi0ko3SSkfe96UnK5KV9QujBaX0S2k5YMAVYdVNaZluLJY78O3yLtb3z0rlvJmuJ0aGJiFcF5AOAD611d/pyQaewgvmuF2BiCPunHSm0m0i4ve5WnuW1O0eacRpsIK56saxryYXLxj7hDcgDkD3p9s0QViZGZEwzKT71bvoPNiZrCRHiUBmAXt35qorlYua8R1rDJqN6R9rWFbdNwJH3u2K09Gs5DayTXEgZ5Wwo/xrAsw9tILhP3uOAg6c10S6rZ2GksskRNywO45xtJrWXMo3XUzVr2YkiPpiyETFX7gdDntWdcWk9yz3L5XbwQRg1DNLcpZpJMfkJGXPYetS3LTrZi7knzu5AB++Kw1TN3royxpmrJpl3GHbzEKFcgZApt5c3UF6J7YORnKsB0qnNPaxW63Eb7GbG1Md+9aLakbuybzJguFG0lcfhVxu3oQ7Lcyr6+uZ5xJKuU3biqnjNbEhshHFqJmBdBwBxtIo0zTX1KNzDJCsSABT7981lXNnLb3DW0xVlLZ+U/rWk5JuyexMY2V7G7eeJTqdpDFI53qOp60sk9nDZKCGG7ncOzVjjyZWMYYiVMBcDk0y+vCLTyJ2KhjxgZORXRRk4XfQwnHmZrvJLJHHbQsX2/NIoGdg9ajW4vmvoFtSuz1K4x61k6bqFzAJ5LWclwvzgjt7GrVhpWo39mdUu3K2qHcm5sZNa+2VrbGfs3rY6RL37Leo0Mhu9wO4Hgr7VNZ6Be38jXt1AERm/djng1TaOCbTvtfm+TKpAEeOD+Na/8Ab8sFrbsJ1P8A0xVuAcdcVsp88dXsZOPK9FuZ+sG/0mZUmVHiUf6xQflq5pFzEsnmTOGYr+7z0rLj1qXWruYzsMq2GQj5SP8AGq8lpcz6lDC8vkxvJgkDoPWpniNbpaDVK610ZtXl8ttaXJjAMpYFRjgVLb6s8Fuks0TN5ijATkZ96hubGx0u6Nhdz75PvBs8OKpW6PcNLHau2yFsbgc/StadV1LNGdSCgrM6E3htdIxPGzseTtHC5rR+0ItihWTJYD5cYIrk9VGp2scUjSrI6/MwA7VrafM+oaclzcZ80/dJ4FdEZOEndmMoXskdBAyJZ+YxGFXJxXMG7n1TUGNtuMKtgkdj9affa0kMMdmjr5jnDEd6tSQQ2GlqYpPLlZgxI7mnze2emyJ5fZq0typNGrq41BNqnG00ljZva2/7m5do3bdtB7UzxFfCOyWG5cbjgKy1a0/y101I0kGNuQT1aqi1z8oSV4psvFlijHnooHQZHNPSaKAqqNnPf1qpfzyy26ERZCkByTgCqTBGb5HZtxPCfdWtJSd9DNRVtdzpTfQEbXZUYDPLVnJchxJOmDJkgkGm3FlHHYLOux5FGck/eqpaXDcoR+8ZsNGeAo9aJSb91gopK6ZtwRE2+WAywzk1NYg+RnOTnBNErCO1IYgFV4NZU1/LaxRNblHBHzpnkn1rTmjHQy5XJXNW5kMZUp95uMUqRFeXcljWVp99JeTObj5G7Z6VpveRLb/KQ0h4o9paPNYSptvlJwoXoc/WlBBqqL2E9G3EDHApgulT72VB9RWkZKSuiJQcXYvE4oqFCZiD0Xt71KZBGymQZXpQ3ZXZPK27C9aSjIGc8DtSbs9OlUhC0UtJigAoopGbaPegNdhCcGnYpig9T1NOzigBcUYoNGaADFFFFABRRS0AAoopaBBSjrQKXFJgPjVZN8bgESIVrx7xVG1rdyDGCrEEV7AhwwNeffELTV/tEOowsi7h718/mkLNVD6DK53i6ZgaFOs0LgE4HWuZ8RJI11NtX9y53Ka6Hw7tV2t3GAwwTUvifR2gslcDjlTx+VeKp/vD2JQ908rlXEmM5qMj2q3JbP5jZGDmpIbJplJA5rsucVjPC81oadamSUMegqxDpfzZfnBrUt4ViX5VxQA8fcHrTgP50ZAHPB9aqyX8cSuCfmXtQBfVfenhR1JxWFHrXzfMvFaFlerPHlmGSaAE1K0Wa1Yj7w6VyzqQTnrXblQ8Z6ZIxXPy6Q5uGA6dc0AYoGTV7T9Oe5mGQQvcmtWz0dYnV5fmb0rURI4B8qgAnkUCIraxitV+VcUXdwIupAFRXt8IIyewrm72+e5c8/LS3GXbzVjnbF69azJLqWRTuc9ahpRzTESwFvMXbnOa6SEkxDdxxWZYafu2Slh9K1Zm8qPJFAzH1SLLbo0+tZZrojNFNHxg+tVJ7ON1yo+b2oEY1GKtyWUkfUZFMe2ZcEjimBWxT40LNhRk1Y+yScErwatw2gjww5agCp9kbgmprZCjEP2q9tXiq1ypH+r60ATi6ZIJIozjf1PtXU+APED6drUcTvtiYYOTXBiRlOGNWre5McgkU4K962p1XCSZnUgpxcT6itbmK6gWSJgympq8v8C+KhHpojuHPyZJya9ItLpLy3WaNgQwHSvoqVRVFdHgVKbpuxMaDQetBrcxG0hpe1JQAUnNLSUAFFFFABSGiigBKKWkpgGKSlpDQAUUUUDEopaSgApRSUUAfN11KY7vfCQ3zngHg1qX92+twWU1+rAIHQ+WnO0DOKWbR0h1zYVYIVMiuegBGf60yfUyjy2tjIkUKrzxy3t/OviJPXY+qW1ynpl35czx2kIYscBz/DXTeZJJFa6UrGV3cSSuThUY5GM+mMH61zum2VxcXBFtiNOpf2711Ntbi4uvLdcxllbcDgH0z+tZ1Wo6sFqWtRvLXRIZrT7VHLNIm5iBnB9q4m4uEu32wZfJOAorY1/TXGruwYSQofvdjU9mmmRx+Xbwbp2YsJB0VQM4p07cugznliuLIF92xzkBWPIGOav2t5PJapDeMxGAqZ7D1qWO1TUPJnvS6Ru2CxHPNRauRBDGFbcIjgYHbtWvMnoHLZGzHDcNb/ZrBvKTH76TOFP41ZgvM2vlWz+bGmRKe7nHWsGxvr7U51hMqRQFS2B90YHWq6yG0vnxISR91k70WV9BXN2+0y40/TUn8tAk43DJ5x9KZc3Dx6bFHDHncB5joOAPSqMt3NfthpMs2OP7uK12mFjpslnOqy3Ey5Z933aUnZlIow3S2kQeA/u2bHPtSXN6l3KUhkMrP85LDGOKgttPnMMZhjZ4mbJLeverkNj9naZ5SqBlwHI5+gq7p7kq5Vm1VfsotboMY85x1zWlFGH8MhkgJLEhGY5AHoBWNeGzjtwsKEzlgC27oO9XnaW2EMfzKuBtXOc0Jcwr2ZSsLS6uIWFwgEMLZ3/3avWd3b3FwYijPAoIBPGT61rPqFvNpZhjREkUfMRwTXO316UUQRhVVV5KjBP1qFeV1sU7LU2bDWzp2+1SON7d+p7r9DTbqSLUZGa0EiSg4+bpiq2nPZto6IRsER3Scctk12+oto2qaDDJolviaCPMqgYxj19ai9pbFnO+H9IN1E/nS+S2erDGSO9ZWrWFzNeDyUDAE7iO2KtW2sXkM0irGJI5flCv1Wm2Rvbm6uITuRQdxwKtyktbkpJq1icWCRxQtaygiVNroOSD3rcs9Xtl0Z9Ini/dxjrtzg1SvbhV0/8As63gCyNyJuhxWXb3C6fE0KSBpZCMseQtHMprVByuD0LTk6jOLJH8qGM7t+PvfSpYp0tbhLYIsjEhTI3UVJpX2f7fid1mCJuZgcc+1Phjjl1G7lmRdkQ3Bf8A69ae26EezNk2Ntb6eLgRRiMH76HDZ96yYRdQXZurtSLN/lWRu1IupJNFJYGM20MgD887qzbs3TBYLS5eSB+Nh6CtVXu7diJU7rU05LyHVY2eKEubf+JvSsvQdbfT765a7icQs+VqDzhp9j9nL+XLu+bHepdKH2zcqhvN6lj0xSp1XGfME6alHlZ1EviOwvroRxfOW+9IRwKWxnWa8lSxkZ1gGWDDAPtisMwCGQTXEKoE6DHU1NJd3dttubJlxP8AK0KjkCta2IcyKVDlL8MYfXBLL5ZCncFbgmuhvr9LmMRxwljHg4HQ/jXKQ6tbwIsoRpbo/KUfnbWtpd+rWEr36KHLEAJ1ruw1SMIpX3OKvCTnzWKWvot7D5shETIAVjA5P410OmNaWunwT3e0fuvl9q5cXMbvcrdysqqCI938qhtLseTC3z3Gznaen4VcaqVR2Qp03KCuzp9ZWW5tTcxqyWvUr3YVc0t7KPSI5YifLkXJUjJNU4NdD20n2uNtrDaEx04rK8OXTNrs1tLuSGNt0aH0rq9pdprqczg7a9DoIkRY2kmGYegXP3PwrNS1Vbh72G43Kr7QO1aHiK+W3s3WJU8xh0JxkVy2g6pPBcN9lRJd7ktG/Kg+1cmLqOKUY7nVh4xfvNaHUX90Lq32BiCg3HHespreNI0CXLhmXJycYq5Z7pp2y4EpyGReWqJJNPls5LaFS02MF8c5qFCT1k9TRygtEtB4EMMMUyQyybBgnnBq214YrVnjijVlHyjPJ/Cs6DUDKklpKWiSMbRgcufSm6VdW9wkisjRso+cE5+ldCqaJX6HNyWb9TS0OW4uPMMiKHzkrnpV+Y5Q78F88CqWksiK7QEEDrJ7VLJcQNuTzByRg561tTlyxRnOPvtmjAX8sMCAG6gdqZexSvG2GBRRk460sRFuuZjhD0zVJtbSW4ltoVL7OGK9xWtScVZdzKnBtuRpQgPGpznipjhR6CsmC/8AJlkhWNpVjIwwHH0qRr24dcfZX2noSa05jJxbZfV98hx90U8Gs+Ke6KECFf8AvqpN95u27YwT2zVXJ5S25wM/jUKS75MY5xnNQTPeCNvljxj1ptul8sQz5WT0qXqy0kkXvMQdTgD1piOCxkYgL2qhPb3DMTdONqjIC9qsQwFlU7s8cZHalz62Dk925P56nIQFj9KAZOu39akC4AH8qXFWZDQW7inUuKKADFFFLTASlopaAAUtFKKQgFZPijSTqujsw/1lvypHpWuKnhw8c0JHEqFa4MbT9pQaO7A1PZ10+55r4b8MGTU0SRuGPPFdhrugwGzEMo3EEEfhWhpGlNazGR/l2nj6UzxPdeVaSrHywThu+a+LT94+xnqjxzxHoljbySyphXDcL6iubjRU6DitXW2na8le63Ju5UVhi8jXgtXow2POnuXAopSMCqjX8UajLZzVmKQSRgrytaGZU1KUww5B71z8kpkkLN3rX1eVfs+0/e7Vgk0APzU9tOY5VOeBVXNOU80AdpbTB4QQeop7bAeTzWPopbyyzEnngVPq8zRwblbBoAuSTpGDuZc1j3ur7ZAsXQday5Lp5f8AWNk1AeetAE1xdvOcsePSq4oxSgUwExUkELTSBVBPPNCL8w7iui02zVIvMAHPNJjJLa3W3t/XArO1G+BiKgkN6VpXVysSH0rm7yWOVyUHOetJARLKyHKmrkF8RxJ09azjRmqEbQuI3xk1LhXXpxWPbsgfMnStaMb1wvAxQA/eoAXFQT3CovXkVSuGeKUgN0qrJIWOTQBaa+LLjoc1aFwJLct/EBWRmrNo4LbG6GgRE7ZYmnI5XpSTJtlIHrSxIzNgCgZqWd/Jb/6tjgnkV6T8PPGGb1rO8fCsMpk968yWDYB64qS0uZLS5WSIlWBrpo13Tl5GFakpxs9z6eilSaPdGQwPQ06vP/A3itL2RbKZzux8vNd/X0FKoqkbo8KrTdOVmBpKWkNbGQhpKU0hoAKKKKACkpaSgAooooADSUppKACkpaQ0xhRRRQAdqSl7UlAHm/j+COP4d6XPGgSXaE3qMEjHQ+teW6SizahH5o3fvF60UV8ZL+Gj6l7I7bTVAtr0gfdjYD25FMcmM3caEhPO6UUVy1/gJ6Db35ra3Uk4bORnrRpcMa3uxVG027MR74PNFFVR+FGi2Kgupnu7KJnzGJPu4GOtbtxDFd61qMVxGjxrEWC7QADx6UUVs9xLc5iMeSJPK+XI7VV08l9RXfzx3+tFFLoHU39Fhjea5DIDhTiqkqKl1EFH3jz3zzRRRHcJGxk2kw+zkoFAwAeBxVe6YzTr5h3ZyTRRUL4maS2ILGCJ4LnfGpw4IJHvWiFDM24Z2qdue1FFUg6nPaeoM1yTk45HNWWiQWcr7Ru9aKK17EPcl06NTpyqVGGk54612ej28UenTBEAGwmiispfEVE5m2dhq8seflyOKuxyPb3kzwsVbOM/jRRSnsNbj76eT7Wx3ckjPFZcyhZ5GUAEjk4ooopbA9zotEs7d/C5maIGQsfmPWqGoTyRaXcPG21iMEgdqKKhfEOXwk8EjTRoJTuAt1xkdKbJK8N15cR2qVBwAKKK1jsQynfRo8js6gloySSOtR2SgWcDjhi+CRxxRRUv4R9TW1z93bRbOO9UPDMzzXc7StvKg4z2ooqn8BJ0GmW8LW8jNGpZm5OOao6z/oupIlv8ilhwKKK6f+XkTF/AyhI7HVolJypBJHrWjpqgQ5HXmiiuyPxHNLY05okWSB1GGYZY561WuGMWsW00fyyOQGYdxmiiuuXwIxhuzM8XXM0l86vISAOKh8MgRaOzx8Pk89aKK8+X8RHTH+GzqdH/AHKrcR/LM4+Z+pPFVdKkYSTsD8yk4NFFd8jj6GfbSO95lmJLMxPPeo9LkZr+VWYkEEketFFZo0l1NppHt7WOKA7I3cFlHerFvGsm1nUEqxwfSiiuqOxydy9qMrnSYiWyWfBrIU/Zld4PkYg5I+lFFZVf4kTeh/DZq6Yx8m3XPDfM3ueKtM7NdMrMSoBwKKK6uxz9x2mMW8zJzhuKtSHMhbuAcGiitn8Jg/iGysTbsT3IqxF/q1oopxJkMuv9Qf8APep26J9KKKXUa2CiiirMgooooGFKKKKYBSiiigBRS0UUgHCpITiZcUUVlU+FmlP4kaN6xEXBx0rn/EQ/0MN345oor4Op/EZ9pT/ho8G8W3c73DK0hIBOBXGbjnqaKK7qexy1NxwJJ5NdFYf8eS0UVqZGXrP3hWTRRQAU9eooooA6jTRi1XHpVTXP9WtFFMDn6KKKYB3p68sKKKQG5p1tCygtGCa1gAkfyjH0oopMo5/U5HJwW4rKNFFCERmiiimIcn9a3LXm3FFFAGZe/wCuaqZoooAKlg/1i/WiigRdkRS2SKkhUK3AxRRQxiSyNnrUaEnrRRSBnTeCJHTxVZbWx+8x+lfQQ+6PpRRXvZf/AAzycw3Qvakoor0jzBDRRRQAUUUUAFIaKKBiUUUUABpKKKACkoooAKKKKAClFFFMD//Z"

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
      value: true
});
exports.default = africaMap;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function africaMap() {
      return _react2.default.createElement(
            "svg",
            { className: "africa-map", width: "708", height: "400" },
            _react2.default.createElement("defs", null),
            _react2.default.createElement(
                  "g",
                  { transform: "scale(0.3793462434544914) translate(483.18440898827015, 0)" },
                  _react2.default.createElement("path", { d: "M264.1,336.73l-0.38,0.6l0.64,1.4l-0.24,0.6l0.45,4.56l-0.35,0.78l0.96,2.95l-0.52,0.38l-1.13,-1.12l-1.14,-1.92l-3.05,-2.52l-6.67,-0.25l-5.65,2.08l-0.81,1.11l-1.3,-0.33l-0.81,-0.58l-1.06,0.11l-0.97,-0.44l-2.77,-1.95l-0.31,-1.37l-1.35,-2.42l-2.01,-0.98l-1.43,0.04l-1.31,-1.03l0.73,-3.93l-0.35,-3.1l1.58,-1.01l1.2,-3.07l0.23,-1.91l-0.71,-1.89l0.01,-1.44l1.9,-1.47l3.57,-0.76l1.28,-0.57l1.37,-0.98l1.89,-2.21l0.18,-3.18l-0.55,-0.89l2.84,-1.62l-0.0,-1.17l-1.15,-2.62l1.92,-2.04l1.07,-0.83l1.03,-0.2l4.85,2.6l2.89,-1.19l0.65,-1.69l0.16,-2.87l2.6,0.33l0.84,-0.24l0.52,-0.67l-0.09,-1.24l0.56,-1.81l1.04,-1.38l2.19,-1.78l1.28,-0.48l4.22,1.21l0.87,-0.55l0.92,-2.93l3.12,-0.59l2.38,-1.42l5.16,-2.3l3.42,-2.74l2.42,-0.33l1.68,0.77l1.87,-0.53l4.84,1.61l-0.54,4.66l2.53,3.13l-0.28,1.32l0.93,2.11l2.22,3.21l3.45,1.25l0.77,0.57l0.62,1.12l1.49,0.83l-1.54,-0.34l-0.49,0.28l-0.2,2.42l0.31,1.85l1.36,0.54l5.62,4.39l2.81,0.25l2.58,-1.21l0.76,0.11l0.56,0.66l0.68,2.06l-1.55,0.4l-0.37,0.74l0.45,1.07l3.34,4.38l-1.06,2.14l-3.38,3.04l-1.4,-0.26l-2.79,0.47l-0.58,-0.54l-1.85,0.09l-1.35,1.84l-1.84,0.43l-1.01,2.24l-1.1,0.01l-0.52,0.8l-4.55,0.45l-0.36,-0.43l-9.2,-2.08l-0.8,0.93l-1.17,0.12l-0.64,0.9l-1.44,0.83l-0.73,-0.69l-3.99,-0.25l-21.0,0.14l-0.48,0.5l-0.82,3.01l-0.1,1.69l0.51,1.27l0.95,0.91Z",
                        "data-code": "BF", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M800.21,310.86l2.49,-0.89l2.06,2.6l1.22,3.04l-0.29,1.0l-1.15,1.3l-2.56,1.63l-2.88,1.05l-1.89,2.09l-1.18,-0.12l-0.43,0.5l0.21,0.81l0.84,0.38l3.96,-1.06l2.72,0.22l0.63,0.5l-3.48,5.46l-1.25,-0.1l-1.52,-0.81l-1.29,-0.06l-7.07,1.65l-1.47,-0.35l-0.35,-6.88l0.5,-1.41l2.1,-2.23l4.78,-6.87l0.41,-0.18l2.18,1.59l0.67,0.03l1.08,-0.76l0.97,-2.11Z",
                        "data-code": "DJ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M645.42,511.17l-3.4,-6.8l-0.35,-5.31l-0.5,-0.69l-0.91,-0.23l0.15,-3.04l-2.45,-3.14l0.12,-1.27l0.29,-0.52l1.17,0.22l1.0,0.53l0.56,1.26l0.68,0.41l3.89,-0.15l2.23,-1.13l0.73,-4.21l1.87,0.92l1.43,-0.81l1.84,-0.36l1.16,0.82l-1.21,2.39l0.44,0.94l-0.49,1.29l0.1,0.79l1.2,0.8l3.01,0.8l0.04,2.71l-1.83,0.84l-0.27,0.31l0.11,0.7l-2.25,1.87l-0.64,1.8l-1.27,1.37l-1.42,2.74l-2.26,2.52l-2.81,1.65Z",
                        "data-code": "BI", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M308.12,330.21l0.86,-0.9l0.64,0.14l0.6,-0.3l0.86,-2.1l1.82,-0.46l1.23,-1.76l1.22,-0.03l0.73,0.59l2.95,-0.5l1.71,0.19l3.64,-3.28l0.95,-1.86l0.61,-1.99l-0.56,-2.46l3.11,-0.81l1.69,-0.98l0.63,0.14l3.09,2.89l1.79,2.3l1.82,0.94l1.42,1.5l-1.11,2.16l-0.07,1.39l2.7,3.89l0.46,3.62l0.9,1.82l-0.57,1.92l-0.76,-0.15l-0.67,0.27l-0.97,1.57l0.01,0.66l0.72,1.13l-0.93,2.67l-2.37,1.13l-0.44,0.68l0.04,1.14l-2.2,2.49l0.07,1.73l-1.05,2.47l-2.97,0.39l-0.35,0.34l-0.49,3.14l-0.55,10.76l0.42,3.23l0.74,1.58l-0.4,0.87l0.07,3.84l-0.41,1.09l0.59,3.12l-0.76,3.68l-10.19,1.27l-0.39,-1.8l-1.68,-2.19l-0.17,-0.62l0.25,-0.77l-0.62,-2.49l0.9,-0.43l-0.29,-24.23l-0.51,-1.3l-2.01,-2.49l-0.45,-2.39l-0.22,-5.16l-6.61,-4.58l0.26,-3.59l1.26,-3.12Z",
                        "data-code": "BJ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M740.97,1053.87l-0.3,0.16l-2.08,-0.34l0.77,-0.88l0.95,0.15l0.83,0.6l-0.17,0.3ZM513.38,877.36l-0.7,-2.43l0.21,-1.52l1.33,-0.97l-0.39,-2.31l-2.04,-3.95l-1.28,-0.93l-0.91,-1.89l-0.98,-0.79l-0.44,-1.41l-0.87,-1.03l-0.28,-1.52l0.86,-1.1l1.02,0.73l1.17,-0.42l1.58,-1.41l0.87,-1.92l-0.14,-5.2l-1.18,-4.99l-6.3,-9.48l-3.86,-7.37l-1.84,-4.4l-2.82,-8.97l-2.49,-5.08l-3.19,-4.84l1.71,-1.23l1.58,-0.5l1.51,-4.23l0.55,-0.6l1.17,-0.4l0.86,0.51l0.67,1.49l1.71,0.81l0.27,0.89l-0.5,1.25l0.06,0.63l1.46,2.85l2.93,0.89l3.23,0.54l1.6,0.79l8.58,-0.04l2.15,0.73l1.89,0.12l1.15,-0.62l0.66,-2.0l1.14,-0.28l0.89,-0.67l0.72,-1.13l1.41,-0.82l2.31,-0.66l1.14,0.02l0.41,-0.4l0.0,-45.51l3.59,2.68l0.95,1.39l4.2,9.51l0.27,2.9l-2.22,3.62l0.17,3.82l0.55,1.14l1.12,0.53l1.45,-0.47l2.34,0.53l4.45,-0.24l2.39,0.25l1.22,-0.68l1.03,-1.55l2.03,-0.52l1.07,-0.76l1.54,-2.45l4.44,-3.21l0.59,-0.91l2.77,-7.63l0.78,-1.0l1.09,-0.64l2.32,-0.54l1.33,0.28l3.19,1.73l2.71,2.14l0.99,0.34l2.51,0.09l1.71,1.37l4.87,0.93l1.67,-0.08l1.44,-0.71l2.47,0.03l2.89,-0.6l1.77,-1.52l3.74,-10.56l5.64,-1.65l0.77,-0.5l1.88,-2.25l2.53,-1.91l1.9,-6.79l1.09,-1.48l2.61,-1.84l2.17,-0.7l0.76,-0.54l0.84,-1.24l1.42,-0.32l0.29,-0.74l1.83,-1.35l0.14,-0.7l3.09,-3.46l1.9,-1.17l3.64,-0.71l1.74,-0.69l1.35,-1.12l0.83,-1.45l1.19,-0.7l6.13,-0.81l2.7,0.45l3.43,1.33l3.27,0.47l5.28,-0.47l1.78,0.2l2.22,1.0l2.84,10.65l0.18,2.57l3.01,5.17l2.14,6.91l-0.02,14.51l-0.75,1.88l0.25,2.05l-0.38,0.1l-5.35,-2.92l-1.09,0.12l-1.7,1.23l-1.4,1.72l-0.68,1.53l-2.73,4.04l-0.07,4.73l0.46,0.47l0.66,0.07l2.05,3.86l2.6,1.72l2.49,0.78l3.2,0.18l2.56,-0.05l0.39,-0.43l-0.14,-1.63l0.52,-4.16l3.87,0.62l5.77,-0.15l-0.36,2.4l-2.25,6.66l-1.43,7.49l-1.84,3.72l-1.01,1.51l-2.97,2.73l-1.48,0.86l-1.49,0.43l-5.23,5.67l-1.94,2.72l-1.74,4.0l-1.71,2.2l-4.74,8.26l-2.14,3.28l-3.68,4.5l-2.75,1.91l-2.96,2.65l-7.38,8.08l-4.73,4.27l-2.78,1.91l-4.1,3.69l-5.83,4.03l-3.32,2.09l-7.45,3.08l-5.07,-0.62l-2.27,0.34l-1.99,1.57l-0.29,2.16l-0.44,0.19l-4.58,-0.97l-2.09,0.16l-1.39,1.25l-0.86,1.33l-2.44,0.07l-4.83,-1.48l-5.72,-0.91l-1.5,-0.07l-3.6,1.24l-3.92,-0.23l-2.3,-0.7l-2.13,-0.0l-3.86,0.86l-5.25,3.93l-2.63,0.0l-2.42,0.46l-4.2,-0.54l-1.32,0.26l-1.31,0.71l-2.94,0.34l-5.89,4.21l-4.29,-0.41l-2.76,-1.89l-0.65,-0.02l0.02,-1.4l-1.07,-1.12l-1.17,-0.04l-0.78,-0.87l-2.78,0.16l-0.24,-3.04l-0.95,-0.65l-2.91,0.11l-0.94,1.2l-0.06,1.39ZM623.55,807.58l-1.33,0.56l-5.08,7.29l-2.34,1.04l-0.45,0.34l-0.22,0.76l0.97,2.51l2.58,4.01l-0.03,1.17l0.48,0.94l1.3,0.73l3.08,3.04l3.47,0.6l1.11,-0.88l0.57,-1.81l2.77,-3.68l3.97,-0.58l2.01,-0.85l2.35,-1.56l0.64,-2.92l1.77,-1.76l1.17,-3.92l-1.08,-2.49l-4.17,-2.79l-3.9,-3.86l-2.17,0.4l-2.81,1.09l-3.25,2.21l-1.44,0.43Z",
                        "data-code": "ZA", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M592.94,670.5l-0.23,1.26l0.71,1.59l1.23,1.28l2.04,3.62l2.35,2.48l0.65,1.85l1.45,1.67l0.11,1.69l2.56,5.57l6.11,4.47l5.85,2.54l0.78,1.38l0.27,2.94l0.41,0.38l4.41,0.23l0.15,2.87l-0.36,3.84l2.09,2.49l2.0,3.59l0.63,0.38l5.67,0.95l5.59,1.71l-0.22,1.52l0.42,1.17l0.85,0.66l1.53,0.2l0.68,0.71l-1.78,0.15l-1.53,0.86l-0.91,1.53l-1.14,0.97l-1.61,0.64l-3.77,0.75l-2.01,1.24l-2.24,2.32l-1.09,1.4l-0.12,0.65l-1.8,1.31l-0.2,0.62l-1.22,0.19l-1.62,1.81l-2.2,0.71l-2.77,1.97l-1.27,1.76l-1.75,6.53l-2.49,1.88l-2.45,2.61l-3.1,0.72l-2.77,1.1l-3.86,10.72l-1.49,1.23l-2.54,0.49l-2.51,-0.03l-1.61,0.75l-1.29,0.04l-4.76,-0.92l-1.79,-1.39l-3.3,-0.35l-2.6,-2.07l-3.36,-1.81l-1.52,-0.33l-1.57,0.28l-1.61,0.5l-1.77,1.76l-3.29,8.45l-4.38,3.15l-1.55,2.46l-0.82,0.61l-1.99,0.51l-0.68,0.47l-1.05,1.61l-7.08,0.09l-2.33,-0.53l-1.57,0.47l-0.8,-1.03l-0.17,-3.51l2.21,-3.57l-0.28,-3.35l-4.29,-9.69l-1.09,-1.56l-4.12,-3.05l-0.04,-33.77l11.25,0.0l0.39,-0.32l0.05,-44.66l11.82,-1.44l14.08,-2.4l0.71,0.26l1.82,2.37l1.36,2.58l0.7,0.36l1.27,-0.46l2.42,-2.43l3.94,-2.42l1.22,-0.5l2.22,0.81l3.02,-2.24l1.27,-0.49l3.45,-0.39Z",
                        "data-code": "BW", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M221.33,99.35l5.55,-0.16l6.56,-1.62l1.94,-1.36l1.39,-1.43l2.48,-3.82l2.1,-1.06l5.33,-1.88l3.96,-2.76l3.8,-0.7l0.66,-0.8l-0.08,-1.13l-2.32,-1.51l0.5,-2.08l-0.68,-3.22l0.65,-0.61l3.77,-0.18l5.04,-1.7l0.6,-0.79l0.62,-2.04l0.54,-0.29l4.79,-0.71l13.74,0.53l0.74,-0.27l0.25,-0.37l-0.41,-2.14l0.19,-0.64l1.95,-1.62l0.11,-0.49l-0.64,-1.23l-3.91,-2.98l-0.64,-1.1l-0.52,-2.63l-1.44,-3.04l0.54,-3.16l-0.97,-2.93l0.25,-2.74l-0.17,-2.45l-0.95,-2.48l0.64,-1.41l-1.32,-1.83l0.6,-1.91l-4.07,-3.16l-0.72,-1.01l3.05,0.07l2.93,-1.21l4.11,-2.52l2.84,-2.79l7.62,-3.71l2.73,0.57l1.86,-0.27l1.23,-1.02l1.17,-2.1l1.79,-1.26l7.68,-3.75l3.27,-0.99l12.68,-1.21l2.9,0.13l4.55,-2.47l6.35,-0.14l3.11,-1.36l11.33,-0.0l2.63,1.13l2.44,1.81l1.39,0.39l1.59,-0.39l3.49,-1.65l4.02,-0.89l2.16,-1.0l1.01,-1.47l1.48,-0.43l1.07,1.05l4.12,1.13l3.87,-0.66l0.27,-0.48l-0.26,-1.08l2.04,0.34l1.97,0.77l2.11,1.58l1.54,0.39l2.7,-0.72l4.92,-0.34l0.15,0.75l-1.6,0.85l-1.01,1.82l-1.55,1.12l-0.44,0.7l0.24,0.66l1.01,0.49l0.39,0.87l-1.18,7.58l0.84,2.07l-0.03,3.22l0.88,2.63l-0.87,1.43l-0.46,1.49l-0.37,3.25l-1.33,2.08l-3.26,1.97l-1.16,2.14l-2.75,2.31l-0.25,3.53l2.8,7.65l0.48,0.56l4.0,2.24l1.11,1.61l1.56,5.14l8.2,5.98l5.48,23.47l-2.2,1.33l-0.13,0.55l3.85,6.11l1.91,5.8l0.42,2.6l-0.31,5.2l0.5,6.57l0.66,3.21l-1.96,5.8l0.58,3.71l0.49,1.63l0.65,0.87l-0.12,2.54l-0.23,0.81l-4.32,2.79l-0.68,1.25l-0.17,1.41l0.36,1.12l6.44,9.15l0.31,3.47l1.07,3.25l1.71,2.65l1.86,1.42l0.67,0.05l2.78,-0.85l9.44,2.89l5.07,9.39l-52.31,32.38l-19.32,17.03l-0.94,0.5l-28.22,5.41l-2.21,-1.53l1.57,-2.44l0.16,-0.76l-0.64,-1.89l0.02,-2.73l-1.0,-1.05l-3.24,-1.37l-5.26,-1.26l-1.41,-1.71l-0.82,-0.54l-3.55,-0.36l-1.93,-0.67l-0.68,-0.49l-0.88,-2.15l-3.87,-2.03l-1.27,-1.07l0.08,-1.93l-0.49,-1.74l-66.42,-45.76l-11.74,-7.74l-36.95,-23.29l0.16,-17.66l11.35,-8.01l2.34,-0.55l3.78,-2.8l5.93,0.6l0.75,-0.22l0.97,-1.1l0.25,-1.88Z",
                        "data-code": "DZ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element", cursor: "pointer" }),
                  _react2.default.createElement("path", { d: "M725.94,291.31l1.59,-0.58l1.43,-0.08l2.7,0.48l0.61,-0.32l0.82,-1.39l1.01,-0.41l0.96,0.83l1.77,2.54l1.16,0.25l3.75,-8.2l1.03,1.12l2.48,0.99l1.79,2.1l0.92,0.64l4.56,-0.65l2.86,-1.74l1.54,1.78l0.99,0.1l2.98,-0.77l2.55,0.43l1.76,0.7l2.77,-0.18l0.84,0.26l3.51,2.43l2.92,1.0l1.85,1.82l2.18,2.98l2.82,2.82l4.68,3.74l2.17,3.56l2.21,1.42l2.63,3.35l-4.31,6.33l-2.45,2.83l-0.34,3.34l0.4,5.17l0.27,0.35l2.11,0.47l7.0,-1.64l0.99,0.03l1.51,0.81l1.06,0.14l-1.56,1.9l-1.21,1.96l-0.07,0.61l1.49,2.73l0.69,2.0l2.69,3.32l1.34,0.64l1.39,3.09l2.16,2.79l1.75,0.62l4.76,4.15l34.61,11.66l10.92,0.04l-17.54,17.0l-17.34,18.6l-10.93,-0.52l-4.87,1.14l-5.48,2.53l-1.37,1.04l-1.78,2.71l-7.25,1.39l-2.4,0.75l-1.75,1.86l-6.41,0.41l-1.94,-0.21l-3.04,-2.61l-1.65,-1.03l-10.87,4.97l-2.27,3.29l-1.66,1.29l-6.08,-0.75l-4.27,-0.94l-5.97,-0.55l-13.9,-8.97l-10.28,-0.64l-2.84,-3.78l-0.07,-1.51l0.51,-2.54l-0.17,-1.57l-0.77,-0.92l-3.24,-0.88l-1.76,0.59l-0.34,-0.26l-0.05,-1.06l-2.16,-2.09l-1.1,-2.08l-0.32,-2.25l-3.0,-7.36l-1.7,-1.38l-1.03,-1.48l-2.35,-1.2l-2.43,-2.53l-0.51,-1.66l-1.49,-1.78l-2.88,-1.96l-5.15,-1.06l-2.36,-1.3l3.05,-5.92l7.75,-0.06l1.97,-1.84l-0.12,-11.17l0.91,-3.93l1.79,-4.02l-0.39,-4.04l1.71,-2.87l1.37,-0.92l2.44,1.52l0.66,-0.22l1.4,-1.3l0.53,-3.71l-0.08,-1.4l1.71,-6.24l1.65,-1.69l4.82,-7.84l1.58,-0.64l3.63,-0.69l0.37,-1.06l0.29,-3.43l0.59,-2.06l2.1,-4.28l0.66,-2.58l-0.02,-1.8l0.85,-2.9Z",
                        "data-code": "ET", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M636.22,488.26l1.26,-0.91l1.11,-0.31l3.12,-3.45l0.23,-0.83l-1.49,-3.68l1.28,-1.64l2.53,-1.49l2.72,-0.58l0.72,1.41l1.45,-0.17l1.44,-1.01l2.6,-3.03l0.8,-0.44l0.3,0.02l0.44,1.46l1.5,1.94l1.0,0.44l0.5,0.61l0.54,1.12l0.07,4.67l0.54,0.99l0.12,1.02l-0.7,2.22l-2.66,0.4l-1.82,-1.01l-2.16,0.44l-1.14,0.76l-1.49,-0.87l-0.74,-0.03l-0.38,0.37l-0.64,4.17l-1.74,0.8l-3.47,0.17l-0.99,-1.54l-2.37,-0.94l-0.91,0.27l-0.5,1.03l-0.74,-0.57l-0.32,-1.82Z",
                        "data-code": "RW", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M644.97,516.58l0.34,-4.61l0.73,-0.07l2.75,-1.8l2.34,-2.61l1.44,-2.77l1.32,-1.45l0.54,-1.65l2.32,-1.91l0.01,-0.89l1.73,-0.74l0.51,-1.14l-0.4,-2.83l-3.35,-0.98l-0.71,-0.33l-0.07,-0.35l0.54,-1.4l-0.47,-0.77l1.15,-2.31l2.85,-0.57l0.51,-0.36l0.71,-2.54l-0.14,-1.28l-0.54,-0.98l-0.11,-4.79l-1.25,-2.03l-0.99,-0.42l-1.36,-1.75l-0.34,-0.99l2.03,-0.25l1.49,-0.64l11.95,0.24l-0.4,3.55l-0.73,1.55l-1.17,5.25l0.13,4.05l1.26,2.01l-0.54,1.03l0.18,0.62l0.62,0.55l-0.27,0.69l0.26,1.29l0.42,0.3l0.53,-0.25l0.27,-0.85l0.41,-0.17l0.39,0.57l0.66,0.23l0.44,-0.51l-0.24,-2.1l1.79,-0.16l0.18,-0.44l-0.51,-1.29l1.57,-1.06l0.72,1.22l1.06,0.65l0.89,0.12l0.26,0.53l0.53,0.05l0.89,-0.65l0.47,0.59l1.22,0.21l-0.07,1.31l0.5,1.15l-0.97,0.97l-0.19,1.62l0.62,0.4l1.52,-1.4l0.71,-0.13l0.28,-0.57l-0.87,-2.06l0.09,-1.95l0.42,-0.49l1.11,-0.09l1.72,0.93l2.65,0.47l0.49,-0.38l0.02,-0.58l4.25,-3.12l-0.1,-1.24l-0.74,-0.36l-2.13,0.64l-3.59,-0.58l1.78,-0.61l1.16,-0.01l0.39,-0.48l-0.77,-1.09l-1.56,-0.14l0.58,-0.45l1.09,0.08l1.33,-0.78l0.22,-0.91l0.88,-0.93l-0.29,-0.75l0.22,-0.55l2.55,0.33l0.33,-0.73l-1.08,-0.91l0.08,-0.38l1.28,-0.24l0.04,-0.69l-0.44,-0.51l1.47,-1.96l41.71,23.3l0.4,2.07l-0.91,2.38l0.09,0.83l1.23,0.54l1.04,1.59l16.48,11.86l-2.76,9.33l-0.79,1.29l-1.08,2.96l-0.19,2.37l0.91,3.37l1.26,1.46l1.69,1.19l1.16,1.46l0.67,1.48l2.25,0.91l0.72,1.43l-0.25,0.93l-0.99,0.98l-0.94,1.58l-0.81,2.28l-0.02,3.18l0.68,0.29l0.28,-0.26l0.72,0.49l0.13,2.05l-1.16,2.69l-0.42,2.58l0.86,3.27l1.26,1.67l-0.33,1.1l2.14,2.83l-0.14,2.6l1.73,5.01l0.08,0.71l-0.6,0.9l0.27,0.62l1.51,0.24l1.23,1.45l1.38,0.17l3.45,2.23l0.64,0.9l-5.28,4.01l-1.96,1.06l-2.98,0.79l-2.85,1.71l-1.64,0.49l-2.22,0.02l-2.26,0.73l-3.44,2.1l-1.86,-1.09l-1.74,-0.43l-3.31,0.24l-0.55,0.43l-0.66,1.93l-1.1,1.05l-2.05,1.07l-1.85,0.39l-1.7,-0.27l-2.93,-1.43l-1.38,0.08l-2.36,1.34l-1.68,0.35l-2.4,-0.11l-1.08,-0.34l-0.27,-0.73l-1.09,-0.86l-2.25,-1.07l-1.76,0.1l-0.92,0.92l-1.46,0.75l-6.7,-0.3l-0.8,-2.01l-0.72,-0.67l-0.78,-0.14l-1.78,-2.85l0.71,-3.19l-0.06,-1.07l-0.9,-2.23l-0.18,-3.36l-0.59,-2.65l-2.47,-3.64l-2.72,-2.29l-1.18,-0.56l-0.46,0.09l-0.62,0.96l0.06,0.99l-2.57,-0.86l-3.12,0.15l-1.19,-1.08l-2.29,-0.28l-1.74,-1.13l-0.85,0.04l-4.84,-2.19l-0.8,-0.73l-2.44,-0.36l-1.17,-0.63l-1.97,-0.2l-0.31,-1.29l-1.28,-0.52l-1.64,0.09l-1.18,-1.05l-0.39,-1.22l-1.0,-0.7l-1.39,-0.63l-1.67,0.03l-0.42,-1.69l-2.07,-2.49l-0.06,-1.31l-2.75,-5.02l-1.4,-1.85l-0.05,-1.9l-0.96,-2.74l0.48,-0.66l0.06,-1.01l-0.46,-1.02l-0.91,-0.88l-1.81,-2.8l-1.67,-1.67l-1.13,-0.35l-1.39,0.42l-2.51,-2.66l0.27,-2.19l1.84,-0.96l0.58,-1.21l-1.05,-2.93l-1.22,-1.91l0.69,-3.57l-0.3,-1.39l-0.66,-0.88l-1.43,-0.88ZM762.78,552.69l-0.45,-0.03l2.18,-1.95l-0.46,1.08l-0.77,0.24l-0.51,0.66ZM764.47,517.47l-0.18,3.41l-0.94,1.84l-0.66,-0.51l0.6,-2.83l-0.24,-1.79l1.42,-0.13ZM760.15,532.01l0.83,2.31l-0.43,0.34l-0.52,-0.95l-0.74,-0.16l-0.92,-0.93l-0.6,-0.04l-0.52,-0.88l0.25,-1.03l-0.15,-1.61l1.05,-1.58l0.23,1.82l0.76,1.93l0.77,0.77ZM683.58,482.55l0.38,0.28l1.24,-0.06l0.79,1.43l-3.05,-1.0l-0.14,-1.03l0.6,-0.17l0.18,0.55ZM670.5,485.68l0.64,0.7l1.71,-0.3l-0.03,0.36l-1.27,0.27l-0.41,0.62l-0.7,-0.98l0.06,-0.68Z",
                        "data-code": "TZ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M410.07,446.64l-1.07,-0.77l-1.18,-0.22l1.11,-3.0l1.66,-1.63l0.99,-2.55l1.02,-1.6l-0.11,-3.49l1.8,0.85l15.42,0.0l0.07,12.9l-14.92,-0.05l-1.36,0.5l-1.02,-0.39l-0.73,-0.94l-1.1,0.01l-0.59,0.36ZM399.74,415.59l1.81,-0.01l0.26,0.34l-0.04,0.66l-1.74,2.58l-0.37,1.17l-0.56,0.76l-0.36,0.05l-1.91,-0.51l-0.27,-0.45l0.22,-1.02l1.41,-0.56l0.73,-2.22l0.81,-0.78Z",
                        "data-code": "GQ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M466.74,733.07l0.38,0.14l0.53,-0.3l0.29,-1.49l0.06,-1.38l-0.78,-3.22l-1.69,-3.26l-4.06,-5.17l-1.58,-3.62l-4.54,-6.79l-3.29,-8.89l-1.52,-2.0l-6.83,-13.38l-1.6,-2.24l-3.3,-3.31l-1.06,-2.44l-2.01,-3.19l-0.48,-2.93l0.08,-5.67l1.56,-0.23l1.36,-0.7l0.99,-0.04l1.23,0.54l3.93,0.03l6.56,-2.95l4.09,0.79l1.02,1.22l1.56,1.11l2.97,1.93l0.99,0.26l4.73,-0.25l46.65,0.14l0.82,0.42l2.79,3.2l2.87,1.25l5.01,0.28l3.11,0.53l6.52,-0.06l2.21,0.27l2.71,1.31l1.59,0.3l4.32,-0.77l1.91,0.08l1.68,0.45l33.47,-6.28l7.59,0.74l1.71,1.01l1.22,1.2l-3.15,0.36l-1.47,0.55l-2.98,2.19l-1.88,-0.83l-1.58,0.57l-2.92,1.63l-3.54,3.27l-0.86,0.33l-1.39,-2.56l-1.91,-2.5l-1.28,-0.49l-14.2,2.41l-9.11,1.31l-3.01,0.14l-0.38,0.4l0.04,44.55l-11.33,0.0l-0.4,0.4l0.04,80.24l-3.33,0.69l-1.64,0.94l-0.77,1.18l-0.76,0.57l-1.24,0.35l-0.49,0.57l0.02,1.07l-0.29,0.46l-0.78,0.38l-1.43,-0.12l-2.25,-0.75l-2.8,-0.18l-3.43,0.39l-2.32,-0.18l-1.49,-0.76l-6.0,-1.39l-1.09,-2.32l0.46,-1.7l-0.33,-1.21l-0.66,-0.69l-1.17,-0.31l-0.68,-1.49l-1.21,-0.76l-1.78,0.45l-0.85,0.85l-1.42,4.13l-1.43,0.38l-1.94,1.43l-6.19,-5.65l-1.96,-2.31l-5.01,-8.64l-1.8,-6.11l-0.09,-1.33l0.45,-1.04l-0.28,-1.16l-0.62,-1.24l-1.39,-1.25l-0.41,-4.36l-1.0,-2.93l0.21,-2.32l-0.53,-3.62l0.2,-2.77l-0.81,-3.06l-1.66,-3.05l-1.46,-4.23l-0.32,-11.33l-0.81,-3.84l0.15,-0.39Z",
                        "data-code": "NA", fill: "#03396c", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M321.81,313.66l1.53,-0.4l0.4,-0.89l-0.22,-1.1l-1.45,-2.12l-1.95,-0.1l-1.94,1.11l-2.45,-0.24l-5.39,-4.29l-1.15,-0.38l-0.09,-3.16l1.82,0.33l0.68,-0.44l-0.04,-0.61l-2.08,-1.29l-0.5,-1.0l-1.0,-0.75l-3.25,-1.11l-2.12,-3.07l-0.8,-1.8l0.24,-1.49l-2.48,-2.91l0.68,-5.15l5.45,0.19l2.78,-0.35l4.15,-3.46l19.81,-0.82l0.66,-1.03l5.16,0.84l0.46,-0.35l0.17,-1.37l2.04,-1.75l1.66,-0.81l1.31,-3.09l0.79,-2.94l1.26,-2.04l0.73,-2.79l0.23,-4.44l0.38,-0.57l-0.08,-25.67l17.51,-3.48l1.14,-0.59l19.35,-17.05l52.45,-32.47l17.54,4.13l1.29,0.7l7.35,6.23l0.48,-0.02l8.29,-4.41l2.16,12.67l0.17,5.07l1.36,1.45l3.48,5.3l-0.67,1.12l0.55,1.73l4.36,4.66l-2.64,5.31l-3.05,36.2l-12.92,13.89l-6.58,9.41l-1.95,4.04l-2.24,2.94l1.66,7.95l-2.93,0.41l-1.59,1.19l-3.77,1.49l-2.64,1.53l-1.7,1.58l-0.55,1.13l-3.62,0.02l-1.52,-1.2l-3.53,-1.28l-3.33,-0.67l-5.41,-0.22l-5.67,0.49l-3.48,0.73l-1.75,0.81l-1.44,0.91l-3.55,3.74l-4.66,-0.12l-5.18,-1.01l-3.4,-1.78l-4.22,-2.75l-3.26,-0.65l-0.74,0.08l-4.95,2.7l-2.18,0.27l-1.39,1.02l-1.14,-0.09l-1.38,-1.06l-2.54,-3.62l-3.47,-3.04l-1.54,-0.13l-8.22,-2.48l-1.61,0.45l-1.39,0.93l-4.84,-0.04l-3.14,0.7l-1.76,0.72l-2.05,1.71l-1.11,0.52l-0.9,5.04l-0.54,1.37l-1.02,1.82l-3.62,3.17l-0.08,6.6l-0.33,1.1l0.59,1.46l-0.27,0.23l-1.57,-1.62l-1.7,-0.84l-1.78,-2.28l-3.39,-3.09l-1.09,-0.17l-1.79,1.01l-3.36,0.92l-0.28,0.74l0.48,2.67l-3.22,-4.6Z",
                        "data-code": "NE", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M338.89,383.6l2.54,-1.3l-0.03,-0.73l-0.68,-0.18l-3.28,0.84l-1.28,1.51l-6.76,0.28l0.76,-3.44l-0.58,-3.21l0.4,-1.07l-0.07,-3.83l0.41,-1.05l-0.77,-1.74l-0.38,-3.03l0.54,-10.63l0.44,-2.81l3.16,-0.57l0.81,-1.34l0.44,-1.57l-0.11,-1.56l2.13,-2.36l0.08,-1.47l2.54,-1.34l0.66,-1.31l0.54,-1.9l-0.79,-1.5l0.27,-0.67l0.61,-0.69l0.99,0.13l0.54,-0.54l0.61,-2.19l-0.92,-2.01l-0.46,-3.61l-2.67,-3.8l0.03,-1.02l0.7,-1.48l1.32,-1.61l-0.59,-1.61l0.33,-1.04l0.07,-6.43l3.4,-2.82l1.15,-2.01l0.62,-1.58l0.68,-4.61l1.0,-0.46l2.05,-1.71l4.52,-1.29l4.94,0.02l1.55,-1.0l1.31,-0.37l8.03,2.47l1.3,0.04l3.27,2.88l2.53,3.62l1.77,1.29l1.51,0.1l1.52,-1.06l2.17,-0.26l5.34,-2.74l2.96,0.57l4.18,2.72l3.58,1.86l5.33,1.04l4.91,0.13l3.94,-3.96l1.29,-0.81l1.58,-0.74l3.34,-0.7l5.62,-0.49l5.27,0.21l3.23,0.65l3.39,1.23l1.67,1.25l2.36,0.2l1.78,-0.24l0.83,-1.36l1.6,-1.49l2.51,-1.44l3.83,-1.51l1.47,-1.12l2.92,-0.36l5.2,7.23l1.55,8.19l1.14,0.62l1.71,0.16l1.06,0.48l1.05,1.56l-0.27,3.59l-0.42,1.35l0.04,2.5l-4.04,2.55l-2.67,0.72l-1.12,0.93l-2.27,3.19l-1.98,3.29l-1.38,5.02l-1.73,1.72l-0.81,5.49l-1.97,0.77l-1.19,0.9l-0.66,1.55l-0.81,4.89l-0.8,1.5l-1.58,1.31l-2.31,0.53l-1.99,3.69l-0.93,4.05l-1.56,2.65l-0.11,1.52l-2.86,3.7l0.97,1.91l-3.18,2.63l-0.57,2.7l-2.25,1.88l-1.77,0.5l-0.54,-0.53l-0.86,-2.8l-3.25,-3.02l-1.62,-0.94l-0.8,0.12l-0.77,1.58l-0.93,0.43l-2.2,-0.14l-0.59,-1.08l-0.57,-0.11l-4.23,2.76l-1.51,2.76l-3.3,2.46l-3.76,3.74l-1.53,2.82l-1.56,6.81l-2.8,5.0l-0.32,0.25l-0.57,-0.15l-0.36,-0.64l-0.74,-0.3l-0.96,-1.07l-0.78,0.16l-0.11,0.44l1.05,2.82l-0.27,0.76l-7.24,0.38l-0.69,-0.32l-0.35,-0.95l-0.61,-0.18l-0.74,1.1l-1.77,0.08l-1.48,-1.46l-0.92,-0.48l-0.55,0.49l0.99,1.21l-0.08,0.83l-1.43,1.19l-0.76,0.06l-0.45,-0.41l-0.92,-3.27l-0.6,-0.23l-0.39,0.5l0.29,2.91l0.54,0.89l-1.76,0.21l-0.6,-1.48l-0.67,0.21l-0.25,1.31l-2.68,0.38l0.1,-1.13l-0.65,-0.28l-0.8,0.82l-0.08,0.87l-1.03,-0.1l-3.13,-1.87l-2.38,-2.16l-1.09,-2.2l-1.1,-2.87l0.83,-0.4l-0.21,-0.65l-0.94,-0.26l-0.02,-1.24l1.51,-0.54l0.61,-1.2l-0.54,-0.51l-1.74,0.77l-1.75,-1.15l2.03,-0.1l0.74,-0.44l-0.08,-0.72l-1.21,-0.16l-0.03,-0.57l-0.61,-0.36l-0.67,0.8l-0.89,0.33l-0.37,-0.24l-0.23,-1.38l-2.79,-3.17l-5.14,-3.88l-3.8,-0.8l-6.74,0.03ZM382.56,407.1l-0.87,0.28l-0.02,-0.0l0.45,-0.68l0.44,0.41Z",
                        "data-code": "NG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M393.95,11.16l1.69,-1.28l0.94,-1.75l1.74,-0.94l0.03,-1.47l2.63,-0.77l3.65,-2.61l6.28,-1.93l1.22,0.27l-0.47,1.25l0.54,1.03l0.6,0.12l0.78,-0.63l-0.06,-0.91l1.95,0.05l0.97,0.47l-0.08,2.06l1.65,2.34l-0.39,0.92l0.2,0.52l1.4,0.67l1.63,-0.83l0.68,-1.19l2.26,-0.71l2.09,-1.67l0.72,-0.11l0.65,2.05l-1.66,1.69l-1.96,3.31l-1.73,0.93l-1.45,1.35l-0.7,2.23l0.38,2.14l1.07,2.04l1.15,1.17l1.21,0.45l2.36,1.69l0.47,3.82l0.81,1.23l-4.84,7.19l-1.78,1.72l-4.9,3.52l-1.05,2.18l0.14,1.24l1.29,2.72l1.8,1.72l2.07,0.97l2.54,-0.29l0.17,1.91l0.41,0.33l2.13,-0.26l0.76,-1.06l1.0,0.56l0.72,2.39l1.13,0.83l-0.39,0.32l0.07,0.66l3.32,0.78l-0.51,3.44l-0.06,3.37l0.96,2.13l-0.26,0.57l-7.85,4.28l-0.71,0.81l-1.87,1.17l-1.54,2.48l-1.86,0.38l-0.61,0.42l-1.38,1.86l-0.56,1.34l1.5,5.57l0.14,1.99l-0.42,0.94l-3.67,4.98l-3.88,1.77l-5.51,-23.48l-8.3,-6.14l-0.33,-1.91l-1.09,-3.01l-1.2,-1.77l-4.43,-2.74l-2.68,-7.3l0.14,-3.04l2.61,-2.15l1.12,-2.09l3.28,-2.0l0.93,-1.22l0.67,-1.32l0.75,-4.52l0.94,-1.54l-0.85,-2.92l0.01,-3.35l-0.83,-1.99l1.18,-7.61l-0.6,-1.31l-1.0,-0.53ZM429.08,34.41l0.05,-0.04l-0.0,0.02l-0.05,0.02ZM425.59,47.89l-0.94,0.42l-1.23,-0.47l0.15,-1.38l1.64,-0.05l1.05,0.9l-0.66,0.58Z",
                        "data-code": "TN", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M182.44,359.46l0.23,0.58l0.47,0.24l0.48,-0.27l1.56,1.32l0.86,5.09l0.9,2.38l-0.16,1.38l-0.9,1.59l0.14,0.72l2.35,0.46l1.98,1.95l1.88,-0.62l0.71,0.07l2.06,-2.86l0.41,-1.94l0.86,-0.18l0.23,0.6l1.41,1.2l1.6,5.06l-0.4,3.01l-3.07,3.32l-0.02,0.55l0.88,0.56l1.08,0.13l1.92,1.64l1.09,0.35l2.5,0.04l0.9,0.5l1.14,3.08l0.99,0.75l2.94,0.87l0.57,3.05l-0.33,0.87l-0.01,1.69l-0.59,0.94l-0.16,1.24l-0.89,0.8l-0.26,3.02l0.23,5.05l-7.51,-2.68l-10.18,-5.43l-2.8,-2.16l-10.57,-9.84l-1.72,-1.1l-2.19,-0.56l-2.02,-1.05l-0.86,-1.9l-5.16,-2.62l-2.18,-2.21l2.51,-3.59l2.12,-1.94l2.46,-1.67l2.6,-2.53l1.07,-3.83l2.4,-1.31l0.98,-3.42l1.53,-0.28l0.28,0.68l0.51,0.25l3.12,-1.1Z",
                        "data-code": "LR", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M634.16,822.85l-4.19,0.68l-2.99,3.91l-0.2,1.11l-0.69,1.14l-3.16,-0.43l-2.91,-2.91l-1.25,-0.68l-0.33,-0.65l-0.02,-1.31l-2.6,-4.03l-0.85,-2.36l2.71,-1.31l5.14,-7.34l2.48,-0.8l3.26,-2.21l4.38,-1.45l3.67,3.7l4.02,2.67l0.94,2.02l-1.08,3.55l-1.82,1.85l-0.49,2.65l-2.12,1.4l-1.88,0.8Z",
                        "data-code": "LS", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M619.52,667.32l1.52,-1.13l1.42,-2.83l1.6,-0.75l1.18,-1.13l0.85,0.25l0.79,-0.39l0.36,-0.77l-0.19,-0.61l0.53,-0.97l2.1,-0.57l1.33,0.92l0.84,-1.35l1.5,-0.62l0.21,0.77l0.48,0.37l0.76,0.08l0.76,-0.44l0.55,-1.03l0.84,-0.17l0.52,-0.76l-0.02,-0.65l-0.48,-0.38l-1.81,-0.41l0.65,-1.04l0.29,-3.44l0.54,-1.6l4.29,-2.48l2.29,-0.94l2.77,-0.61l7.38,-0.02l0.15,3.65l0.52,0.52l9.44,0.4l2.95,1.85l2.3,0.42l2.88,2.51l3.74,0.33l4.47,1.65l1.34,1.1l2.08,0.36l-0.79,1.76l0.12,1.98l0.97,2.52l-0.17,9.97l0.44,3.27l-1.23,4.36l-1.91,1.23l-0.31,1.56l0.43,1.1l1.33,0.98l-0.83,3.48l0.65,2.13l2.02,3.74l-0.14,1.15l-3.67,6.34l-1.62,1.14l-0.59,0.8l-0.2,3.53l-1.38,2.2l0.74,2.07l-11.51,12.13l-1.41,1.08l-2.38,-1.05l-1.92,-0.23l-5.39,0.47l-3.06,-0.45l-3.34,-1.3l-2.89,-0.49l-3.45,0.57l-1.32,-1.27l-1.7,-0.28l-0.55,-0.43l-0.24,-0.74l0.24,-1.52l-0.36,-0.6l-5.85,-1.81l-5.67,-0.96l-0.62,-0.64l-1.54,-3.01l-1.98,-2.29l0.4,-3.6l-0.05,-2.82l-0.31,-0.6l-0.94,-0.41l-3.68,-0.07l-0.29,-2.75l-1.0,-1.73l-5.96,-2.62l-5.89,-4.28l-2.44,-5.32l-0.17,-1.82l-1.52,-1.78l-0.65,-1.86l-2.36,-2.5l-2.0,-3.57l-1.22,-1.26l-0.6,-1.32l0.24,-0.97l2.0,0.54l2.22,-0.23l1.01,0.35l1.57,1.18l1.76,0.19l1.59,-0.67l2.12,0.2l2.81,1.11l2.65,0.23l3.66,-1.15l2.42,-3.38l0.75,-0.83l1.22,-0.47l-0.01,-0.38Z",
                        "data-code": "ZW", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M297.58,329.02l5.02,1.16l0.41,0.5l4.27,-0.43l-1.21,2.91l-0.23,4.07l6.74,4.89l0.05,4.61l0.5,2.61l0.52,1.0l1.61,1.69l0.34,0.89l0.29,23.77l-0.72,0.04l-0.35,0.56l0.57,1.3l0.2,3.15l1.71,2.23l0.29,1.1l-1.57,0.41l-0.26,0.49l-4.23,1.18l-0.32,-0.43l-1.07,-0.3l-1.32,-1.77l-0.76,-0.09l-1.87,-1.33l-0.36,-1.41l-2.02,-3.08l0.05,-1.2l0.71,-0.89l0.49,-3.74l-1.49,-1.17l-0.09,-1.04l1.24,-2.27l-0.25,-4.87l0.14,-0.58l0.99,-1.08l0.07,-0.86l-0.87,-1.65l-1.64,-1.23l-1.12,-1.56l1.31,-1.36l-0.27,-3.1l0.74,-2.97l-0.15,-0.72l-1.1,-1.08l-1.07,-0.07l-0.96,0.6l0.16,-0.87l0.84,-0.48l-0.21,-0.65l-0.32,-0.08l0.41,-0.48l0.67,-7.15l-5.49,-4.69l0.85,-2.38l0.12,-2.09Z",
                        "data-code": "TG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M578.03,273.18l-3.93,-0.49l-1.78,0.39l-4.06,0.13l-1.4,1.01l-0.94,1.17l0.33,2.92l-0.38,1.56l-2.0,2.01l-0.95,1.7l-0.15,1.58l-2.18,0.91l-1.13,1.08l0.69,3.53l1.01,1.3l-4.1,2.79l-0.9,1.48l0.01,1.14l1.31,3.02l0.08,1.52l-0.7,1.15l-2.02,1.29l-1.81,3.11l-0.18,1.11l0.84,1.32l1.56,0.36l2.71,-0.44l1.16,0.49l0.58,1.09l-0.24,1.06l0.95,4.57l0.28,0.53l0.98,0.47l-0.28,3.72l0.43,1.24l2.34,2.15l0.9,0.19l0.67,0.54l0.13,1.52l-0.79,2.84l-4.16,-0.83l-3.05,1.22l-0.89,0.77l-1.27,0.05l-1.09,1.08l-2.3,1.14l-0.9,1.11l0.23,2.36l-0.43,0.77l-0.48,0.5l-1.29,0.43l-1.57,2.45l-1.53,0.31l-2.98,3.09l-0.36,0.99l-2.37,2.61l-4.93,3.21l-3.03,-0.07l-1.54,0.71l-3.23,0.62l-6.19,0.07l-1.27,0.3l-1.1,0.68l-0.91,0.7l-0.08,0.78l2.5,2.18l-2.17,2.71l-3.17,2.77l-0.67,1.34l-10.77,0.76l-4.72,2.01l-1.56,1.33l-2.55,0.76l-1.02,0.93l-2.07,-2.05l-0.46,-1.29l-0.49,-0.32l-1.81,1.18l-0.37,1.04l-3.88,1.25l-0.93,0.78l-1.16,0.33l-3.54,-0.51l0.55,-1.29l-0.04,-1.55l-1.31,-0.92l-2.2,-5.47l-1.62,-2.83l-3.08,-2.96l-1.52,-0.81l-4.63,-3.94l-3.79,-4.5l-0.24,-0.91l1.76,-2.31l1.06,-0.81l6.79,0.46l3.55,-0.49l2.16,0.34l2.59,-0.07l1.48,-0.59l0.07,-0.7l-1.41,-0.93l-2.93,-3.11l-1.64,-3.35l-0.73,-2.36l-0.44,-3.05l0.29,-2.9l0.77,-2.02l-0.48,-1.41l0.03,-2.37l-2.37,-5.15l-0.43,-2.84l-1.01,-1.83l-1.71,-1.01l-0.8,-0.94l-0.32,-1.79l-0.79,-0.75l-2.69,-0.74l-2.02,-0.03l-5.2,-7.24l-1.79,-7.81l2.17,-2.87l1.95,-4.05l6.54,-9.36l13.06,-14.17l3.05,-36.28l2.66,-5.37l-0.48,-1.05l-3.96,-4.05l-0.45,-1.41l0.67,-1.28l-3.68,-5.61l-1.25,-1.27l-0.11,-4.85l-2.21,-12.95l11.33,-5.34l93.4,48.28l-0.08,45.21Z",
                        "data-code": "TD", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M725.98,290.45l-1.08,-9.87l1.07,-1.39l1.84,-5.7l1.57,-3.22l1.19,-3.67l-0.27,-4.02l1.01,-2.0l0.29,-2.92l1.67,0.22l3.06,-0.38l1.52,-3.09l2.72,-1.6l2.69,-0.91l1.01,0.09l1.86,-0.73l1.52,-1.7l0.59,-1.3l1.73,-1.8l3.31,6.53l1.43,4.09l1.26,4.26l0.93,6.42l0.91,3.33l1.48,1.71l0.96,2.98l1.01,0.37l0.48,0.66l1.03,2.81l0.81,1.16l0.69,-0.07l0.4,-0.92l-0.29,-1.59l0.51,-1.27l1.63,1.29l0.51,2.14l1.63,1.88l4.01,0.97l3.0,2.29l4.31,1.43l5.66,7.61l6.8,4.67l1.12,2.14l0.61,2.17l0.41,0.29l1.27,-0.09l2.29,2.23l0.94,1.99l2.03,0.67l0.51,-0.26l0.16,-0.49l0.44,0.4l0.27,0.93l-2.78,1.01l-1.16,2.36l-0.56,0.38l-2.39,-1.59l-0.67,-0.04l-0.58,0.41l-2.59,-3.3l-2.15,-1.36l-2.21,-3.6l-4.73,-3.78l-2.78,-2.78l-3.55,-4.5l-3.59,-1.45l-3.5,-2.43l-1.06,-0.36l-2.94,0.16l-1.53,-0.66l-2.68,-0.47l-3.79,0.7l-0.72,-1.17l-0.72,-0.56l-0.84,-0.08l-2.63,1.77l-4.17,0.63l-2.39,-2.59l-2.53,-1.03l-1.42,-1.39l-0.6,0.17l-3.59,8.22l-2.01,-2.62l-1.44,-1.07l-0.85,0.09l-0.82,0.56l-1.09,1.51l-2.45,-0.51l-1.56,0.09l-1.44,0.51ZM766.22,272.78l0.48,-0.41l0.03,-0.47l0.53,0.36l0.91,2.23l-1.05,-0.03l0.45,-0.33l-0.04,-0.49l-0.64,-0.68l-0.67,-0.19ZM769.17,274.55l0.38,-0.41l1.15,0.55l-0.68,0.02l-0.84,-0.16ZM767.02,269.46l0.02,0.06l-0.07,-0.03l0.04,-0.04Z",
                        "data-code": "ER", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M432.51,55.96l1.38,0.62l1.77,0.32l5.52,3.09l5.6,0.76l6.2,-1.47l2.92,1.16l3.54,0.43l3.69,1.05l4.24,2.61l7.66,1.54l0.93,0.91l1.01,1.84l0.07,2.47l1.57,4.11l2.63,3.18l4.95,2.13l7.8,0.67l6.6,1.71l5.58,1.96l1.45,1.0l2.76,0.94l5.64,4.66l3.13,1.61l2.32,0.35l2.19,-0.32l5.0,-2.61l3.6,-4.1l1.2,-2.18l0.49,-1.56l-0.1,-1.66l-2.12,-4.73l-0.39,-3.28l0.53,-2.25l1.66,-2.73l2.87,-2.72l2.89,-1.92l5.07,-2.5l4.24,-0.32l2.53,-1.81l2.26,0.38l4.02,-0.12l10.29,3.8l0.39,1.92l-0.1,1.87l2.3,1.61l5.95,0.71l3.97,1.95l4.11,0.17l2.4,-0.25l2.18,0.39l1.51,1.16l1.29,2.64l-3.38,4.27l0.29,3.57l1.12,3.66l-0.13,1.16l-0.95,2.74l-2.09,3.53l3.25,13.05l-0.01,114.09l-11.32,-0.01l-0.4,0.4l0.0,5.43l-93.2,-48.18l-12.16,5.56l-8.69,4.61l-7.05,-6.08l-1.45,-0.8l-17.67,-4.18l-4.98,-9.44l-0.57,-0.48l-9.64,-2.95l-3.37,0.82l-1.45,-1.16l-1.58,-2.44l-1.03,-3.13l-0.39,-3.67l-6.44,-9.16l-0.26,-0.86l0.7,-2.02l4.25,-2.71l0.44,-1.21l0.15,-2.82l-0.71,-1.06l-0.46,-1.54l-0.55,-3.46l1.96,-5.89l-0.67,-3.24l-0.5,-6.52l0.31,-5.16l-0.45,-2.79l-1.96,-5.95l-3.69,-5.86l6.61,-3.36l3.84,-5.21l0.47,-1.05l0.04,-1.2l-1.64,-6.67l1.74,-2.63l2.37,-0.68l0.85,-0.94l0.76,-1.6l1.76,-1.09l0.71,-0.81l8.06,-4.48l0.38,-1.64l-0.94,-1.63l0.06,-3.19l0.47,-3.16Z",
                        "data-code": "LY", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M102.75,314.04l2.01,-0.15l3.14,-1.06l3.53,0.23l3.21,-0.63l4.46,-2.25l16.69,0.07l0.02,0.75l0.64,1.26l-0.54,1.98l-1.27,0.14l-1.39,0.92l0.14,0.78l2.35,1.93l0.04,2.71l-2.28,0.75l-3.76,0.09l-2.18,1.22l-2.78,0.61l-1.26,1.37l-2.71,5.05l-0.18,-0.26l0.4,-1.37l-0.4,-0.51l-0.79,0.17l-0.73,0.93l0.04,-0.85l-0.36,-0.42l-1.1,0.02l-0.63,-0.55l-0.0,-1.0l0.43,-0.41l0.03,-0.63l-1.26,-0.26l0.29,-0.52l1.89,-0.81l2.09,-0.29l0.24,-0.64l-0.81,-0.9l-1.27,-0.3l-1.19,0.21l-0.88,0.6l-0.81,-1.0l0.31,-0.99l0.41,-0.23l2.3,0.01l1.58,-0.65l0.36,-1.03l-0.76,-0.31l-1.01,0.5l-2.93,-0.17l-1.03,0.37l-1.56,1.14l-1.82,0.6l-0.9,-0.17l0.34,-1.16l-0.84,-0.93l-2.27,0.43l-1.37,-0.62l-0.48,-0.67l0.08,-0.8l0.87,-1.17l-0.35,-0.52l-0.95,-0.05l-1.3,0.41l-1.74,-0.97ZM112.9,326.69l0.12,-0.11l0.02,0.0l-0.05,0.06l-0.09,0.04ZM110.3,324.02l-0.59,-0.08l0.44,-0.86l0.04,0.01l0.1,0.93ZM108.31,319.69l0.84,-0.06l-0.27,0.64l-0.57,-0.57ZM107.34,328.61l0.47,-0.15l0.65,-0.58l-0.03,0.58l-1.09,0.15Z",
                        "data-code": "GW", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M578.83,587.79l0.57,0.09l0.9,1.63l1.94,0.49l0.41,0.52l0.31,1.3l-0.6,1.66l0.66,0.65l1.04,0.36l0.81,-0.09l1.84,-1.04l6.98,-1.64l-0.32,1.99l0.92,2.81l1.87,1.51l1.5,0.02l4.75,1.72l6.71,0.98l2.85,-0.1l1.64,-0.9l1.15,-3.33l0.93,-0.3l0.75,2.3l2.11,1.86l1.24,2.89l0.6,0.54l1.03,0.56l2.46,0.22l6.31,2.67l1.54,3.66l1.6,0.52l0.56,0.64l2.18,3.35l0.35,1.25l0.84,0.74l2.45,0.45l4.15,-1.77l0.53,0.36l0.42,1.55l1.15,0.51l0.87,-0.41l0.27,-0.68l-0.0,-14.77l-0.48,-0.39l-3.47,0.9l-0.38,0.66l0.12,1.47l-0.48,0.23l-4.08,-0.94l-2.45,-2.65l-4.23,-3.58l-1.39,-3.69l2.15,-7.93l1.13,-1.72l0.08,-1.41l-0.44,-1.86l0.26,-6.68l-0.31,-1.88l-2.38,-5.09l3.16,-2.4l2.27,-2.77l0.64,-1.18l0.2,-1.3l-0.31,-1.03l18.7,-2.93l-1.02,0.9l-0.41,1.25l0.48,1.04l0.86,0.1l-0.31,0.61l0.36,0.26l1.56,-0.81l1.29,0.58l2.05,2.1l1.03,0.63l1.28,-0.7l0.67,-0.01l0.32,-1.43l1.31,-0.02l1.89,1.09l0.32,1.13l1.42,1.26l1.88,0.0l0.84,0.3l0.08,0.89l0.53,0.6l2.13,0.23l1.15,0.62l2.33,0.33l0.66,0.66l4.88,2.21l0.68,1.21l0.2,1.17l1.25,0.47l0.59,-0.42l0.56,0.16l0.61,1.47l1.12,1.15l-0.33,2.25l2.45,2.21l0.31,1.85l1.23,1.86l-2.11,2.29l-1.44,0.39l-1.06,1.03l1.27,3.42l-1.16,2.57l-0.53,0.46l-0.03,1.61l0.71,0.92l0.15,0.78l-0.03,2.25l-0.54,2.88l1.16,2.49l0.58,0.33l1.12,0.01l-1.01,1.15l-4.53,1.8l-0.94,2.18l0.61,1.37l-0.34,3.58l-1.32,2.73l-2.19,1.84l0.25,0.57l1.27,0.75l-0.34,0.47l0.11,0.55l1.17,0.66l1.59,2.48l-17.08,5.92l-10.13,2.9l-5.19,2.06l-0.33,0.44l0.01,0.94l0.35,1.48l1.14,1.98l0.46,2.96l-7.37,0.02l-2.93,0.64l-2.44,1.0l-4.42,2.56l-0.62,0.85l-0.49,4.58l-0.64,0.98l-1.53,-0.37l-2.6,1.01l-1.11,-0.43l-0.51,0.83l-1.06,0.52l-0.31,0.78l-1.33,1.19l-1.56,-0.61l-1.27,0.61l-0.34,0.5l0.37,0.69l-1.24,0.36l-0.34,1.46l-0.84,0.2l-2.09,2.74l-1.07,2.03l0.28,0.56l-2.25,2.1l-1.87,3.23l-2.45,0.87l-2.23,-0.22l-2.92,-1.13l-2.27,-0.21l-1.78,0.69l-1.34,-0.19l-1.34,-1.07l-1.31,-0.48l-2.27,0.23l-2.12,-0.58l-3.08,-2.74l-3.24,-0.64l-5.5,-0.44l-10.3,1.89l-4.83,-4.16l-5.83,-5.69l-3.54,-2.57l-1.25,-3.88l-0.7,-3.64l-0.01,-34.94l21.47,0.0l1.47,-0.15l0.34,-0.33l0.02,-0.63l-0.95,-1.78l0.29,-1.74l0.97,-2.63l-0.38,-3.68l0.15,-5.67l0.87,-2.84l-0.85,-5.77ZM685.33,624.73l0.57,-0.41l0.12,0.17l-0.69,0.24Z",
                        "data-code": "ZM", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M196.93,382.8l2.89,-3.19l0.43,-2.32l0.05,-1.25l-1.95,-5.59l2.65,0.26l1.4,-2.46l-0.07,-1.4l1.32,-2.37l-0.2,-1.26l-2.64,-1.14l0.19,-2.03l1.8,-0.25l2.48,0.33l1.19,1.09l0.5,-0.0l0.54,-0.65l-0.08,-1.98l-0.43,-1.18l-0.92,-1.03l-1.72,-0.69l0.14,-1.82l1.69,-1.03l0.15,-0.57l-1.54,-1.29l0.22,-2.44l-0.47,-0.41l-1.42,0.2l-0.94,-0.89l-0.2,-5.46l1.75,-1.9l1.13,-0.28l0.94,-0.66l1.71,-2.17l1.57,-0.14l1.2,1.15l0.49,0.96l2.9,0.63l0.7,0.63l0.7,0.09l0.8,-0.68l-0.24,-1.02l0.28,-0.64l3.14,-0.28l0.32,-0.77l-0.12,-2.48l0.84,0.63l1.75,0.34l0.59,-0.68l-0.25,-0.8l1.38,-0.4l0.08,1.59l0.56,1.82l-0.55,1.65l1.67,1.02l1.39,-0.0l2.13,-2.23l3.13,-0.56l1.92,1.43l1.56,-0.01l1.64,0.79l1.18,2.2l0.43,1.55l4.1,2.6l1.18,-0.07l1.4,0.85l1.01,0.06l1.05,-1.24l5.38,-1.98l6.5,0.29l1.39,1.61l1.16,0.7l2.0,3.06l0.9,0.17l0.48,-0.23l-0.11,1.32l0.27,0.37l-0.75,1.69l-0.05,0.95l1.17,1.19l0.56,1.83l1.07,6.74l-1.2,0.72l0.04,1.01l-2.14,1.56l-1.25,2.9l-0.74,2.72l-0.32,2.93l-2.9,4.63l-0.14,2.06l0.52,3.62l2.38,7.52l0.74,1.08l1.69,0.35l0.4,1.76l-0.53,2.87l-1.4,0.37l-2.08,-0.82l0.17,-1.41l-0.35,-0.44l-0.57,-0.07l-0.86,0.46l-1.04,2.14l-5.87,-1.01l-1.43,-0.87l-1.66,-0.2l-5.1,0.35l-0.86,0.6l-0.13,0.46l0.24,0.16l-3.28,0.45l-0.63,-0.08l-0.81,-0.68l-3.17,-0.06l-0.81,0.35l-0.38,0.48l0.21,0.38l-2.29,0.19l-4.15,0.94l-10.94,4.0l-2.52,1.5l-2.05,0.7l-2.23,1.26l-1.09,0.23l-0.31,-5.08l0.26,-2.79l0.84,-0.77l0.14,-1.18l0.66,-1.17l0.01,-1.71l0.32,-0.84l-0.63,-3.6l-0.32,-0.39l-0.7,0.03l-1.32,-0.71l-1.13,-0.16l-0.56,-0.47l-1.27,-3.21l-1.23,-0.65l-2.59,-0.06l-0.89,-0.3l-1.79,-1.61l-1.47,-0.29Z",
                        "data-code": "CI", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M98.08,205.07l0.08,-0.53l4.61,-0.68l7.72,-0.24l5.41,0.61l5.74,0.12l1.56,-0.12l1.34,-0.77l1.0,-1.33l0.7,-1.83l-0.17,-1.39l3.6,-3.91l1.16,-1.68l0.59,-5.54l0.82,-4.2l0.93,-3.8l1.48,-3.37l1.25,-1.1l5.4,-2.37l3.07,-5.33l0.75,-0.79l4.19,-2.59l2.47,-2.01l1.44,-3.57l1.65,-6.62l1.03,-2.84l-0.07,29.53l-3.82,1.71l-3.02,0.64l-4.82,3.35l-1.56,2.38l-0.19,1.07l0.84,3.16l0.89,13.84l-46.06,0.2ZM157.4,147.05l2.57,-0.61l1.1,-2.54l1.47,-2.19l2.08,-2.13l0.27,-1.55l-0.77,-1.45l5.06,-1.49l1.86,-0.12l2.33,0.36l3.62,1.65l2.5,-0.62l1.43,0.71l1.21,0.04l1.17,-0.23l3.65,-2.79l4.69,-0.01l2.5,-0.39l0.81,-0.78l-0.51,-2.08l0.27,-1.89l-0.47,-2.03l0.74,0.0l0.01,20.13l-37.6,0.0Z",
                        "data-code": "EH", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element", cursor: "pointer" }),
                  _react2.default.createElement("path", { d: "M398.03,403.42l2.82,-5.07l1.56,-6.82l0.7,-1.54l4.33,-4.63l3.33,-2.48l1.48,-2.73l3.85,-2.5l0.77,1.06l3.39,0.0l0.65,-0.58l0.66,-1.41l1.37,0.78l3.12,2.89l1.1,3.23l0.74,0.41l1.2,-0.12l1.18,-0.46l1.88,-1.4l0.92,-1.25l0.3,-2.19l3.23,-2.63l0.05,-0.68l-0.95,-1.47l2.76,-3.48l0.19,-1.76l1.53,-2.56l0.92,-4.0l1.86,-3.45l2.06,-0.36l0.87,-0.57l1.58,-1.83l1.16,-5.86l0.56,-1.3l0.91,-0.64l1.78,-0.59l0.53,-0.56l0.81,-5.49l1.72,-1.7l1.41,-5.1l1.89,-3.12l2.21,-3.11l0.96,-0.78l2.6,-0.68l4.35,-2.85l0.28,-1.28l-0.22,-1.64l0.65,-3.05l0.02,-2.08l-1.41,-2.05l-1.21,-0.55l-2.37,-0.41l-1.43,-7.58l1.58,0.01l2.42,0.63l0.45,0.36l0.4,1.94l1.03,1.17l1.52,0.83l0.92,1.66l0.43,2.83l2.31,4.93l-0.04,2.29l0.48,1.26l-0.74,1.97l-0.31,3.08l0.46,3.19l0.77,2.5l1.76,3.56l3.9,3.8l-3.05,0.31l-2.23,-0.34l-3.5,0.49l-6.96,-0.45l-1.52,1.09l-1.89,2.46l0.35,1.76l3.85,4.57l4.71,4.0l1.55,0.84l2.88,2.74l1.56,2.71l2.23,5.53l1.32,1.21l-0.26,1.38l-1.73,2.8l-1.5,1.07l-0.56,0.78l-2.02,4.94l-2.03,2.73l-1.17,2.86l-0.59,0.61l-2.27,1.1l-0.87,0.92l-0.17,1.0l0.88,1.5l0.99,0.19l0.27,0.34l0.0,4.08l-0.63,2.62l0.93,1.38l0.8,6.0l0.8,1.4l2.94,2.34l0.41,0.75l0.84,2.49l-0.87,0.14l-0.29,0.54l0.34,0.86l0.83,1.49l7.59,8.23l1.64,0.47l1.66,2.0l-0.07,1.5l0.47,1.61l0.09,1.92l0.88,2.36l-0.05,0.45l-1.1,1.19l-0.17,1.15l0.77,3.32l-0.42,0.3l-3.71,-2.71l-1.74,-0.43l-2.99,0.05l-2.09,-1.04l-0.92,0.38l-1.87,-0.13l-0.45,-0.73l-1.33,-0.01l-2.52,-1.41l-1.03,0.48l-13.6,-0.08l-0.34,-0.67l-0.79,-0.44l-4.15,0.11l-5.9,-0.58l-9.45,-0.07l-2.47,0.03l-0.39,0.45l-0.17,1.1l-15.4,-0.0l-1.15,-0.48l-0.6,-1.01l0.96,-6.81l0.72,-1.86l-0.37,-2.11l-2.68,-3.39l0.9,-1.2l-0.4,-0.23l-1.12,0.11l-0.72,-1.57l0.47,-0.59l1.05,0.16l0.46,-0.45l-0.17,-0.57l-0.95,-0.85l0.42,-1.2l-0.75,-0.29l-1.01,0.5l-0.86,-0.44l-0.46,0.49l0.16,0.59l-0.55,0.59l-0.95,-0.14l-0.84,-0.7l-2.75,-1.02l-0.24,-1.42l-0.75,-1.51l-0.12,-2.56l-1.84,-0.35l-1.21,-1.05l-0.58,0.45l0.29,1.2l-0.69,0.03l-0.29,-0.55l0.31,-1.81Z",
                        "data-code": "CM", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M655.53,78.07l-0.21,0.35l0.36,0.35l1.61,0.17l3.64,-0.77l0.94,-1.8l1.14,0.18l3.97,1.69l1.1,0.01l3.14,-1.05l-1.65,2.54l0.15,0.61l2.72,0.93l0.97,1.48l0.46,0.19l1.43,-0.47l0.88,-1.06l-0.14,-0.7l2.53,2.05l1.11,0.5l5.96,-1.22l1.05,1.0l2.1,-0.59l3.42,-0.0l2.85,-0.68l3.12,-1.55l3.69,10.84l1.5,3.26l2.79,8.89l-1.89,2.68l-1.39,6.51l-1.99,5.07l-0.55,4.32l-1.88,2.86l-1.71,-0.68l-3.26,-2.7l-1.92,-2.6l-2.13,-1.76l-1.9,-2.18l-1.38,-5.22l-0.69,-1.29l-2.37,-2.68l-1.71,-2.94l-0.86,-3.49l-0.98,-2.31l-0.57,-0.19l-1.09,0.62l-0.04,1.2l-0.9,1.26l-0.58,1.8l0.54,1.4l1.92,1.84l0.35,0.72l0.43,1.69l-0.04,2.52l0.38,0.93l1.44,1.76l1.33,2.8l3.63,4.62l2.0,2.0l1.43,0.97l0.51,0.81l0.08,3.75l1.71,3.32l1.28,1.04l0.5,0.94l1.26,6.66l1.12,1.4l3.28,6.61l2.75,4.15l7.37,15.17l3.35,4.03l2.71,1.97l-1.8,0.35l-0.67,2.14l0.22,4.24l0.51,2.18l1.57,4.02l2.67,2.73l3.69,1.38l2.18,2.88l4.79,3.59l0.28,0.58l-62.68,0.01l0.41,-1.64l-0.55,-0.76l-0.75,-0.13l-0.92,0.38l-1.05,2.11l-0.37,0.06l-72.63,-0.01l0.0,-89.62l-3.24,-13.0l2.01,-3.21l1.01,-2.95l0.14,-1.41l-1.12,-3.66l-0.28,-3.32l2.97,-3.67l0.94,1.36l1.84,0.27l6.06,-1.39l15.73,3.12l3.47,2.15l1.06,0.29l2.32,-0.04l1.71,1.26l6.36,0.6l6.65,2.85l2.52,-0.49l1.84,-0.82l5.87,-3.87l1.26,-0.44l2.0,0.08l2.21,-2.6l1.58,-0.15Z",
                        "data-code": "EG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M165.73,342.66l1.63,1.75l4.17,5.64l-0.74,2.31l0.41,0.45l1.16,0.27l0.13,2.11l1.18,2.05l-1.46,1.62l-0.99,2.31l0.19,0.48l2.24,0.2l1.92,-1.94l0.63,-0.04l-0.81,2.95l-1.78,0.68l-0.74,0.82l-0.86,3.51l-2.61,2.56l-2.42,1.64l-2.15,1.96l-2.54,3.61l-2.43,-1.92l-2.36,-1.16l-6.28,-2.31l0.53,-1.8l-0.81,-1.26l0.29,-0.85l-0.38,-0.53l-1.19,0.6l-1.19,-0.14l-1.72,-1.16l-1.23,-3.82l-0.97,-0.75l-1.27,-0.14l-1.3,-2.27l2.07,0.42l1.94,-1.79l0.37,-1.04l-0.12,-0.31l-0.63,-0.17l-0.45,0.38l-1.42,-0.11l-0.88,0.52l-0.4,-1.02l0.17,-1.3l1.31,-0.13l0.46,-0.52l-0.29,-0.56l-1.01,-0.18l-1.29,-1.17l1.56,0.14l0.69,-0.3l1.03,-1.02l0.45,-1.28l1.3,-0.4l1.04,-0.94l2.42,-4.06l0.62,-1.73l0.66,-0.33l1.59,-0.34l1.71,0.62l2.58,-0.56l0.39,-0.82l7.08,-0.04l0.57,0.16l0.21,0.45ZM150.0,371.51l-0.53,-0.45l-3.08,-0.87l2.81,-0.26l0.92,0.47l-0.12,1.11Z",
                        "data-code": "SL", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M433.42,487.21l1.46,0.55l2.4,-0.56l1.54,0.77l4.48,-0.97l0.31,-0.36l0.38,-2.57l-0.54,-1.98l1.55,-0.98l1.97,1.09l2.51,4.59l4.34,1.09l1.37,-0.11l2.01,-1.45l1.27,-1.44l1.17,1.9l-0.19,0.83l0.33,0.82l1.68,0.45l1.3,-0.4l1.29,-1.29l0.14,-0.92l-0.44,-0.81l0.43,-0.47l0.59,-2.07l1.57,-1.38l0.46,-2.09l-0.23,-1.35l0.52,-0.89l0.1,-1.31l-0.52,-5.19l0.74,-4.75l-1.44,-1.48l-1.88,-0.53l-1.61,-1.82l-2.25,-0.59l0.27,-4.43l0.69,-1.73l1.47,-2.0l1.73,-0.23l1.13,-0.89l1.42,-2.45l-0.06,-1.17l-1.53,-2.72l-0.71,-2.27l-0.98,-0.83l-4.06,-0.56l-6.96,2.03l0.37,-1.14l-0.98,-3.22l0.1,-1.55l1.4,-4.04l13.58,0.08l1.08,-0.46l2.22,1.39l1.15,-0.05l0.48,0.79l2.32,0.12l0.75,-0.36l2.1,1.03l2.95,-0.06l1.54,0.39l4.07,2.79l1.13,-0.93l-0.78,-3.49l0.11,-0.86l1.14,-1.24l0.07,-0.69l3.31,-6.52l0.14,-4.02l1.05,-3.37l0.36,-0.37l7.04,-1.03l2.53,-1.01l4.94,1.51l2.66,0.03l0.86,0.63l1.92,-0.97l1.69,-0.38l0.59,1.03l0.63,0.42l0.12,1.75l-1.5,4.35l-3.29,6.01l-1.64,4.71l-0.18,5.65l-1.83,4.96l-0.19,3.14l0.46,3.7l-0.43,3.46l-1.32,3.31l-0.59,2.7l0.31,3.13l-2.32,2.5l-3.03,2.57l-3.56,1.65l-1.18,1.06l-4.04,7.27l-3.8,3.94l-0.37,1.47l0.3,8.77l-0.81,4.99l-3.1,5.33l-3.04,1.07l-1.0,0.74l-0.6,1.05l-2.47,1.56l-5.69,6.29l-0.7,0.35l-2.98,-0.39l-0.49,-2.66l0.94,-1.72l-1.13,-1.89l-0.38,-0.18l-3.82,1.45l-1.14,0.73l-1.66,-0.57l-1.04,0.27l-0.55,2.93l-2.86,1.5l-1.96,-1.42l-0.96,-1.18l-1.17,0.06l-1.93,-2.01l-1.33,-0.17l-1.86,1.19l-2.92,1.0l-0.99,1.73l-1.36,0.32l-1.79,2.28l-2.02,-2.53l-0.43,-0.88l-0.13,-1.42l-7.43,-7.49l1.06,-2.28l2.93,-1.84l1.95,1.87l1.98,0.18l0.8,-0.71l-0.06,-0.81l-0.48,-0.73l1.17,-2.53l-0.16,-0.38l-2.49,-1.6l-0.19,-0.36l0.72,-1.02l0.09,-0.67l-1.56,-1.76l-0.94,-0.23l0.66,-2.47l-0.31,-2.57Z",
                        "data-code": "CG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M474.14,412.46l0.6,-0.07l0.43,-0.47l-0.9,-3.12l-0.56,-0.97l-2.96,-2.34l-0.6,-1.05l-0.8,-6.02l-0.9,-1.17l0.63,-2.48l0.0,-4.35l-0.53,-0.82l-0.99,-0.17l-0.64,-1.1l0.78,-1.08l2.75,-1.48l1.46,-3.29l2.04,-2.73l2.02,-4.95l2.0,-1.76l1.06,-1.74l4.03,0.55l1.47,-0.39l0.95,-0.79l4.0,-1.29l0.53,-1.2l1.01,-0.76l1.43,2.22l1.74,1.32l0.61,-0.19l0.77,-0.82l2.62,-0.8l1.56,-1.33l4.57,-1.94l3.36,-0.03l7.48,-0.76l0.5,-0.38l0.46,-1.18l1.28,-0.85l1.86,-1.9l2.4,-3.0l-0.52,-1.18l-2.03,-1.58l1.67,-1.11l1.03,-0.22l6.16,-0.06l3.37,-0.65l1.4,-0.67l3.29,0.0l5.12,-3.35l2.49,-2.75l0.34,-0.96l2.79,-2.9l0.85,0.05l0.78,-0.46l1.51,-2.4l1.15,-0.35l0.74,-0.71l0.62,-1.18l-0.05,-2.6l2.63,-1.43l0.97,-1.01l1.33,-0.08l0.94,-0.8l2.84,-1.14l4.0,0.86l1.16,1.87l4.08,4.31l2.7,4.2l1.15,2.37l-0.28,5.52l-0.27,0.81l-1.54,1.91l-0.03,0.99l0.99,1.2l-0.05,1.65l0.7,0.7l1.13,0.39l5.92,0.9l-0.29,2.04l0.44,1.26l0.97,0.92l2.11,0.71l3.26,0.56l1.24,0.58l1.8,2.02l2.21,1.8l0.45,0.8l-0.75,1.98l0.2,0.63l1.04,1.08l1.28,1.18l5.95,3.16l1.64,1.23l1.56,2.04l2.1,1.6l-0.55,1.87l0.19,0.91l1.15,1.54l1.11,2.41l1.06,0.74l1.62,0.27l4.76,3.13l0.89,1.67l0.33,3.21l0.86,1.25l-2.75,-0.64l-2.83,1.59l-15.36,-2.89l-1.64,0.82l-1.65,2.58l-1.96,0.61l-1.09,-0.16l-2.4,0.6l-3.76,-0.92l-1.52,0.18l-10.6,3.89l-1.07,-0.0l-2.37,-0.86l-3.03,0.16l-2.04,1.7l-2.44,4.54l-0.73,0.65l-8.48,-1.69l-1.78,0.41l-2.16,-0.76l-1.52,0.07l-1.03,-0.3l-2.05,-0.97l-4.52,-0.54l-1.89,-2.58l-1.96,-1.69l-2.69,-1.4l-2.21,-1.63l-1.69,-0.5l-2.31,-0.05l-2.19,0.72l-2.99,2.11l-2.86,4.41l-1.45,1.56l-1.4,0.66l-0.3,1.3l0.6,1.61l0.15,1.81l-0.43,3.19l0.1,1.59l-0.6,-0.98l-0.64,-0.29l-1.9,0.52l-1.53,0.88l-0.63,-0.56l-2.75,-0.06l-4.63,-1.55l-3.2,1.05l-6.39,0.73l-1.02,0.47l-0.57,0.66l-1.08,3.45l-0.14,4.01l-2.93,5.77l-0.5,-1.57l-0.59,-5.29l-1.63,-2.02l-1.84,-0.65l-3.64,-3.79l-3.83,-4.31l-0.87,-1.68Z",
                        "data-code": "CF", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M441.82,531.2l5.51,-1.02l3.33,-1.64l1.19,-0.09l1.33,0.29l8.0,-0.28l4.95,0.42l22.42,-0.32l1.26,0.37l1.14,0.71l1.79,2.25l0.1,3.42l0.4,1.79l2.1,3.81l0.49,1.37l-0.13,1.2l0.44,1.3l1.98,2.39l4.47,7.24l0.9,0.45l3.78,-0.36l1.27,0.46l2.2,-1.0l4.3,-1.02l4.37,0.77l2.35,0.0l2.39,-0.42l0.33,-0.35l0.36,-3.62l1.27,-2.22l0.05,-2.25l0.46,-1.41l1.39,-1.13l2.4,-0.57l7.93,-0.79l-0.65,2.71l0.29,0.87l0.73,0.59l13.96,0.54l0.34,0.88l-0.09,2.02l-0.63,3.19l0.24,2.91l1.12,2.76l0.11,4.05l-0.88,5.58l-0.2,3.59l0.58,1.73l2.74,3.2l1.23,2.03l0.88,2.52l0.36,5.0l-0.24,0.86l-0.77,0.46l-0.47,0.94l0.61,3.11l0.62,0.86l0.7,0.22l3.01,-1.69l6.04,0.37l4.49,-1.4l4.32,0.52l0.97,-0.4l0.33,-0.83l0.12,0.75l0.66,4.66l-0.87,2.86l-0.15,5.66l0.44,2.8l-1.33,5.29l0.97,1.94l-22.89,0.1l-0.4,0.4l0.01,35.38l0.73,3.82l1.44,4.23l3.58,2.59l3.09,3.14l7.11,6.3l-22.18,4.19l-1.47,-0.46l-2.05,-0.09l-4.31,0.77l-2.64,-0.77l-1.47,-0.82l-2.4,-0.29l-6.44,0.06l-3.08,-0.52l-4.9,-0.26l-2.61,-1.13l-2.74,-3.16l-1.29,-0.6l-46.71,-0.14l-4.64,0.25l-0.75,-0.2l-2.84,-1.86l-1.5,-1.07l-1.11,-1.29l-0.96,-0.42l-3.59,-0.49l-6.59,2.95l-3.74,-0.03l-1.09,-0.51l-1.36,0.01l-1.42,0.71l-1.3,0.19l0.84,-6.11l-0.26,-8.66l-0.49,-1.66l1.62,-1.29l0.85,-1.13l0.57,-1.45l0.68,-3.23l2.42,-7.3l1.16,-7.18l1.47,-3.45l0.53,-3.68l4.0,-4.81l1.03,-3.01l4.94,-2.94l2.29,-2.96l1.06,-2.0l1.17,-3.7l0.01,-3.95l0.74,-5.12l-0.16,-1.58l-1.12,-2.13l-0.27,-1.57l-2.1,-2.5l-0.54,-1.94l-1.88,-3.01l-0.51,-1.98l-0.91,-1.49l-0.63,-3.68l-1.83,-4.02l0.0,-0.28l0.54,0.15l3.67,-3.94l0.21,-4.04l-3.37,-6.95l-2.66,-6.41l-0.54,-3.41l-3.52,-4.26l-2.62,-5.27ZM440.92,526.36l-0.23,0.06l-0.46,-1.04l0.57,-1.98l-0.34,-1.69l-1.72,-3.63l1.89,-2.34l1.27,-0.25l0.93,-1.67l2.84,-0.99l0.98,-0.75l1.21,-0.42l2.01,1.99l-2.43,0.95l-2.71,2.81l-1.66,1.07l-0.15,0.59l0.81,0.81l-0.21,6.12l-2.58,0.35Z",
                        "data-code": "AO", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M441.08,527.14l2.62,-0.32l0.5,-0.41l0.31,-6.68l-0.67,-0.81l1.41,-0.9l2.69,-2.79l2.59,-0.98l0.6,-0.53l2.73,2.56l0.9,0.14l3.0,-1.47l0.38,-0.55l0.36,-2.58l2.25,0.5l4.69,-2.15l0.85,1.26l-0.93,1.82l0.66,3.06l0.65,0.43l3.26,0.2l0.95,-0.51l5.66,-6.27l1.52,-0.76l2.34,-2.46l3.17,-1.13l1.55,-2.11l1.91,-3.71l0.83,-5.09l-0.29,-8.85l0.24,-1.04l3.8,-3.95l3.94,-7.14l2.54,-1.79l2.1,-0.82l3.1,-2.63l2.5,-2.68l-0.23,-3.43l0.55,-2.55l1.36,-3.43l0.44,-3.56l-0.46,-3.81l0.19,-2.97l1.83,-4.94l0.17,-5.58l1.6,-4.62l3.26,-5.95l1.57,-4.52l-0.28,-4.52l0.43,-3.28l-0.16,-1.91l-0.59,-1.64l0.22,-0.72l1.21,-0.47l1.55,-1.65l2.78,-4.32l2.88,-2.03l1.96,-0.63l3.32,0.4l2.3,1.68l2.61,1.35l1.88,1.62l2.12,2.74l4.65,0.58l2.01,0.95l1.22,0.35l1.43,-0.1l2.16,0.77l1.91,-0.4l2.5,0.31l6.01,1.39l1.36,-0.97l2.45,-4.55l1.62,-1.41l2.72,-0.14l2.23,0.83l1.38,0.04l10.7,-3.9l1.25,-0.17l3.78,0.92l2.61,-0.6l1.12,0.16l2.34,-0.79l1.75,-2.67l1.24,-0.56l15.09,2.92l0.87,-0.23l1.71,-1.24l0.86,-0.12l3.17,0.98l0.98,1.57l2.08,1.49l1.47,2.37l2.25,1.33l1.15,1.25l1.59,0.98l2.81,0.3l3.57,-2.11l2.31,0.2l2.36,1.11l1.09,0.02l2.08,-1.32l1.01,-1.32l0.71,-0.21l1.26,0.5l1.11,1.15l1.11,1.86l3.78,4.03l3.69,1.75l0.49,1.88l0.43,0.58l2.05,0.06l0.84,1.41l0.67,0.41l-1.38,3.1l-0.32,1.5l1.12,1.86l-0.93,2.39l-0.49,2.71l1.4,1.0l1.6,0.02l1.31,1.27l1.03,0.18l0.8,1.0l-4.36,3.23l-4.04,3.9l-1.68,2.79l0.19,0.89l-0.92,0.36l-0.95,0.97l-0.71,1.55l-2.86,1.9l-0.14,3.81l-1.76,3.74l-0.71,0.84l-0.39,2.38l-2.23,0.93l-2.0,4.12l0.1,0.9l0.81,0.94l1.86,-0.41l0.81,-0.64l-0.85,4.62l0.2,4.56l-2.58,1.52l-1.19,1.5l-1.68,-0.6l-0.86,0.61l-0.61,2.37l-0.9,1.96l0.03,0.96l-0.5,1.34l0.48,1.07l-0.59,0.83l-0.15,1.1l0.89,2.99l1.03,0.51l0.14,0.94l2.33,2.84l-0.15,2.87l-0.81,1.14l0.06,2.46l-0.51,1.94l-0.21,3.61l0.14,1.38l-0.47,1.01l0.32,0.67l0.82,0.31l0.51,-0.15l0.23,-0.44l-0.2,1.74l-0.54,0.38l-0.37,0.91l-0.26,5.62l0.68,2.24l2.36,4.2l-0.32,0.51l-0.0,1.49l-1.69,1.55l0.07,1.66l1.42,1.9l1.32,3.51l0.63,0.46l-0.02,1.12l0.72,1.53l2.59,2.91l3.08,1.78l1.45,1.67l0.68,1.96l-0.04,1.33l0.92,3.24l3.01,2.58l0.46,1.23l-19.43,3.1l-0.27,0.52l0.39,1.15l-0.17,1.13l-0.52,0.92l-2.15,2.63l-3.41,2.77l0.05,0.8l1.63,2.75l0.72,1.93l0.29,1.73l-0.26,6.63l0.44,1.9l-0.07,1.24l-1.11,1.64l-2.18,8.02l0.3,1.25l1.24,3.06l4.33,3.69l2.73,2.83l4.21,0.97l0.89,-0.14l0.54,-0.79l-0.05,-1.58l1.86,-0.25l0.8,-0.42l-0.13,14.47l-0.78,-0.2l-0.33,-1.4l-1.09,-0.72l-4.33,1.77l-1.91,-0.31l-0.68,-0.59l-0.27,-1.11l-2.28,-3.49l-0.67,-0.76l-1.44,-0.37l-0.83,-2.38l-0.86,-1.41l-6.59,-2.81l-2.52,-0.23l-0.73,-0.42l-1.62,-3.2l-2.18,-1.96l-0.46,-2.0l-0.6,-0.54l-1.07,0.11l-0.86,0.5l-1.11,3.3l-1.21,0.61l-2.55,0.07l-6.62,-0.96l-4.76,-1.73l-1.22,0.08l-1.73,-1.38l-0.71,-2.37l0.41,-1.85l-0.74,-0.81l-7.38,1.68l-1.8,1.02l-1.28,-0.22l-0.2,-0.22l0.58,-1.46l-0.43,-1.64l-0.73,-0.83l-1.97,-0.54l-0.92,-1.61l-1.3,-0.23l-0.71,0.27l-0.5,1.17l-0.51,0.23l-4.31,-0.52l-4.53,1.4l-6.0,-0.38l-3.1,1.67l-0.45,-0.63l-0.53,-2.57l1.16,-1.19l0.31,-1.1l-0.28,-2.86l0.24,-0.82l-0.33,-1.63l-0.95,-2.72l-1.27,-2.11l-2.71,-3.15l-0.47,-1.36l0.19,-3.45l0.89,-5.67l-0.11,-4.16l-1.12,-2.79l-0.23,-2.79l0.72,-5.25l-0.44,-1.25l-0.46,-0.37l-13.84,-0.49l-0.57,-0.79l0.72,-2.73l-0.47,-0.7l-8.49,0.79l-2.52,0.6l-1.84,1.53l-0.51,1.59l-0.05,2.25l-1.28,2.29l-0.33,3.35l-4.27,0.35l-4.49,-0.77l-4.42,1.04l-2.03,0.97l-1.18,-0.46l-3.83,0.36l-4.74,-7.36l-1.95,-2.34l-0.33,-1.03l0.13,-1.22l-0.54,-1.51l-2.07,-3.71l-0.38,-1.66l0.1,-2.59l-0.25,-1.07l-1.95,-2.48l-1.44,-0.9l-1.48,-0.42l-22.47,0.32l-7.45,-0.44l-5.46,0.3l-3.52,-0.52l-2.56,0.51l-1.35,0.99l-1.81,0.47l-0.95,-0.16l-1.94,-2.08Z",
                        "data-code": "CD", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M400.47,467.86l1.76,-0.1l0.68,-0.62l1.11,-0.24l2.58,-3.26l0.57,-3.7l-0.33,-3.99l0.42,1.18l0.79,0.61l1.38,0.19l2.48,1.16l0.62,-0.25l0.14,-0.73l2.0,-0.74l0.26,-0.36l-0.91,-0.67l-2.07,0.27l-2.54,-1.14l-2.4,-2.83l1.62,-0.75l1.0,1.07l0.8,-0.39l0.1,-2.43l-0.51,-2.64l1.44,-0.44l0.67,0.9l1.36,0.46l1.38,-0.51l15.3,0.05l0.4,-0.4l-0.08,-13.67l0.28,-1.19l11.42,0.05l5.92,0.58l4.03,-0.12l0.58,0.78l-0.05,0.66l-1.36,3.55l-0.13,1.73l0.98,3.32l-0.48,0.7l-0.08,0.59l0.31,0.36l1.09,0.21l6.7,-2.07l3.65,0.53l0.52,0.42l0.71,2.25l1.48,2.57l0.06,0.78l-1.25,2.13l-0.89,0.7l-1.58,0.16l-0.5,0.37l-0.52,1.07l-0.91,0.92l-0.8,2.11l-0.18,4.88l0.67,0.58l1.92,0.31l1.46,1.73l1.95,0.58l1.15,1.38l-0.81,4.08l0.52,5.26l-0.09,1.18l-0.53,0.93l0.22,1.4l-0.42,1.89l-1.5,1.25l-0.61,2.11l-0.51,0.67l0.43,1.42l-1.14,1.14l-0.88,0.22l-1.01,-0.24l-0.02,-1.48l-1.06,-1.88l-0.78,-0.48l-0.53,0.16l-1.27,1.54l-1.68,1.28l-1.09,0.1l-4.03,-1.0l-2.35,-4.46l-1.01,-0.78l-1.59,-0.54l-1.71,0.94l-0.58,0.65l0.14,1.47l0.4,0.75l-0.35,2.16l-4.06,0.88l-1.43,-0.77l-2.53,0.56l-1.69,-0.52l-0.5,0.52l0.3,2.78l-0.75,2.72l0.31,0.5l1.08,0.2l1.21,1.31l-0.83,1.39l0.34,0.89l2.49,1.66l-1.15,2.37l0.58,1.2l-0.15,0.27l-1.56,-0.11l-1.67,-1.76l-0.87,-0.13l-3.24,2.06l-1.11,2.25l-0.67,-0.61l-1.03,-1.96l-3.56,-3.08l-0.67,-1.42l-2.79,-3.11l-6.22,-5.17l2.01,0.83l0.83,-0.53l-0.07,-0.64l-2.39,-1.27l-2.18,-0.36l-0.43,-0.4l-1.06,-2.36l-1.88,-2.18l0.78,0.38l0.54,-0.19l0.02,-1.08l-1.87,-1.01l-0.79,-0.07l-0.01,-0.96l-0.87,-1.72l1.17,1.19l1.11,0.03l1.47,-0.44l0.24,-0.57l-0.26,-0.51l-0.71,-0.66l-1.75,0.09l0.66,-1.79l-0.47,-0.54l-1.49,0.64l-1.42,-0.86l-3.38,-6.36Z",
                        "data-code": "GA", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M141.71,352.29l0.24,-1.06l-1.47,-1.71l-0.56,-1.34l-1.55,-1.46l-1.15,-0.05l0.22,-2.42l-0.48,-0.96l0.11,-0.77l-0.48,-0.45l-0.82,0.62l-0.47,-0.12l-1.47,-0.9l-0.67,-0.8l-0.31,-1.14l-1.73,-0.05l-2.82,-1.33l-2.03,-3.39l0.19,-2.52l-0.67,-0.22l-0.51,0.48l-1.17,-2.5l-1.69,-0.42l-0.61,0.48l-0.49,1.4l-0.2,-0.14l0.07,-0.91l1.13,-1.55l1.92,-3.92l0.92,-1.04l2.68,-0.58l2.16,-1.21l3.61,-0.06l2.68,-0.87l0.27,-0.36l-0.07,-3.33l-2.46,-2.14l0.84,-0.42l1.18,-0.05l0.78,-0.82l0.42,-2.05l-0.67,-1.95l7.04,0.45l-0.17,0.92l0.49,0.79l0.87,0.11l0.82,-0.57l1.42,0.91l3.08,0.91l0.88,-0.02l0.75,0.45l1.44,0.12l2.83,-0.81l2.77,0.12l2.7,-0.46l1.39,0.12l-0.92,2.0l0.08,0.69l2.33,2.0l0.68,0.21l0.85,-0.26l1.8,-1.8l1.12,-0.32l2.17,3.28l0.63,0.37l1.27,-0.57l1.83,-2.36l1.99,-0.78l5.18,1.97l1.51,0.01l0.83,-1.29l3.56,-1.41l0.37,-1.11l-0.67,-1.38l1.56,-0.04l1.84,0.87l0.44,0.57l2.07,4.93l0.15,3.21l1.17,0.55l0.65,1.31l2.95,1.51l-1.34,1.23l-1.7,2.4l0.03,0.83l1.07,0.37l1.51,-0.69l1.26,0.55l0.25,0.81l-0.2,1.83l0.74,3.29l0.55,0.69l2.51,1.32l0.17,0.36l-0.05,1.08l-1.58,1.5l-0.35,0.75l0.19,5.81l0.64,0.99l0.8,0.5l1.36,-0.08l-0.23,2.15l1.47,1.18l-1.59,1.07l-0.26,2.57l2.11,1.1l0.65,0.78l0.4,2.48l-1.27,-1.01l-2.66,-0.33l-2.16,0.26l-0.43,0.55l-0.09,2.74l1.44,0.91l1.14,0.2l0.16,0.6l-1.33,2.39l0.09,1.33l-1.0,1.89l-2.23,-0.32l-0.72,0.4l-0.94,-1.27l-1.3,-0.1l-0.73,0.54l-0.38,1.88l-1.6,2.52l-0.9,-0.0l-1.32,0.53l-1.81,-1.85l-1.08,-0.37l-0.95,0.1l0.87,-1.56l0.17,-1.75l-0.89,-2.34l-0.07,-1.39l-0.7,-1.96l-0.08,-1.77l-1.91,-1.88l-0.85,-0.04l-0.63,-0.76l-3.15,1.15l-0.29,-0.57l-0.83,-0.36l-1.2,0.36l-1.56,-0.05l-2.28,2.08l-1.1,-0.15l0.74,-1.76l1.41,-1.48l0.14,-0.56l-1.23,-2.26l-0.12,-2.22l-0.32,-0.34l-1.24,-0.26l0.71,-1.67l-0.05,-0.82l-6.32,-8.12l-0.91,-0.24l-7.48,0.04l-0.49,0.9l-2.19,0.48l-1.71,-0.62l-1.86,0.41l-1.07,0.67l-0.62,1.76l-2.29,3.88l-0.78,0.75l-1.41,0.43l-0.71,1.58l-0.76,0.74l-1.95,0.03Z",
                        "data-code": "GN", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M100.95,304.31l-0.62,-2.32l1.36,-1.21l1.03,1.81l2.06,0.55l2.56,-0.15l0.45,-0.42l0.18,-0.82l6.11,-0.87l1.77,0.01l0.51,-0.12l0.24,-0.62l-0.4,-0.34l-1.65,-0.2l-6.6,0.61l-2.59,1.24l-0.77,-0.09l-0.89,-1.06l-0.24,-0.98l11.84,0.03l1.25,-1.76l1.67,-0.67l1.8,-0.26l1.84,0.29l1.93,1.34l2.32,0.66l2.07,1.38l1.09,0.18l2.1,-0.56l1.82,-0.08l1.23,0.65l0.21,0.58l-0.15,0.52l-4.38,1.11l-2.13,-0.37l-6.84,-2.9l-1.81,-0.49l-0.66,0.46l-0.9,1.43l-6.12,0.84l-0.31,0.35l-0.19,1.66l-9.2,0.03l-1.0,0.59Z",
                        "data-code": "GM", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M870.84,327.12l-0.01,20.86l-11.07,16.91l-11.42,0.0l-34.59,-11.65l-4.62,-4.08l-1.65,-0.54l-0.96,-1.1l-1.04,-1.49l-1.39,-3.12l-1.43,-0.74l-2.61,-3.2l-0.65,-1.9l-1.44,-2.61l6.6,-10.04l1.89,1.5l2.19,3.63l2.7,3.09l5.03,3.72l1.48,0.56l6.71,-0.13l4.61,-2.52l5.45,-2.16l7.45,1.19l1.36,-0.13l4.91,-2.16l3.04,-2.08l1.94,-0.83l3.56,0.74l3.6,-0.32l6.5,-2.15l1.09,-0.02l2.75,0.8Z",
                        "data-code": "XS", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M28.84,267.68l1.39,0.08l0.47,0.44l-0.15,1.03l-1.06,0.56l-1.06,-0.44l0.41,-1.67ZM28.19,260.4l0.01,0.82l0.07,0.36l-0.26,-1.07l0.19,-0.11ZM25.22,280.01l-0.28,-0.24l0.06,-0.77l0.23,-0.43l0.34,0.03l0.14,1.18l-0.48,0.22ZM19.01,279.11l1.9,1.57l0.86,1.27l-0.44,0.68l-1.23,-0.07l-0.64,-0.36l-0.81,-1.2l0.35,-1.89ZM11.49,262.35l0.91,0.29l-0.49,0.6l-0.43,-0.74l0.02,-0.15ZM11.76,283.5l-1.0,0.16l-0.47,-0.36l-0.06,-0.74l0.96,-0.54l0.38,0.12l0.2,1.37ZM3.48,259.84l1.06,-0.47l0.31,0.54l-0.53,0.16l-0.84,-0.23ZM0.42,257.15l2.3,-1.09l0.63,0.14l0.4,0.61l-1.9,1.44l-0.97,0.21l-0.46,-1.31Z",
                        "data-code": "CV", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M262.02,399.49l0.83,0.05l1.7,-0.53l0.77,-3.59l-0.62,-2.21l-1.9,-0.53l-0.37,-0.63l-2.62,-8.49l-0.12,-4.16l2.86,-4.55l0.36,-3.07l0.72,-2.66l1.23,-2.82l1.87,-1.22l0.36,-0.65l-0.17,-0.62l0.83,-0.31l0.47,-0.77l-1.1,-6.96l-0.63,-2.01l-0.48,-0.81l-0.61,-0.32l0.84,-2.44l-0.33,-0.54l0.19,-1.39l-0.24,-1.21l-0.85,-2.35l0.34,-0.69l-0.45,-4.6l0.24,-0.72l-0.63,-1.09l0.35,-1.17l-1.07,-1.04l-0.37,-0.87l0.08,-1.47l0.78,-2.87l20.69,-0.14l3.81,0.23l0.51,0.61l0.57,0.13l1.74,-0.99l0.75,-0.93l1.08,-0.1l0.55,-0.75l2.23,0.5l0.7,0.8l-1.13,3.45l0.09,0.86l3.6,3.42l1.74,1.15l-0.58,6.67l-0.65,0.37l0.23,0.93l-0.64,1.71l0.76,0.7l1.38,-0.72l0.53,0.04l0.76,1.06l-0.73,2.89l-0.07,1.67l0.35,1.29l-1.2,0.93l-0.1,0.83l1.32,1.93l1.55,1.14l0.73,1.31l-1.2,2.26l0.24,4.93l-1.23,2.23l0.19,1.57l1.36,0.89l-0.47,3.5l-0.79,1.08l0.04,1.34l2.13,3.32l0.47,1.52l2.08,1.48l0.77,0.13l0.8,1.32l1.46,0.78l-1.48,1.1l-1.15,2.09l-2.15,0.54l-5.86,0.07l-4.5,2.21l-2.58,0.78l-1.69,1.29l-2.11,0.87l-1.51,1.07l-3.1,0.52l-5.16,1.71l-5.81,3.21l-0.82,-0.02l-3.64,-1.93l-7.18,-1.54Z",
                        "data-code": "GH", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M658.82,780.66l0.07,-4.13l2.66,-3.92l0.66,-1.48l1.33,-1.64l1.4,-1.03l0.63,-0.09l5.29,2.91l1.03,-0.19l0.99,0.55l-0.24,3.09l0.76,3.04l0.07,3.34l-0.71,-0.14l-0.66,0.4l-0.57,4.53l0.11,1.32l-5.23,-0.14l-2.19,-0.69l-2.35,-1.51l-2.04,-3.9l-1.02,-0.31Z",
                        "data-code": "SZ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M853.67,633.45l0.24,0.85l-0.77,2.09l0.28,0.45l0.83,0.15l0.76,-0.4l1.68,-2.95l1.01,-1.09l2.0,0.4l0.46,-0.19l-0.09,-0.49l-1.69,-1.44l-0.39,-1.81l2.54,-4.79l-0.06,-0.45l-1.05,-1.16l-0.03,-1.17l0.86,-1.19l0.4,-0.13l1.7,1.27l1.16,0.04l1.77,-2.17l2.52,-1.33l2.05,-1.89l1.44,-4.12l0.13,-1.24l-0.32,-1.57l-1.15,-2.76l0.76,0.15l0.76,-0.37l3.13,-4.13l0.3,0.0l1.01,1.69l2.02,2.3l1.19,2.47l3.46,5.1l0.34,2.28l1.26,3.72l1.17,5.47l0.72,8.28l0.97,2.6l1.46,2.49l0.46,2.67l-0.88,2.8l-2.08,3.7l-0.91,-0.61l-0.8,-1.07l-1.68,-4.3l-0.67,-0.26l-1.29,0.12l-1.28,1.14l-0.18,0.72l0.73,6.08l1.39,2.24l0.09,2.65l-0.29,1.27l-0.94,1.41l0.32,1.27l-1.9,1.26l-1.76,3.88l-0.14,1.39l0.66,3.86l-0.18,2.69l-1.34,5.26l-5.21,14.49l-5.28,16.74l-1.38,5.51l-2.04,6.04l-3.14,7.68l-1.23,6.53l-2.34,7.91l-0.54,2.98l-2.17,4.27l-1.17,4.31l-1.1,2.72l-1.61,2.3l-3.44,2.03l-3.98,0.28l-2.67,0.72l-6.59,3.76l-1.02,0.39l-3.41,0.09l-0.93,-0.3l-3.61,-2.63l-5.34,-1.29l-1.12,-1.39l-2.45,-1.42l-1.45,-4.36l-2.77,-4.12l-0.28,-6.85l0.2,-1.27l0.68,-1.46l-1.81,-5.63l-2.04,-2.46l-0.44,-1.1l-1.07,-4.95l0.29,-5.37l0.61,-1.75l1.12,-1.81l0.72,-3.43l0.79,-0.65l1.47,-0.5l1.23,-1.05l0.68,-1.34l0.63,-2.51l3.85,-5.95l1.29,-2.91l0.68,-2.79l0.52,-6.07l-2.48,-4.42l-0.06,-3.97l-1.49,-3.0l-0.78,-2.52l-0.31,-5.85l-0.8,-2.68l0.38,-2.1l5.14,-8.25l0.12,-5.12l0.35,-0.57l5.08,-0.53l3.57,-2.63l1.47,0.99l1.63,-0.59l1.18,0.08l0.41,-0.2l0.98,-1.95l3.49,-0.38l1.74,-0.51l1.69,1.96l1.37,0.19l0.49,-0.35l0.03,-0.63l-1.21,-1.29l0.62,-1.73l5.66,-4.31l0.79,0.06l0.36,2.17l0.34,0.46l1.09,-0.27l0.6,-1.2l-0.47,-2.39l2.11,-2.4l0.83,-2.09l0.73,-0.54ZM863.67,615.59l0.19,1.33l-0.78,-0.09l-0.12,-0.76l0.72,-0.48Z",
                        "data-code": "MG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M111.55,174.08l0.87,-0.82l2.29,-1.53l4.61,-5.0l1.83,-0.96l1.58,-2.13l0.64,-2.12l0.15,-4.31l0.54,-2.21l3.21,-6.6l0.6,-2.92l0.57,-0.97l1.17,-0.55l1.63,-1.44l2.55,-0.94l4.55,-3.25l0.97,-1.81l1.0,-3.42l1.79,-3.61l0.93,-2.75l1.51,-1.38l1.09,-1.81l1.65,-0.74l3.81,-0.4l5.66,-1.52l5.19,-2.35l1.53,-0.99l4.03,-4.16l6.97,-4.48l3.42,-4.1l5.39,-7.44l0.96,-2.1l0.51,-3.13l-0.35,-1.39l-1.47,-2.13l-0.93,-0.57l-0.18,-0.67l0.49,-1.68l0.27,-7.37l1.52,-3.6l3.87,-4.95l0.73,-2.09l0.48,-4.21l4.69,-4.44l3.76,-4.32l2.43,-1.56l8.66,-3.5l4.9,-2.5l2.99,-1.94l1.74,-2.22l4.72,-8.51l4.99,-13.29l3.36,-0.55l2.57,-1.29l0.51,0.13l-0.27,0.42l0.05,1.69l1.04,1.81l1.78,2.01l3.24,2.54l2.53,1.02l3.5,0.6l4.2,-1.08l2.23,-0.02l1.08,-0.42l1.19,0.64l2.3,0.22l2.32,-0.37l2.46,-1.79l1.42,3.08l2.75,0.4l4.57,0.08l1.03,1.67l3.86,2.86l-0.6,1.9l1.29,1.6l-0.64,1.51l0.97,2.48l-0.08,5.17l0.95,2.82l-0.52,3.35l1.5,3.22l0.46,2.49l0.75,1.34l4.0,3.09l0.35,0.73l-1.93,1.71l-0.25,1.1l0.41,1.75l-13.96,-0.43l-4.91,0.72l-1.1,0.68l-0.9,2.5l-4.79,1.63l-3.95,0.23l-0.87,0.56l-0.27,0.68l0.67,3.3l-0.5,2.12l0.31,0.69l2.13,1.25l-0.34,0.84l-3.71,0.64l-3.92,2.74l-5.29,1.87l-2.27,1.14l-2.62,3.95l-3.02,2.58l-6.39,1.58l-5.73,0.19l-0.43,0.39l-0.23,1.86l-0.99,0.91l-6.07,-0.61l-4.01,2.89l-2.44,0.61l-6.8,4.71l-4.58,3.31l-0.43,0.7l-0.06,12.74l-1.18,-0.0l-0.4,0.43l0.5,2.41l-0.32,1.33l0.57,2.17l-0.25,0.45l-2.28,0.36l-4.87,0.03l-3.88,2.88l-0.82,0.12l-0.84,0.0l-1.68,-0.76l-2.46,0.63l-3.43,-1.6l-2.64,-0.4l-2.01,0.14l-5.47,1.59l-0.29,0.51l0.87,1.77l-0.18,1.02l-2.02,2.05l-2.06,3.28l-0.38,1.28l-3.45,0.81l-0.57,0.65l-2.99,11.13l-1.34,3.36l-2.26,1.8l-4.28,2.67l-0.88,0.94l-2.85,5.11l-5.33,2.33l-1.55,1.39l-1.55,3.53l-0.95,3.88l-0.83,4.25l-0.57,5.45l-4.71,5.41l0.11,1.58l-0.65,1.71l-0.85,1.11l-0.91,0.53l-1.42,0.11l-5.7,-0.12l-6.83,-0.61l-8.12,0.37l-2.68,0.51l0.76,-5.27l1.56,-3.09l1.18,-1.3l2.11,-0.87l1.83,-3.22l0.66,-2.98l1.13,-1.29l0.45,-1.2l-0.38,-0.93l4.64,-7.95l0.06,-1.38l-0.73,-0.14Z",
                        "data-code": "MA", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M696.13,456.91l1.2,-1.94l0.9,-2.52l1.23,-0.89l1.69,-2.18l0.87,-2.1l1.3,-1.23l2.39,-1.11l-0.06,-1.76l2.06,-2.98l0.2,-1.72l-0.17,-3.41l-0.94,-4.11l0.23,-0.9l-0.46,-1.29l-0.65,-0.47l-0.86,-2.33l-1.78,-1.27l-0.73,-2.16l-0.9,-0.64l-0.52,-2.66l0.44,-2.85l-0.65,-0.74l-1.55,-0.55l-0.89,-0.7l0.13,-0.45l-0.73,-0.65l-1.64,-3.48l14.24,-14.05l0.92,0.87l1.84,-0.59l3.03,0.82l0.38,0.54l0.09,1.28l-0.5,2.4l0.08,1.75l3.18,4.28l0.95,0.31l9.51,0.42l13.93,8.98l6.14,0.58l7.22,1.42l3.36,0.26l0.68,-0.24l1.44,-1.33l2.14,-3.16l10.47,-4.79l4.37,3.57l2.19,0.25l5.87,-0.41l-5.9,8.46l-4.23,4.19l-0.29,0.61l0.17,43.23l6.42,8.43l0.09,1.09l-1.59,1.87l-1.29,0.85l-1.74,0.4l-1.14,-0.34l-0.49,0.17l-0.43,0.9l-0.24,-0.17l-0.63,0.38l0.36,1.94l-0.21,0.67l-0.83,0.7l-0.2,0.76l-1.77,1.54l-2.85,0.23l-2.23,1.63l-0.61,1.84l0.17,2.25l-0.89,2.57l-1.42,1.19l-1.49,2.6l-0.57,2.6l-1.01,2.38l-2.81,5.67l-1.16,1.5l-1.16,-0.05l-0.72,0.71l-16.23,-11.7l-0.96,-1.51l-1.12,-0.47l0.93,-2.7l-0.34,-2.17l-0.38,-0.57l-41.77,-23.33l0.6,-0.4l0.53,-1.22l-1.1,-2.04l-0.08,-0.78l1.21,-1.79l0.85,-0.2l2.27,0.58l0.47,-0.54l-0.1,-1.15l3.66,-0.65l0.42,-0.81l-1.12,-2.16l-0.47,-0.2l-3.55,1.24l-0.7,0.63l-0.5,1.16l-1.84,-2.03l-0.07,-1.02l-0.85,-0.13l-0.41,-0.45l-0.29,-2.46ZM779.14,483.65l0.05,-0.04l0.01,0.0l-0.07,0.03Z",
                        "data-code": "KE", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M581.04,357.13l1.37,-1.12l2.93,-1.06l0.24,-1.49l1.15,-2.04l0.29,-2.42l1.3,-1.74l0.04,-2.89l2.49,-3.21l0.28,-2.18l0.39,-0.53l8.3,-1.41l0.43,0.1l0.2,0.45l0.08,1.69l0.41,0.58l2.98,2.46l4.44,5.17l1.42,0.61l1.53,-0.19l3.52,-1.32l9.24,0.18l1.18,2.38l0.97,0.82l9.33,0.03l0.39,-0.49l-0.07,-1.29l1.52,-1.48l2.94,-1.39l2.87,-0.69l1.6,-1.89l0.08,-1.72l4.26,-2.24l5.29,3.38l3.41,3.0l4.95,-0.48l0.96,-0.42l5.07,-5.03l2.36,-3.09l0.89,-2.12l5.78,-5.15l0.05,-0.67l-0.97,-2.24l-0.02,-4.76l-2.62,-3.02l6.91,-0.03l0.4,-0.37l-0.19,-2.16l4.79,0.06l-0.71,2.77l-0.16,2.99l-0.58,1.11l1.15,8.97l-0.49,1.2l0.39,0.52l2.63,0.98l0.99,1.18l5.16,4.28l0.53,1.37l0.07,2.18l-0.79,1.64l-0.28,2.62l0.47,0.85l1.95,0.04l0.29,8.87l-0.26,1.32l-1.23,1.06l-8.0,0.16l-0.65,0.61l-2.58,5.22l-0.17,1.0l1.09,1.04l1.77,0.78l5.15,1.06l2.69,1.85l1.26,1.5l0.61,1.81l2.52,2.63l2.42,1.26l0.95,1.41l1.64,1.33l2.86,7.13l0.33,2.27l1.2,2.25l1.92,1.85l-20.42,20.03l-3.67,-0.22l-2.17,-1.21l-1.83,0.94l-5.96,1.12l-1.69,1.2l-0.49,0.91l-1.94,-0.92l-1.73,-2.29l-0.45,-0.03l-2.79,1.41l-3.63,-1.25l-0.95,-0.02l-2.86,1.86l-0.8,1.15l-0.84,-1.09l-0.88,-0.25l-1.11,0.2l-0.72,-2.26l-3.78,-1.85l-3.73,-3.98l-1.03,-1.76l-1.27,-1.32l-1.6,-0.67l-1.23,0.27l-1.16,1.42l-1.73,1.15l-0.63,0.03l-2.46,-1.13l-2.59,-0.23l-2.61,1.61l-1.59,0.57l-1.98,-0.36l-2.41,-2.09l-1.61,-0.77l-1.98,-2.82l-2.06,-1.47l-2.65,-3.66l-0.32,-3.16l-1.07,-2.03l-4.97,-3.31l-1.65,-0.29l-0.78,-0.51l-1.11,-2.4l-1.04,-1.31l-0.15,-0.54l0.59,-2.01l-0.13,-0.42l-2.24,-1.72l-1.59,-2.06l-1.73,-1.29l-5.96,-3.17l-1.15,-1.07l-1.0,-1.17l0.59,-0.94l0.16,-1.06l-0.6,-1.22l-2.34,-1.95l-1.78,-2.01l-1.6,-0.77l-5.07,-1.13l-0.84,-0.79l-0.27,-0.87l0.45,-1.63l-0.67,-1.05Z",
                        "data-code": "SS", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M158.55,301.7l-0.54,-1.32l-1.75,-2.1l0.09,-0.89l0.69,-0.68l0.3,-1.15l-0.68,-1.35l-0.07,-2.89l-2.36,-2.87l0.46,-2.09l-0.6,-1.27l1.44,0.3l1.94,-1.71l0.9,-1.49l0.52,-3.0l0.75,-2.02l2.76,-2.33l6.42,5.8l0.97,-0.19l2.15,-3.09l3.15,-0.17l5.53,0.77l2.29,-0.34l3.6,-0.68l0.33,-0.35l0.0,-1.39l0.39,-0.65l0.32,1.53l2.03,0.41l43.0,-0.0l0.39,-0.33l1.79,-9.46l-3.16,-3.69l-11.26,-102.64l20.21,-0.01l69.78,48.0l0.27,3.49l1.54,1.35l3.72,1.92l0.77,2.02l0.93,0.73l2.19,0.78l3.38,0.31l2.16,2.22l5.44,1.34l2.99,1.24l0.68,0.58l-0.02,2.61l0.63,2.09l-0.65,0.69l-1.08,2.33l0.35,0.81l1.56,1.07l1.96,0.38l9.28,-1.79l0.08,25.36l-0.37,0.53l-0.24,4.56l-0.69,2.6l-1.27,2.05l-1.6,5.2l-0.56,0.78l-1.29,0.44l-2.22,1.9l-0.27,1.36l-4.9,-0.79l-0.82,0.33l-0.19,0.72l-19.62,0.81l-4.18,3.48l-2.63,0.33l-5.06,-0.3l-0.79,0.21l-0.32,0.48l-4.9,-1.63l-2.05,0.51l-0.55,-0.52l-0.96,-0.22l-1.71,0.1l-1.25,0.34l-3.34,2.7l-5.19,2.31l-2.34,1.4l-3.22,0.61l-1.21,3.23l-0.36,0.17l-3.89,-1.22l-1.82,0.58l-2.32,1.88l-1.18,1.54l-0.67,2.08l-0.11,1.41l-2.82,-0.31l-0.86,0.46l-0.57,4.31l-2.32,1.06l-3.6,-2.2l-1.4,-0.4l-1.39,0.31l-3.31,3.19l0.13,1.16l0.98,2.02l-0.01,0.7l-2.75,1.34l-0.18,0.54l0.65,1.04l-0.07,2.61l-1.78,2.08l-1.19,0.84l-4.76,1.29l-1.52,0.95l-0.84,0.99l-0.03,1.86l0.71,1.88l-0.23,1.63l-1.03,2.7l-1.62,1.02l-0.16,0.4l0.38,3.12l-0.64,3.57l-1.85,0.07l-1.86,0.57l-2.16,2.23l-1.82,-0.57l0.52,-1.59l-0.54,-1.75l-0.14,-1.95l-0.64,-0.39l-2.03,0.66l-0.25,0.5l0.18,0.76l-1.15,-0.27l-0.99,-0.78l-0.54,0.04l-0.49,1.17l0.1,2.31l-3.13,0.29l-0.54,1.2l0.3,0.79l-0.28,0.19l-0.85,-0.69l-2.82,-0.62l-0.19,-0.71l-1.74,-1.48l-2.16,0.26l-1.82,2.27l-1.24,0.67l-0.36,-1.58l-3.03,-1.94l-0.64,-2.98l0.13,-2.4l-0.34,-0.64l-1.85,-0.87l-1.94,0.69l1.58,-2.24l1.16,-0.87l0.35,-1.13l-0.32,-0.44l-2.85,-1.43l-0.59,-1.25l-1.17,-0.59l-0.0,-2.92l-2.1,-5.0l-0.68,-0.86l-2.2,-1.02l-1.09,-0.08l-1.23,0.34l-0.2,0.66l0.64,1.04l-0.06,0.77l-1.45,0.34l-2.04,1.03l-0.95,1.28l-6.22,-2.14l-2.42,1.0l-1.78,2.32l-0.64,0.39l-1.8,-2.9l-0.67,-0.63l-1.1,-0.14l-0.94,0.49l-1.69,1.73l-0.72,0.09l-2.06,-1.77l1.29,-2.46l0.08,-0.89l-0.8,-0.97l0.61,-4.85l-1.78,-2.61l-0.38,-1.41l-0.67,-1.04l-1.72,-0.47l-0.82,0.85Z",
                        "data-code": "ML", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M817.5,603.11l0.61,-0.24l0.5,-0.86l0.49,1.37l-0.0,1.05l-1.59,-1.3ZM809.46,604.09l0.26,0.03l0.6,0.37l-0.69,-0.09l-0.17,-0.31ZM806.8,599.18l-1.42,-0.7l-0.71,-0.87l0.32,-3.55l0.29,-0.43l0.51,0.21l-0.15,2.23l1.15,3.1Z",
                        "data-code": "KM", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M383.99,440.62l-0.33,-0.08l0.53,-0.7l0.05,0.23l-0.25,0.55ZM375.07,457.57l-1.05,0.63l-0.5,-1.61l0.52,-1.0l1.46,-0.64l0.52,0.65l0.0,0.69l-0.94,1.28Z",
                        "data-code": "ST", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M681.13,619.76l1.74,-1.46l1.44,-2.96l0.38,-3.9l-0.61,-1.2l0.73,-1.72l4.31,-1.64l1.54,-1.88l-0.35,-0.69l-1.7,-0.22l-0.93,-2.11l0.55,-2.61l0.03,-2.37l-0.19,-1.02l-0.71,-0.92l0.05,-1.02l0.39,-0.27l1.32,-2.96l-1.29,-3.24l0.68,-0.62l1.52,-0.44l2.28,-2.28l0.14,-0.7l-1.31,-2.14l-0.33,-1.91l-2.41,-2.19l0.32,-2.22l-1.17,-1.21l-0.79,-1.69l-1.23,-0.32l-0.55,0.4l-0.41,-0.09l-0.68,-1.96l1.71,1.11l2.38,0.31l1.15,1.07l3.32,-0.1l2.2,0.84l-0.11,1.28l1.3,3.56l2.72,3.57l-0.7,2.02l0.63,6.18l-0.24,0.8l1.15,5.72l-3.03,4.51l-0.36,2.15l0.6,1.96l1.16,0.77l0.18,2.55l0.83,1.15l0.72,2.39l0.16,2.45l-0.26,2.73l1.16,2.0l1.6,0.84l0.58,0.7l0.15,0.79l-0.96,2.74l0.39,1.72l1.87,2.05l0.5,0.06l1.31,-0.89l0.42,-2.09l0.51,1.42l1.09,0.39l2.18,2.65l0.8,0.07l0.45,-0.87l-2.17,-6.4l8.0,10.32l0.46,2.59l-0.56,1.56l-0.41,2.77l0.29,1.92l-0.12,3.09l-0.7,4.33l-1.57,0.66l-3.01,0.52l-0.86,1.14l-1.49,3.84l0.75,1.26l0.57,1.91l0.08,3.32l-1.41,0.08l-0.46,-0.39l-0.14,-0.42l0.52,-0.56l0.21,-0.91l-0.41,-1.04l-1.81,-1.01l-4.7,-5.26l-1.29,-0.85l-0.14,-1.96l-1.78,-2.3l0.32,-0.97l0.94,-0.93l0.91,-2.74l1.26,-2.27l0.2,-3.44l-0.69,-5.22l-1.53,-2.08l-0.87,-0.35l-2.75,0.5l-0.65,0.42l-4.09,0.54l-0.52,0.37l-2.66,-3.09l-1.7,-2.92l-1.14,-1.26l-0.48,-0.13l-1.48,0.93l-1.35,-2.28l-0.96,-0.53l0.3,-0.65l-0.16,-0.35l-1.1,-0.81ZM707.94,620.9l-1.35,-0.14l-0.08,-1.18l1.13,0.99l0.3,0.33ZM704.22,601.65l0.03,-0.32l0.11,-0.2l0.13,0.19l-0.28,0.32ZM703.11,600.89l-0.08,0.18l-0.2,-0.25l0.11,-0.06l0.17,0.12Z",
                        "data-code": "MW", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M784.81,478.05l-6.52,-8.7l-0.07,-43.18l4.26,-4.23l6.72,-9.72l1.17,-1.15l2.26,-0.71l6.71,-1.1l1.31,-0.88l1.43,-2.38l1.21,-0.9l5.27,-2.43l4.69,-1.11l10.76,0.6l0.66,-0.27l17.38,-18.64l18.24,-17.68l11.31,-17.26l0.07,-21.27l4.96,-0.97l3.0,-1.29l5.57,-0.97l4.18,-2.36l2.01,-2.56l1.6,-0.41l4.95,1.72l-0.32,1.61l-1.57,3.84l0.43,3.23l0.12,5.56l-0.39,1.09l-0.71,0.59l0.19,0.58l-1.22,0.58l-0.57,1.2l-0.8,6.56l-0.09,3.22l-1.57,2.11l-0.59,1.6l-2.45,3.14l-1.7,3.98l-2.09,3.57l-3.01,2.94l-1.06,3.55l-1.04,2.2l-3.75,5.6l-1.38,2.6l-1.67,4.35l-0.52,2.76l-4.65,7.91l-4.85,6.35l-3.04,5.37l-12.82,14.18l-9.68,9.49l-2.59,1.91l-10.64,5.88l-6.89,4.92l-10.19,9.06l-10.64,11.06l-4.03,4.91l-2.84,2.8l-2.92,5.38l-1.57,2.2ZM897.88,336.12l0.13,-0.45l1.54,0.9l-0.87,-0.13l-0.8,-0.32Z",
                        "data-code": "SO", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M92.84,285.0l-0.36,0.43l-0.22,-0.26l0.58,-0.18ZM93.02,284.95l3.4,-1.72l3.59,-4.5l3.2,-5.29l0.83,-2.25l0.67,-3.33l0.45,-0.33l1.82,-3.52l0.62,-0.14l2.37,0.65l2.36,0.09l4.53,-1.16l3.09,-0.27l0.35,-0.55l0.8,0.03l0.52,-0.36l0.48,0.3l1.66,0.09l2.93,-0.12l2.61,0.87l3.62,3.07l0.54,1.33l0.83,0.74l0.88,0.21l0.96,-0.38l0.52,0.52l0.72,0.1l1.12,-0.25l1.15,0.85l0.67,0.94l1.01,3.19l0.65,1.11l0.91,0.33l0.76,1.11l1.05,0.13l0.55,0.46l0.73,1.24l0.27,1.4l2.27,1.89l1.38,0.54l0.87,0.69l0.68,1.09l1.46,0.95l0.95,1.66l-0.4,2.43l2.4,2.94l-0.02,2.6l0.68,1.29l-0.2,0.74l-0.77,0.84l-0.04,1.49l1.78,2.16l0.23,0.95l0.62,0.7l0.78,-0.04l0.6,-0.73l0.96,0.19l0.53,0.8l0.41,1.47l1.75,2.61l-0.67,4.5l0.76,1.32l-1.77,-0.18l-2.77,0.46l-2.77,-0.12l-2.95,0.83l-5.72,-1.44l-1.63,-0.97l-1.35,0.55l0.12,-1.1l-0.62,-0.67l-7.61,-0.48l-17.22,-0.07l-4.58,2.28l-3.0,0.6l-3.6,-0.23l-4.38,1.29l-2.05,-0.11l-0.58,-0.98l0.14,-0.31l2.13,-0.82l1.2,0.26l0.48,-0.65l-0.22,-0.52l-1.7,-1.1l-0.53,-0.05l-0.94,1.15l-0.44,0.05l0.09,-4.89l1.05,-0.83l9.43,-0.03l0.4,-0.35l0.2,-1.73l5.87,-0.78l0.8,-0.6l0.79,-1.29l8.18,3.38l2.32,0.41l4.84,-1.19l0.53,-1.39l-0.5,-1.06l-1.46,-0.77l-2.19,0.04l-2.08,0.56l-0.8,-0.15l-1.96,-1.35l-2.24,-0.62l-1.93,-1.35l-1.24,-0.32l-2.96,0.2l-1.94,0.77l-1.05,1.65l-11.81,-0.02l-0.29,-1.04l-1.99,-2.29l1.65,-1.45l-0.38,-0.61l-1.62,0.42l-0.12,-0.88l-2.03,-3.65l-1.29,-1.05l-1.0,-1.81l-1.31,-0.91l-1.89,-0.3Z",
                        "data-code": "SN", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M98.1,207.95l0.48,-2.23l45.99,-0.06l0.4,-0.43l-0.92,-14.29l-0.73,-2.46l0.03,-1.39l1.33,-2.06l4.72,-3.28l2.88,-0.57l3.44,-1.47l0.9,-0.72l0.08,-31.14l38.71,-0.0l0.4,-0.4l-0.01,-15.52l43.54,27.63l-19.44,0.01l-0.4,0.44l11.32,103.21l3.12,3.52l-1.69,8.94l-42.64,0.0l-1.49,-0.2l-0.16,-1.61l-0.51,-0.35l-1.15,0.88l-0.23,1.79l-5.46,0.96l-5.49,-0.77l-3.39,0.19l-0.7,0.5l-2.02,2.76l-5.86,-5.58l-0.75,-0.24l-1.45,0.84l-1.96,1.81l-0.9,2.33l-0.51,2.96l-0.74,1.2l-1.69,1.48l-2.04,-0.76l-1.13,-0.78l-0.65,-1.06l-3.18,-1.85l-1.35,-1.32l-0.05,-0.99l-0.93,-1.58l-0.74,-0.62l-0.99,-0.08l-0.3,-0.72l-1.2,-0.59l-1.54,-4.08l-0.86,-1.2l-1.31,-0.99l-1.93,0.12l-1.04,-0.58l-1.17,0.32l-0.96,-1.08l-0.18,-0.79l-1.34,-1.33l-2.52,-1.94l-2.86,-0.98l-3.09,0.1l-2.42,-0.37l-0.53,0.38l-0.81,-0.1l-0.5,0.66l-2.77,0.2l-4.5,1.16l-2.18,-0.08l-2.44,-0.66l-0.97,0.2l-0.97,1.11l-2.02,4.02l-0.0,-1.73l0.84,-3.76l4.5,-11.36l0.59,-4.22l-0.64,-7.78l-1.51,-5.89l-1.14,-1.95l-2.02,-1.65l-0.27,-0.56l1.52,-0.5l0.77,-1.25l-0.02,-0.45l-0.43,-0.14l-0.76,0.22l1.52,-3.1l0.84,-5.34l-2.7,-5.63l-1.28,-0.76l-0.55,0.34l-0.15,0.78l-0.25,-0.13l-2.9,-5.41l-0.77,-0.52l-0.79,0.35ZM104.46,225.57l-0.06,-0.38l0.55,-0.92l-0.13,0.74l-0.35,0.56Z",
                        "data-code": "MR", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element", cursor: "pointer" }),
                  _react2.default.createElement("path", { d: "M644.58,475.13l-0.21,-4.33l0.98,-5.43l2.6,-2.48l0.22,-1.53l-0.22,-0.42l-1.22,-0.6l-0.84,-0.05l0.28,-2.03l0.69,-0.8l1.8,-3.83l0.06,-3.66l1.17,-0.51l1.59,-1.29l0.76,-1.6l0.83,-0.85l1.38,-0.47l0.26,2.06l0.79,0.38l0.73,-0.26l3.63,-4.87l0.83,-0.85l2.25,-0.89l1.27,-1.01l1.68,-2.63l-0.16,-4.31l1.05,-1.66l-0.5,-0.47l-0.7,0.27l-1.73,2.27l-0.78,-0.98l-1.15,-0.25l-1.29,-1.26l-1.7,-0.06l-0.88,-0.48l1.43,-4.87l-0.39,-1.09l-0.71,-0.78l0.79,-2.54l0.91,-1.47l-0.08,-0.92l-0.5,-0.42l0.8,-1.23l2.43,-1.66l4.5,1.27l2.93,-1.38l1.56,2.17l2.34,1.05l0.49,-0.11l0.65,-1.06l1.46,-1.03l5.84,-1.07l1.74,-0.88l1.82,1.17l3.98,0.23l1.21,-0.78l4.38,-4.39l1.59,3.37l0.5,0.31l-0.0,0.73l1.2,0.94l1.86,0.85l-0.46,2.66l0.57,2.95l0.94,0.7l0.9,2.36l1.65,1.11l0.83,2.28l0.67,0.53l0.35,0.97l-0.24,0.79l0.95,4.18l0.14,3.91l-0.34,1.21l-1.85,2.57l0.13,1.65l-2.14,0.88l-1.5,1.41l-0.88,2.11l-1.6,2.07l-1.35,1.04l-0.96,2.65l-1.04,1.69l-1.19,0.34l-1.1,-0.21l-0.21,-0.9l-0.68,-0.4l-0.89,0.33l-0.62,0.82l-0.73,0.02l0.25,-0.52l-0.15,-0.55l-1.55,-0.47l0.27,-1.15l-0.54,-0.3l-1.08,0.11l-1.0,0.4l-0.72,2.09l-0.52,0.11l-0.37,0.73l-1.1,0.83l-1.07,-0.75l-1.5,0.72l-0.04,-0.81l-0.53,-0.67l-0.55,-0.16l-0.84,0.83l-0.52,1.32l-0.47,0.13l-0.78,-0.41l-0.88,0.85l-1.74,0.2l-2.94,1.58l-0.4,0.78l0.76,1.1l-0.05,0.53l-1.46,1.84l-1.71,3.66l0.56,2.24l-10.98,-0.08l-2.43,0.87l-2.24,-0.06l-0.8,0.24l-2.48,2.91l-1.77,1.39l-0.71,0.2l-0.54,-1.28l-0.59,-0.26l-2.39,0.57ZM687.18,457.18l0.12,-0.82l1.06,-0.02l-0.55,0.44l-0.16,0.59l-0.47,-0.19ZM673.83,462.4l0.46,0.01l-0.02,0.46l-0.21,-0.11l-0.24,-0.35ZM675.29,463.38l0.55,-0.04l-0.4,1.17l-0.61,0.23l0.55,-0.77l-0.09,-0.59Z",
                        "data-code": "UG", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M636.92,346.14l-1.71,1.58l-0.17,1.46l-8.66,-0.03l-1.72,-2.99l-0.48,-0.24l-9.48,-0.14l-4.74,1.51l-1.07,-0.42l-4.41,-5.13l-2.98,-2.46l-0.61,-2.66l-1.15,-0.4l-5.95,1.19l-2.18,0.09l-0.69,0.37l-0.58,0.87l-0.22,2.05l-2.53,3.29l-0.06,2.98l-1.28,1.68l-0.28,2.41l-1.15,2.04l-0.13,1.24l-3.63,1.38l-0.82,1.09l-6.16,-1.05l-0.35,-0.38l0.06,-1.63l-0.94,-1.06l0.04,-0.55l1.41,-1.64l0.39,-1.07l0.41,-4.45l-0.15,-1.56l-1.21,-2.49l-2.74,-4.26l-4.11,-4.35l-1.09,-1.77l0.88,-3.16l-0.19,-1.94l-1.0,-0.91l-0.83,-0.15l-2.09,-1.83l-0.35,-0.93l0.26,-3.9l-0.51,-0.76l-0.73,-0.14l-0.95,-4.58l0.22,-1.18l-0.73,-1.36l-1.8,-0.79l-3.43,0.38l-0.89,-0.97l0.9,-2.28l0.9,-1.24l2.0,-1.26l0.88,-1.46l-0.06,-1.96l-1.32,-3.07l-0.01,-0.67l0.67,-1.12l4.31,-3.03l-0.04,-0.84l-0.94,-1.07l-0.7,-2.9l0.77,-0.75l2.42,-1.1l0.24,-1.72l0.92,-1.67l2.02,-2.04l0.46,-1.89l-0.39,-2.6l1.72,-1.74l4.03,-0.14l1.72,-0.38l3.9,0.5l0.75,-0.53l0.12,-51.43l11.17,0.01l0.55,-0.49l0.01,-24.02l72.66,0.01l0.96,-0.31l1.31,-2.23l0.55,0.29l-0.56,1.71l0.38,0.53l63.39,-0.01l0.12,2.49l0.56,2.35l1.81,3.2l1.93,2.41l-0.62,-0.25l-0.55,0.34l-0.11,1.49l0.37,3.13l0.63,2.12l-0.45,1.97l0.06,3.35l0.81,4.03l-0.15,2.62l1.33,5.96l1.31,3.36l0.89,1.02l2.35,0.74l2.16,1.61l3.24,3.67l1.17,-0.15l0.46,0.59l2.73,1.71l0.22,0.43l-1.99,2.04l-0.62,1.36l-1.37,1.52l-5.34,1.43l-2.9,1.71l-0.54,0.6l-0.97,2.46l-2.64,0.23l-1.9,-0.2l-0.36,0.27l-0.38,3.16l-1.06,2.25l0.3,3.86l-1.16,3.57l-1.58,3.23l-1.82,5.63l-1.16,1.66l1.14,10.41l-0.92,3.13l0.02,1.82l-0.64,2.5l-2.08,4.21l-0.63,2.17l-0.4,3.98l-4.35,0.9l-0.91,0.57l-0.91,1.08l-4.01,6.87l-1.69,1.76l-1.79,6.45l-0.37,4.87l-1.41,1.11l-1.86,-1.32l-0.74,-0.18l-1.68,1.12l-1.12,1.63l-0.86,1.83l0.42,3.87l-1.77,3.95l-0.96,4.36l-1.64,-0.19l0.26,-2.3l0.82,-1.84l-0.09,-2.39l-0.66,-1.65l-5.28,-4.41l-1.07,-1.24l-2.59,-0.99l0.4,-1.09l-1.16,-8.77l0.56,-1.07l0.17,-3.01l0.68,-2.33l0.07,-0.98l-0.39,-0.43l-5.6,-0.07l-0.44,0.42l0.22,2.12l-7.41,0.03l-0.3,0.67l3.05,3.42l-0.01,4.63l0.97,2.46l-5.6,4.89l-1.71,3.36l-6.56,6.83l-5.16,0.74l-3.2,-2.87l-5.53,-3.54l-0.42,-0.0l-4.7,2.54l-0.17,1.9l-1.33,1.56l-4.06,1.1l-1.75,1.06Z",
                        "data-code": "SD", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" }),
                  _react2.default.createElement("path", { d: "M682.61,781.45l-5.86,0.15l-2.46,-0.31l-0.07,-3.6l-0.75,-2.96l0.22,-3.37l-1.36,-0.96l-0.28,-2.0l0.75,-1.85l0.01,-14.7l-2.2,-7.12l-2.99,-5.12l-0.14,-2.42l-2.83,-10.56l1.53,-1.18l11.71,-12.29l0.1,-0.46l-0.8,-1.77l1.38,-2.29l0.16,-3.4l2.08,-1.71l3.82,-6.63l0.14,-1.59l-2.06,-3.84l-0.57,-1.9l0.6,-1.72l0.19,-1.93l-0.43,-0.72l-1.15,-0.63l-0.14,-0.51l0.15,-1.01l1.44,-0.73l0.55,-0.64l1.3,-4.59l-0.44,-3.4l0.16,-10.06l-1.0,-2.64l-0.09,-1.68l0.83,-2.1l-0.32,-0.45l-2.3,-0.38l-1.29,-1.07l-4.63,-1.71l-3.52,-0.25l-2.86,-2.5l-2.47,-0.5l-3.08,-1.89l-9.33,-0.38l-0.14,-3.84l-0.54,-3.55l-1.17,-2.06l-0.33,-1.85l5.01,-1.99l10.13,-2.9l19.34,-6.68l1.96,3.1l2.92,3.37l5.14,-0.87l1.93,-0.74l1.62,-0.05l1.4,1.9l0.6,4.86l-0.19,3.24l-1.2,2.08l-0.89,2.71l-1.31,1.51l-0.04,0.93l1.8,2.36l-0.07,1.37l0.34,0.83l1.34,0.92l4.78,5.33l1.68,0.91l0.08,1.13l-0.61,0.86l0.32,0.88l0.99,0.73l1.83,-0.11l0.54,-0.67l-0.11,-3.49l-0.62,-2.13l-0.67,-0.93l1.38,-3.52l0.6,-0.83l4.04,-0.77l0.81,-0.7l0.44,-1.29l0.34,-3.37l0.12,-3.14l-0.29,-1.86l0.39,-2.67l0.61,-1.67l-0.59,-3.02l-7.04,-9.27l-2.76,-3.05l-1.69,-1.39l-0.18,-1.71l-0.42,-0.53l-0.11,-3.29l-0.35,-1.0l0.44,-2.32l-0.22,-1.58l-1.07,-2.47l0.09,-2.62l1.74,-1.65l0.42,-0.79l0.53,-1.44l0.29,-3.15l6.72,0.29l0.99,-0.31l1.75,-1.46l1.22,0.02l2.84,1.67l0.42,0.88l1.44,0.44l2.5,0.12l1.92,-0.39l1.26,-0.92l2.18,-0.46l2.72,1.39l2.04,0.3l2.08,-0.46l2.24,-1.19l1.23,-1.17l0.93,-2.13l2.82,-0.17l1.52,0.36l2.43,1.18l3.51,-2.16l2.16,-0.7l2.09,-0.0l1.88,-0.54l2.84,-1.71l3.04,-0.82l2.06,-1.12l5.19,-3.94l1.31,1.73l-1.13,0.91l0.03,0.67l0.9,0.54l-0.75,1.01l-0.12,0.82l0.41,0.85l-1.61,3.06l0.7,1.57l-0.34,2.52l1.12,4.02l-0.34,1.37l0.24,3.2l-0.39,1.08l0.76,0.81l0.32,1.07l-0.27,1.97l-1.26,1.04l-0.15,1.09l0.39,0.39l1.18,0.01l-0.21,3.2l0.32,1.05l-0.41,1.14l0.59,7.87l0.25,0.8l1.14,0.55l-0.88,1.76l0.07,1.85l0.3,0.34l0.43,-0.17l1.0,-1.23l0.27,0.3l0.32,2.9l-0.08,0.64l-1.51,1.6l-0.21,1.61l-0.78,0.64l0.32,1.89l-1.03,2.43l-5.24,6.03l-0.18,1.13l-1.22,1.74l-2.24,0.85l-0.16,0.48l0.5,1.34l-6.81,4.22l-1.83,2.13l-2.22,0.79l-2.44,0.1l-6.24,2.34l-1.25,0.99l-2.41,0.86l-3.86,2.16l-3.14,2.05l-3.64,3.12l-0.53,1.72l-4.19,4.69l-1.5,2.12l-0.14,0.86l-0.39,0.12l-0.58,-0.69l-0.7,0.19l-0.27,1.45l-1.13,-0.25l-3.22,1.86l-2.46,2.15l-3.33,3.99l-4.78,3.79l-0.8,0.08l-1.65,-1.35l-1.24,0.12l0.06,0.45l1.13,1.31l-0.58,7.87l3.29,4.23l1.55,4.65l0.16,2.57l1.6,3.06l0.72,4.68l-0.16,4.36l0.92,1.04l0.63,-0.13l0.29,-0.64l0.32,-3.09l0.36,1.14l0.13,1.44l-0.6,3.55l0.97,3.72l-0.92,2.66l-1.46,7.65l0.4,0.74l0.99,0.33l0.61,-0.67l-0.58,2.82l-2.69,4.42l-1.11,1.33l-1.85,1.31l-4.46,2.1l-9.03,3.07l-5.76,2.42l-4.59,2.9l-2.05,1.98l-0.89,2.3l-1.54,2.29l0.0,0.41l1.35,1.98l1.8,1.47l0.6,-0.22l0.28,-0.92l-0.58,7.72Z",
                        "data-code": "MZ", fill: "#6497b1", fillOpacity: "1", stroke: "none", strokeWidth: "0", strokeOpacity: "1",
                        fillRule: "evenodd", className: "jvectormap-region jvectormap-element" })
            ),
            _react2.default.createElement("g", null),
            _react2.default.createElement("g", null),
            _react2.default.createElement("g", null)
      );
}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(45);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _app = __webpack_require__(54);

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(_app2.default, null), document.getElementById('react'));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var m=__webpack_require__(6),n=__webpack_require__(11),p=__webpack_require__(5),q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}
function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}
function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b)}
var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b)},count:function(a){return null==a?0:P(a,"",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),
d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W["default"]?W["default"]:W;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var _assign = __webpack_require__(6);
var emptyObject = __webpack_require__(11);
var invariant = __webpack_require__(7);
var warning = __webpack_require__(12);
var emptyFunction = __webpack_require__(5);
var checkPropTypes = __webpack_require__(14);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(46);
} else {
  module.exports = __webpack_require__(49);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(0),l=__webpack_require__(22),B=__webpack_require__(6),C=__webpack_require__(5),ba=__webpack_require__(23),da=__webpack_require__(24),ea=__webpack_require__(25),fa=__webpack_require__(26),ia=__webpack_require__(27),D=__webpack_require__(11);
function E(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:E("227");
var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};
function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
var xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,"default":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,
scoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
a.setAttribute("value",""+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,
xmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E("197"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=
q)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E("198")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}
function Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};
function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E("96",a);if(!Oa[c]){b.extractEvents?void 0:E("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E("98",d,a)}}}}
function Qa(a,b,c){Ra[a]?E("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E("101"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E("102",c):void 0,Ma[c]=d,b=!0)}b&&Na()}
var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
function $a(a,b){null==b?E("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;
function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?E("231",b,typeof c):void 0;
return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E("95"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
function pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E("33")}function rb(a){return a[ob]||null}
var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}
function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}
function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}
function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b)}
var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S={_root:null,_startText:null,_fallbackText:null};
function Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return"value"in S._root?S._root.value:S._root[Eb()]}
var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
function T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}
B(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,
destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function Lb(a){a instanceof this?void 0:E("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&"CompositionEvent"in window,Wb=null;l.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
if(Xb=l.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}
var Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}
function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
function yc(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
function Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
function Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null)}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}
function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc()}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
a&&e.setAttribute("value",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E("188"):void 0}
function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:E("189")}}c.alternate!==d?E("190"):void 0}3!==c.tag?E("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}
function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}var qd=[];
function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}
function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}
var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
var Ld=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
function Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
function ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c});
var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
$d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}
function me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}
function oe(a,b,c){null!=ie.cursor?E("168"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E("108",jd(a)||"Unknown",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}
function re(a,b){var c=a.stateNode;c?void 0:E("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}
function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}
function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a)}function Ee(a){"function"===typeof Ae&&Ae(a)}
function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}
function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===
c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E("191",e):void 0;e.call(b)}}
function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
a(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E("110"):void 0,d=b.stateNode);d?void 0:E("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?E("148"):void 0;b._owner?void 0:E("149",c)}return c}
function $e(a,b){"textarea"!==a.type&&E("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E("150"):void 0;m=h.call(m);null==m?E("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
g,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E("152",h.displayName||
h.name||"Component")}return c(a,d)}}var bf=af(!0),cf=af(!1);
function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
b.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E("156")}},beginFailedWork:function(a,b,
c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E("157")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
function ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E("235"):E("236");
return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&
(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E("167");default:E("156")}}}}
function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E("235"):E("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"]}E("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E("161")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
c,c);break;case 3:break;default:E("163")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};
function hf(a){function b(a){a===gf?E("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
d=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}
function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a}var e=a.shouldSetTextContent;
a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E("175")},prepareToHydrateHostTextInstance:function(){E("176")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
t);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
break;case 3:null===ca&&(ca=f.error);break;default:E("157")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E("243"):void 0;ja=!0;a.isReadyForCommit=
!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g["return"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m=""}h+=m;g=g["return"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&
Vc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?
Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a["return"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
null,Ub=!1,a;}function m(a,c){Fa?E("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E("246"):
void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
ka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E("187"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}
function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E("171")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
nextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},
a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
var sf=void 0,tf=void 0;
if(l.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"))};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},
tf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else Kf(a,b,va(b,c)?c:null)}
function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}
function Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}
function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Qf(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}
function Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E("91"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}
function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});
function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E("61")),null!=b.style&&"object"!==typeof b.style?E("62",c()):void 0)}
function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns("");
function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}
var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case "source":U("topError","error",a);f=c;break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);f=c;break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);f=c;break;case "details":U("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U("topInvalid","invalid",a);
lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=B({},c,{value:void 0});U("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
C)}}
function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
"");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f}
function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1))}}
function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case "source":U("topError","error",a);break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);break;case "details":U("topToggle","toggle",a);break;case "input":Mf(a,c);U("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
U("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U("topInvalid","invalid",a),lg(e,"onChange")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
(a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}
var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E("90");Cc(d);Of(d,e)}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:
{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
a.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=""},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,
b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
function Pg(a,b,c,d,e){Ng(c)?void 0:E("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E("200");return pf(a,b,null,c)}
function Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};
var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E("188"):E("213",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
E("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug["default"]?Ug["default"]:Ug;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(48);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = __webpack_require__(0);
var invariant = __webpack_require__(7);
var warning = __webpack_require__(12);
var ExecutionEnvironment = __webpack_require__(22);
var _assign = __webpack_require__(6);
var emptyFunction = __webpack_require__(5);
var EventListener = __webpack_require__(23);
var getActiveElement = __webpack_require__(24);
var shallowEqual = __webpack_require__(25);
var containsNode = __webpack_require__(26);
var focusNode = __webpack_require__(27);
var emptyObject = __webpack_require__(11);
var checkPropTypes = __webpack_require__(14);
var hyphenateStyleName = __webpack_require__(50);
var camelizeStyleName = __webpack_require__(52);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work — work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary -— we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(51);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(53);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

__webpack_require__(83);

var _home = __webpack_require__(84);

var _home2 = _interopRequireDefault(_home);

var _navbar = __webpack_require__(85);

var _navbar2 = _interopRequireDefault(_navbar);

var _tail = __webpack_require__(86);

var _tail2 = _interopRequireDefault(_tail);

var _schedule = __webpack_require__(87);

var _schedule2 = _interopRequireDefault(_schedule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_React$Component) {
  _inherits(App, _React$Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.state = {
      isEnglish: true
    };
    _this.changeLanguage = _this.changeLanguage.bind(_this);
    return _this;
  }

  _createClass(App, [{
    key: 'getEnglishHome',
    value: function getEnglishHome() {
      return _react2.default.createElement(_home2.default, { isEnglish: true });
    }
  }, {
    key: 'getTurkishHome',
    value: function getTurkishHome() {
      return _react2.default.createElement(_home2.default, { isEnglish: false });
    }
  }, {
    key: 'getEnglishSchedule',
    value: function getEnglishSchedule() {
      return _react2.default.createElement(_schedule2.default, { isEnglish: true });
    }
  }, {
    key: 'getTurkishSchedule',
    value: function getTurkishSchedule() {
      return _react2.default.createElement(_schedule2.default, { isEnglish: false });
    }
  }, {
    key: 'changeLanguage',
    value: function changeLanguage(isEnglish) {
      this.setState({ isEnglish: isEnglish });
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        _reactRouterDom.BrowserRouter,
        null,
        _react2.default.createElement(
          'div',
          { id: 'application-container' },
          _react2.default.createElement(_navbar2.default, { isEnglish: this.state.isEnglish, changeLanguage: this.changeLanguage }),
          _react2.default.createElement(
            _reactRouterDom.Switch,
            null,
            _react2.default.createElement(_reactRouterDom.Route, { exact: true, path: '/', component: this.getEnglishHome }),
            _react2.default.createElement(_reactRouterDom.Route, { path: '/tr', component: this.getTurkishHome }),
            _react2.default.createElement(_reactRouterDom.Route, { path: '/en', component: this.getEnglishHome }),
            _react2.default.createElement(_reactRouterDom.Route, { path: '/en/schedule', component: this.getEnglishSchedule }),
            _react2.default.createElement(_reactRouterDom.Route, { path: '/tr/schedule', component: this.getTurkishSchedule })
          ),
          _react2.default.createElement(_tail2.default, { isEnglish: this.state.isEnglish, changeLanguage: this.changeLanguage })
        )
      );
    }
  }]);

  return App;
}(_react2.default.Component);

exports.default = App;
;

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(18);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

BrowserRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  forceRefresh: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.bool,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (BrowserRouter);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(5);
var invariant = __webpack_require__(7);
var warning = __webpack_require__(12);
var assign = __webpack_require__(6);

var ReactPropTypesSecret = __webpack_require__(15);
var checkPropTypes = __webpack_require__(14);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(5);
var invariant = __webpack_require__(7);
var ReactPropTypesSecret = __webpack_require__(15);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(16);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createHashHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(18);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

HashRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  hashType: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.oneOf(['hashbang', 'noslash', 'slash']),
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (HashRouter);

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(16);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__ = __webpack_require__(62);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__["a" /* default */]);

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(19);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

MemoryRouter.propTypes = {
  initialEntries: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.array,
  initialIndex: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (MemoryRouter);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(9);

var _LocationUtils = __webpack_require__(16);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Route__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Link__ = __webpack_require__(31);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__Route__["a" /* default */], {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */], _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: __WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */].propTypes.to,
  exact: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  activeClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  activeStyle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  isActive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  ariaCurrent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(['page', 'step', 'location', 'true'])
};

NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

/* harmony default export */ __webpack_exports__["a"] = (NavLink);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(66)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__ = __webpack_require__(68);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__["a" /* default */]);

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Prompt.propTypes = {
  when: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  message: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      block: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Prompt);

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__ = __webpack_require__(70);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__["a" /* default */]);

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(71);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["a" /* createLocation */])(prevProps.to);
    var nextTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["a" /* createLocation */])(this.props.to);

    if (Object(__WEBPACK_IMPORTED_MODULE_4_history__["b" /* locationsAreEqual */])(prevTo, nextTo)) {
      __WEBPACK_IMPORTED_MODULE_2_warning___default()(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;


    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Redirect.propTypes = {
  push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  from: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Redirect);

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__ = __webpack_require__(72);
/* unused harmony reexport createBrowserHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createHashHistory__ = __webpack_require__(73);
/* unused harmony reexport createHashHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__ = __webpack_require__(74);
/* unused harmony reexport createMemoryHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationUtils__ = __webpack_require__(13);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PathUtils__ = __webpack_require__(10);
/* unused harmony reexport parsePath */
/* unused harmony reexport createPath */










/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(34);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["g" /* supportsHistory */])();
  var needsHashChangeListener = !Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["h" /* supportsPopStateOnHashChange */])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["d" /* isExtraneousPopstateEvent */])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createBrowserHistory);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(34);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  },
  slash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["f" /* supportsGoWithoutReloadUsingHash */])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["b" /* locationsAreEqual */])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location));
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createHashHistory);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createTransitionManager__ = __webpack_require__(21);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_3__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, createKey()) : Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = __WEBPACK_IMPORTED_MODULE_1__PathUtils__["b" /* createPath */];

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createMemoryHistory);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__ = __webpack_require__(76);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__["a" /* default */]);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history_PathUtils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history_PathUtils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Router__ = __webpack_require__(19);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;


  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createLocation = function createLocation(location) {
  return typeof location === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["parsePath"])(location) : normalizeLocation(location);
};

var createURL = function createURL(location) {
  return typeof location === 'string' ? location : Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["createPath"])(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler('go'),
      goBack: staticHandler('goBack'),
      goForward: staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__Router__["a" /* default */], _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

StaticRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  context: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object])
};
StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (StaticRouter);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__ = __webpack_require__(78);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__["a" /* default */]);

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(20);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.forEach(children, function (element) {
      if (!__WEBPACK_IMPORTED_MODULE_0_react___default.a.isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Switch.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    route: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};


/* harmony default export */ __webpack_exports__["a"] = (Switch);

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__ = __webpack_require__(20);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__["a" /* default */]);

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__ = __webpack_require__(81);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__["a" /* default */]);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Route__ = __webpack_require__(33);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Route__["a" /* default */], { render: function render(routeComponentProps) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
  };

  return __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default()(C, Component);
};

/* harmony default export */ __webpack_exports__["a"] = (withRouter);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _culture = __webpack_require__(35);

var _culture2 = _interopRequireDefault(_culture);

var _landscape = __webpack_require__(36);

var _landscape2 = _interopRequireDefault(_landscape);

var _lodgeParadise = __webpack_require__(37);

var _lodgeParadise2 = _interopRequireDefault(_lodgeParadise);

var _safari = __webpack_require__(38);

var _safari2 = _interopRequireDefault(_safari);

var _reactRouterDom = __webpack_require__(8);

var _africaMap = __webpack_require__(39);

var _africaMap2 = _interopRequireDefault(_africaMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Home = function (_React$Component) {
  _inherits(Home, _React$Component);

  function Home() {
    _classCallCheck(this, Home);

    return _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).apply(this, arguments));
  }

  _createClass(Home, [{
    key: 'getLanding',
    value: function getLanding() {
      return _react2.default.createElement(
        'div',
        { className: 'landing-image-container' },
        _react2.default.createElement('div', { className: 'landing-image', id: 'landing-image-mobile' }),
        _react2.default.createElement(
          'div',
          { className: 'landing-caption' },
          this.props.isEnglish ? "Namibia" : "Namibya"
        ),
        _react2.default.createElement('div', { className: 'background-layer' }),
        _react2.default.createElement('i', { className: 'fa fa-caret-down', 'aria-hidden': 'true' })
      );
    }
  }, {
    key: 'getNamibiaDesc',
    value: function getNamibiaDesc() {
      var isEnglish = this.props.isEnglish;
      var namibiaDesc = {
        true: {
          0: "We travel looking for ourselves.",
          1: "We long for where we came from.",
          2: "Namibia is not just a place but it's a sensation",
          3: "The touch of wilderness rekindles",
          4: "our sense of belonging to nature.",
          5: "The Namib desert,",
          6: "the rich ecosystem with unusual plants,",
          7: "monoliths, caves, sinkholes, waterfalls,",
          8: "lakes morph into a unique sense of Namibian identity.",
          9: "Think about it. Things will not be same as before."
        },
        false: {
          0: "Kendimize bakmak için seyahat ediyoruz.",
          1: "Nereden geldiğimizi uzun süre bekliyoruz.",
          2: "Namibya sadece bir yer değil, aynı zamanda bir sansasyon",
          3: "Vahşi doğanın dokunuşları yeniden canlanır",
          4: "doğaya aid olma duygumuz.",
          5: "Namib çölünün enginliği,",
          6: "olağandışı bitkilerle zengin ekosistem,",
          7: "monolitler, mağaralar, düdensler, şelaleler,",
          8: "göller, Namibya kimliğinin eşsiz bir anlamda morph.",
          9: "Bunu düşün. Her şey eskisi gibi olmayacak."
        }
      };

      return _react2.default.createElement(
        'div',
        { className: 'namibia-description-container' },
        _react2.default.createElement(
          'div',
          { className: 'namibia-description' },
          namibiaDesc[isEnglish][0],
          _react2.default.createElement('br', null),
          namibiaDesc[isEnglish][1],
          _react2.default.createElement('br', null),
          _react2.default.createElement(
            'b',
            null,
            namibiaDesc[isEnglish][2]
          ),
          _react2.default.createElement('br', null),
          namibiaDesc[isEnglish][3],
          _react2.default.createElement('br', null),
          namibiaDesc[isEnglish][4],
          _react2.default.createElement('br', null),
          _react2.default.createElement(
            'b',
            null,
            namibiaDesc[isEnglish][9]
          ),
          _react2.default.createElement('br', null)
        ),
        _react2.default.createElement(
          'div',
          { className: 'map-container' },
          (0, _africaMap2.default)()
        )
      );
    }
  }, {
    key: 'getQuote',
    value: function getQuote() {
      var isEnglish = this.props.isEnglish;
      var quoteHelper = {
        true: {
          0: "I never knew of a morning in Africa",
          1: "when I woke up that I was not happy.",
          2: "True at First Light",
          3: "by Ernest Hemingway"
        },
        false: {
          0: "Bir sabah bilmedim ki",
          1: "Afrika'da huzurla uyanmadığım.",
          2: "Günün İlk Işığında Gerçek",
          3: "Ernest Hemingway"
        }
      };

      return _react2.default.createElement(
        'div',
        { className: 'quote-container' },
        _react2.default.createElement(
          'div',
          { className: 'quote-cover' },
          quoteHelper[isEnglish][0],
          ' ',
          _react2.default.createElement('br', null),
          ' ',
          quoteHelper[isEnglish][1]
        ),
        _react2.default.createElement('br', null),
        _react2.default.createElement(
          'div',
          { className: 'quote-author' },
          _react2.default.createElement(
            'i',
            null,
            quoteHelper[isEnglish][2]
          ),
          ' ',
          quoteHelper[isEnglish][3]
        )
      );
    }
  }, {
    key: 'getOnlyInNamibia',
    value: function getOnlyInNamibia() {
      var isEnglish = this.props.isEnglish;
      var onlyInNamibiaQuote = {
        true: {
          0: "Trip Inspirations",
          1: "Our Schedule"
        },
        false: {
          0: "Gezi İlhamları",
          1: "Programımız"
        }
      };

      var linkPrefix = isEnglish ? "en" : "tr";

      return _react2.default.createElement(
        'div',
        { className: 'namibia-activities-header' },
        onlyInNamibiaQuote[isEnglish][0],
        _react2.default.createElement(
          'div',
          { className: 'go-to-recommendation' },
          _react2.default.createElement(
            _reactRouterDom.Link,
            { className: 'go-to-recommendation-text', to: "/" + linkPrefix + "/schedule" },
            onlyInNamibiaQuote[isEnglish][1]
          )
        )
      );
    }
  }, {
    key: 'getGrid',
    value: function getGrid() {
      var isEnglish = this.props.isEnglish;
      var activitiesHeader = {
        true: {
          0: "Cultural Excursions",
          1: "Wilderness",
          2: "Safari",
          3: "Lodge Paradise"
        },
        false: {
          0: "Kültür Gezintileri",
          1: "Doğa çöl",
          2: "Safari",
          3: "Lodge Paradise"
        }
      };

      return _react2.default.createElement(
        'div',
        { className: 'six-grid' },
        _react2.default.createElement(
          'figure',
          null,
          _react2.default.createElement('img', { src: _culture2.default, alt: 'The Pulpit Rock' }),
          _react2.default.createElement(
            'div',
            { className: 'picCaption' },
            'Cultural Excursions'
          )
        ),
        _react2.default.createElement(
          'figure',
          null,
          _react2.default.createElement('img', { src: _landscape2.default, alt: 'The Pulpit Rock' }),
          _react2.default.createElement(
            'div',
            { className: 'picCaption' },
            'Wilderness'
          )
        ),
        _react2.default.createElement(
          'figure',
          null,
          _react2.default.createElement('img', { src: _safari2.default, alt: 'The Pulpit Rock' }),
          _react2.default.createElement(
            'div',
            { className: 'picCaption' },
            'Safari'
          )
        ),
        _react2.default.createElement(
          'figure',
          null,
          _react2.default.createElement('img', { src: _lodgeParadise2.default, alt: 'The Pulpit Rock' }),
          _react2.default.createElement(
            'div',
            { className: 'picCaption' },
            'Lodge Paradise'
          )
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'home-container' },
        this.getLanding(),
        this.getQuote(),
        this.getNamibiaDesc(),
        this.getOnlyInNamibia(),
        _react2.default.createElement(
          'div',
          { className: 'gridContainer' },
          this.getGrid(),
          _react2.default.createElement('div', { className: 'gridCover' })
        )
      );
    }
  }]);

  return Home;
}(_react2.default.Component);

exports.default = Home;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = NavBar;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

var _english_flag = __webpack_require__(40);

var _english_flag2 = _interopRequireDefault(_english_flag);

var _turkish_flag = __webpack_require__(41);

var _turkish_flag2 = _interopRequireDefault(_turkish_flag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function NavBar(_ref) {
  var isEnglish = _ref.isEnglish,
      changeLanguage = _ref.changeLanguage;


  var linkPrefix = isEnglish ? "en" : "tr";

  var getLogo = function getLogo() {
    return _react2.default.createElement(
      'div',
      { className: 'navbar-logo' },
      _react2.default.createElement(
        'span',
        null,
        _react2.default.createElement(
          'span',
          { className: 'navbar-logo-bold' },
          'EURASIA'
        ),
        ' TOURISM '
      ),
      _react2.default.createElement(
        'div',
        { className: 'navbar-date' },
        'since 1991'
      )
    );
  };

  var getNavbarTop = function getNavbarTop() {
    var aboutUsHelper = Object.assign({}, { true: { 0: "About Us", 1: "Contact Us" } }, { false: { 0: "Hakkımızda", 1: "Iletişim" } });

    return _react2.default.createElement(
      'span',
      { className: 'navbar-about-us' },
      _react2.default.createElement(
        'ul',
        null,
        _react2.default.createElement(
          'div',
          { className: 'mobile-top-left' },
          _react2.default.createElement(
            'li',
            { className: 'navbar-us-container' },
            _react2.default.createElement(
              _reactRouterDom.Link,
              { to: linkPrefix + '/about-us', className: 'navbar-us' },
              aboutUsHelper[isEnglish][0]
            )
          ),
          _react2.default.createElement(
            'li',
            { className: 'navbar-us-container' },
            _react2.default.createElement(
              _reactRouterDom.Link,
              { to: linkPrefix + '/contact-us', className: 'navbar-us' },
              aboutUsHelper[isEnglish][1]
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'mobile-top-right' },
          _react2.default.createElement(
            'li',
            { className: 'navbar-flag-container' },
            _react2.default.createElement(
              _reactRouterDom.Link,
              { to: '/tr', onClick: function onClick() {
                  return changeLanguage(false);
                } },
              _react2.default.createElement('img', { className: 'navbar-flag', src: _turkish_flag2.default })
            )
          ),
          _react2.default.createElement(
            'li',
            { className: 'navbar-flag-container' },
            _react2.default.createElement(
              _reactRouterDom.Link,
              { to: '/en', onClick: function onClick() {
                  return changeLanguage(true);
                } },
              _react2.default.createElement('img', { className: 'navbar-flag', src: _english_flag2.default })
            )
          )
        )
      )
    );
  };

  var getMenuItems = function getMenuItems() {
    var menuItemsHelper = Object.assign({}, { true: { 0: "Places to Go", 1: "Things to Do", 2: "Travel Blog" } }, { false: { 0: "Gideceklerimiz", 1: "Yapacaklarımız", 2: "Yolculuklarımız" } });

    return _react2.default.createElement(
      'span',
      { className: 'navbar-togo-items' },
      _react2.default.createElement(
        'ul',
        null,
        _react2.default.createElement(
          'li',
          null,
          _react2.default.createElement(
            _reactRouterDom.Link,
            { to: linkPrefix + '/places-to-go' },
            menuItemsHelper[isEnglish][0]
          )
        ),
        _react2.default.createElement(
          'li',
          null,
          _react2.default.createElement(
            _reactRouterDom.Link,
            { to: linkPrefix + '/things-to-do' },
            menuItemsHelper[isEnglish][1]
          )
        ),
        _react2.default.createElement(
          'li',
          null,
          _react2.default.createElement(
            _reactRouterDom.Link,
            { to: linkPrefix + '/travel-blog' },
            menuItemsHelper[isEnglish][2]
          )
        )
      )
    );
  };

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'div',
      { className: 'navbar-container' },
      _react2.default.createElement(
        'div',
        { className: 'navbar-left' },
        getLogo()
      ),
      _react2.default.createElement(
        'div',
        { className: 'navbar-right' },
        _react2.default.createElement(
          'div',
          { className: 'navbar-top' },
          getNavbarTop()
        ),
        getMenuItems()
      )
    ),
    _react2.default.createElement(
      'div',
      { className: 'navbar-container', id: 'display-changes-for-mobile' },
      _react2.default.createElement(
        'div',
        { className: 'mobile-nav', id: 'mobile-nav-web-disappear' },
        _react2.default.createElement(
          'div',
          { className: 'navbar-left' },
          getLogo()
        ),
        _react2.default.createElement(
          'div',
          { className: 'navbar-right', id: 'navbar-right-mobile-disappear' },
          getNavbarTop(),
          getMenuItems()
        )
      )
    )
  );
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Tail;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

var _english_flag = __webpack_require__(40);

var _english_flag2 = _interopRequireDefault(_english_flag);

var _turkish_flag = __webpack_require__(41);

var _turkish_flag2 = _interopRequireDefault(_turkish_flag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Tail(_ref) {
  var isEnglish = _ref.isEnglish,
      changeLanguage = _ref.changeLanguage;


  var linkPrefix = isEnglish ? "en" : "tr";

  var getLogo = function getLogo() {
    return _react2.default.createElement(
      'div',
      { className: 'navbar-logo' },
      _react2.default.createElement(
        'span',
        null,
        _react2.default.createElement(
          'span',
          { className: 'navbar-logo-bold' },
          'EURASIA'
        ),
        ' TOURISM '
      ),
      _react2.default.createElement(
        'div',
        { className: 'navbar-date' },
        'since 1991'
      )
    );
  };

  var getTailItems = function getTailItems() {
    var tailItemsHelper = Object.assign({}, { true: { 0: "Destinations", 1: "Experts", 2: "News Letter", 3: "Contact Us" } }, { false: { 0: "Gidilecek", 1: "Uzmanlar", 2: "Bültene", 3: "Iletişim" } });

    return _react2.default.createElement(
      'span',
      { className: 'navbar-menu-items' },
      _react2.default.createElement(
        'ul',
        { className: 'navbar-menu-container' },
        _react2.default.createElement(
          'li',
          { className: 'tail-middle-menu' },
          tailItemsHelper[isEnglish][0]
        ),
        _react2.default.createElement(
          'li',
          { className: 'tail-middle-menu' },
          tailItemsHelper[isEnglish][1]
        ),
        _react2.default.createElement(
          'li',
          { className: 'tail-middle-menu' },
          tailItemsHelper[isEnglish][2]
        ),
        _react2.default.createElement(
          'li',
          { className: 'tail-middle-menu' },
          tailItemsHelper[isEnglish][3]
        )
      )
    );
  };

  var socialFavicons = function socialFavicons() {
    var faviconLinkHelper = Object.assign({}, { instagramLink: "https://www.instagram.com/eurasia_tourism/",
      facebook: "https://www.facebook.com/eurasia.tourism",
      whatsApp: "https://api.whatsapp.com/send?phone=905536099043",
      phoneNumber: "tel:+902123693640" });
    var faviconItemsHelper = Object.assign({}, { instagramFavicon: "fa fa-instagram",
      facebookFavicon: "fa fa-facebook-square",
      whatsAppFavicon: "fa fa-whatsapp",
      phoneNumberFavicon: "fa fa-phone-square" });

    return _react2.default.createElement(
      'div',
      { className: 'navbar-bottom-container' },
      _react2.default.createElement(
        'div',
        { className: 'favicon-container' },
        _react2.default.createElement(
          'a',
          { target: '_blank', href: '' + faviconLinkHelper["instagramLink"], className: 'favicon' },
          _react2.default.createElement('i', { className: faviconItemsHelper["instagramFavicon"], 'aria-hidden': 'true' })
        )
      ),
      _react2.default.createElement(
        'div',
        { className: 'favicon-container' },
        _react2.default.createElement(
          'a',
          { target: '_blank', href: '' + faviconLinkHelper["facebookFavicon"], className: 'favicon' },
          _react2.default.createElement('i', { className: faviconItemsHelper["facebookFavicon"], 'aria-hidden': 'true' })
        )
      ),
      _react2.default.createElement(
        'div',
        { className: 'favicon-container' },
        _react2.default.createElement(
          'a',
          { target: '_blank', href: '' + faviconLinkHelper["whatsApp"], className: 'favicon' },
          _react2.default.createElement('i', { className: faviconItemsHelper["whatsAppFavicon"], 'aria-hidden': 'true' })
        )
      ),
      _react2.default.createElement(
        'div',
        { className: 'favicon-container' },
        _react2.default.createElement(
          'a',
          { target: '_blank', href: '' + faviconLinkHelper["phoneNumber"], className: 'favicon' },
          _react2.default.createElement('i', { className: faviconItemsHelper["phoneNumberFavicon"], 'aria-hidden': 'true' })
        )
      )
    );
  };

  return _react2.default.createElement(
    'div',
    { className: 'tail-container' },
    _react2.default.createElement(
      'div',
      { className: 'tail-top' },
      getLogo()
    ),
    _react2.default.createElement(
      'div',
      { className: 'tail-middle' },
      getTailItems()
    ),
    socialFavicons()
  );
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _culture = __webpack_require__(35);

var _culture2 = _interopRequireDefault(_culture);

var _landscape = __webpack_require__(36);

var _landscape2 = _interopRequireDefault(_landscape);

var _lodgeParadise = __webpack_require__(37);

var _lodgeParadise2 = _interopRequireDefault(_lodgeParadise);

var _safari = __webpack_require__(38);

var _safari2 = _interopRequireDefault(_safari);

var _reactRouterDom = __webpack_require__(8);

var _africaMap = __webpack_require__(39);

var _africaMap2 = _interopRequireDefault(_africaMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Schedule = function (_React$Component) {
  _inherits(Schedule, _React$Component);

  function Schedule() {
    _classCallCheck(this, Schedule);

    return _possibleConstructorReturn(this, (Schedule.__proto__ || Object.getPrototypeOf(Schedule)).apply(this, arguments));
  }

  _createClass(Schedule, [{
    key: 'getQuote',
    value: function getQuote() {
      var isEnglish = this.props.isEnglish;
      var quoteHelper = {
        true: {
          0: "I never knew of a morning in Africa",
          1: "when I woke up that I was not happy.",
          2: "True at First Light",
          3: "by Ernest Hemingway"
        },
        false: {
          0: "Bir sabah bilmedim ki",
          1: "Afrika'da huzurla uyanmadığım.",
          2: "Günün İlk Işığında Gerçek",
          3: "Ernest Hemingway"
        }
      };

      return _react2.default.createElement(
        'div',
        { className: 'quote-container' },
        _react2.default.createElement(
          'div',
          { className: 'quote-cover' },
          quoteHelper[isEnglish][0],
          ' ',
          _react2.default.createElement('br', null),
          ' ',
          quoteHelper[isEnglish][1]
        ),
        _react2.default.createElement('br', null),
        _react2.default.createElement(
          'div',
          { className: 'quote-author' },
          _react2.default.createElement(
            'i',
            null,
            quoteHelper[isEnglish][2]
          ),
          ' ',
          quoteHelper[isEnglish][3]
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'home-container' },
        '"Hello World"',
        this.getQuote()
      );
    }
  }]);

  return Schedule;
}(_react2.default.Component);

exports.default = Schedule;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDg2MmMwYmI3YWM5NjQyOWQ4MTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9zaXhHcmlkL2N1bHR1cmUuanBnIiwid2VicGFjazovLy8uL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvbGFuZHNjYXBlLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9zaXhHcmlkL2xvZGdlUGFyYWRpc2UuanBnIiwid2VicGFjazovLy8uL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvc2FmYXJpLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL3ZlY3RvcnMvYWZyaWNhTWFwLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9mbGFncy9lbmdsaXNoX2ZsYWcucG5nIiwid2VicGFjazovLy8uL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL2ZsYWdzL3R1cmtpc2hfZmxhZy5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vamF2YXNjcmlwdC9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL2phdmFzY3JpcHQvYXBwLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vc3R5bGVzL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9qYXZhc2NyaXB0L2NvbXBvbmVudHMvaG9tZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vamF2YXNjcmlwdC9jb21wb25lbnRzL25hdmJhci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vamF2YXNjcmlwdC9jb21wb25lbnRzL3RhaWwuanN4Iiwid2VicGFjazovLy8uL3NyYy9tYWluL2phdmFzY3JpcHQvY29tcG9uZW50cy9zY2hlZHVsZS5qc3giXSwibmFtZXMiOlsiYWZyaWNhTWFwIiwicmVuZGVyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIkFwcCIsInByb3BzIiwic3RhdGUiLCJpc0VuZ2xpc2giLCJjaGFuZ2VMYW5ndWFnZSIsImJpbmQiLCJzZXRTdGF0ZSIsImdldEVuZ2xpc2hIb21lIiwiZ2V0VHVya2lzaEhvbWUiLCJnZXRFbmdsaXNoU2NoZWR1bGUiLCJnZXRUdXJraXNoU2NoZWR1bGUiLCJDb21wb25lbnQiLCJIb21lIiwibmFtaWJpYURlc2MiLCJ0cnVlIiwiZmFsc2UiLCJxdW90ZUhlbHBlciIsIm9ubHlJbk5hbWliaWFRdW90ZSIsImxpbmtQcmVmaXgiLCJhY3Rpdml0aWVzSGVhZGVyIiwiZ2V0TGFuZGluZyIsImdldFF1b3RlIiwiZ2V0TmFtaWJpYURlc2MiLCJnZXRPbmx5SW5OYW1pYmlhIiwiZ2V0R3JpZCIsIk5hdkJhciIsImdldExvZ28iLCJnZXROYXZiYXJUb3AiLCJhYm91dFVzSGVscGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0TWVudUl0ZW1zIiwibWVudUl0ZW1zSGVscGVyIiwiVGFpbCIsImdldFRhaWxJdGVtcyIsInRhaWxJdGVtc0hlbHBlciIsInNvY2lhbEZhdmljb25zIiwiZmF2aWNvbkxpbmtIZWxwZXIiLCJpbnN0YWdyYW1MaW5rIiwiZmFjZWJvb2siLCJ3aGF0c0FwcCIsInBob25lTnVtYmVyIiwiZmF2aWNvbkl0ZW1zSGVscGVyIiwiaW5zdGFncmFtRmF2aWNvbiIsImZhY2Vib29rRmF2aWNvbiIsIndoYXRzQXBwRmF2aWNvbiIsInBob25lTnVtYmVyRmF2aWNvbiIsIlNjaGVkdWxlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OytDQzdEQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM0RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDbERBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7OytDQzUwQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Qjs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qjs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCOztBQUV0QjtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUIsRUFBRTtBQUNyQyx5QkFBeUIsd0JBQXdCLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0sseUNBQXlDO0FBQzNNO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUNBQXlDO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhNQUE4TTtBQUM5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SyxZQUFZO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUxBQXVMLCtCQUErQjtBQUN0Tjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtKQUErSixpQkFBaUI7QUFDaEwsT0FBTztBQUNQLCtKQUErSixpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQ3pTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMElBQTBJLG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzNNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQzdoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7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dkI7QUFBSixXQURGO0FBQUE7QUFDc0NhLHNCQUFZYixTQUFaLEVBQXVCLENBQXZCO0FBRHRDO0FBTEcsT0FBUDtBQVNEOzs7NkJBRVE7QUFDUCxhQUFPO0FBQUE7QUFBQSxVQUFLLFdBQVUsZ0JBQWY7QUFBQTtBQUVKLGFBQUtrQixRQUFMO0FBRkksT0FBUDtBQUlEOzs7O0VBbkNtQyxnQkFBTVYsUzs7a0JBQXZCb0MsUSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0Mik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNDg2MmMwYmI3YWM5NjQyOWQ4MTYiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBfQnJvd3NlclJvdXRlciBmcm9tICcuL0Jyb3dzZXJSb3V0ZXInO1xuZXhwb3J0IHsgX0Jyb3dzZXJSb3V0ZXIgYXMgQnJvd3NlclJvdXRlciB9O1xuaW1wb3J0IF9IYXNoUm91dGVyIGZyb20gJy4vSGFzaFJvdXRlcic7XG5leHBvcnQgeyBfSGFzaFJvdXRlciBhcyBIYXNoUm91dGVyIH07XG5pbXBvcnQgX0xpbmsgZnJvbSAnLi9MaW5rJztcbmV4cG9ydCB7IF9MaW5rIGFzIExpbmsgfTtcbmltcG9ydCBfTWVtb3J5Um91dGVyIGZyb20gJy4vTWVtb3J5Um91dGVyJztcbmV4cG9ydCB7IF9NZW1vcnlSb3V0ZXIgYXMgTWVtb3J5Um91dGVyIH07XG5pbXBvcnQgX05hdkxpbmsgZnJvbSAnLi9OYXZMaW5rJztcbmV4cG9ydCB7IF9OYXZMaW5rIGFzIE5hdkxpbmsgfTtcbmltcG9ydCBfUHJvbXB0IGZyb20gJy4vUHJvbXB0JztcbmV4cG9ydCB7IF9Qcm9tcHQgYXMgUHJvbXB0IH07XG5pbXBvcnQgX1JlZGlyZWN0IGZyb20gJy4vUmVkaXJlY3QnO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gJy4vUm91dGUnO1xuZXhwb3J0IHsgX1JvdXRlIGFzIFJvdXRlIH07XG5pbXBvcnQgX1JvdXRlciBmcm9tICcuL1JvdXRlcic7XG5leHBvcnQgeyBfUm91dGVyIGFzIFJvdXRlciB9O1xuaW1wb3J0IF9TdGF0aWNSb3V0ZXIgZnJvbSAnLi9TdGF0aWNSb3V0ZXInO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gJy4vU3dpdGNoJztcbmV4cG9ydCB7IF9Td2l0Y2ggYXMgU3dpdGNoIH07XG5pbXBvcnQgX21hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5leHBvcnQgeyBfbWF0Y2hQYXRoIGFzIG1hdGNoUGF0aCB9O1xuaW1wb3J0IF93aXRoUm91dGVyIGZyb20gJy4vd2l0aFJvdXRlcic7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG52YXIgaGFzQmFzZW5hbWUgPSBleHBvcnRzLmhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZXhwb3J0cy5zdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG52YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCB2YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBoYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgcGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuZXhwb3J0IHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG5leHBvcnQgdmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZSA9IHJlcXVpcmUoJ3Jlc29sdmUtcGF0aG5hbWUnKTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVBhdGhuYW1lKTtcblxudmFyIF92YWx1ZUVxdWFsID0gcmVxdWlyZSgndmFsdWUtZXF1YWwnKTtcblxudmFyIF92YWx1ZUVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAoMCwgX3Jlc29sdmVQYXRobmFtZTIuZGVmYXVsdCkobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgKDAsIF92YWx1ZUVxdWFsMi5kZWZhdWx0KShhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHB1dHRpbmcgaGlzdG9yeSBvbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgaGlzdG9yeTogdGhpcy5wcm9wcy5oaXN0b3J5LFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6ICcvJyxcbiAgICAgIHVybDogJy8nLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSAnLydcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG5cblxuICAgIGludmFyaWFudChjaGlsZHJlbiA9PSBudWxsIHx8IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMSwgJ0EgPFJvdXRlcj4gbWF5IGhhdmUgb25seSBvbmUgY2hpbGQgZWxlbWVudCcpO1xuXG4gICAgLy8gRG8gdGhpcyBoZXJlIHNvIHdlIGNhbiBzZXRTdGF0ZSB3aGVuIGEgPFJlZGlyZWN0PiBjaGFuZ2VzIHRoZVxuICAgIC8vIGxvY2F0aW9uIGluIGNvbXBvbmVudFdpbGxNb3VudC4gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiBkb2luZ1xuICAgIC8vIHNlcnZlciByZW5kZXJpbmcgdXNpbmcgYSA8U3RhdGljUm91dGVyPi5cbiAgICB0aGlzLnVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgbWF0Y2g6IF90aGlzMi5jb21wdXRlTWF0Y2goaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyh0aGlzLnByb3BzLmhpc3RvcnkgPT09IG5leHRQcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PicpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVubGlzdGVuKCk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBjaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZXIucHJvcFR5cGVzID0ge1xuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblJvdXRlci5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSAncGF0aC10by1yZWdleHAnO1xuXG52YXIgcGF0dGVybkNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG52YXIgY29tcGlsZVBhdGggPSBmdW5jdGlvbiBjb21waWxlUGF0aChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9ICcnICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgY2FjaGUgPSBwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldIHx8IChwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldID0ge30pO1xuXG4gIGlmIChjYWNoZVtwYXR0ZXJuXSkgcmV0dXJuIGNhY2hlW3BhdHRlcm5dO1xuXG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChwYXR0ZXJuLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IHsgcmU6IHJlLCBrZXlzOiBrZXlzIH07XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZFBhdHRlcm47XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoIHBhdHRlcm4uXG4gKi9cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IHBhdGg6IG9wdGlvbnMgfTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBwYXRoID0gX29wdGlvbnMkcGF0aCA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29wdGlvbnMkcGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG5cbiAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoKHBhdGgsIHsgZW5kOiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09ICcvJyAmJiB1cmwgPT09ICcnID8gJy8nIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICB2YXIgdG9QYXJ0cyA9IHRvICYmIHRvLnNwbGl0KCcvJykgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy8nKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcbiAgfWlmIChtdXN0RW5kQWJzICYmIGZyb21QYXJ0c1swXSAhPT0gJycgJiYgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSkpIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVQYXRobmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciBnZXRDb25maXJtYXRpb24gPSBleHBvcnRzLmdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG52YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGV4cG9ydHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuXG52YXIgaXNNb2RpZmllZEV2ZW50ID0gZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExpbmssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIGlnbm9yZSByaWdodCBjbGlja3NcbiAgICAgICFfdGhpcy5wcm9wcy50YXJnZXQgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgdmFyIGhpc3RvcnkgPSBfdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICByZXBsYWNlID0gX3RoaXMkcHJvcHMucmVwbGFjZSxcbiAgICAgICAgICAgICAgdG8gPSBfdGhpcyRwcm9wcy50bztcblxuXG4gICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHJlcGxhY2UgPSBfcHJvcHMucmVwbGFjZSxcbiAgICAgICAgdG8gPSBfcHJvcHMudG8sXG4gICAgICAgIGlubmVyUmVmID0gX3Byb3BzLmlubmVyUmVmLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsncmVwbGFjZScsICd0bycsICdpbm5lclJlZiddKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIGhyZWYgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuY3JlYXRlSHJlZih0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8geyBwYXRobmFtZTogdG8gfSA6IHRvKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIGhyZWY6IGhyZWYsIHJlZjogaW5uZXJSZWYgfSkpO1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5MaW5rLnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVwbGFjZTogZmFsc2Vcbn07XG5MaW5rLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIGNyZWF0ZUhyZWY6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGUgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JvdXRlJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3Igd2l0aFJvdXRlcigpIG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIHJvdXRlID0gcm91dGVyLnJvdXRlO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gKGxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uKS5wYXRobmFtZTtcblxuICAgIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKHBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIHN0cmljdDogc3RyaWN0LCBleGFjdDogZXhhY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLnJlbmRlciAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IHZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciBnZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQWtBQ1FBQUQvNFJDZ1JYaHBaZ0FBVFUwQUtnQUFBQWdBQkFFN0FBSUFBQUFQQUFBSVNvZHBBQVFBQUFBQkFBQUlXcHlkQUFFQUFBQWVBQUFRZXVvY0FBY0FBQWdNQUFBQVBnQUFBQUFjNmdBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR0YxZEdodmNtbDZaV1IxYzJWeUFBQUFBZW9jQUFjQUFBZ01BQUFJYkFBQUFBQWM2Z0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFZUUIxQUhRQWFBQnZBSElBYVFCNkFHVUFaQUIxQUhNQVpRQnlBQUFBLytFS1oyaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOEFQRDk0Y0dGamEyVjBJR0psWjJsdVBTZnZ1NzhuSUdsa1BTZFhOVTB3VFhCRFpXaHBTSHB5WlZONlRsUmplbXRqT1dRblB6NE5Dang0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlQanh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SW5WMWFXUTZabUZtTldKa1pEVXRZbUV6WkMweE1XUmhMV0ZrTXpFdFpETXpaRGMxTVRneVpqRmlJaUI0Yld4dWN6cGtZejBpYUhSMGNEb3ZMM0IxY213dWIzSm5MMlJqTDJWc1pXMWxiblJ6THpFdU1TOGlMejQ4Y21SbU9rUmxjMk55YVhCMGFXOXVJSEprWmpwaFltOTFkRDBpZFhWcFpEcG1ZV1kxWW1Sa05TMWlZVE5rTFRFeFpHRXRZV1F6TVMxa016TmtOelV4T0RKbU1XSWlJSGh0Ykc1ek9tUmpQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012Wld4bGJXVnVkSE12TVM0eEx5SStQR1JqT21OeVpXRjBiM0krUEhKa1pqcFRaWEVnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0OGNtUm1PbXhwUG1GMWRHaHZjbWw2WldSMWMyVnlQQzl5WkdZNmJHaytQQzl5WkdZNlUyVnhQZzBLQ1FrSlBDOWtZenBqY21WaGRHOXlQand2Y21SbU9rUmxjMk55YVhCMGFXOXVQand2Y21SbU9sSkVSajQ4TDNnNmVHMXdiV1YwWVQ0TkNpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEQ5NGNHRmphMlYwSUdWdVpEMG5keWMvUHYvYkFFTUFCd1VGQmdVRUJ3WUZCZ2dIQndnS0VRc0tDUWtLRlE4UURCRVlGUm9aR0JVWUZ4c2VKeUViSFNVZEZ4Z2lMaUlsS0NrckxDc2FJQzh6THlveUp5b3JLdi9iQUVNQkJ3Z0lDZ2tLRkFzTEZDb2NHQndxS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUt2L0FBQkVJQXY0RXF3TUJJZ0FDRVFFREVRSC94QUFmQUFBQkJRRUJBUUVCQVFBQUFBQUFBQUFBQVFJREJBVUdCd2dKQ2d2L3hBQzFFQUFDQVFNREFnUURCUVVFQkFBQUFYMEJBZ01BQkJFRkVpRXhRUVlUVVdFSEluRVVNb0dSb1FnalFySEJGVkxSOENRelluS0NDUW9XRnhnWkdpVW1KeWdwS2pRMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvT0VoWWFIaUltS2twT1VsWmFYbUptYW9xT2twYWFucUttcXNyTzB0YmEzdUxtNndzUEV4Y2JIeU1uSzB0UFUxZGJYMk5uYTRlTGo1T1htNStqcDZ2SHk4L1QxOXZmNCtmci94QUFmQVFBREFRRUJBUUVCQVFFQkFBQUFBQUFBQVFJREJBVUdCd2dKQ2d2L3hBQzFFUUFDQVFJRUJBTUVCd1VFQkFBQkFuY0FBUUlERVFRRklURUdFa0ZSQjJGeEV5SXlnUWdVUXBHaHNjRUpJek5TOEJWaWN0RUtGaVEwNFNYeEZ4Z1pHaVluS0NrcU5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcUNnNFNGaG9lSWlZcVNrNVNWbHBlWW1acWlvNlNscHFlb3FhcXlzN1MxdHJlNHVickN3OFRGeHNmSXljclMwOVRWMXRmWTJkcmk0K1RsNXVmbzZlcnk4L1QxOXZmNCtmci8yZ0FNQXdFQUFoRURFUUEvQU9nQXA0RlJoaFVpa1Y4K2V4WWNCVGdLQlRnS0FBQ2xGRkZBQ2luWXBCVGhRQVlwckNuMEVVRFJXZGFxeUptcnppcXppc1pIUkF6Wm9oZzFTeVk1TUd0aDBCQnFuTmI4azFpMWM2WXlJMTVIMXA2cFVDc1VmRFZZVnM5S3dhc2RCRythWXhxMHlacGhocVFJRmNpbks1SnB4Z05BaU5KaXNQQnpTNTRwTmhGS0VKcVNScE5QREhGSVZ4U0dsWWFKTjNGSm5qSnFNWnpTazhZcEZESGZtcXNzaElxWmh6VmRvbWM0QXBwanNWSlNhaGp0SkxtVEhSYTE0ZE5aaUMxYU1kcXNJemdWb3Bzbmx1VjdHelcxaTZVczhtTTFKTkpqcFdmY3k0VTFjVXhiRlM4a3ptc2VXWERWYXU3a0JTVFhPM3Q5aGp0TmR0T0YwYzAyaldSd3g2MVppYkZjM2JYNTNqTmJjRTRrWElxcHhhSVVrelFXVTdoaXRDMmtPS3lZdVRXamJuYVFhNVpHeU5OUnVVVWpRNU5FTFp4Vm5ia1ZoY3NxaVBGUFVZNjFONWRKNVpOVGNWZ2orOVZsZWUxUkttT2xUb3ZGSnNMQXlBcnlLcnRicVQwcXl4d0tqTkNrMEpwRlUyYWsxSUlRaTR4VXdCelN0SG1yOXBKazhxUmpYV21MTzJlYzVxUzNzL0lYZ25OYWUzQTZVM0hQU3RmYnlhNVdSN09ON21OZldqenR3YWswK3llSEhOYXV6UGFwRWpBN1ZYdDN5OHBQczliZ0YrVVpwajl4VDJ6bjJwQ3Z5MXpwbXRqRTFHMTM1YkgwckllZVNCU3ZXdW51RkJVZzF6bXBZWE9CWGZScVhqeXM1cHdzN281KytMVEU1NzFRUzJBZk9LMFptQk5RWjVyclVyS3lNTGE2a2lMOHVLVllGTGRLVktuU3NuS3hYS09WZG93S1EwNm1tcFdwZXdGc0NzeStsemtDcnM4bXhEenpXTk01a2ZnNXJXbkhxWlRkaU9KTnpacS9FbUJWZUtQRlhJK2xiU01vand0UFVVQ25Dc3lyQzRvMjB0S0JTTEk4VllnaDh3aW85dFhySmNOVVNsWkdrWTNKbzdRQUNteXdBVnJCRjh2UHRWT2Npc09hNTBPQ1NNNHgwbTJyUlVHb2l2TlVaa1cycHJhQnBaQWlqSkpvRWVUaXVzOFBhWXAydXk4bXBkM3NKdXhhMFBSaEdxa2c1NjExMXRINWE0b3RiVllsSEZXY2NWdEZXTUhLNUdSU0duNHBNVlJJeWtJcDJLS0FHRVVsUElwTnRJQnVLUWluNG94UU1qMjBtMnBTdEp0cGlJOXRSdU9LbklwakxTS1JRbFErbFVaVXJZa1RpcVVzVks0ekxJd2FsaWNpbnlRMUZqRldpRFJobHE3RzJWRlk4VDROWDRaYzQ1b1l5NzFwcEZLalpwK0tnQ0xGR0trSzAwaWdvWVJUQ0tscHVLUlJDNjVGVkpvczFvRmMxRThkQW1ZYzhPTTFBT0sxNTRjOXF6NVlTRHdLcEVFbHZManZXbkRKbkhOWXFaVTFldDVlZXRVQnJvY2luRVZYaGt5QlZrY2lwR054UlQ4VW1LUURNVVlwK0tUYlFBMmpGT3hTY1VBSmlreFRzaWtvQWFhaWMxS2FoYzBBUk1haWFwR05SOWFZREN1YUJGVXFyVXFwUUlyaUtuaE1WT0k2WFpRQlh4aWpPS21LVkV5NG9BRmFwUWFoNlU5VFFCTFJpa0RVN0lvQVRGTklwMlJTVUFOeFJUc1VFVUFOSXBNVS9GSVJRQXcwMDFJUlRDS0FJalNacHpVek5BQzBVZ05PR0tBRUlwdUtrcENLWWlJaW0xS1JUYUJtWUxrR3BrbkI3MXlxNm1QNzFXWXRUSDk2amxaYk9uV1lldFNDWWV0YzRtcEQrOVVvMUVZKzlSWWs2QVREMXBmTkhyV0NOUVgrOVR4cUMrdEZnc2JvbEhyVGhLUFdzSCswQi9lcHcxRmZXbFlkamVFdzlhUXlqMXJER29EKzlTTnFJSGVpd0d1OHc5YXJTVGpQV3NxVFVoNjFWazFKZDMzcWh4dWJSTm96RDFwcnlCbHJEL3RFZXRQWFVBZXBxT1JtMTBXTGdsWHlLSVp2VTFYa3VCSnhtbkNJbUhjdFpUaWF3a2FjVW9hcklJTll0dk9RMkd5S3ZwTUF2TllPTmplNWRDZzBvaEI3VldTY1o0Tlc0NUFSV2JRQy9ad2VsSjlueFV5dUtsQkJGVFlSbnZBU2VsUkdBNTZWcWtMM3FFc29iR0tWbUNLUXQvYWd3Q3JaWUNvdHdKcGNyS1JYK3pacVdPQlY2MUlYQXFKcE1BMDdESmd5cjBxR2FiZzFYa21xdTBtYzFwR0lnbWxKck52SnNLZWFtdUoxVlR6V0xkWERUSGJIMzZtdDRvem16TXZyaG1MS25KTlZZOU1rbTVldG0yMDdMYm41clFXRlZHQUs2dmFKYUk1dlp1UnljMm12Qjh5NXAxcmRORElGZjFycUpMVU91TVZsM0dtNGJjQlQ5b210U1hUY2RpL1pNSlZyVWlYQUZjOWFtU0IrT2xidHRMNWlnMXkxRnFhd1pvUk5pcnNSeUt6WTJ3YXZRdUJpdVptaFlLWnA0V2xSMU5QRzA5NmhqRVJNbXBkdUtjZ3BUVWdRU2NEaW9sSmJyVmgwelRCSGlnVEdZeFRqMDRwQ3ZOS09PdE1RMEE1NXBHR0tsQXBDbE1ReFZwL0lvWEFwY2cwYWlFSUhlbXVjTHhVbTNOUk9NS2FBS053M0JybWRXYnJqaXVqdXVBYTVqVThsalhaUjNNWjdHSy9KTk1BNXFabDVwb0hOZDF6bUhwVXlVeFZxVlJpczJVaENjVXgzd3VhSDRxamVYR3hNVmNZM1lwT3hWdjcwQWtacXBCS0diT2FvWFVwbGxQcFNST1VydWpTdEU0NVR1em9JOEhwVmhSeFdOYlh1Q0FUV3BGTUpGNE5aU2kwWEZrNE5QQnFJVkt0Wm1vOFU4Q21xS3NSUkZpTVZEZGkwaElvaTU2VnBXOEhsNEpGUHRyYkFCcXpJQW80cmxsSytoMHhpT1hsU1BhcWN5WUpxWlpLU2I1bHpVTGN0N0ZOalNZb1BKcVJGenhXcGt5NXBkbDlwdVJrY0ExNkxwVm1zY1E0eGl1WDBPSllnUFd1dmd1RlNNRE5YQ1BVeHFkalE2ZmxUU1JWUTNnOWFhYnNWb1oyTFpZVW00ZXRVVGRnMHczWW9DeGZMQ2pjUFdzNDNZcEJkaWdkalIzRDFwYXp4ZGoxcDYzWTlhQldMdEpWVDdXUFdtbTdIclRzQmRMQ2szQ3FCdWg2MG4yc1VoMkwyNm1scXBmYXhRYnRUU0hZdHR5S2dkQmlvdnRROWFqZTZIclJZQnNxQ3FjbUFhbGx1QVIxcWhOY0RKcWtGaVlPQWV0VHd6WTcxa05kS0tjbDJQV21LeDBjVndQV3JTekE5NjV5SzhIclZ0TDBZSE5TeXJHeVpoNjB3eWU5WnYyeGZXaysyQ2tWWTBqSjcwbThldFovMnhhVDdZS1E3R2o1ZzlhYTBneDFxZ2J3WXBodkI2MEQ1UzFMSU1HcVVwQnBqM1lOVjVMcGNkYWFKY1JIWUEwc2MyMDlhb1RYUTlhaVc3SHJWb2hvNlczdU9CeldoSEtEM3JsWUwwREhOYVVGOFBXa3dzYndmaWxMaXN0YjBiZXRMOXRIclVqc2FPOFVHUVZtbThGUm0rSHJRT3hvdExqdlVUVCs5WnozbzlhclNYNmp2VHNGalk4L0hlbkM0SHJXQWRSWDFwVjFBZXRPd2Nwdm1jSHZVRWtvUGVzbiswQjYwMXI4WTYwckJ5bWtaUGVsV1FldFpCdmg2MHFYdzlhQldOeFhIclVxdUt5RXZCanJVcTNveFNDeHFiNlF2NzFtbTlIclREZkQxcEQ1VFQ4d2V0SVdCck4rMmoxcFB0ZzlhWW1pOHpBVkdaY2Q2cE5lRDFxdkplQWQ2ZGhXTlR6d085TDlwOTZ3bXZ3TzlNL3RJZjNxcXdXT2grMFo3MDRUZTljOHVwQTk2bFhVaDYwV0hZM3hKNzA4T1BXc1JOUUI3MUtMNGV0S3dyR3NYSHJTYnhXWjl0R090Tk42UFdsWVZqVUxqMXFObkhyV2NiNGV0Tk42UFdpd0Y5bkhyVVpjZXRaN1hvOWFpYStIclRTRWF2bUQxcFJLUFdzWTN3OWFCZmoxcDJBMnZOSHJUVEtQV3NqN2VQV21uVUI2MFdBMlBOSHJSNW85YXhUcUE5YVQrMFIvZW9zQjVldXJuKzlWaVBXY2Z4VnltOXZXbkNSdld1MzJhT2Yyak93WFd4L2VxVmRjSDk2dUw4eGgzcHdtYjFwZXpRZTBPMUd1RCs5VHhyZy92VnhJbmYxb053L3JSN05EOW9kdi9BRzZQNzM2MG8xNGYzdjFyaC90RCt0SjlwY2Q2WHNrUDJoM1kxMWY3OU5mWFIvZkZjTjlyZjFwRGR2NjAvWklQYUhaU2E2UDcxVnpyT2Y0cTVRM0RudlNDZHZXajJLRDJyT3NYVnMveGZyVTZhcC90Vnh5M0REdlVxM2pqdlNkSkZLc3p1TFhVOTB3QmF1djA1aFBhZ0ExNUJiNmd5ektTZTllbmVHTHNPZ0JQVVY1K0twOHNiblhRcVhab1QyaEJMTHdhaFNVZzdYcmNkQTY4MW1YRm5saVZITmVjcGR6MEJxeUFBWU5Yb1pjS09hd25tTUVtMStLbFMrQkdOMVc0NlhDNXVDZm5pZzNXRGdHczJLNUJVSGRVdm1xVG1vR2FDVEdST3RBUE9UVmFLUVlxY01EMHFXQU5JYVlwSmFwTm1hZUk4Q3MyeTBNSU5RU05nR3A1VGdHcUx0bGpWUkdSdTNOVmJtYllwd2FmUEtFQnJIbm5hNG1FY2Y0MXVrUTJNbWxlNGZhbk5YclRUUWlCbkZXckhUbGpRTXc1K2xYV1hqQzFMcWRDVkcrck05MENjS0tpMjFlZUgxcUJreFZSbGNybEsrS2F5aHV0U01NVXpGYW96a2l1MXVOMlZGVHdnb09PS2R0elRnQUtKSzVHeE5HY3RWNkRyV2ZHY0htdE96WGNNMXp0RkZ1TWUxV2hHTnZTcWhjS2NBMVpXY1k1cUdndVNySGdacU51dlUxTDVnMjFYOHdGcWl3N2p4bmpCb083MXpUeGpHYVVZTkZnS3piejBxSjJrV3JoeFRYVmNjMVNFWjV1WkZwalh6MUpNaTVxb3lMV3NVbVEyT041S1NjVTVMdVh1YWdJV21rZ0RpcjVFVGN2cmR1ZU0wOHpTRmFwUk1CeVRWdEhVamcxTFNRN2xXZVdUQnl0WXQ2N0UvTWcvS3Q2ZmJ5TTFsWGNRSVBOYVFkak9SelYwUm5JR0RWZEg1cTFleDRZMVNWU0RYWWptWmNRaXBBYXJwbkZQeWNVbWgzQ1lnSVRYTzZqUGxpTTF0WFRmdThEMHJuTG9GcERYWGg0M01hc3RDb0JrNU5PMjA4TFM0RmVnY1pHTXFlS3RXOTBZMkhOUWtaRlJzTnRSS0thS1Vtam9yZTRFZzYxY1Q1dWxjeGJYUmpiQk5kRnA4d214WERValk2WVN1WDRvV2JuRmFWcmJkTTFOYVc2bEFjVmRWQXZTdlBuUFU3b3cwSXg4aTFCTEptcFoyeFZCNUtsSzViMEZlVGFhaiswOVJtb3BKTTVxbXo4MW9vazNaZERaYXJzSXdBVFdWREx6ejJxWTNvVWRjWXJUbHVSSnBJNnZUcm9Kakp4aXRYKzFBUDRxOC9HdENNY1BTSFgvd0RiL1d0MVRaenVTWjM1MVJmNzFNYlZSL2VyZ1RyNC92MDF0ZHovQUIwL1pzT1pIZUhWaC9lcU50WEdmdjF3VGE0ZjcxUm5Xei9lbzlteDg2Ty9PckQrL1NEVngvZnJ6ODYyZXpVMyszRC9BSHFmc21IT2owVWFzdjhBZnA2NnFQNzllZUpybisxVXFhNS90VXZac25uUjZDZFVYKzlURHFxLzNxNFE2NS90ZnJVWjEwZjNxUFpzT1pIZUhWaC9lcGgxWWYzNjRKdGMvd0J1bURXeVQ5NmoyYkh6bzlBR3JEKzlTLzJxUDcxY0VOWS8ycWNOWS8ydjFvOW1QblIzWTFSZjcxTWJVeC9lcmlmN1p3UHZmclRmN1gzZnhVY2djeU96YlVRZjRxcHozK2U5Y3dkVlA5Nm8yMUVudlRVR0hNamVrdnY5cW9ocU9EOTZzQjcwbnZVRFhoOWF2bEk1anJJOVZ4L0ZWbE5XSDk2dUkrM1k3MG8xSEhjMG5BcFRSM1g5c0QrOVMvMnQvdFZ3NDFQL0FHcWQvYWYrMSt0VDdNcjJpTzNHcmY3Vkg5cWorOVhFRFZNZC93QmFYKzFUNjBuVEg3UTdVNnNNZmVxSnRZSDk2dU1iVlNmNHFqYlV5ZjRxUFpqOW9kbWRYeWZ2VTF0VXlQdlZ4djhBYVh2VGhxT2Y0cWZzeGUwT21sdjg5NmcvdERIZXNEN2RrZGFqYTd6ME5Xb0dia2RQSHFlRys5VjZEVlFQNHE0Z1hoSGVwVTFFci9GUTRBcEhmTHE2N2Z2VXY5cmorOVhDZjJ2aitLbVByT09qVkhzaXZhSTcwNndQNzFSTnJBL3ZWd0xhMDM5NzlhVCsyQ2Y0cUZTWWUwUjNFbXNqKzlWR2ZXZVRocTVCOVZiMXFFMzVidWEwVkluMmgxcDFnK3RQVFdEL0FIcTQ4WGg5YWtGMmZXcTltTDJoMkkxZlA4VkkycmNmZXJrUmROMk5MOXFmMXFmWmg3UTZyKzFzL3dBVlRSNnIvdFZ4NHVXOWFldDJ3NzB2Wmh6bmJwcXdBKzlVbjlyais5WERpL2NmeFVqYWt3NzFMcEQ5b2R1ZFpIOTZtSFdmOXF1RmJWWEhjMDMrMVc5YVhzU3ZhSTd6KzJSL2VGT1hXQi9mcmdQN1VmOEF2VTVkVWYxTlVxUkxxSGVuVjEvdlZXazFZWSs5WEcvMnEzOTZvMzFOajNwK3pGN1E2aWJWY2RHcXEyc0grOVhNdmVsdTlSbTZKNzFhcGt1b2RVdXNuUDNxbmoxYy93QjZ1T0YwUWV0U3Jla2Q2cmtRdmFIYnhhdi9BTFZXbDFmQSs5WEJMcVRMM3AzOXJQNm1vZE1QYUhlLzJ4aitLbS8yeG4rS3VFL3RWejNOSDlxUDZtbDdJZnREdS83WUg5Nm1uV0IvZXJodjdUZis5U2YyazU3MC9aQzlvZHErcmorOVVUYXNQNzFjVytwUDYxQytwdjYwMVNFNmgyN2F1UDd3cGgxa2YzaFhETnFVbnFhak9vUDZtcVZNbjJoM245dEQrOVRHMW9mM2hYQ2ZiNUQzTkgyNlQxTlAyYURuTzNPdGdmeDBuOXRyL2ZGY1FieHozcHYydC9XbjdOQzlvTTIwdTJwTmxPQ1Z0WXhJdHRMc3FVSmlsMjByQVJiYU5sVEJhWFpTR1FiS2F5MVoyVXhrNXAyRVY5dEp0cWZaUnNwMkFnMjBCS24yVWJLQUl0dEFGUzdLVFpSWUJnenVHSzczd3BlSFltVDByaUk0OHNNMTBPalQvWnBzWjROY21JaHpST21oSzBqMXFDVHpJMVBxS25NWWRheDlIdXZOaEFKN1Z0Ujhpdm5haWNXZTFGM1JnYXRZTkl1VjRyblpta3RaQ3NnSXhYb1VrQ3V2U3VhMXJUUk1yWUdENjFyVHFhMllwUjZveEk5UnhnQTFhajFEUGVzT2VDUzJrdzNTblJTODEwdUNlcU0xSnJRNnEydWkyT2ExWUNYd2E1N1RWTDRycWJPSDVjbXVLZWpOWTZrcUx6elRuTzBVTXdYaXEwMDNCcVl4dWFqSjVSZzFtU3poY2s4VSs1bndDVFdKZFhUTy9seG5MR3VpTUNISUwyOE1qbU9Qa25qaXIrbGFlRlVPNDVQYzFGcCtuYmYza295eDU1clVXVUo4cTFNNWFXUVJqZlZsazR4aGVLUUtDZWFZcmJxbFdzV2FXSXBGOUtnYUltclpYSnBmTHpWSmdaclEwenlmYXRRd1Uwd2ZoVnFSRE1wMTIxR1RWKzRod0t5cm1RSmtWMFExTUo2RGpNRmJrMXAyTjBHVUFHdU92dFVXSGdIbXJ1aTM3VFlPY2lyblNzcm1TcWEyT3FhWEw1RlRDYkJBcW5FKzQ5S3N4S1dldVdTUnNYUklmS0o5cWhpazNTVTI1WXBEd2FpdFc1eWFocEROWmVsSVh4VUJtd0tqRXBacXpzVVdkL2VvSkpzbkhTaHM3ZXRWM3lUVFNFeHpEZFZXVUJhc2duYlZlY1pyV0pESUNmU296a21uNHhTZEsySUFBZ1ZORzJEMXFBbklwb09HNHBOWEFkY1M5Y1ZuejNCeGdtclU1SkJyTXVUdDYxVUVaeVpuWHJnNXJQUi9tcWE4azZpcWFObHE3SXJRNW05UytqY1U4R29vK1ZwNDYwbU5FTjB1VnJCblRiSWE2T1ZjcWF3dFJHM3BYVFFscVkxRmNvTXd6Z1VpamRUVVVzMVdVVEMxNkNPYXd6YmdWRzR6VTVHYWxlRlk0bExjNXBOMkN4bU1DcHpXbnBGNFV1RkJQZW81TFR6TUNQbk5XTGJRTHRIV1J2bFhQRlkxRXBSTklYdWVnNlpMNXNJd0IwcWFaOXVheDlOa05tRldSK3RhZHhJQ28rYnJYaXpweVVqMVl5VFJYbGx6MXFqSzNQRlNTdDgxVjI1cWtyQTNjYVd6VmVUclV6Y1ZDOWFKRWlSdGdHcU45TXdYQU5XK2dOVXJwZDFkTkpIUFVkakxlVi9VMUdaWDlUVnRvYWpNRmRtaHlhbGJ6bjlhVHpuOWFuTUZOOGltVHFSZWUvclNlYy9yVTNrVXZrVWFCZGxZeXY2MGVhL3JWZ3dVM3lQYWdWMlErZS9yUjlvay92Vkw1RkhrVWFCY2krMFNldEJuazlhbE1GTk1OR2dha2ZuTjYwNFRONjA3eWFQS3hRTzdBVFA2MDlaMzlhUVI1cDRqcER1eHdsWTk2a1dSdldvZ3RTcXRLdzdqeEszclMrWXc3MDBDbmJhVmg4ekVhUnZXb21rYjFxUmxxSmhUc0RrTVoyOWFpTXJldFNrWnFNeDVwcEUzSS9OYjFwM210NjB2bFVvanAyRmRqZk5mMW84MXZXbmVYUjVkRmd1eHZtTlFIUHJTK1hTN0tMQmRpYnpTaVErdExzbzJVV0M3SExJM3JUZ3hwb1duaGFWaDNZYmpUR1kxSnRwQ21hTEJ6TXJNNXFNc1QzcXlZcVlZYWVndFNEbWx3MVNpTTBvam9BaDVvQWFyQWpxUVJDZ0NCUWFuVVU5WXFrRWRTVWhnRkxpcFFsTDVkSVpGaWpGUEs0cG1jR2dCQ3VhWTZacVlZTktRRFFCUmVPb21RMWZaS2hhT3FGWXFnR25xS2w4dkZHMmdSR1JUU0ttSzAwaWdMa0pXbWJhbklwaEZPd215UEZPQXBhVVU3Q3VHS2FSVWdwQ0tWZ3VNeFQxV200eFVpMER1S0V6UVV4VXk5S1ZnQ0tBS2JyVUxMVnQxcUxaVFNFMlZpdE1LMWJNV2FZWXFvZ2dDMEZLbkVkT0NVeGxYWlNiYXROSGltN0tRRmpaUzdLMEJaTzNhZzJUcjJwWFFXWlFDVWJLdmZaRzlEVGxzSGJvS09aQlptZnRwZHRhZzB0eU9sTWJUcEY3VWN5SFl6dHZGTktWZit4U0QrRTBoczMvdW1pNkZabERaU2lPcjRzblA4SnF6QnBidVJ1R0tISkJabVI1WnBObGRPTkRCU3FjK2pPbkk1cEthSHlzd3lsS0kvYXRBMkRnOUtjdGkvb2FkMEZtWjRYRldZSEt5S1I2MU9iRi9RMHNkc1ZrRzRZcVcxWWFUVE84OE11MGlMOUs2Mk03UlhLZUdXVlkxNTZWMVRkQXkxNGVKcDlVZXJoNm5SazRPUlZlNGhFaW5jTTA5SHpUcEdHSzg3cWR4eXVyYWFHQklXdVllSXd6Ylc0NXIwTzVpRGcxeWVzYWU3SGNuR0RYWFNxZERPY1Z1WDlFWlR4WFVvNFNQOEs0YlJaakhKdGF1b056bU1WTlNuN3hjTlVUVDNBSGVxTXR5TUhKcXZjM1J3YzFoWDJvN09BMWFVNERsS3lKZFMxRGFjQTV6UzZiR0MzbVB5eDVyRVJudVp0eDZWcnd1WTR3SzFuR3lzWlJkMmJiWEFDYlZwcU5scXBRa3ZpcjBNUjZtdU42YUhTbmRGeUljVkt0UXJ3dFNMelVqc1NqbXBWWGlvbDRxVU5nVVdFeCtBYWE0QXBwbHdLcDNGMkZIV3FVYmsyQzhrVkVKTmNUcmVxckFyQU56V2pyZXJyRkUyRzUrdGVhNnRxTFhFcHdhOUxEVVcyY09JcXFLRm52NUxxNndHSkdhN2J3NUd4aVJSbjFOY1BwVnNaSkFjZDY5UzBLMFdHM1hqdFcyS2tvNkk1S0Y1TzVzUUlWWExWZHRRR1ltc3lhNTIvS25yVjYwY3JGazlUWGt5VFBSUTYrR1NGRk5pR3hlYVlaRE5ja0U4Q3JCaE93VkJSR1pDeHFSWENEazBMRVByVVV5UGpnVWFNWlA5b0I3MUUwbzNWV0NNbzVvSU8zTlZZVExQbnFCVmFlNFVkNnFUeXN2SXFsSmNrMXRHbmZVemJzYUt5YmpVdTJxRnBKdmJyV3ZIRmxSbWxMM1JibFE4Q29pMkt1eXhnVlVaQ0Qwb3VGaU9YN3BySXZIcllkUGxOWkY3SHdhMGh1WnoyT2Z2WDVxckUvelZMZkhER3EwUDN2eHJ2UzBPTjdtdEMzeWlwZ2FxeEg1S2Q1bURVV0t1VHVheWIrTGZtcnpTMURNTjZFMXBUVm1STFV4MFRiVDhaUEZPbEcxK2xUMjBTdUN6SHBYZmZRd3NOVzFZcms5S2h1SXBHQUhKVVZxYmp0QUE0cDZ4NVVqYm5OSzQ3Rkd4bFdIYTc5aldwTDRnanhzWWZqVkthQXhwc0M4R3E1czBPQytRUFdsWkZjelJhYlhJeXl0Z25hYTFvTlhpdnJiMElyblpMWkVqL2RZUHJUck1sSVdTTEFhaHhUUTFOcG5XMi9sM01adzNJcGp4TjJVam52V0pZYWhOWnNWWlF4SjZWZm0xZWE3ZFVTUFlCMU5jMDZTT2lNeVNXTW93RFZFeThWTUJ1R1NjMGpBQVZ6K3oxTmVaSkZWaGlxc3E1TldwRFVMclhWVGpZNDV5dVZTbE1LVllZVkdSV3htUUZLVHl4VTVGSmltSWhFWXBmS3FjTFRndEFGYnlxUXhWYjIwaFdnQ3A1VkhsZTFXdGxJVW9FVlRIN1V3eDFiSzB3clFCVjJVdmw1cXhzcFFvcGdWaEZpbDh1ck93VW9TcEFxK1hUZ2hxeDVkS0VvR1FpT2dwaXJHeWpaUUJXSzVxTms1cTJZNmFZNkVES25sNXBQS3EzNWRLSXFZaXA1ZEw1VlcvS3B3aW9DeFQ4bW1tR3J4aW84dWdMRkh5YVBLcTk1WHRTZVZUQ3hTOHFrOHFydmsrMUo1VkFpcDVkS0VxeVk2VVIwZ0svbDB2bFZhRWRLSTZCbE14VW5sVmRNZEo1ZEFGRXcwQ0tycGpwdmw0cERLdmwwb1NyR3lnSlFCRXEwOVU1cVFKVWlyUU1ZRXBTdUJVb1drWmVLUXlvNHF1M0JxNDZHcTd4MENJdzFQQnpUQXZOUEFwMkVGTVpjMUppbXRSWUNQYlNFVStrTk1SR1JUV0ZTRVVtMmdDSEZNWmFzYktObWFhRVZkdEx0cXlZNlR5eFRFUkt0TzJWSUV4VHR0TUNEWlFCZzFNVnBoRkt3Q3FhZjFGUjhpbEJKcDJBR1hOUmxhbUl6VGR1YUJFZTJrSzFONVo5S2NJRDZHbUlyaGFYWlV4aGIwTkhsTVQwcFhIWXJsYWJzcTM1RGVsSjVEZWxGMEZqc0JaZ2RxY2JEZDJyYUZpZDNTcktXWEhTdVBtT3JsUnpxNmIvczFNbW0rMWRBdG1QU3Awc2g2VXVaajVVYzhOTjlxUnROOVYvU3VvRmtQU2tleUhwUzVtUGxSeVRhYi9zL3BRTk16L0QrbGRPMWlQU2dXUXgwbzVnNVVjMm1tRFAzZjBxMUZwMk1IYlc2dGt1N3BWZ1dxaGVCUnpCeW94QmFCVjZWbjNOdG5PQlhWdGFBanBWR2UwSFlVMUlPVTVNMmZ6ZEtrU3lIOTJ0OFdJWnVsVExwdzlLYm1Ma09lL3MvUGFxVjFZTXZJV3V6V3dHT2xNYlRRN2NpcGNtVW9vb2VGTEtXYVVaQkF6NlYza3VuN0xmZ2RxcjZCWXBGdEFINlYxRTl1cGc0SGFwVU9lTHVUeldrY1J5akVIakZETm1yZXB3Q0tRc3BxaWpacnhxbE54a2V2VGx6SWtXUGQxcUM3c2xlTTVBcTRwNG9jWlVnMWpzelRjNGU2dGpiWFJaQWNacS9IYzVnSFBOYU45WmI4OFZoelc4a0JJd2R0ZFVKS1c1R3owSUwrODJBODlhNXVhUnJtZkE5YXZhbEljRlQ2MVhzSU56Ym1yc1h1eE9lY201V05HMmhFY1lQVGlwWXlYZkZJM09GRldyRzNMTnlLd2xJMGlqUnNvZUJrVnBLZ0M4VkRESHNRY1ZNbjNxNUhxenBpTHNwdzRxUlJtZ3g1cEdnemRTRjZlVXhWZVp3aW5OYVJWeVhvUnozRzFldUs1L1U5VEVTSDVxbDFIVVJHcHlhNFBXOVhNa2pLcC9XdTJoUjVtY2xlcW9JcmF4cXp6eXNxbjlheGtReVNmalNrbVJzOVNUV3BwV25OY1RLTnZldlgwcFJQRmxKMUpHMzRkMC9leS9MeDNOZWhRSjVkdUFveHhXWm8ybUxiUWpqdFd4S3lwRml2RXJUNTVYUFRwUTVZbWVZekpjQUQxcmEyaU9EOEt6N1JOOHBmdDJxZTZtT1JHcDVOWXlac2lhd2pMU0UrcHJXWkFBUHBWWFRvZ0VCSXE2NHJtZTVvaXNVeDBwR1VjVTl1dUtZMU5ESVhRVkU0Q2lwR2FxczBoSXJTTjJTWjE0TTV4V1l5bXRPWEp6M3FrNkhzSzdJT3lNWmt0a2RyRDYxdHh6WVVaTll0c21XOUt2b3B4eldOVFZoRXVGdDNOVnBjVTRmY3FKOCt0Wm9wa01rbUZOWmwwKzdOWHBtNU9hekxoZ00xdkJhM01wczUzVWVDYXB3dDgzNDFiMUk1elZHRTROZWpGYUhGTGMwMGZDVWhiSnFKR3l0UFJDekRQVE5OUnVBNGdudlRnQnQyazgxREc3UzNMNTRpWHBpbkM0VldiMXpXcWdSY1I3YUptNVkvbFQ0b0ZqUENscUZZZFNPdnJVOGNpQUhwbXRlaE83QlltWCtEajYwMS9QM0R5MUZXMWZlb2JGU2J6dCtWUVByUVhZeXBsdWR3SXdmYW9KcmljUStXOFdQcFdoSktxdGxxcDNFeVRIQ25udFZJaGxKTG5xcFVnanNhVzNoS3NYRGN0elJPcDY0R2ZYRlZ6UEpHYzgvU3FJTDZBaVFuTmFFTXdBK2JyV0dsMCszT0Rtck1jemRYNE5US055bEt4dUxNUFdsTTJWOTZ4eGNrTU1HdEt5ZEp5TjNYM3JMbHNYelhIQjhzUGw1cHNpODVyU05seU9ncVdQU3kvSjVvdUZyN0dFWXllMU44bytsZElOSXovRFNuUkNSbkZIT2hjck9ZYUlpbTdDSzZVNk1mU29KZEhJSFNueklubFpnZ0VVOEExcURTV3owcGY3TklQU256SU9VeTZTdFJ0TWNqZ1ZIL0FHVkxub2FPWkJ5c3pzRTlCUzdENkd0cURSbU9OeTFhL3NqSFVmcFM1MFBsWnpKUStocHBRMTA1MGNOMi9TZ2FHRDJvNTBIS2NxVUlwQURYVXk2Qjh2QXJPbjBaMCs2S0ZOQzVXWklGUEFxWnJTU004clNMRXcvaHE3b213emJTN2FtRVo5S1h5dmFrTWlDMGJLc0NPbDh1Z0NzVXB1eXJKanBCSDdVQVYvTHB3U3B2THBkbE1SQjVkTHRxYlpTaVBOSVpCc29LVlA1WkZKdDlxQUlRdEcycDlsTDVYb0tZRmJaU2JLdXJiTTM4Tkkxc3k5alJjVmlsNWRKNVpxMlk4ZHFUWlFCQUZwMjJwTm50U2hhQUlpbE5LVlpDVXBqcERLcFNrS1ZhOHFtbU1pZ0NtWTZVSmlySlNrMlVBUWJhVUxVdXlqYlRzQXdDbElGTGpGRklDRjFxdkl0V3lLalpLQVpUMlV1MnJHeW03YXBFa0pXbU10VDdhYXkwN0N1VnlLVEZTTXROeFRzRnh1S1hiVGdLY0Zvc0F6YlM3YWtDMHUya0JDVnBwRlRsYWFVOXFZRU9LVUNwUkVXNkNwUlp5SGtLYVFGWWltRmF1bXlrN3FhRnNtenlLTG9MRkFvYWVsdTU3R3RpMzAzZGdrVnB4YVdPUGwvU3Bja2lsRnM1Mk94ZHV4cXpIcGJudFhTSnB1UDRhc1JXSFBLMW02aGFwbUJEcFdQdkxVcmFjby9ocnBQc1dCOTJtbXg5cW5uSzVEbS83UFU5cVgremxIYXVoRmpqK0dsTmxudFM1eDhoenYyQWYzYVQ3QVA3dGRBYlBIYW96YW4wbzV4OGgwMndIdFVxUkEwcUo3Vk9vd0t3TlJnaEFwNmhhUW1sSEZBRXFnVWhBTkp1cE4xQXhDZ28yQUNnbW1scUFEYUtYZlVaYWdVQVNNM0ZWbVVNYW1JelFFV2daRkhDTjFUaUVVOVZBcVJhUWlNUllGQWk1SEZTNEpQQXE3WWFlODBvTEE0ejNvdGNUYVJwNkpaa3FHeFY3VUpmSmpJUFlWZXRZbHQ0Y2RNQ3VmOEFFRjRzY2JuZGppdWxLMFRuamFVcm5PNnJmSXhZWjVyT3Q1dzdmS2E1RHhCNGpFTnl3RGNacCtpYTRKcEFkM0JyejhSU2JWejBLVlJMUTc2TWdqbXBDT0tvVzArK05TS3VLMmE4bVNzenZXd2pSYnVDT0txM09ucThad0swRkZTYlF5OUtFMnRoMlBQZFcwVXRJU0Jpc3dXNzJuQkhIclhvdDVhcStjaXVlMUt3QlU0SEZkY0sxOXpHVUVZa0E4eDYyN1dNS285YXdremJ6WWJpdFczdUFRT2FkUmFYUVIzMU5aWEcwVkluSnFsRys0akZYb3VsYzdSc1RLS21WYzFFbFRBNEZJcTQyU01iYXhOVm04cU04NHJXdXJwWTR6azF3bmlmV0VDTUEySzZLTVhLUmxVbW9yVTU3WE5WTzlsVnE1U1dReXlFazlha3VyaHA1bVludlRiZUZwcEFxaXZmcHdVSTNQQ3ExSE9SWXNyWnA1VkNqdlhvT2dhUDVZVmlNR3FYaHpRZHFLOGk1YXUxdG9GaFVDdlB4TmZtZGtkVkNqYlZraXI1VWRVN2lZdSsxZTVxMWN6QlZQTlZyT0xmSVpXNmRzMXdMUkhhWDdWRmloK2IwcXB6TmU1eHdEVWx4TVF2bHIxTlc3QzE2TXc1ck51eUdqU3RRRWlGVE0yZTlOVlFGeFJpc1N5SnVPYWhkdldyRGppcXpMazFTQXF6U1lxbzgyYXQzRWZ5bmlzeVFZZkZiUU0yeDJRelVyVzRmcFNxcXFvSUhOV1lTRHdhcHNuY2lpZ0VmSnFSbUFIeWlwWHgycUU4Vm5kc2V3TTN5MVRraytZMU5LL0hCcW16Wk9LdElsc2htY25OVUp3U3RYbjVOVnAraHJvZ1l5T2QxRVlCTlp5SDV1SzBkVHlBYXlZZHpTZkxYb1EyT1NXNW93bjFxZWVYeTdaMlhyamlvVlRDako1L2xUajkzbmtWckZFWEtkbkxLSThOMUo1cWZDOVNhY1FHejBGUm5wZ2NtdDBaazZzWEFGWElvRlZRekg4S3k1WEtSZ0FuTk9pdXBSak9jVXJEVE5neklxN1Y2MUZMY2xGK1kxblBka0U5L3BWTysxQVpBQU9SVHNQbVJadVpDeHlwck5OeVVuOXFraW44eVBrY0VjbXE3SXJFNE9hcEVOM05LRzlqa0dIcHNxZWNjeGppcUVGdkkwZzJ0eDNyVEVQbElEbnRRSWgyYkU2ODBpdmcvTWMwcnhsMnlEZ1U2TzJ5ZVRTSFlSV3ptcDRaR1hsRzV6U2ZaZU9uTlBTQUtNbHNWSmRqUWkxU2RXVXMyY1ZyV2ZpSGFWM3hnK3RZS29nQUpPYUNGQStROWFscE1kMmp2TExWcmE0eDBVazk2M1lZbzVrQlFxMzByeXVBbER3K0syZFA4UlhPbnZqZnZYM3FKUVhRcU1tZHk5bHo5Mm9uMC9JNlZTMHZ4VERkT0Jja0szcFhTUVBGY1Job3lEbXNaUmxFMVZtWUIwNFo2VXY5bXIvZHJvR3R1ZUJTQzM5cWk0N0dDTk9IOTJuRFRsejByYk1JSGFrRVhQU2dMR1NMSUwyb05wbnRXejVHZTFDMjQ5S0xqc1pTYWVNZEtYN0VBZWxiSWlBN1VubEF0MHBCWkdTYkxJNlZTdWRQQVhwWFRDRDVlbFY1cmNObmltRmpqSnRNRE1mbHF1ZEpBUDNhNjJTMHllbFJOWmc5cWZNVHlvNWIreTE5S2pmU2NqZ1YxWXN2YW5mWWgzRlBuWXVWSEV0cHNpbnBUZnNFbnBYWnZZajBwb3NCM0ZQMmpEa1J4NDArUTlxY05OZnVLNjc3Q093cGZzUTlLUGFNT1JISHRwemVsUXRZdU8xZHA5aEI3VkZKcDQ3Q2oyakZ5STQ0V2o1NlZJTFlqdFhVL3dCbmowcHAwNGVsSE94OGlPYSt6NTdValdMZWxkTC9BR2NCMnFRNmY4dkFvNTJKd09URmszcFU4Vm9SMUZieldPRzZVMDJtQjBxdWNYS1owY0tnY2lubTJWK2dxZG9EdTRGV2JlMkp4bW56YUJ5bVBKcGhKeUJUUDdLYkhTdXNXMEczcFVxV1FZZEtqblkrVkhHSFNuOUtiL1piK2xkczFnUFNtRFR3RDBvOW93NUVjWWROa0E2VXhyTjA2aXUzYXhIcFZlWFRRM2FuN1JoeUk0d3duMHBSYk0zYXVvYlNsM2RLUWFhRjdVL2FNT1E1WnJOaDJxSnJkaDFGZGEybisxVlpyQWJUeFRWUmt1Q09hOGsrbE9GdVdyVGt0ZGg2VVF3L01PSzA1aU9VekRhTjZWRTlzeTlxNlpMTU9PbE9PbEJoMHFlZXhYS2NrWXo2R21OR2ZTdW9rMGZCNEZRblNnT29vOW9oY2pPWUtIMHBSQ3pkQlhTLzJVUFNsR21BZHFmdEVMa09hK3p2NlUwMnIrbGRVTEJlNHByV2FqakZQbkZ5SEp0Yk9PMVJtMmIrN1hWUFpqUFNrR25oajBwKzBEa09ZRnE1N1ZJdGxJZTFkWEhweWp0VXE2YUQwRkoxR05VMGN2SHA3ZWxUTHBtZW9ycUUwNGVsVExwK08xUTVzcjJhT1VHbFk2aW5McFhQU3VyTmo3VTAyWkhhbHpzZklqQWgwcEIycTlIcHFZNlZwUjIzUFNyY2Rya2RLT1pqNVRDZlRCMldveHBuK3pYVXJaZ2pwUy9ZeDZVdVlPVTUrRFQvQUdyUWlzc1k0clRTMUFQU3JNVnNQU3BidVVra1pxV1k5S2Y5bEFQU3RjV3dBcUdSQUR4VU81ZWhTVzJCN1U3N0tQU3JLaWhxQUtFbHVBYVFRaXJMcVRVWkdLTlI2RURRaW9URXVhdGticWlLYzBhaU5NY1V1S1NsSnBERzR4U0ZxR3BoNG9BZHVwZDFNcERRQS9kVFdiQXFNbkZJV29BZG1sM1lGUWtta3dUU0dXa2VuWnF1dldySW9BZXBQRlRScnVOUkpWdTN4dTZVQ2V4cFdHbmhpR2JtdFV5UldpOXM0cXZiQWlQSTlLemRZbFpJMk80aml0NHBKWE1QaVltcmVLSXJWR0RTYlFLODE4VGVPSW5WMVNYUDQxZytPZFZtU1lvSkR5Zld2UFpYa2tZbHR4cmFLdnF3YjVkaTFxZXBQZlhCYm5ibmptcnVnNmtiYTRBWS9MOWF4T2xPUWxXeURnMWNvS1ViR1NtMDdudEdqYXVzc2FBc09lbk5kTkRMdVVFSGl2Rk5DMWxvSkZTUmoxNHIwelJ0VVdaRkJiUEZlRGlLRGl6MXFGWlNSMVNObXBnd0ZaOGN2eTA3eitldGNOanRMRnhncFdWUEh2QkZYSlpjcjFxcVdwclFSek9xMnBCeUIwckxndTJqYmEzQkJyc0xxQVNvZU9hNVBWTEJvMloxNHg2VjEwcEo2TTU1cHJWR2phM1lkaHpXdkRPTm81cmliVzZNYjRKUEJyYWh2K25OT2RNcUZSTTZkSkFWcHp6aFFmcFdORGQ3aDFxTyt2dGtad2UxWktEdWF1U3NVdGYxYnlvMkFQTmVaNnJxVDNVcEJPYTEvRU9wTTdzdWE1aFVhVnlmV3ZZdzFKUlYyZVZpYXJrN0lSRkx0Z1YwL2h6VFJKTUN3NEI1ck10TFRHQ1JYV2FFdXh3QnhWMTZqNWREQ2pCWDFPd3M0a2d0eGdZNHAwazQ3R29mTVBrZ1ZWZGl6NFhxYThmUnU3UFU2YUVtOXJtYnl4MHpXc3FMQkI2WUZWYlcyRUtibSs5NjB5V1l6U0NOVHhubXBlcjhocEVsdEUwOXp2YjdvTmI4U0NPUEhlcVZqQUkxQk5YejByQ1R1eTBHL0ZLSEJxTGJqTk4zZk5nVk5oa3NoK1dxeGNidUttUEttcXNoeFZJVnhKWHpXWk12N3cxYWxrNTYxVWtmbXQ0Nkl6WktpWlduaGNWREZMeFQyYnBpa3hJa1o4S0tyU1RkYUpIK2JHYWhZWkJxb29sc1kwbFJHVVpxS1lrSGcxQVNSM3JaUk0yeTB6REZVNWprbWthUTFFeHpWcU5pVzdtVHFTWlExbVdqQldJN25wV3pmREttczIydFR2M3Q2MTNVWHBZNWFtNDVkNWJuTlNrZEtuOHNzd0NjVktrTWNmTW5KcnB0WXozTTV5UXh4VUJrd01uZzFxdWl1MzNSN1UwMmlEL1dDbmNYS1pKRHVSVG5EcXRhSmd4OXhSajFwd2lYYjgvTlBtRGxNUjJmbmIxcXNVTWpmT00vaFc4Nnhad0U1cEJCZ1pWQlJ6QnltVERiT1FTRndvN1lwSUxKZzdNNE9Pd3JaQ1NkQmdmaFQvSnlveFJ6QW9veklrYUlaWmNVa2x6azk2MUZVTTIyUmVLaWEwaWRqOGxLNCtVemQ3TXdBcTBnZE51N2pOU2l5UW5LQ25mWjJYcURSY0xBV080YzU5NmQ1WUtFazhVK0s0TUZ1MFJqVnR4NEpIU29ONUw0MjBoa3FOOHZTbnNBUHUwTGd4K2hwVllZcGdOQjJuSnBwY00zQnBaRGtjaXE2NDNFMHlTN0dlTnlua1YwR2orSjVyQWhKaVdRVnk2dGhmbG9NcFE1eG1rMWZjYWRqMlBTdFpnMUdNTWtnejNVbXRjYlNLOFB0dFJtdEpGYUNSbE9lY0d2UVBEZmkyTzUydzNUWWZvQ2E1NTAzdWpXTTduWHNnTklJd0tjSERybFRrZGVLWEZZMlpxSnRGS0ZwT2FjQlFBbTNOT1ZSbWluQ2dCeHhpb0pFelUxTklvQXB0RlVaaDVxNFJUY0NnQ3VJYVV3ajBxelJTQXFtQVV3d2UxWGdCUVZGQUZBUVVHQ3JoVVVZRkFGTHlLUTIrUjBxN2dlbExzb0F6dnN2dFNHMkhwV2tFRklZL2FnRE4remM5S1BzL3RXaDVWSGxVaG1ZMXNQU3E4bHRqTmJMUkExWG1pNE5PNGpCZUREVkxDdTJwNTR5TzFWMXlEVklrMG9sRENyMFVIRlVMVnExNEdHS1RHTkZzRDJwRGJEMHE2bUN0RzBHa016bXR4NlV3MjJlMWFMS0tqSUFvQXkzdHNOMHBQczJlMVgyVUZxVlVGSVpuTlppcWM5cGpQRmJ6S0twenF1MDB3c2N4YzJmZkZWVWh3MWIxeXE3VFdXK0ZhdEV5R2lhM2pHS3ZSeENxRU1nQnJRaWZOTVFra1FJNlZWa3R4NlZvWXpUV2pxUm1iNUh0VFREN1ZvK1hUV2pGTUxHY1lhZ2toNXJVWkFLZ2RBYUxpc1p2aysxU3BCaXJYbGluS2xPNHJJaFNHclVjRlBTT3JDZ0NsY3F3eFlCNlZLdHVEUzd3S2xTVVZJeG4yVWVsTk5zUFNySmxGTU1nOWFBS3d0Z0QwcVdPSUNtdkw2VTN6S1lGdFVVQ21sQlVhU1UvZlFBQk9hc3hEQnFzcjgxWVFnMHhFelkyMVRsSHpWYVBJcU4wK1hwUllWeW9XQzB3dm1pNFVoamlvT1JTc081S3pBQ3EweitsS3pWQXhCRkFENDNweDYwMklBdFY1WVJ0Rk93aCtlS2FUVFMyS2lMODFCb1RFMHc4MGdOTFFJT2dwcGFsTk1JelFBMG5MVW9GT0MxS2tlYUFJTm1UVHdnQXFab3ZRVUxFZTlBRWFwM3FVQ243Y0xVZWFReVRHSzBkTnR6TElNMW5yeml1azBXRURCTk9LdXlKdXlOTllsaHQrYTVEeERkNVIxRmRicU1tMkVnVndPcnZ1a2F0NWFJeXA2czgvMWZTVHFOMEN3enpXbnBmZ2UzbmpIbVFnNTlSV2txS0p3Mks3UFFGU1RieFdiYmJLa2p6VFdmaGpFWVdlMVVvMk9NVjVwcWVrWE9sWExSWENZd2VEWDEzZmFkRTlwbmJ6aXZIL0hQaDRYRU1wRVl5QndjVjBSZktZdFhQR1Vjb3dJT0NLN2Z3dHFSK1FNZVI3MXhVa1pobGFOeGdxY1ZwNkpkTkRlcHp4bWxYaHp4SFRueXlQYUxlYnpMZFNQU25DV3MzUnAvTWdIUFVWb1NManBYejg0Y3JQYmhLNkpESm1nYzFFcmRqVXc2Y1ZpYVhFUE5VYjIwRXFrWTdWZXh6Uzdjam1rblpoYTV3OS9wYkl6TWdyTmltZEpOclo0TmVnWE5xc2luaXVjdjlIQVl1b3dhN2FkWk5XWnpUcHRPNklZYnNDUGs4MVMxRzkzSWNHb1pVa2hKQkJxbE1TL0ZkTVlyY3pjM2F4ZzMwTHpURTgwKzJzdG9HUld1dHFHT2NWTDlteDBGZFB0TkxITnlKdTVVaWh3SzJ0SVRhMmZlcUFqd2EwOVBSaTIxQVNmYXNha3RDb0xVM2ZNK1VLT1NhdVdkbVJtU1FjOXFXeHNzQlhsR1c3ZTFYcFpGaWpJSFd2TmNyN0hja1VyMllxTmlkVDZWSnA5cnlHWVpKcElMYnpwZDdkYTFvNGhHZ3g2VkRscFpGSkRnQWlqRk8zNXFGbVl0Z1U5QWR2TlFVT1ovbHBpOG1oaFNZUGFtSmtyTUF0VVo4bk9LbWRqaW9aRGdWU0laVWtVa1ZYYU03cXQ3dHhJTlJzT2ExTTJRWTJEcFVCbk83QXF6SjkwMUNzT1RtcUlHTkxnYzFIOW96UzNNZU9sVmxYSnJTS1FtSktkM1FWRHpXaWx1R1hPTUdvSjR0dFVwQ2FLTEhubWtKRzBDbGtHR3F2TktGVnR2V3Q0eDVuWkdVbllodUNIYkJwZ2gyamNPQlRVeVRsdVNhbUw3MDJqb0s5Q0VPVTVaTzQwRHVPdEJYY0R6azFMcytYYjBOTlpERWd5ZXRVRmlPSkNDY2Mwcm9PTXR6VHkyeGZsNzlhZ1lsbTRvR0I0T0QwcGp0eVFvcWJ5eWtlTzVwSXlpS1diclRFUkpGc0FhVHFlMVRvOGFxQWNFMUh6SVN4UEZOMmdEM29HRTVPLzVlS1E3OGpiMXBUR1NSbXBRcXF2djYwZ0lYWWpDa2ZqUTJGYkk2R21TN25rQUorVVU0QmVuV2dCd2tBenRHS1kwaEp4amludEcyMzVNWjk2VUl5eGd2ZzBBUkFibkFBK3RPWkZYbnZTZyszTktRdUR1NzB5U0Y4WnlQd29RYmNFODA5aUN1UHlOTUIyNHp6VHNBMlE1SlBTb2NrOVJpcDJZQnVhaWtjWXozcG9UQldHNDBraWtqanBTSnR6azA3emxKMmpwUUExY0FZTk9XNWFKd1l5UVIzRk5LaHM0TlJzTnE4VWhIb3ZoUHhhVzIyMTQzMEpOZC9HNnlvR1E1QnI1OWhuZU53NmNFVjZYNE44U05kaGJhWnN0V05TSFZHdE9kOUR1MVVHbllGQ2ZjL0NrSXJuc2FpR2dVRDNwakdrVVMwaEhGTkZCTkFEU0tZYWVhYWFBRzVwYWJTMEFHYVRmUzBtS0FETkprNW82VW81b0FVVS9GSUJUaFNBQUtLZnhTY1VBTnBNVXJjVWdvQVFyVUVpWnF3VHhUV0FOQUdaY1JjR3FEeDdUV3pNbkJyUG1UMHFrSmtVVDdhMHJlYjNySTVCcXpETHRQV21JMzRwTXFLbDNWbXdUY0RtclFrejNxV2hrcm1vbWFtdS92VmQ1Y2Q2UXlZc0JURE9CVlI1L2VvR241NjBXSGN2dFA3MVZtbDRxQXpaNzB3dHVvQXIzRFpGWmsrYTFuanpWT2FISVBGWEVobWVraFU4MWZndU9uTlVKSThOU3hrZzFvUWJzVXVSMXFiT1JXYmJObXRPRmNpb2FLUXdnMUU0SXEvNVdlMUliZlBhcHNPNWx1VFVSVmllbGJIMk1IdFQvc0kyOENxMUZjeFJHUjFwNm9hMFh0c0hGTjhnVUFWMUZEWnFieXNVZVY3VWhsYm1uaGpVaGpwTm1LQUUzbWtMWnBTS1lhUTdqU2ZXazMwMlExRnVwaXVXMWtBNzAvek0xU0RudlMrWmp2UUZ5NXV6MHFlSjhIazFuck5VeXkxUXJtcUh5S1F2eFZXT1RLakpxVGNEUUliS3U2cXNvQ2lyakhpcXN3TENrTW9NM3pVdzhLYWxhTDVxUXhrMHhESVdJYXRGWlBsRlZJb3VhdUtvMmlnWTBqTlF2OHBxVW5tbU56V1pvSXBxVlRTSXZGTzZVaERXcHRTWXpTaGFCaUtwTldJMDZacHFFQ3BSbWdSS0ZHS2E0QTZVM0p6U1NIaW1BM3JWZVFiV3FaZURUSEc1cUFIUS9lRmRIcDF3RWpIT0t3WTB4ZzFjamxLcmdVNDZNbVN1YU9wWG01VHoycmo3MEdSelc4NU1uQjcxVHViVEM4REpyU1R1VEZXTUVSZk1BQlhVK0hnRWtHVFdQRnA3Tkp1YXR6VFlmSlphenZxVTFkSFh5ZnZMWEE5SzVYVzlQV1dGOGpPYTZLM216SGcrbFpXcnpCWTI5SzN2Y3hTc2VHK0lmQjZ5WFVyd2pCUE5jYkRhUzJlcGVYSXBCVTE3cmN4Sk8yNEFISFd1SThUYUlodUZ1SWxBUGZGWGU2SnRxV2ZEOXppSlZKcnJFWHpJYzlhNFhTMk1LalBCRmRqcHQwSFFBbXZMeE5QcWowYU11Z3laR2pja0NwSXBBZXRYWm9RNjVGWmt5TkUyVnJ6dHpyV2hlWEJHYVJtQXFpbDNqdlMrZVhiaWprWlNraTNrYmFyeVJDVGdpcDRVTEx6VTZXK2FpL0tNNTY3MGtTWnd0YzlkNk84UkpVSEZla2ZaUVY1cXBkYWNwVGhhdU5kb3lsU1VqelpJU3B3UmlwL0ozQ3Vndk5HTzRsRnJOYTJlRnNPcEZka2Fxa2puZE5venZzeExBRG11ajBld1dGUXhIemV0VUlJd1pNbnRXekFKR2pBVGpOUlZsZERoRXVTWEN4cmhldFJSUnRNMjU4MU5CWkVuTEROYUVWdUVIU3VSejZJNlVoa0VJUUE0cWZHUlQ4VWJhaTVSR0lzbXBkb0FweWlsSXlPS0xnVjNYbW1aeFU3TFViTHhtcVRFeUNRQWppb1pNQmVlMVNzY0dxbHpLQUNNMXBIY3paRHZBWTAxbkI0cW8wM1BGS3NtN0ZiV00yeDBoSjRGUGlPRjVxTXNDYWZuOTJjZGFOaVNuZFM1a3BJQUR5YWEwVFBNT0t2eHdCRUhGWGRKQ3RxU3FBSTZxWENnbXJCSkM0QnF0Y1NlV3BMZWxUSFYyRzlqS3ZDRXpXZUY4MStPUjNxZWVVenlNQjB6eFRZa1pjakdNOTY5bWpEbGpxZWZVazVNWVlDQmtHbWdIalo2MVplTnRuV21LTnB3djQxc1RZakpNY3VEMUlwSlh4ak5TTW5tU2J1UWFDaWpDbmx2NVVESS92cU1EQUZHekhQZnRUdHJlWVJUekV3VUVqUE5BRURFK1p5U1c3Q2tsdDVISEFHZlNyelcyRkJWVG51VFFJV1ZjczJEUmNkaWl0dEl2RHRqMnBrdUZjRHRWMStEeDgxVlpJSGtmMEZBV0dJemQrbE9KWnNZcVVRN1ZHZWxKS1FpOU9hQUlTckVIam1td3drRTVxNUNma3lSVWNnTy93Q1hwUUZoUXVlZ3FHUkgzZTFXRXoyNlV5VW5qYlFGaXZ3RHpUWDVwNVhkOWFhVklIRlVUWWd6MjlhUXRqQUZMZzVwakRCOTZZaHJnbW03TTlUUkl4VUFVbWVNaW1JVnNJdFJCaG5ORWhKWEpwcWREUUs1TmtCZXRSR2JjTm9wZ2JzYWFVSTVGS3dYSkZjRWtDcnVsYWpKcDk3SE5HZnV0eldSdTJ0a0dueHk0YW5hNnNSZXp1ZlFQaDdXSTlYMDVKVVBPTU5XdGl2TGZodnJTUlN0Wnl0dDNINVFUWHFPN0k0cmltdVZuWkYzVnhDTVZDM1dwV05SbXN5N0NqcFNHa3pTWm9HTG1tTWFVbW1ubWtBRG1seFFvcVFDZ0JtS1J1S2tJcU42QkRNMDlBYWpGU0lhWUV3WGlrMlU1RG1wTVVDdVFIaWszVkt5MUFlS0F1UEp5S2JTWnBNMERIazAwMG02ak5JWXlRWkZVNWtxNmVhaGtUTkZ4V01tVk1Hb2cyRFYrV0tzK1liZWxXbVNXb2JqSFUxY1M1R090WVBuYlRUaGQ0NzA3Q3ViclhBSTYxVmtteWVLei90ZWU5SG5aNzBXSGNzdkptbzkrYVprbW5LcE5JQnlqTlRLdVNLSTRzOXF0eHdkT0tReUVSWnFPU0RnMXFKQngwcEhnR09sSURucDdYMjVxazBKVTEwRThRR2F5NTBHVFdpWkRRMjBHR0ZiVnV1UldMQzIxcTFiYVhHS2RndWFLUjFPc09haWljR3JjWjZZb1JMWUxiVXJ4QUx4VnVNZkx6VEpWOUtxeEZ6S21pcXZzclJsWEFyTm1mRWh4V0wzTllqU296U2xLUlRtbkUweWlObzZqS1ZZQXpSdG9HVmpGVVRSNHE2UnhVVExtZ1JuU0thaTJWb1BHS2phTVk0cGlLVEFBVkM1SXEwMGZOUXlyaGFhRVFpVEZUUno0cUFyU2dWUkpmUzQ0cVJaODFuQmlLbGlmNXVhQVJvckptbEpIZXE0ZmlneWNWR3BZNWlDYWFVcUFTZk5WbVA1dXRNQ01FaW5DVWlwU2d4VWZsajFwWEdLM0pwd1hpbUU4MUltS2dvY0JTOWFVMEFZb0FZYWVQdTBtTTA3R0ZwREdxY05VMi9BcU5Wb1k4MHlTUlpBVFNzMmFoRFlwNjgwREZBTk9DODBvTlBGQURoeGluZzVQRlI1cTlaUVpYY3dvV3JFM1lqR0kxeWFoa3VVYnFhWFU1bGlVNDRyajcvV2ZJWTROVTc3Q2l1ck95aGtpOWMxZGpkQVFSWG5WbDRoTXN1MVRtdW10dFFjb0MxWk85elZXWjFzRndOcHJKMXViTUxZcXJIcVlIOFZWdFJ1eExHY0d0WVN1ak9VYk13VXYvTG1aV05VdFJsV1ZUM3FHN08yWmoyeldkTmRqZHRKclNOeUpXdUlxQmM0clMwNjVLU0FFOFZuSTI1Y2lwRVlvd0lxWng1bFl1TXJNN2kwbUVrZUtTNXQ5eW5GWkdtWHZBQk5iOGNna1N2RnF3Y0pIb1Fsekk1eTV0V2piS2ppbHRTRkkzZXRiTThBYnRXWGNRRk1zdEtNcnF3OWpSaGRTb3hWdEdBcm40YmtvM05hRVY0RDNyT1VHV21hNk1EVFpmbU9CVlNPNUhZMVlqa0QxalpsSmlHMVdRZEt6TDdTa2NINWEzRnhpaG93NjRvVGExQjZuRXBwekpjWUE0elcvYVdZVkJrVm9HeFhPZHRLWXRneFRjMnlWRkloQ0JlbExTa1lvcEZDWXBRS01qMW96NzBDSFlwUnhUQzQ5YVF5WXBnSklhaExjYzBQS09jMVdlWWV0VWtKaloyeHpXWGNFczJhdFRURGtWU2xsQTYxdkJHTW1Rc25OQStWVFVabXlldEdTdzRyWXlFTG5OWElHRExWWVJkTTk2bWgrVTRwU0dpd2tJM2JqVXI0QzAxR3BKSlJpbzNaWkF6YmV0WldwWE9ma1hyVis3bDJ4a2s5cXdnR211QzdjaXUvRFUrWjNaelZaVzBRQ01oZWV0U3F3Q1U3YjgxREp4d0s5TTVMRUFKZmpOU0t1T0Y2bnZSSENWNU5Tb010Z2RhR1VpRlNWWTVvZ2hHU1c1WW1yVFFmTDgxSkhDVkJKTklkaXQ1TGlVbHVuYXJTeDdRQzNib0tmNU9lVFVtM2pwOUtRV0dIN3ZKcXRja0ZlT3RYQkNSeTFRc256Y0RpZ2RpbUVabEhiaW03U09CK05YV0dPZ3FKaGpwVEN4VlZHeWQzU2syWmJrWnFjTHh6UUFPUlFGaHBJVk1WRHlUVTIwRDNwaDlxQXNJVDhwcUlBOTZmMXppak5NQ0ZsMnR4VFNwT2FrWWpyVEdOTWxrRHBqbW9IOWFta09hakkrV3FJWldjNXFNc1ZhcG1VZHFoa1h2VkVEZVd5S2I5MFU0QWpwVVRNTTRKcGlFTC9ObW5DWGdnMUdTS1l4RklWd2ZHN2lsVWR4VWJaRkNrMHlUVzBTNGEyMWVDUlNSODR6WDBCWlRDV3lpY0hPVkZmT1Z0S1k1VWNkam12ZC9ETjc5cTBPQnZSUURYSldYVTZxTDBzYlpOTVkwYnFZeHJtT2dRbWt6U0UwQTBBTFFLS0JRQTRWSXRSVklEZ1VBT09LaGVuTTFSTWVLQkVlN21wVU5RTjFxUkR4UUJhUTFMbXE2dlQ5K2FwRWppYzFDNXB4YW1PYUJEZDFOTFV4bXhVWmVrTkV3YW5pcTZ0VWlOU0tKZ09LWXkwOWFkak5BRktXUElyTXVZelcyNjFRdVlzaW1oTTV5NXlyR3FmbkVHdFc4aDYxa3lSNGJwV3NXWk1zUlNGcXV3b1dyT2g0SXJXdFJrVlRCRnFHRUhHYXVSd0tLampqNHExR2xaTXNWSXNWZWhpSEdhaWppcTBxWUhGSUNReGdEaXFzdzYxYlVFam1vcFVHRFJZTG1MY25yV1hPcHJhdW93S3lwa0o2VTQ3aVpRenRhclVFK0NLcVNnZzgwc2I0clZFRy9iemcxcHdTRGFLNXkzbjk2MWJlZklGSmozTnVPV25NL0ZVWXBNMU1XNHBjd3VVWk80Mm1zcVFicERXaktDd3hWZnlNYzRySXRLeEVpWUZQOEFLcHhVMDVVTkF5TXBUU3BxejVacENucUtCbFVnMUdhdUZmV29uVUh0UmNDakljVkdEVThzZWVsVndwQjVwM0VOY1ZYa1hkVndwbW0rVG1xdUt4UldMSndLbit5OGRLdFIyL3pacTJzQUs0eFR1S3hrTmJZN1ZINVcwOUsxNUxmMnFCb0tWd3NVU0d4eFM0SVhtclJoRlJ5UjhZRk82R1ZPalZMSExpb0hWZ2VLRWJubWtCY0VoTkp6U1JrR24waXJpZ1pxUURhS1FERkl6K2xKQXhRMldxZFJrVlZYT2F0UTBNUXBHQlNoU1JrMDhpazZDa01qUEZKeG5tbkhtbUVmTlFBdE9GSUZxUlJTR0lCVHdLTnVLY0JtZ0FVWllmV3RBVGlLSEh0VkZWNXFaMUxSNHFvN2t5VnpBMWU3ZVJtQXJqZFVqa2tCNE5kN2NXRzhtc3k3MGtGVDh0Tk1aeGVsV2pyUG5KSE5kN1pSN3JjRHZpc1ZOUDhBS2tCSEZkTFpSN0lSbjBxdDJadlRWR0ZlWEVsdE1lVGltSFVOMFlETlUydGhTU1JYTDNFN0x1QU5KUnN5M0s2MUxkOWRxYzQ1ckdaR2xteUtScFhadWF2MmNXUms4MXFaM3V3Z0JXUG1waFE2N1dJb0JvS0xGdk0wVGdnMTBOamU1VVpOY3l0V29Kekd3NTRybnJVbE5HOU9mS2RjSlE2NXFPV0lPcHJPdGJ6ZDNyUVNYY0s4aWROd1oyUmx6R1ZkMnhVa3BWRVNPamRhNkdXTU9LemJtMEI1QXdhcUw2TUdWb3J5UVBqazFyMjl6OG96V1RER04vdldnRkFUM3FaUnVDWnF3emcxYlNRR3VlVzVNUndhdXdYd2J2V0RpelJTTm9NRFVjZ0dLckpjZ2djMHJUaW9zeDNFY1lxSnppaDVoVmQ1aG5rMVNpSzQ5alVUeWtaeFRXblgxcUNTWVUrVUxqek9hWTEwUjNxRnBGQTVPS3B6VHJnODFvb2t1Uk5MZW5PS2dOMGU1TlZHbEhVbW9YbUdPdGFxQms1RTg5MTZWVWU0M0hrMVhsbnpubW9ESjNyZU1ETnlMZ2ZKcTVEZzR4V1ZISVNjMWRoa3hUbEVTWm9aRkE0NUZWaEptcEZrckd4ZHliZnRYaXF6ekhQekdsa2tIYXFrc2xWR04yS1QwSTcrVWtLb1BXaUtMWkdQV29FUG5UOC93MWE3VjdGR1BMR3h4VGQ1Q2JmbXpUc0RGRlBWYTJGWVlWOUtramp4VXFvRHpVeVI1cE5sSkVQbDd1dExzd01WWTIwZVhrMUl5QlkvZW5iZWZhcC9MK1drTWVjVXdJR3lhYnQ5UlZveGhmZWtkZU9CVEFwUEVlVDJxRXAzSXE2dzQ1cUYwelFCVlpjMHdybXJMTHhVWlhGQUZmMnFOOFpOVHNtR3FKaDFOQUVCT09sUW5PYXNFWnFBam1tSVpubW1zYURUR09hWkF4dlNveWVLY1R6VEdIRk5FTWlkcWpQekNuUFRNNHF5U09SdHZBcURxZVJVcjh0bW84Z1UwUXlNakJOSjFOU0VnMHpHRFRKR3NjVTNmazRBcVJsM1V6Ympta0JOR3VGeUs5ZitIdHcwMmg3VDBVOFY0NHBJTmVxL0RHZi9BRUdWQ2U5WVZsb2JVWFpuZWlnaW40RkdLNHJIWGNpSU5HQ2FtQ1pxUklxQXVWd2hwMncxZFdJVTd5aGpwUUZ6UDJrVVo0cTIwUTlLZ2RNVUJjZ05KVHlLWTNGQXlGdVRUMTZVbU0wNERBb0FNNHFSVGtWSGptcGtGQWdwcDVxWEFwQ2xNa3FTS2Fpd2F1T3RRbEtBUXhSelVpcnpRcTFJb29HUFFVNmdkS0JTR05aYzFXbWpKRlhnS2prWElwaU1HNmg2MWtUeGMxMHQxSHhXSmNwaHF1SkRNOVkvbXJXc2w0RlVGWERjMW8yckJhdGtvMVlrR0tzSXRWSXBPQlZsR0pySmxsaFc5S3RSQW5BcXBHaDNWb1FwZ2MwSkNiSCtYaGFxem5BcTI3RUNxYzNLMVRKUmwzUE9hb3N1YTBwUU85VnpFQ2FoYmxzeVo0YzVyUGNGRFhRU3dkYXpyaTI2MXJFaGxTR1hCclZ0WmNnVmtGZHJWb1doNEZVd1J1d1NjVmRVNUFyTWdPUldoRm5Bckpsa29UTk5kYWt4U0VacEFRQ1BKcVpZcWVxMDhZb0FiNVlxSjR4VTVJcGhPYVFGYlprMGpRakZURmNIaW11ZUtBS01xQVZVZVA1cXZ5VlhkUlNHUXFtYWRzcFJ3ZUtmeVJUQVJGeFU2Y1ZFdFNnVUFLNEJGVnBGcWNrWXBoR2FRRmZabW10RG1yUVFHaGtHS2FBekpMZXFNcStXYTJKUldaY0lTYXRFTXJMTVJUL09ha1dIbXBCRlZDTHpjOUtqMm5OU2hlYWVFckpGc2pWYXN4REZOV09wMFRGTUFJcU54aXA5dE1aY21rTWh4VGNaTlQrWG5yVGxpQUZBWEl0dkZQQXFRcFRsU2tGeG16SXA2SlQ4VW9vQUFsU3F1UlRSVThZeUtZRWZrNTdWWG50Z1ZPUldrRjRxT1ZmbE5ORW5OeTI2cXg0NzA0dVkwd0t0M0VmekhGVTNIYXFBdzlTRE96Y1ZnM0VIemRPYTdpVFQvTjV4VlNUUURKeUJUVncwT1BXekRBSEZYSVl2S1N0dVRScElmNGYwcWxjV3p4THlwcTdrNlhNcVkvdkRpbWlsays4YzAwVXlpWmFlS1l0UEZBeWVLVXhucldqYjNtTVpyS3BWY3IwckNwU1VqU05SeE9pVzZERHJUeUJJdkhlc0dHNEliazFxMjEwR3dNMTV0U2k0YW82WXp1UVhNTFJ0bEJ5S1pGZThoWkRnMXBTcXNpbkhlc1c5dDluSTRyT091NVQ3bDFpSDVITlFzNWpQSEZaTWQ4OEp3M1NyU1hpeTl4VjhoUE1Ya3Y1RTZuaWwvdGdEaHFxN1Zib2FobHRDM0k1cWVSZFI4ek5IKzFrUGVvWmRTQlBCR0t4cGJTVmVocXBMRGNMeU00cWxDSkxrMGJ4MUFITlJOZTU1eldCNThxY0hOTysxbnZWK3lSUHRHYkwzdkhXcWNsMFMxVVRjZzk2WVpSNjAxVHNKenVYRE9UVEhsTlZoS1BXbXRKbnZXaWlTMk9lVEpwaGtxTm1waEpOYXBHYlpham1xNUZLRFdTQ1JWaU9iSEZKeEdwR3NKUlVnazlLem81YW1FdkZaT0pwY3NPOVFTY3FhWVorYVF5Ymxxb3JVbDdDMnFZM0dwd0R1cElWMndnbnZVb0ZlbEhZNTdDZ1ZJaTVwaWpKcWRFNXFteWtpVkV3T2FtVVo0cG9CcVZSaXBLQUlCVHNVb1F0VHhIaW1JWVV5dkZBaUE1SnFmWlR4RG1tSXJlVG5tbXVtQjBxMHk0NEZSdDcwd00rUmFnSXgxclFkYzVxczZEb2FBSytBVkpxTms0elU1K1ZhaGt6Mm9BcnNPYWhZVllhb1hBNW9FVjJHQWFydFZoenhWZGpURXlCamcxR1c1cVI4WU5RTjFxaUd4RzYxRzdVckgwcU5qbXFJR01jMUVUZzFJYVkvU21TUnRVTGMxSWVhamJnOFUwSmpjY1U0Y2ltbjcxSVR0SXBza1ZsSTZVRWpiaHFVc1QwNXFOdVhwQ0hxUVFNVjN2d3puWWFvOFFQeWtkSzRCVGhzZHE3YjRkQWpYQUIwSXJLcHNhUTNQWWl1S1VDbmJmbG9WYTRqcUhLdFNvdE5VWXFWVFFCSXE4Vkp0d0thakFVNW5GTVJFNHF0SXRXV05SU0Rpa0JSWk9hUEx6MnFmYnpUZ3ZGSXE1V0VlS050VGxhUUp6UllMa0lTbmdBVktFQXBDdEFYSThVTndLY2VLaWQ4VXhFYnRUQlNsc21rM0Qyb0dQVmMxSUZxSlpBUFNwRmt6U3NGeDJRS1VNRFNZRERpa0F4UUJOMEZNWTVwQy9GUmw4VUFWcm5ITllsMTk0MXJYVDV6V1ZNaFkxYUpaU0svTnhWdTNVazAxWVRrY1ZmdG91bFUyU2kxYngvS0t2UnA3VkZDbUFLdEtNVkRMSm94aXJLSGlxNjFNdE5Fc213R0ZWTGtZWGlyQmJBcXZNZHdOTjdFeDNNMTFMR2dSVlo4dWsyMW1hRlY0K0tvM0tBVnF1dkZadDJCZzFvaVdZOHlEZFQ3WTRPS0pUOHhvaEh6Y1ZaS05tMU9SV2pHY1lyTnRRZHRhRVk0RlpNdEZrUG1uWnFKUmlndmlrTW16U1pxSVNVMXBRS0FKeXcyMUNaTUdvalBVVHlFOUtUQW5lUUVWQTBudlVaYzRxQjVDTTBESkpIeFZkNWdLclRYT085VUpidm5yUllMbW41L3pWS3M0NzFpTGQrOVBGNk05YXF3cm02c3d4UytlRDBySVM2M2RLdFJPV05Ld1hMbStrREdrQXlLY0k2TER1UFZxY1c5YVp3T3BwalNZb3NJSk1WU2xVYzFKTE5WVjVDYXBFc2pjN2VsTTMwT1NUVGVhb1JyaGVLa2pVRTgwd0ROUFhnMW1XVEJRS2NLWm1sM1lvQWZnVTByelRmTXBkMlJRQXVNVTdjS1puSnBjYzBBS2FWVHpTWXpTcU9hUUVnRktjQ2tveG1nWUtlYXNSMUNveFV5OUtCRXdhb3BUUzlLaWxiNWF0Q0trd0JCcW1JLzN2TlduSkpOUkloTWd6U2V3STBMYU1NQURXakRaSzRIRlZiT1BnVnVXNjRGYVJNWk1vUHBTSGtqUDRWZ2E1cHFMYnRoZTNwWFpzK0s1L1huRFFOOUswdG9LTDFQSmJsZHM3RDBOUmlwcnovajdrLzNqVUZTZEJNaHFRVkVocVFVQVBCcGFibWxCb0FYcDBwNlhCUWptb3ljMUcvU29sRk1hbFkxWWRReHdlbFc5MGR3T090Y3d6c2g0cXphNmdZMkdUaXVLcGg3YW8zaFZYVXRhaHAveXNRS3cyODIzY2p0WFNyZlJ6cGhpTTFCTlpySXZBSE5ZeGJqb3luWjZveVlOUUlPQ2EwNEw0TXZKeldaZGFjVUpLREZVUkxMQzJDS3JsakpFOHpSMWFQSEoxcHpXOGJqaXVmaDFBZ1lKcS9GZjVBd2F5ZE5yWXRUVEo1dE1SczhWUm4wWWJUZ0d0Rkw0SHJVNjNDUDF4UnpTUTdKbktUYVpMR1R0elZHU09TTnVWTmR3OGNicVR4VkNYVGtmdFdrYXZjemxEc2NsbHZlbEJOZEkybEovZHFNNlFwN1lyVDJrVFBsWmhBbWpOYm45anFPMU1iU1BRVS9hSVhLekRaeUtRU3RXei9ZcEo1cVJkQzlxZnRJaHlzeVVuUGVwZnRHUlcxSG9BOU0wOXZEd1BRVm02a1MrVm1HSkFUVXlOeFdrZkR6ZHMxWGwwbVczRzdxQWVhY2FrWElIRnBFdy8xYS9TZ0drWnVGeDZVTHlhOU9PeGdXSXg2MWFpRlY0eGhSVnFMQUFKNlVGa3lEUFdwUVBXb2xJM0FldFRBOWFZQ2pnMDdkVVRQaW5JMmU5QXJGaFdISEZTZVp4MDZWQ08xVERweFRGWWpKK2JPS2hjamNTYW5rNGpKcWxJK0RpaTRKRFg1ejZWV2tZRGlwV05WMk81OFV4MkdTTjh1QjFxRmp4VWttYWdaaWFCRFRpb1g3MDh0ZzFDV3lhQkVMMVdlclVneWZwVmFTbVNRTWVLamVudWFpWnUxVVpzalkxRXpVOXFpWVZaQTBtbWs1RktSU1lvQWpJcU5oVmdyeFVNZ29FeGdIUE5OYm1uanBUV09PbE1rYUNWVWoxcUxKTGMxTWZXbUVaNlVDRVU4aXUrK0dZVnRhTzdzT0s0SlVIZnJYZGZEWkNkYUxEb0JXVlRZdUc1N09jQVUwbkZSbDZidnpYR2RSTURUdzFRQTB1N21nWk9IUHJTK1pVRzZsRFVnSmkxSVRtbzkxRzZnQjJLQm1qZFJrVXdEYlNFWXB4ZW1GczBBTkxZcU15VXNuRlZYa3dhQkVyVFlxQ1NUTlY1SjhkNmdOeHpRQlpkOFZYZVlpbXZMeFVCa3lhZGdMS1RGalZtSmpWS0xIV3JTTjZVZ0xpTnhUODVxdWhKRlBHYzBoa2hHYWF5MDRkS1FtZ0NwTW02b0RCVjhwbW1GTVVDS1F0czlxc3dRNHFWVnFSUUJUQW1qVGlwbFVWRUd4VGc5QUU0d0tkNWdxdVpjQ28ybUZBV0xaY0dvM0lBcXQ5bzRxTnJuTkFyRmd5WXFKcGFnTXVhaWFTaXhSSkxQV2JjelpxZDJKcW5NTTB4Rk56a2sxSkMyTVUxeFNJY0dyNkVHemJTOFZmU1hnVml3UzlLdlJ5OENwWlJwK2JrY1ZHejFYV1hpbXRNUlUyR1RtVEZSRjl4cXU4eHhVUW1PYUxBV2pUaHoxcUJaQ2FlQ2FMQVNzRkMxblhNZ0djVmFkamlxVThlN05GZ3VaRnpNUTFaOGtqRnExcDdiTlUzdHNOMHpXaVNJZHlubHFsakJKcDVnYnNLa2pqWU1NMVdnbGNzMjY4VnBRamFCVk9GT2xYWTFhb1paWlZqaW5ieUJURk9GcHJHcEdEdVRVWkxHbll6U2hjMEFRTWhOTThvMWJFZEtZOENnQ2c2WXFBdmcxYm1HQlZNamswQ05aR1Blblp6VllOODFTcXhwRkV3WTRwcGx3ZWFhWHFKbXpRQlpERnVsT1VHb29UVmxlUlNBUmMwNDVvSXhUMUhGSUJBS1ZSU21sRkF4NHhTcU0wZ3FSUlNBTVlwNjhVbEtLQUZOUk9NOFZOak5HMnFRaXI1TlNSd2ZNS2tOT2pQTk1UTHR0RUZyU2lxaEMxVzFmaXRJbU1rUGw0RmMzcmpmdVcraHJjbGw0TmMvckxaZ2I2VnBjbU81NWpkSE53LzFxRVZOY2ovU0grdFFnVkowajFxVUdvaFR4UUlmbWxwdEtEVEFkVFc2VXVhYVRtZ0NKaG1xMGlrY2lyWkZST3ZGQWluOXFlTnVTYTByUFZzQUs1NHJQbWlEQ3M2WVNRdGxheG5SVWlsTm83VVNRM0svS1JtcWR6cDZ0MEZjM2JhdThMZk9jVnVXZXJwSmdNd05jY3FVb00yVTR5S3Mybk1uS1pxSFpMRjJOZEtqUXpMa0VVa2xrcktjQVZITzltUGxUMk9iVzZaVGduRldvci8zcXhjNlVEeW81cWkrbXlJVGluZUxGN3lOQkw3Z2MxWVM5WDFybjJqbWk0d2FiNTBpZ0RtajJhR3BzNk5ic0dwQmNweG11ZWp1V0E1cHh1em5ybXA5a0hPZEQ5b1NnU1JucFdDbDAzV3JDVHNhWHM3RFVybXdKRUpxZU4xcklqZGpWeU5tNHFKUktUTlNObHF3R1R2V2RHeHA1bE5aV05FelJEUkhyaXF1b3hvYlZpdnBVQ1NIUFdpN2wvd0JHWVU0TDNrRW5vYzg0K2MwNUZxYnl3VlpqVVFQcFh1TFk0N2FrNjhMVXF1UmdWQXB5dk5PSERVeG9zaVQ4NnNSTnVQTlVONDlhZXN4UEFvdU94Y2xLY2JlVDNvalB5MVhEY1V1LzNvdU94ZVNRRHJVd2s0ck9XVDNxZFpkcUhORndzU3l5RUwxeUtweXNHeVFjVVN6MVVrY21pNGNvOW55T3RSYnVDYVl6L0xnbW95NDlhTGh5am5mTlYzZmlsWnFnZW5jaGlPOVJsalRzWnBwL0lWYUlZaFBGVjNxZGlNNHFCeFRJSzdpb1dGVHlkYWhQTlVpR1JGYWpZVllZWlhGUk1tS29sa09LYlR5TVUzRk1rUDRhaVlEQnFRMUcvU2dDUGJ4VWJqRlNyeWFSc0RORndhSURrQ21sdlNwTUJ1S2paUUc1cGsyRlZqWGZmRElNZFNjam9PdGNBcTk2OUErR1JZYWcyM3Azck9wc1ZEYzlhZnBVQmNpcFQ5Mm9HNjF4SFVQRWhxWlh6MXF1S1VOZzBBV2dhTTFENXROZWI1YUxESnk0Rk5NbzlhcE5jVkUxeFFCbytiNzBvbTk2eXZ0R085UEZ4bjFwMkVhZm0wR1hGWjMyakhlbU5kRDFvc0JibnVNRHJWQ1c1NjB4NXQxVlpHNjA3Q2JHelhOUnBMdU5ST3BMVkpHdFhZaTVZenVGT0VXYVNNWkl6VnlOQWFrb2pTUDBxZU9NMUtrUXF3a1lBcVNoa2FrZGFsb3lGcHZtQ2tBOGRLVEhOTU13cFBPb3NCS2NEclRHMm1vM200cUF6YzlhTEFXY2dVaGt4Vk43aW96T1RUc0JlOC9BNjAwM09POVVkNU5OM0UwV0F2RzU5Nlo5bzlUVlhCcGp0aWdDNFp4NjFFYmpCNjFSWitldE5KTFU3Q3VYemNEc2FqYTU5NnFxclU0cFRzSzVLWnM5RFVMdVNhVUNuQk0wQ3VSRmMwM3l1ZUt1Q0xpazh2bW1CRkdwQnEwaElwZ1VWS3EwbU5FcXNhSHppbFJLZnNxU2lzUWFic0pOV2pFYUZqb0FqalhGVERBb0NZb29BVnNZcUJ3T2FrYk5KczNVQVVuVUdxNWd6MnJTTUZJWXdCelRFek1NSUhha0VZSGFyVW9BemlxelBpcUpKSTFHZUt1UmpBcWxISlZtT1VVTVpJYzB3c1JVbThHbXNQYW9LSTkrYWtqNXBnVEp6VWtZeFFCWVZSaWtrQTIwcW5BcGtoelFCUW54MnFEWXRUem5iVkJwZm1OSzRHaXZBNlV1OGlsT0RURzRvS0kzbHdlYWI1dzlhaXVHcXFzakZ2YW1JMllaTWdjMWNoYm1zaUdRaXJrTXB6VU1ab3NSUU9hcnJKdXFhTSt0SVk0ZzA1UlNqbW5xS0FCUlVnRkFXbmRLQUduaWhUU05UYytsQWlkV3pUcWhRMUlEVEVLUlNvdklwS2tUazBBVHhuRlQ3amlvVUhOVFk0clpHTXR5S1FuRlllcm45eTMwcmRrSEhOWWVycis2UDBxaExjODF1djhBajRmNjFFQlUxMk1YTC83MVJnVUc0b0ZMUUJTNHBnQXBhTVVVRWhTR2xvb0FhYVkxUE5SdFFCQzRxck5HR1hwVnRxaGNVQ01hNnRPcFdzOFhVMXBKa0U0cm9KVXlLeTd5MkRBNHFySjZNaDZGeXc4UmRBV3dmYzEwVnByYXlZeTNGZWEzRUx4TVNweFNXMnF6V3pZSkpyR2VGVXRVVkdzNDducjhWM0ZLTTVGV1BLallkQmsxNXRwL2lNOEJtcnFMTFhGZFI4MmE4K3BRbEY2SFRHckZteStueHY4QXdpcTB1a28zUmFuaTFGSDcxWVM1VnU5WSsralhSbVdkR0dPQlVYOWpFdDAvU3VoUjFQV3Boc05MMmtrUGtSenlhT1MzU3JLYVh0WGtWdEtpQTA4cXBGUzZqS1VFWW9zUXRUTENGNHhXZzBRcUpvOGRLWE1IS2xzUWhCaW1GZUtsSXgxcHBOQURGNEZNdWlERmcxSVJtb0xsZmxxNGZFaFMyTWg1U3JFZGpUVWZOTm4vQU5hY2V0TVg3MWV5dGpsTHFjcUtVNURjK2xOaDZETlRPdVJtZ1pDM0l6U3ErS1J1S1llbEl0RTIvd0JUUnY1cURtbnJTS0xBYjBxWHp2M2VLcnFhY1NBdEZ3c1JTeWVwcUx6U1ZwWlRVSFFVN2dLWEpOTmM4Y1V3dHpTRTUrbEFDazhWR3hvTFUwbXFSbXhSU0U0cHU2a1pzOFZhTVpDUCtsUVNITlM1K1htb21wa2tMaW85dFNzYWFUVEVNd0JVVG1walZkL3ZWU0V5SS9lcERTbnJTR3FNN0ViVkUyYWxhbzJwZ01CcG1hZGltbWdRd25hMUllUms5YWRqbm1ra1BHQlFBMEd2VWZoaGFJSTNuSTVQZXZMUndCbXZXUGh5NS9zL0JIRloxTmlxZTU2RXhCRlYzUHBUeWZTbU5YSWRCSHZ4VFM1OWFVaW1rVUFHNCt0SVNUUWFhV3hTQWF3cU1xYWV6VXd2VkNHRVk2MUU4b1h2VHBINHFwSmswN0N1T2t1c2Q2aE4xazlhcnpxMktxWllOVkVtc2t3UGVwUVExWjF1R0pyU2hpSnhROUJpZVZta0VaRlhGaTRwaktCU3VGaU5UZ2lyTWJWVGRzSGlsV1lpa05HcEhKanZVbm5lOVVJNUNhbERWSXl5Wk1qclROMmU5UkYrS1p2OTZCay9YdlRHYmFPdFJ0TmdkYXJ5UzVIV25ZVnlTVzR4M3F1WnlhZ2tjbDZCazFWaWJrd1lzM1dwMFNvb29zNHE1RkZTR2hBbnRSNWRXMWdxUVExSlJRS0dvcEl5YTFUQlVid1VETVl4VXF4NDYxZWtpeFZTUTQ2VTB5UTRGTVpoMnBNNXB3aXpWQ0JlVFZpS01HbXBIVnFPUGlnQUVRMjFHOGVLczR3S3F6eTdSUUlpYmlsVjhkNm9UM29VMVhPb0R0VHNCdXBKNzFhaVlIR2E1NksreXc1clJndWdRS2hsbXhzQkZOOHNEdFVjTnhtcGk5U0Ewb01WRWR0T2VVQ3E3eWM4VURITVFLYjVnRlJPeHFNdFRFVHRMbGVLaGFRbW1GcWpKcGlFa1lFYzFUbElxZHptcTdvVFRRaUpaRHVxM0V4UGVxb2l3MVdvZU1WUWl5bWFzSXVldFJ4QUhGV2tVQ3N5eVB5OFVuU3B5dFJzdEFDQTB4enhUZ2hwcklhUUZLNEdSVkJvenVOYXJ3azFDWU9hQUpJbEpwTGc3VnFjYlY2VkJjcnZYaW1nTW1kOG1va1lnMWJOdmx1UlVpV2c5S0FJb1dabjlxMFkxK1VWSEhiNFBTcmNVZUJVakpJa3F5b3hTUko4b3FjS0tFaFhCUlV1TVVpakhOSXo4MDdCY2VLQ2FnTTN2VGcrUlJZWU9lYVROS2VhQUtWZ0FIbXBrTlFrVTVUaWdDVW1wNGg2MVhYazFPaHBBWElselZwWXNpb1lCeFYyTmEyaVlTS2NzZFltc0ppRS9TdWttV3NMV0V6Q2ZwVkJIYzhzdTEvMHFUNjFCVnkvWGJlU2ZXcXVLUnVBRlBBb1VVNENnQnUya0sxS0ZvWmFvUkJSVHlNVTJnUXcxRzFTR21HbUloYW8ycVZoVVRVQVY1T2xWSmhtcmoxVmw3MElsbVRkUWdqaXNTNWd3VGl1am1XczI1aXptdFlzeWtqRHlVUEJJclFzZFFtaUl3eE5WWjRzSGlwckNQZXhGVzR4YU1idEc5YjY2NmNOeFdyYitJQVFNdCt0Y3hkVysyTU1BYXFaZE9ockNXSGd5NDE1STlLdHRjRFl5d3JVZzFOV0E1cnlxMnZaVWtBeng5YTNMZlYyVlBtT0s1SjRQcWpwamlUME5id0grS3BGdXZldUdnMXhTZVhyVnRkVldUR1dya2xRYU9xTlpNNnRKdzFUREJGWkZ0ZG8yTU5XZ2s2NDYxek9MUnNwRWtpY2NWWEtuZFVubmh1OUFJcEJjYUZ4VUZ6anl6aXJETUtyM0grckpxNC9FaFBZd1pSKzh6VFZXbnk4dFRCWHNyWTVtV0lmOXFySjVTcVNIREExYVYvbHpRVWlPU29TZWFtbEdSa1ZBNDlLbGxJZURrMUlCVVVZK2JtckM4aXB1VU56VEhZNHB6RERVMStlS0JvZ2tiSXFNbmlwSEFBcUdSZ0twQ1kwMHgyd0tVdGtjVkMvTk1RcXRTc2VLSVlTL1NudGJzejdhWkJXeWFkSEd6TmtqaXRCTElBQUdwbHQxVmNWVnlHak5hUEZRTWhQYXRXU0pmV29HVkZwM0Z5bEFRazlhYThRcTQwZ0ZSczZuMG91RmlrNmZsVUVpYzhWZGNnNXhVREw4MVdRMFVYVXIxcVBOVzVVelVYa2pGVWlHaXN4NXBLYzY0Tk5BNjFabU1lb3ZyVTdEMXFKeG5PS0FHTWNMVWZVMDA1elQxWEl6UUppaXZWdmgrQ21tQXQzNlY1VXZVZld2WC9CaVkwYU1nWXhXTlI2RjA5enF2TU5IbUdrQXpRVnJtTnlObk5NTEdwQ3RReUhiUUFGalROMVJ0TUtpWnllbE1SWUxqMXBoY2V0VmlXcG1UVEVXQzJhTmd4VUtubXJTTG1nQ3UwVzd0VWJXV2VRSzBraEZUR0liYVZ4Mk0yQzNBN1ZlampBcFZpNTZWT3NacE5oWVp0NHF0SWg5SzBWajQ1cHJ3MHJqc1lza1p6VVJSZ2VsYTdXK1RVWnRxZHdzVW9TUVJtcmljclMrUUJTZ2JhQUdsVFRHR0tlOHVCVmVTYmloQU1jODFHZWFpZWZtaEhMVlpCTXFBMU1rT2UxRU1lN0ZhTU1IVGlrMk5Jamh0K0J4VnlPSEJxV09MQXFVTGlvYkxzS2lZVWNVYlJUcUtWd0dsYWhrR0tzVkJMMG9BejdnL0theVpudzVGYWR5MkFheHA1TXlIRldrUXlXSnNtcmFjOUtwUUFraXRXMWlxbUNKSW9pZW9xMnNRQzArT01BVVNNRldwWTdGV2NoVk5ZVjlPUmtBMXFYVGtnMWhYYXN6SGltaE15TGlaaTNXcTVtWVZlZTBkbTZHbkpwak5qajlLMHVrUlpsT0M1ZmVLMjdPWmlCbXE2NlNWNXhWeTN0OW1CaW9iVExWMGFrRW5xYXVCOGpyV2RHTVZhUW5OU1VTa1pOS0lzOWFjQm5wVXlxU0trWlZhT28yU3J4aXoyb01BeFRFWnZsbWp5c0hwVjh3WU5JMFdLQUtKZ3oycHBnSHBWOFI1b2FHZ0xHVzBIdFFzV0swVENLYjVJOUtMaFlpaFhwVnRFb2ppcWRFb0dKczQ1cU5rR2FzbE9LWVVxUUlDb0ZNeFU3TFVUREZNQ0pnTVZFVkZQWnFibWdDQTlLamNjVk1PYVh5dDFBaXNxNU5XRVVDcFZnMmdVOHhnRE5LNHhnQTlLa2pYSnFKbkE0RlN3dFFJc0t0U3FLUk1ZcHltcUVPZmhLcHlQelZpVnh0eFZLUTB3QXVNMUtqVlV4azFaakdLZ29zclM1NXBpbXBCZzB4QzlxTVV1UFNseFNZMEt0U3gvZXFJVkpHZWFrWnAyNXJSaUhGWnRzYzFwdy9kcmVKenlHekNzWFZrekNhM0pSV1RxYTVoTldUSGM4bjFWZHQrNDk2cGRhMHRkWGJxTFZtMUoxRGhVaWltQ3BZK3RDRXg0V2tJcVVMbWhseFZDS3JDbWJhbWNWR2FaSkVSVWJDcGlLallVQVYycUpoVTdDb1dvRVYzcXRMVnR4eFZTV21JcFRWUm1xOUxWR2FyUm16T3VGR0tOT08yNXhTejk2clJQc3VCOWExUmhJM3AwRDJ6RHZXZDltM0w3MW9vMjZNajFGRnVxc2ZlbXpKR1ZIQ2ZQVmNjNXJkVFNuYTMzZTFQaHNsYTZRa2Q2NnVHMFVXdlR0V2JrV2tlZFRSU1FTa0hQV3BZTCtXRThISXJSMXFFSmNIQXJHMjBuRlNSYWswYjlwNGdLa0JqaXQyMTE0TUFOK2Z4cmdTQ09sS2swa1orVW1zSllhTDJOWTE1STlPaDFWWDZrVmNTN1ZnTU5YbVVHcnl4SDVpYTFyVFhoMExHdVNlRmEyT21PSVRPOTg0ZXVhamxseWhybjdmVzFJSHpWZVMvamwvaXJtOW0wemRUVFFqeDVhazhzQTA2NW1XTEFIZW9mT0RIaXZSanNRVGlNRWNWT2tYRlUvTklHU2NBVTM3ZVY0SDRWUXk2VjJqQjZWR1lmbFBGVjB2SGR1YXZ3VEsvQnBEUlVDbFJ6VTZFZVhWaVVSTXZHQlZKcEZpWTU2VkRSUWtqYzFHWDRwa2s0ZnBUYzhVSVlqY21vSktsSnF2S2FvVEZXcG80Ti9PS3FMSnpVMFYzNVpJSkJwa21uSGJDSk1qMHBtNVVZNDYxU2JVeGpHNnEzMjlXY2pkUnFHaG90ZDRiYWFnZThLdDE0cW0wd2Q4NXBTbm5OOHRVUTJXUE8zOUR6VVVnWS9XblIyYmpuZFZnUmdKOC9XalFFbVVDU3luUFVWQTJmV3RGNGdCeFZTU0hrOFV4TkZSbklweXZ1Rk9hUEFOUloyR3JJRlljMG0wQmFES0diMHBHY0U0Rk5FTXJ5TGttb0NNVmJZZGFydUt0RXRFRW5Tb2U5VHVLZ0lKTk1raGs0UEZDa2hmYXBHVEpwcEE2VXlSMXV2bVhDTDJ6WHR2aHEyOG5Tb2dCZ2JRYThoMEcxODdWNEVLNUJjWkZlKzJOdWtWcWlnWUFVVnpWWDBOYWE2a2VNVUJUVnBvaG1sV09zRFlxRmFyelJGZ2NDdEZvdWFEQngwb0F3bXQyRGRLZXR1ZlN0Tm9PZWxPV0Qyb3VGak1GdDYweHJmRmE1Z3gycUo0ZU9sTzRyR1VJdHBxMUVLYzhlS1JPRFZJUlpWUUtjMU5Ya1VqVVdZRDF4bXAwSzFTREhOVElUVXNaY3dEMHBwV2lJNEZPZGxGU01hWXdSVUxydHA1bUFQV29KWmdlOU5DSVpYeFZTU1hGTFBNQm5tc3k0dWNFODFhUk55YVdmM3FCcEMxVkRLWGFwNDBZMDdXRmNNRXRWMjJpeVJtbXd3a25rVmRqaUs4NHBObEpGcTNod0JXakZIZ1ZWdHpnRE5YRVlWbmNzZjBGR2FhVFRjMGdKTTA0R29jMDVUUUE0bXEwN2ZLYW5jNHFoY3lnQTB4TXo3eVRBTlkrZDBuNDFkdlpSeldmRzQzMXBGR2JOVzBUMXJYZ0FXc1czbUFyU2l1QnQ2MFNHaStaTUNvWkh5T3RWSHVSNjFFMTE2R3BLSkpSa1ZWYUFNM05QODB0VGtCSnF0aERVc2dlZ3F5bG9vSFNwWWxxeUl5Y2NVbUJTK3pnOFlxRnJYRGNWcnJEVWNxQVVBWjZ3NHFaVnBIT0tZSk9hQUxjWUdhdElvcWhISU53cTBIK1drTXRxcTAwcXRWeEo3MDd6S1FEbUFGTndEVEhmaW92TXhRTXNZVVUxbUJxczBwcGdrb0FtSkdhVUFHb2QyYWNIRkFGaFJVeWlxaXlEMXFSWndPOUFGekFwcFVWWCswRDFwR3VCanJRQTk4Q3FVMG9HZWFXVzVIcldiYzNJR2VhYVFyajNuR2V0TTgvM3JMbHUvbTYxSDlxOS8xcXVVWE1kSEhIbkZXbGlHS1pHTVZMdnh4V2RpaE5tS2prNlZNZVJVTGpQU2l3RllyODFTQVlPQlVUbmFhZWhMODBBWFl4OHRPemlvVms0eFR5ZU0wQ0d1YzVxdXd6VTU1cUVpbmNZMVZxWk9CVEZ3S1hkVWpzU2cxSWhxQU5tcFZOQVdKd2FNMUh1NHBRMUFFaE9CU3huSnFJdGtVNkkvTUtUQTE3WHRXdEFQbEZaTm9lbGE4SDNSVzhUbWtPa0dheXRSWE1KcldrcWhkeDc0aldoS1BLZkVjZUw3Tll1TVYwL2lxRXBPcHJtMkZROUdkU2QwTkJxUkRVV0tjdEFpMmo4VXJ0VUFiRkJlbUFqbkpwaG9KcGpHbUlDYWpZMEZxWVdvRU1hb21xVTFHd3BpSVg2VlVsRlczNlZWa3BvVEtFd3htcytmdldqUFdkUDNyUkdjalBuTlVqL3JBZmVyZHhWTnZ2VnFqQm5RV3JibzErbEpDK3k0SVByVE5QYmZBdU8xRjBQTHVNK3RCbDFPaHNXRHV0ZE9uL0hyK0ZjZHBVd01pMTJFSnpibjZWaEphbWlPTzF3ZnZpZmVzUXJYUTYybjd6OGF4ZHZOYXgyRklyRmVLaksxbytSdVdxOGtMS2VuRlVUY3FGYVFaSFFtcGlsTkswV1FYSVRlU3duaGpXanBPc1N5WDBVWlk4c0t5TGdWWThQUiticmx1djhBdFZuVXB4YXVhMDV2bVNQVFRhK2NkelVvdGxBd0t1bEJIR0EzcFZlU1ZFQnJpdWVvbzZFY3RzcktBRDlhcnlXMnpvT0tyWG1xQ0VFN3VuTlVtOFMyenhqNXZyV25LN0V0eFJha2tFYmRjVkMrcCtTZUdyQzFIWElaQis3Ym42MWt2cVN2MVkxb29ObVRxSlBRNjk5ZEJHTjFWMjFiZmticTVwSncvUTFZaUc1eGlqMll2YTNPa3Raekl3NTRyU1k4Y1ZpMmFNcWl0T01uYnpXVWxxYnhlZzVtcUNVNFhtcGlPYXJ6cWFFTzVXYVhhcHFoSmViTTRxNUtwMjRHTW1xTTFxVGl0RVpTS3IzYms5YVJMaVRQV3BoWm52VlM0SkRGVUhUdlY2R1dwY1c5OHRnWGFya1dzVzhZenU1cm5YdHBuaGVVQWtEdmltMk9tdmVZOHlZSUNjQ3JqVFVqS1ZaeE9yWHhIQVQ5Nm1OcjhiUHd3ckJuMEVSYnRrKzVsNmlxY1ZyT0p3dUNlYXAwTENXSnVkZkhxeVNjRnNWSWJ0R0hCcm5wZFB1SW93Y0dvRnVKSW0ya2tIM3JKd05sVnVkRzBnUFNxOGpjMW14M3g2TlV3bjMwbEZvcm1USkdiMHA4ZVNLcmxzMVp0eGxhb2tjYWdZYzFPL0hTb1c1cG9HTVpjaW9XR00xYUgzYXJ5Q21RVlpEak5ScXc3MDI1ZkJ3T3RRb0hKcWtqSm5UZUU4dnJrQUJ4ODNXdmRyWS91VkI1NHI1enNiaWF6a1dXRnRyRG9hOUU4S2VPWmZQUzMxRTdnM0FiTlkxWXZjMnB2b2Vua1VLZWFySmRxNmdxY2c5S2tXUUVpdVEzTE9BUlRlQlFIK1dvbmxBTkFDc3ZOQ2tBMUUwd3hWZHJqQm9HYURFRVZXbHFFWElJcGp6ZzBXQVpLcE5NUlRtaHBnYVlKUURWb2hsdFZvSXlNVkdrNHAzbUN0Q0JObUR4VWk4VXd5REZNODNtc1dhSXMrWmhhZ2x1c2Q2WkpLTnRaVjFkYmM4MEpEWmVhNjY4MUE5Mzcxa05lRWtqTklKR2J2V3FpWnRsdWE0TFp3YXBQdWR1YW1XTXRWbU8yNDVwNklSWGd0aWVhMFk3YjVSeFVsdkNCaml0Q0tBRmVsWnRscEZXS0RCNlZhMkFMVTZ3NEZOWkRVbERFNHFRU1lxSWdpa3pVakxheWluYmdhcGJ1ZUtsUi9XZ0N6VGh3S2lEaWd2U0dFcmNWbFhjbUFlYXV5dmlzZS9rK1UxYUlabDNrK2M0TlZvR3kxUTNFdVpEejNwWVRnaXQwdERKbXRGd0tuRTJ4YXFRdm5GVGxTYWxsb2E5d3hOTEd6TWVhY0xmUE5XSW9LalFxeFBBdnJWeEVHM05ReFJrVmJpak8ycGJIWVZBQlZxTmhWWmdWcFVZMHJoWXVNL3k4VlZsSk5QQnlPYVk5TzRGRzViYlZWWDVxeGRmTWFxcnczTk1SYVI2c3hTWkdLcVJEY1JpcnNNSm9BZGswdWFjVngxcUYyeFFBck54VVJhZ3Rtb0pHMm1rTWxaaGlveklCVUxPVDBxRWhqUUJZYWZIU20vYWNkNnF1Q0tna2tLclRzSTBmdG1POUo5dDk2eEh1RG1tZmFTTzlWeWl1YnYyMzNvTjl4MXJuemRuMU5OKzBzVDFwOG91WTJaYnpQUTFuM0Z3V3pnMUdqTTNlbDhrdFJzSmxZalBXa3FkNHR0Vnp3YXNnN2FNK3RUY0FWVTNrVklraDcxZ2JGZ3R4VVpZVW1jMUZKa0dnWkZPd3pTeE9NVTExTDBpSnROSUxGcFB2Vkt4cUZLblVicUFzTnh4VWJDcHlNVkV3b0JFUW81cHdITlB5QjJxU2hxaXBBYVNsRkFEMXBTYWpMWXBRMmFZaVFETlN4TDh3cUpUMEZYTFpDMUlSb1dhOEN0V0hoUldmYkxnQ3I0TzFhNkluUElXVjZoM0JvMitsTmxZazhDb1dKUlRuMHErcEtSdy9pOUFZOGpzYTQ1cTdIeFQ4MFRZcmpYNHFYcXpvanNOcFJRdExpZ0JRYWFUUWFTZ0JDYVl4cHhxSTB3R2swM05PTk1OTVFFMHhqU2swMWpRSWplcXN0V21QRlZwZWxOQ00rZXMyNHJSdURXWmNIcldpTXBHZk9jMVVQV3JNMVZtclpHRE5iU1pNcVZxM2ZybEZiMHJLMDJUWlB6V3hjZnZMYysxQzNNbnVHa3k0blVlOWQvWm5kYmZoWG11bnZzdkVIdlhwR2xuZmJmaFdNOXlrem45Y1RrMXovZXVuMTJQQU5jMWo1cTBqc05seTNVTmdHcEpMVGNEeFJhUjdpSzBraW9JT2Ruc3luSXFrNmxUelhWejJvWmF3NzIxMms0cWs3Z1lkd0t1K0ZVM2VJSVQ2YzFWdVVJSnpWL3drTWE2aFBwVXorRm10UDQwZW1YMGdXTUgycms5VjFjeE1WVTF2YWhQdXRtNDVBcmhMcU9XNHVEdFZqWEhUVjl6MDV5c3JJcDNWN05kU2JRVHlhbzNGdEtrZ1U1R1JYUmFYcEJhK2pNcTRCUE9hN0h4RDRPRW1reDNOaWdkbFhrQTlhNlZKTFk0NXhrMWM4NHM5SnQ1Z1RMTHlCbkFwWDBxQXJtRnFsYTNsZ2Nyc1pUbkJHSzJkQzhQWEYxZnhMT2pSeEhrbHU0cm9jNHBiSEw3T1Y5eGJEd2pjU2FhSnRwSVBJTlB0OURtaG1QbUtRT3hJcjFpSmJlMHNJN2VLTm1DakhDMVJ2dGd0MVNTejJxejhQWExLVnpzcHdkamhvN2NyeFZwSXNWZm10Z0xobFFjQTArTzFKSXpYTTNxZDhZNkZXTzFNaEFGSmNXTEJlZXRiMXJaOUNLbnViSGRHU3EvalRKYTFPS2UwdzNTbzN0OFo0cm9yaXhLdDBxczlvTzlPNGN0ekJXMU1yN1FNVlFtczkxNkxTMkc1bVB6TlhTZVdJbUpBcTNZYWRiT3l5aGN1ZXBxMUl4Y05UVDB2d2ZiU2FHOERxcGtkT3Z2WG0rcjZOZGFKcUR4eUlVMm41VGl2VDBrTnVwRWJ5QWdjWU5VcGwrMVlsdXRzMGluZ01NOFZVS25Lek9kSnlQS3k3dElTV0pMVjAzaHJTSkxtZFpwbHhIMnpXcmVhTGF0SUo0b1ZCSkpaUU9sV1lvMldNSWhLcmp0V2txdDBaeG9PNUpxbGxiUlJIQlVuSFFWeEdvMlVqeUZrajQ5Y1Yxd2hrWTRseWVlQ2FHdEFSaGhXWHRYc2Ird2ljTkZaU01NVklMZVNQZ3JYVVhOa2k4cGdIMnFvWXZVVlNrbVM0V01aSW5iZ0RtdEdPRXh4Yzlhdnh4SXFqQ2pQclRKVjROSnNhVmpPbEdLcms4MVp1RHpWWHZWSWhqMXFHY2ZMVXk5S2huKzdUSnNaekp1YzVwMjBScmsxTHR4a21xazB2bWNEcFYzSnNoSHVqbjVlbFQybCt5eUtRZVFldFVQYW53akVsTG9LOW5vZTZlSGRRTnhwRUxNZWR0YjBWd09LNGp3akt6YU5IK1ZkS2tqVnh5alpuVEY2R3o5cTk2aWt1ZXRaKzlzZGFaSTVDMU5paXhKZVk3MVZrdlI2MVF1WnlDYXo1TGsrcHFsRWh5TjViem5yVG11K09EWE0vYkdIYzFLbDB6ZXRWeWk1amFOMWs5YVUzR085VUlpVzYxTGdtaTFndVhVdXZlcGt1Q2U5VUk0am1yY01aeUtRRnhHM1VwR0tJNHlCU3lIQXJQcVdVcnE0S0tjMWczVjBYYml0YS95UWF3WFFtU3RJb2lWeDhXV2JtdFMxaHpqaXFsdEFTUld6YXdrVlRZa2h5Vy90VmxJc0wwcWFPTGlwQWdySnMwU0lvMXdhdVJIQXFBS00xS3RSY1phVTVGSnR6VEZQRlBCb0Fpa1NvU3RXMklQV295b05BeW9lRFFYd0tkTXVDVFZTU1hBb0FuRTNQV3Axa3l0WlJteFNpOHdLcXdYTGtzbWU5WkYrM3lubXJKbnlLenJ4OGcwNG9sbU5ML3JUVnEzanppcTcvNnlybHUzSXJib1pHaGJRWnhWd1FuMHBsa0NUeldvSWhnVmxKbWtTdEhEbGVSVThjSUhhckN4Z0NnRG1zN21pSHh4aXAxQVZhalVZcFdiRklZeVFnMUVHQU5KSStLb3pYT3hxQU5JeWdDb1htck8rMTd1aHB3bHoxTk1STkljMVhZZk54VW04R25CUWFCV0pJQmlyaVNiUlZaUmhjaWpjU0twTVZpdzh2QnFwTE56VFpwQ3FHc3FlN0lwaU5BM0lwbm1lWTFaY2M3U1NZclN0MFBVMDdBV0VqeUtiSnRVVklXd3RVN2hqaWxZQ0dlWUFtcythZk5Qbkp5YXFzTTFhUkxIWkRDb1pEaXBFVmpTeXd0ak9Lc2dxNHlhbGpUTlJrN1R6VTBKK2JpcTZFcmN1MjhQTldtVGFNaW83ZklBcTA2RXBXYk5ET24rN1ZJam1yMDhMWU5WUEphaTRySFc0cHdHS2p5YWRraGF4TkNWVFRKZWxJcHBXNW9HUkE0cFY1YWpITlBXUHZTR1BIeWlubytCVFNPS1JldEFFaGJJcE90QlBwVGMwQUtGNXArek5OQnAyNmdCQ3RJRFRpM0ZOUEZBRFdwVVBQTk5JcDhhRXNLUUZpTk56aXRhMWg0RlZiV0RKcllnand0WEZHY21QaGp4VStNOENrKzZ0SkZJUE01clpHRzViUzFCVE5VYnlMYXVLMUZuWHkrdFVweUpEaXEwQ056ejN4TENmTGV1TGRLOUg4UndBd3VNZHE4OG00Skh2VWJNNkZzUUlPYWtJd0thdldudDkycUVRbWpGT0F6U2hLQUlpS2pZVlpLMUE0b0dRdFVacDdVeW1JYWFqSnA3VkV4cGlFWTFXbGJnMUs3VlZsYmltUzJVNTJyTW5QV3I4NTRyT25QV3RFWk1veTlhcnQxcXhMVURWcVlzV0I5a3luM3JvWTIzeDQ3RVZ6WSs4TVYydWthTkpjYWZIS3luNWhVT1NpeWVXNWdRL0pmRC9lcjBqUlh6QVBwWEFYMXExbnFZVWpIemQ2N2ZRWHpDdWZTcGtJZzE1Y28xY2tlR3J0TlpqM0kxY1hPcFdRL1dyZ05tdFlNQ0JXMUNxa1Z6dGhKZ0N0aUtmRkRJTE04WTIxaTM4Zld0a3Z2U3M2OVRnMElEazc1Y0dwL0N4eHJpZlNtNmd1R05SK0g1UEwxeUkrcHhSUFdKcFQrTk05R2tUZWhIWE5SVzJsUmw4N1JWbFJrMVpRK1dSWERzZXhaTXJQcHFMeW94aXBsbHU0NHpHc3o3ZlExZVdRT0FNVS95UlM1bWkrVldNYURUTGRybFpybGQ1emtqRmROYjNWdENxN0xkUVIwSjdWU0VTam9LbGp0L01QelZhazJadW5BdVNYOHM1K1VoVjdCUlZhK2tNMFFWM0p4eUtrZDFoVFpHTXRWZG95SXl6ZFQyb1lvclVvYkJ1SnFlSlFEbW8zYmFlYWI1aFBTc3pkSzVxUXlJZzVOU3RlUmhkdWF4Y3lFMHhtY05UdURpalV1eWtpaGxyTmtYNXFqYTlNYTdXNlVrZHlKRHpRS3cxb2xZNElvdDRwSUpmays3VnlPTlpPUjJxMGxzRGs5T0tkeVdpQkg4elBZMHBUQ25pa2EzWkRsZXRQUjhERGptbnVTUkxDcmZlRlBXMlJSVmhYVXR6Uy9LMmMwaDZGQjRnQWZUdFZPVHB4V3JNcW5pcytaUUNSUUJsWEdlYXFPUGxxOWNEclZHVTRyUkdjaVBmdEhOTmVRRVZGSklUVVpZbXJNaXZjSG1xMVR5bkpxR3FNMk9IRlJUSGlwS2h1RDh0UHFJcHpYQ0w4cHFKSWxmN3BxRzZUOTVta2hZbzFVUzJMTkVVYjJwc1grdHF6TDg4V2FpdEVMVEtCM09Lcm9SMVBZUEJWbVcwQ056M09hNlVXdUJVWGhTekZ2NGV0bEk1Mml0dnlBUlhES1YyZFNWa1pYa1lGVjVZemcxdWZaK0tyeTJ0U001bTVnWWdtc3FXRjkzUTlhN0tTMEJCNHFsSllxVDBxMUt4RGpjNWhiYzU1RldZcmJtdGcySTlLRnROcHErZTVQS1VrUXJVMFl5ZWF0R0NtZVh0TlMyVllrUmVCVm1IN3dxa1pzY1ZORE9CZzVxV05HcW9HMm9aVnptb2hkY2RSVEh1Yzl4VWxGUzdUSU5aUWhEU1ZwelRCbXhVS1JmTm1xVHNJbHRiY0FpdFdHUEZRV3ljQ3RDTk9LaHNwSWNxOFUxbHhVNmlrWmFrWlhIRlBCcDIwVWJSUUE1V3AyK29pY0Nvek5pZ0N6dXpUQysyb1BQcUdXNHgzcDJBbG1sem1zbTZtMm1uejNYWG1zaTd1dXZOWEdKbTJQa3UrZXROUzV5ZXRZOHR5ZDNXaGJyRmJjaG56SFFDNEczclZPNXVNNXJQTjRhZ2U0TEdueWk1aWZ6TjBsWHJiR1JXU2pjNXE5Qk5naWl3Sm5TMlRBWXJRTTJNWXJuN2E1NEZYUmNaeFdNbzZtcVpzcExsYWI1d0RWbkxkQURHYWFaOXpjVkRSYVpzQ2NZcGp6Z1ZRV1JzVWpsaUtWaDNGdWJvRHZXVk5jRjJOUzNDT1c2VlJlTncxTklUWllTYmJUeGNIZFZhT05pZWxYSXJiY1JrVTJLNU5FKzZyMGFGdWxSUVd3RmFNRVFIMXFXVWhxd25aelI1UkhhcjZ4REZJWVJTR1pFOFJJTlpzMXJsdWxkRkxCMXFsTEJUUkxNWklQTGJwVnlOc0RpaVdQRkVhNEhOYUlnazNaNjFWbmNVK2FUYXZGVVN6TzFNQ0tVRnp4VFk3Y3MzTlg0YmJQVVZaRnNGN1VYRVVWdGdvcEhRYkNNVm9HSDJwaHR3ZTFLNDdHQkpDQzU0NzFQQmI5SzBKclFic2dVNkszeDJvNXRBNWRSMXVtTVpGWFJIbkhGTWh0bU5YbGdJV2xjb3pwb1I2VldNQzVyVm5qd09sVXlocENzWE9LZGppa1ZhZnRPS2dvUUx4UVJpbkhJRlJQbWdBeU4xU3FjaXE2akpxWlY5S0Jqbk9LYXB5S2V5VTNBVVlvQU01cDIya2lYTFZjRVFOQXJsZFVwQ01HckRyaXFydjhBTlRBZlNHbUsyVFV5cHVwREkwWGMyQldoYndjMDJDMndSeFduQkIwcHBYWkVtU1cwV0t2SXVCVWNhYmFXU1hGYkpXTVhxRTB1QlZCcnZZVHpUYnE0NHJFdTdzak9EVGJIRkc4bXA1NHpWeUtiek9hNHkzdW1hWHJYUzJMNVFWbXBPNWJWaWw0aEdZbkh0WG1keU1TbjYxNlhycHlqZTRyenU2VDk4LzFxbTlTNHJRcEtPYWMxTHR4U0dxVEpzTlVjMUoycG9GT3dhWURITlYzcWR4VVRpZ1pYYW1HbnRVWk5NUTFxck9hblk4VldrcG9USW5lcXNqY1ZJNXF1NTRxaUdWcGp4V2ZOM3JRbTZWbnpkNjBSa3luSUtnWVZPOVFrVlprd2dUZGNJdnFRSzl5MEN3ak9rd0tCMFVWNG5ZcnV2WXdQN3dyM3p3dkdUcGFESFlWelZYYVJyQmFIbmZqbXhFR3FLNmpGWGRCZjkydjByVjhlMkcrTVM0NUJyRDBJNDJqMHEwN294bXJNMTlTWGRHZnBYRVgwZTJZMTNsMGhhRTF5R3FSYlpDYTBwc2xsRzJmYXdGYkVCeUJXSEdkc2xhMXBKa1ZiUm1hU3ZoYXAzcjVVMUl6NEZVN2g5eTBXR1lPb2NzYXA2Yy9sYW5DMmY0cXVYNjgxbXhuWmNvM29jMFMrRXFMc3oxbTJHL2I3Z0dyWlVOV2Rwa3UremliMVVWZkRDdlBlalBjanFpYU5CZ1lxMGdxcEdhdEkzclNMYXNTcW81cVFaUEFwaTgxWWpISXpSY214Skhhakc0OG4xcXRla1JLZWF1U1Rxa2ZQSEZZRjNjdFBKak9SbWhzY1k2a0VybDNHUFdydHZiNXh1RkphVzZxMitRMU5QY3hxM3lFWXFQVTJTTHlhZkdiY3VTS3k1b0FXK1drazFOaERzQnBsdGVndU41NHA4eUo1V2pNdjRHQVBVVm54ek5DVG11dHVybXhtancrQWE1dStnaTNFeEVZcWliTXUyRjJHNkhtdHlCZzYxd1MzUnRyZ0hQR2E2dXh1ZDhLdXZlZ0ZabXM4WEhITlYyaTU2VmJnUG1MVDVJZU1xS2FJZWhtTnc5SVg0NDRxZWVIQTl4VkNRbEtZaVJwUUFjbjZWUW5reXhvbGs1cXZMSmtkYUJGV2QvbU5aOHJrMWFuNkdxamo1VFZvemtWMk5JVGhLVitsUnMzeTROV1pzclNINXFhQlN0OTZrSFNxTXdxQ2Y3dFRpcTkwKzFjbW10eVdVTGxlbFYxNE5TU3k3c21vQTJXclN4bGN0RnNRMWEwS0Q3UnFrTWVPcmlxVG5FWUZkRjRJdFRjYTdDY2NLYzBwNlJISFdSN2pZQVFXTVVZL2hVVmJXUVZuS3hDajJxUlhOZWQxdWR4ZkVncFNBdzRxc2hOVHgwaFdHTkZtb1RiWnJRVUFqbWxLcmlnRE1Oc1BTbzJ0aFdpeVZHVTRwM0ZZeTVJT0tweVJrVnRQSG1xMGx2dTVxcmlzWXp4RTgxWGRpblN0cDdmQTZWVG50ZUR4VHVLeGxHOFpUZzBuMndrZGFmY1doNUlxbDVMQnNHcUVXVW1MTm1yMFQxbnhSRVZZR1ZvWUkyYmFVWkZhQ1NqRmM1SGNiT3RYSTd6SUhOWnRGcG01dkZHOFZscmQ4ZGFlYnIvYW9zRnk2MG1LamFmRlVtdXZlcThsejZHbFlMbWkxd0RWZVdjQWNHczJTN3gzcXBMZlo0elZLSkxacHRkWTcxV2x1ODk2ekd2RDYxQzF5VFdpaVM1Rm00dWpucldaY1RscWtjczVxUHlHYnRXcVZqTjNaU1lrbWszVmVOb2ZTbEZpVDJxcm9pektLNVBTbmdONlZweDJPTzFXRTA3ZDJxWEpEVVdaTWFzZTFXbzQyclhqMHpBNlZNbW5nSHBVYzVweW1kRUdTckt5TTNGYVAyQWJlbE9qc01IcFdia1drVkkxYnZWdU9JbXJjZHBnZEtzUjJ2SFNvdVVpc2lacVRaaXJpMjFLMEZBek1raTNWV050ODNTdGN3MUhKRUFhTGdVSTdZVk9zTzFxc0lnelVwQUZLNDdESTF4Vm1NNFlWQnZGT0VsSVpvSzN5MDRNS3ByTjh0S3N0T3dpMDJDS3FUcUJVZ2Ntb1plYWFSTFptejk2cW1RamdWZG1IV29VaXllbFVTVnhHWk90U0paNGJJcTZrQUE2VktrZUtWeXJFVVVHTzFXRENOdFNwd3RPSjRxZVlkaXI1V0tZNmdIRldDYWFZOTFLNHlzWWdhY2tBQnFYWlRsUTVvdUJKRXFqNjFQaFF0Ukt0SzFNa2d1U29GWnJTQU1hdTNHY0dzeDB5eG9BMFJKaXBra3pWZkFGU1I0TkFFeElxTndNVS9GSXc0cGlJaGdHcGx4MXFMYmluaHNVckRITWVhamJKYWszSE5NZVFvMUF5MURHZXRXa3ppcWtGd052TldVblhGTkNHeTVBcWhJZm1xOUxNcHFxWTk3OFVtTkVjV1djQVZyV3NCSUJOUlcxb0F3T0syTGEzQUhTaUtKbElJYmZtcnFSN1JTeG9GSFNsWnNWcWtZdGlPMkZxaGN6WUJxZWFUQVBOWk41UGdIbXFCRlc5dXNaNXJEbnVDN0VBMU5lVEZ6Z0dxZ1FscXprelpJdFdDTkpPSzdDMVhaRVBwV0ZwVnNFRzlxMVpidFlvOEEwbzkySjZ1eUttc3ZsVDlLNE82SDc1NjZ2VWJ3U0tjSGl1V3VEbVUwWHV6VzFrVldXb200cWRoVUxpdEVTeHEwK21VOFV5UmpWQy9RMU0xUXlIZzBES3oxQTNXcDNxRjZZaGpIaXEwb3FjbW9aT2xVU1ZINzFYZXJFbFZwS3BHYktzM1NzK1kxZm1xaE4xTmFJemtWWHFKaFV6VkV3cWpNdjZERDV1cVJqR2NITmUvOEFoMk1SYWN2MHJ4YndkWkdhL0RnWndhOXRzUjVPbmpQR0JYSFZkNW5SVFdoaGVOVlY3RnZwWEU2UjhzNEh2WFcrSjUvT1RaNzF5OW5FWTdqUHZXc1BoT2Vyb3pvcFV6RCtGY2pyTWVHTmRtaTdyY2ZTdVoxdUhodUswaHVaOURremtOVjZ6bHh4VlNRZk5UN1pzT0s2TEdack0yVnFCaGxUVXlmTWxLVStVMGdNTFVGNHJHYmgvcFc5cVM0RlliajVqUjBHZWo2SEx2MG1FK2kxcHExYy93Q0ZwVEpwS2orNmNWME1hNXJ6WjZTUGVvdThVeWVJbXJjWEpxdkd1TVo0cTNDQlVvNkdXRVE0cVlIQTU0cGlrQVUyU1R0UVprTjlLU0NCV05jVEMzUXMzWHJXcTBiU3RXVnIxbzV0eVU3ZHFUTFd4ekdwZUxab0h4SHlQYW9yUHhna3VGdU1xYWxoOE93YWkySldLbXJxK0FMS0xhelNzMmUxYVdoYlV4NXFybG9CMUlTb0dSc2cxWHV0V2EyaExLY25IU3VnZzhJMjRoVVJ1VkE3Wm9sOEhXNzh5TVNQU3BTamNibE94NTYrc1g5M0kvNzB4N1JrVlkwZldMeWFUeTdnRnNmeFYyaitHZE5neG1IUFBPYWZKcFZ2R3IvWWJkY01PdzZWcHpSc1pjczczYk9SdnA4dHh3YTZ2dzFLMCtuZ3QvRFdEY2VINzJhNE8yTUFFOTY2L1FOSk5sWWlOejh4NjFMczBYSGN2MjgreDhWcVJ1cng4OWF4cEl5ajhkUlZ1Q1loY0draTVxK3BOY3A2SHJXVGNydHJUbWNGYzVyS3UySHJUSXNaMDV4VldSdXYwcTFQeXRVWGJIV21nWkE3ZGFydFU3NHpVRG1yUmt5dTlWWkRpck10VTVUbHV0V1pTSXp5YUNjVWQ2YTFVWkJtcVdvTVN1QlZ2cFZHNGJjNUhXcWlUSXByRXpkYWVZQW56VklEaXBBQTY0TmFtWlRKM3RYcFh3ejB4bmVTNVplQndEWEFSV2JOT0ZRWjNIQXIzbndWb28wN3cvRUdYNTNHVFhQV2xaV05hUzF1YVhsWXBWaU9hdkdFVUxDTTF4SFZjaFJjVk1pMUlJaDZVOVV4U0dBWEFwQ2FmMHByRVVDSTgweGhTaytsSUtBR010TlpjVkthTm1SUUJXWkFhclRRakJyUTh1bVNSOGRLYUF3SjRxb3RDQzlkREpiN3UxVm1zUnV6aXFUSnNaUGs3YVk2NHJYbHRzTDBxaFBIdFU4VlNZakpubEtHbUplNDcxRGZ0aGpXZnVQdldpU00yMmpkUys5NmY5dDQ2MWdpUmgzTlBFamV0UGtGekd1OTl4MXFKNzNQUTFuZ3MxU0NKalJ5Mkhkc2ZKZEgxcXUwNUo2MUtiWmlLYUxKeWVLTkExRVhMbmlyc0ZrMG5XbHRyRmdlYTNiTzJ4MUZTNURVU2hIcHZBSkZUR3dVRHBXMnR2OEFLT0tScmIyclBtWlhLWUJzOEhwVWlXbU9jVnJtMTlxUHM0eDBwY3pLNVRNRUhQU3JLVy9JNHEwdHVNOGlwMGlGTG1EbEs2eGNkS2xXR3JheEtSMHBDb1U5S1Z4MklsajRxZUtBR2xWUWFzSmhhUXh2a0RIU2phRkZUR1FCYXFUVDBBSzBtS2llNEFxdExjWTcxWGE1RGQ2QUxuMmtWWGx1Z1RWS1M0eHhtb0RJUzNCcGFoYzFFbnBzdHg2VlVTUWdWSXFselFPNUxGSXpWWlVHb29Zc2RxdXhSWjdWU0ZjWXFrMUlPS3NlVUF2U3EweDIweVJmTnhVTWsxVkxpNEtnODFTTjJXNzFTRVhtYmUxU3dSWllWVGdZc1JtdEtCc1VtTkZsWWZXbmJNVWJqdHBwYXMyV05maW01b2MxRHY1NjBoa2g1cGVsSXBwNEdhUUFLT2xPQzBiS0FEek1VMHlacEdVMDNHS29SSEtBMVZUR005S3RNdWFac29DeFdaeWFkRElRM05NZmcwaU56VkVGOUd5S1UxREcyQlVqUHhSY0JDYWJ1cEMyYWJ0eWVLTGhZY1h3YWErR3BXak9LaktrVURIb01VOEU0NE5RWllWTkVDZW9wWEdTSXBiclZ5M2grWUdvNFV5M1N0T0NNREhGVXRTR3llM2hISEZYNDBDaW9vOEt0RFRBZERXaGxxeVozd3RWbm13ZXRSVFhHQjFxakxjMDdna1MzTng4cHJHdXBpMlFEUzNGMW5JQnFtU1hQTlRLV2hhUXpadWJOU1J3QXlDbkpHVFZxR0lENWpXUm9XWXo1VVdQYXMrOG1aMnd1YXN5eThZelVTb0hQSW92MEtWa1prMGJtSTFpekFySVFhN0dXM1V3WnhYS2FtbmwzQnh4bXFpQlZOUk5RV3BtNnRCQmlsb0hOT0FxaVNOcXJ5VmFkYXJTREZBeUJxaGVwWHBqZEtaSldiaW9aRFU4bFZYcWtTUXVNMVdsNjFZYzFYbDZWU0laU2w3MVJtNm1yMHZTcUUzVTFvak9SQWFqUDNxa05OVmN5QWU5VTlFWjlUMGJ3QllqeWxjamxqWHAxenRpc2Z3cmlQQk1JanM0dU1jQ3VwMWE1MjIrRDZWNTczT3lDc2prTld1QkpkN2ZlcWdVTElNQ3FkMWM3OVRJejNxNlRtTlQzcnBoc2NkYlZteFp0dWl4V1ZyTUlLbkk3Vm9hY2M4VTNWSXQwWjQ3VmEzTWVoNTdPdUpTS2lVN1d6VjNVSTlrNTRxaTNGZEtJTkszbHpqbXJ2OEFBZnBXTmJ5WVlDdFlObVBpZ0RIMU04MWh0OTQxc2FpMldOWTdkYVF6ci9COG1iYVJQUTExOEk0OTY0cndiSmlhVlB4cnNvMjU0cno2M3hudVlSM3BvdGhoZ1ZQSEpWTXQ2VTVaUGVzVHRhTkFQbW44SEdhcUsrNnB3eHdLb3pzVzEyNDZDb3JtTkpJeUdYTk5Sc2RUVFhrNDVQRkpqU1NJSWJLQ0pzaEJVL2txWHlSd0tnTXdCNjFidGYzaW5QSnBwWEpsTGxIQmtVYlJUMGJlY0VacXRJNnJLYzlxa3Q1dDdZVG1yU01wU0sxM0NNblA0VlZWaEFEVjY5WXN6YmhnaXNXNG41eG1xc2lPWXZSeUYrZTlYN1luNjFnUlQ3Y0hOWG9yN0svSzJQV2tVYXNzVzdtb1FOaDVxTkw0WUF6bWlTVU56VXNhQ2Q4THhXVk0rVzYxYXVKdHdBQXhpc3laK1R6UVVNZHhnaXFjaHo5S2taNmdaaHpUUk1pRjI2MUE3aW55dDFxczVyUkdFbU5rYk5VMys5VXNqRVZEMXJReGs5UTdVbFB4UVV3dE1nclR2c2pKck9WdDJTZldyR291UW9BcXRHZUtxSkRIWTVxUkJRb0ZhR2w2WlBxVjBzTnVoWm1QWWRLdHlzaWJhMk9sK0grZy93QnJha3NraTVqaU9lZTVyMjJPQVJSS2lZQ3FNREZZWGhEdyttZzZTcUVBeXNNc2E2SGRYQlVsek81MXhWbFlZUlNiYWVhS3pLRzBaQXBqSG5pa3lUU0FjVFVUVTdOTkp6UU1ZVFNnNXBqVWdiRk1DVEZQQStXb045U0kxQUR3S2F5WnA0T2Fka1VnS3hpOXFpZUtyM0Jwckt0QUdaTEh4V2JkSU5wcmNtUVlySXUwNjAweEhKYWdtWE9LelNwQnJvTDIzQmJPS3AvWkF4NlZ2Rm1Va1pnUW1wNG9DMkswVXMrZWxXNExMQkhGVTVpVVNuQlpFMW93MkdRT0t2VzlzQjJyUWlnQUhTc1hKbWlpWlg5bkQwbyt3QlQwcmFNSTlLYTBBeDBxYmxXUm5SV29IYXI4TnVGSXBWakFQU3AxYkZJTEU2UWdxS1ZvbEFwSTM0cDdOa1VobFYxR2VLajh1ckRZcENWQXBBUUZLUURGSzBnejFwUE5IclRTQzVLcllwak5USGxBNzFBODQ5YWRoWExRbHhUeE54MXJMZTR4M3BuMnZIZWl3WE5TU2ZDOWF6WjdyNWp6VldhL0FCNXJNbHUyZHVLcElWeTdOZEZqd2FoODF5MlFhaWlCZnJWeElodDZWVmhGSjVYTFZidGtMQVpwMzJUSnppcnRyYjR4a1ZPZ3g2V3hJNlZZaHQ4SHBWNjNnRzJwR2hDOXFUWlJXVkFwcTFHQUJVREhEVklIeU90SzRFekg1YW8zSE5XUy9GUVMvTURpaTRqR3ZNZ1ZVUmEwN2lBdURnVTJDeUpISW9USFliYkxuRmFVTVJ6elRMZTAybm1yeUpnZEtZaFNBRnFGaUJVckdxN0FrMG1NRzVGVnlPYXM0d3RSTmdHbFlkeFZIRlNyVWFuNWFVUFJZVnlZR2x6VEZJTlB4VTJLdU1KelVaTlNNQlVSRk1RbExpa0MwN0JvQXoyK2M4VUt1RFVRYm1ucmttbUlzcnppcHZMeXRRUjVGU2xpRnBBSVVBcDhhWk5RTXhwOERFMEFXU29BcUYxRlNFRTBvaExVeEVVY081dmFyMGRybFJpaTNoK2JwV25GRjhvcWtpSlNLc1ZydE9jVllYNWFzN1FvcUNSZ0swdFl6M0JwY0NvSG5xQ2VjRE9EMHFoTmVZelN1WFl0VDNJNTVyTm51K3dxdFBkWjZIbXErU3g1cVd4cEV3Y3MxV29sR09hclJSbXJzTVJOWnMwSkZ3T0trSitXbEVlS0hIRkFGWXJscWxWZG9Cb1g3MlRVNmpkU0dOWmo1QnJsdFlYOTdtdXZkUUlUbXVaMWhBV3lLMGlCenpDbzgxWWRldFFOV2dpUkRVb0ZRS2FrRFV4Q3RWYVVkYW5ZMVhrYnJUQmxkeFVMR3BtTlZwS1pKRTVxczlXR3FCNm9rclNWWGtxdzlWM3FrUVU1cW95OTZ2eWlxTW81TmFJelpYTk90bDMzU0QxSXBDS3M2YW02L2pIdlNsc1F0ejFmdzErN3RrSG9CVjNXcmo5MHc5cXE2RW9XQWZTcTJ1ekJZMjU3VnhkVHNXeHhjay8vQUJOVDlhNkNFN3JjR3VQbGsvMDB0bitLdXMwNS9NdGg3aXVwTFE0NmhwV0V1MlFWb1hpNzRUOUt4b1R0bC9HdHo3OXNEN1VHQnd1c1JZY21zVnh6WFU2M0Q5N0ZjeklPVFhWRjZFc2hSdHNnclRpbStUcjJyS1ljMUlya0xWQ0dYNXkxWmhIekdydHkyZXRVaWVhUXplOEpTYk5SS24rSVYyWkxCdmxPSzgrMGFZUWFsR3pOZ1pydmc0T0NEeGl1REVMM3Juc1lLVjRXSjFrTzJuby9OVnl3N1VnYkJybFBRM05GWk1WT2tudldXSlBlcFJOaGV0VWdab0djTFVFbDBDTUNzMmE3SXpVQ1hHNS9wVldNK1pYTlNOOG5MZEt0UjYzRGFOamcxelYvcXF3cVZWc0dzT1RVOG5KWTVxNHBzeW5LSzNPL2wxcXduSUo0eFZWL0VjTmxrV3lqSjdtdUJHcDRrQUxjWnFLNzFKbWszQThkcTBVV1pjNnNkcko0bU1qSHpDT2FnZTlqbkdWSXpYRXRlczNQTk9UVVhVWUdSVDVXVHpvN0ZiZ0JlU00wMFhtM25OY3pEcXdJS3lOZzFLTlJUdTJSUzVXVXBvNmlHL0dldGFzRjF1ajY5cTRhMTFCWG13RHhYUldzMkFveURrVm5KTkdrSktScHpUZFJXYk01SnFTV1FZUE5RZ3E4RE41Z1VqdDYxSm95RjN3RG1xenZpa2xsejFOUVNQbENlMVdqT1RDUjZydTNGTmFUcm1vV2t6V2lSelNZNG5OQUZDbW5nMVptd1ZjMDJRNEdLa0xiVjVxbGRUQkZOQzFKWlN1eUhmbXFnR0Qxb2xseVRWZHB3cDVyWlJNWEkwMGlab3c2Zk1QYXZRZmg5clZsWlRDR2FFYjJQM3pYblZqZW9od0IxNHJRZ1pyVzhqbWlmaGoycFNncExRSXphZHo2VVdSWlVEcHlwR1JUdWxjMzRRMUdTOTB0Zk9PU0JYUU0yYTg5eHM3SGFuZFhKUWNpbXNjVkdyVWpOU0dLVFNCcWJTR2dCeE5OSm83VTBta01heHFOalQycGhGQURNazFJcHBtS2V0QUV5c2FkdXhURjRvSjVwQU8zMGhlbUZxWVR6UUE2UTVGWjF4em1yem5pcU1neWFZR1RjUlpOVmtnTzdwV3UwV2UxS2tBelZKaXNWSTdiaXAwaDIxYlZBbzZVTVJTWUJGZ1ZQNW9VVm1UVEdQa1ZXYS93dkpwV0hjMlJPTTlhYzF5b1hyWE8vd0JvNDcwQy93QjNlbnlzWE1qZkZ3clU0U2oxckVqdWVjNXBXdmVlS09WaXVib25IclR4T0NPdFlLWFJOVGk0SVdsWWR6UWx1UXRWWkwwRHZXZGNYTE1UaXFNczdDbWtGelhONHZyVVp2QjYxZ3RjUFFzc2pFQ3I1U09ZM0d1ODFESmRIbXFhSzVBNjFNbHN6OVJSWUJETVdOT081aGdWWWpzVGpwVnlDeTU2VXJvZG1aUDJWMzYxTEZweExjaXQrS3hHT2xXRXN3TzFGd3NZOGVuN1IwcWVPenJZRnZnZEtQS0FxR3lyR2V0cjYxYWh0Z0tuMkNwNGw0cERFamoyaW1TOTZuWmhWZHpuTkFHZE8rR3BZM0pGSk1BWkRTS05vb1FFaEpOU0l1UnpVY2ZMVlpVOXFBRThoVDlha2pnQ2lueERMVk93d3RBRmM0SGFsN1VqRDV1YWFaTVVBSStCVUxVOW1CcVBGQXhWWElwUEozZGFsanFROU9LYUpaU2ROZ05WaTVVMWRtenpWUXBscVlrVFJNU0JWbnF0UVJ4NEZUSDd0U3lpR1FuTlJGdWFWMjVwaDVvUWlaR3pVbkZReEtSVTIybU14QTJlbFdJU0QycFVnRzNpblJwaHFsQVdFd2FWaFNJdFBaYzB4RmQ4WXFXM1htZ3hFbXJsdmI0SFNnR09TUE5UQ0wwcWFLR3B4RlZKRU5qTGVMRlhVQVVWR29DaWthVEhlcldoREhTdUJXYmN6QWREVXM4dkJyR3ZicmFPdE80MGlLNXVNRTgxbHkzZVNlYXJYMS8xd2F6MHVkNzhudlVzME5hRW1SdWF2eFFaNjFSc3p1eGl0cUJQbHJKbENSUjFjVDVWeFNJZ0FwZTlBeEdKb0NsaFR3QjNwSGtWRm9BUVJBRG1sM3FnNjFWbHVzRGcxVGx2RDJOT3dybCthNUJVak5ZV3BPR1duUzNSM2Rhb1hjMjhFVmFRN2xHVmdNNHFzVHpVakFscWNzSkl5YTBKdVJkS1ZUVG5YQk5NelJZTGlzMVZwRzYxSTVxSmhtbUJFVFVUMUl3eFVUMHhFTFZDOVN0VUwxU0lJSkJWV1NyYjlLclNkS1pMS2N2U3FVdldyc3RVNUJ6V3FNbVZpS3U2UXViOWZhcWhGWHRIR2IwVXA3RXgzUFR0SGsyMjM0VmphN2M1UnEwN0pHU3hKNmNWekd0emNzTTF5eFYyZFQwUnpjcmZ2Q2ZldW8wS1lQQ3ZOY3BLZWEyZkQ5eGh0dWVsZExSeVMxUjA3cnRteU85Yk5vZDF0ajJyS2ZsRmF0TFRpTUVldFNZR0pyVWYzcTVHWVlZMTNlc1E1VTF4VjdIdGtQRmIweVdVanpSakZHT2FYRmFrbFNlcVJCelYrY1ZVSTVvR05RbFdCSFd1MzBlOSswMks1T1dYZzF4T0sxTkZ2amEzUVZqaEc0TllWWWN5T25EMUhDWjJJZm1uYjZyZVlEOHc1QjZVb2V2T2NXajI0MUUwV1E5STgrRjYxQUhxQ2FVS3BKTkVWcU9VdEN2Zlhtem5kVkFhNGtLa0U4MVQxQ1ZwSk1KazVOWGRLMFAvQUplTHBkM29wcm9VVWxkbkhLVGJzak9MM2VvVC91WTJJSjY0cmMwM3daZFhoQm5ZalBZVmZqZExZNFZBbzloV2hiK0lQczMzVGpGUG5YUXFOUHF5N1kvRFN6TzFwMlp2VVZ0cDhQOEFSQmJTYjdiY1IwNTVyblpQSE1rUzRWNnBONDVuSk9KVzU2MCtZT1R6T2trOE42REFwVVd3SEhlc0crMGJTMWtPeUZRQlZLWHhVWjErWjZ6cmpXeTJjRW1uemo1STIzQzkwU3dZL3V4dHJHbjBQYWYzVXBxYVhVcEg2RTFMYUpQTzRKQng3MCtleGk0cHZRb1cyaTNSblhZK09mV3VtUzFsc1dUekczY2RmV3A3RzE4dkJhcnR3eXlRYkd3U09ock9VbElxTUhIVW90TVc5cXF5TU5wcVJ4aXE4Z3JNM3VST2FoZWJhcFhQRk9ra0FCSGVxY2pWckZHVW1JWlFYOXFibm1vODgwQTFaZ3l3alZJRGptcXl0aW5HWGF1YVpMMEh6eWhGckd1cmplM1dwTHk3M0VoVFdlN1pyU01UR2NoR2JtaDdabWo4eGNFRHJVSk85d283MW90WjNFRnNDdkt2eFd4amNoc1dLeUFNbVZ6WFdycGtVdW4rYkhKMjZlbFkraXdlVGRDSzZqeHY2WkZkRThYMk96bkFJMjR5QlFDT3UrRzJvSDdPMEU3Zk12SE5laWdaTmVSK0Z0dGxMRElXUDd6SElOZXR3bmRib2ZVQ3VHdkd6dWRsRjNWaHhPS1lUUVFhVUxYTWJrZVRSdXA3WUZSbGhUQVhOTkpwaGZMVWhOSVk4bklwbmVtN3FlS0FEYm1ub3RHY0NsQm9FUG9JNHBtZWFYZjh0TUJoSE5HS1JtNXBwYWdCNTVxdEpIelU2bk5ESm1nQ29FcDNsMU1FNXArekFvQWdFZnJVRXFZNkdyYlZBNmswZ01tNVVrR3NLNzh4R0lHYTZ0N2ZkVkM2c1F4NlZhMEV6bGpKSm1wWTVYRmFyYVlNOUtWZFBBN1ZwZEdkbVZvWlN3NXF3a1RPZWxXa3NnbzRGWGJlMXoycVhJcXhWaHR6NlZaOGdsZWxhRVZ2dDdWTXRzRDJySnlLc1lFbHEyNDhWVmtzaVR5RFhVTmFBSHBURFpoanlLRklkam1ScC84QXMvcFUwVmpoaDh2NlYwUzJJMjlLYWJQSGFtMndTTXlLMEhwK2xXNDdRRHRWeElQYXAxakFxYmpzVm83WVk2VmFpdGdPMVNJdFNBNHBYR1NKQUF0TzhzQ21ySlEwbEZ4V0ZiQUZWcER6VDNlb1R5YUFzT1UwNFNiYWl6Z1VoTkF4WlpEbmlveTNGREVIclRjMEFRT0N6MDdiNjFMdEJvSzVvQVlvK2JpcGxRbjJwMFVYT1RWbFVwaUkwK1dwSGJBcGNBVkZJM0ZBaUdSK2FZRG1oamswQmdLQjNHeWNVaWttbGtPYWpWc05RTzVZUUdwUUtnUnNDbmx2U2dRU0wxcXVWNXF5V0dPYWpKR2Fkd3NFWXoycFpRUXRTSUJqTlJ5bmlrd0ticWMwcWpta0xuTlBUazAwQS9PMnBCSU1VeGw0cG00Q21Td0VIWVVvZ0FQRk9VMHU0aW55aXVLSWoycGRob0VtS2tSdDFUWVlSeFpia1ZjaVNvNHg2VllqNG9RbVR4Z0NrTDRxTnBNVkU4dnJWWEZZbGVYM3FHU2ZGUVNUQVZUbnVjWjVvdU93KzV1c1o1cm50UXUrdk5TM3Q1alBOYy9kM0pmT0RRTXEzdDFrbkpxbkRkZnZCODNlbTNLdEpubXFzZHZKNW5HYXA3QWRmcDEwT0FLNksybnd0Y2pwaUZjYnE2TzNPVnJFdEdyNXd4MXBodUFLckZ1S3JTdVIwb0F2dmVERlZaYndZNjFueXl0NjFDek1hYUJsbVc3eWNBMUVITGMxRXFGalY2RzJKSE5XaUNrWTJkNmhuaks5YTNvclAyclAxU0x5NDI0cXJqUmtMdHp5YWxhUkZXc2xya3F4Rk5OeXpDclJMTE1zb0xjVkh1elVTL05VaWlnYUVOUnNhblplS3J1S0JrYkdvbnFScWhZNHBpSTJGUXV0VEUxRTVwa01nY2NWVmxxMC9TcXNsV1N5bEtLcHlkYXZ5OUtveS9lcTBaTWhJclc4TndHWFVoeDByTE5kTDRMajM2bitGVFUrRUlyVTd4N2Z5OU9BeGppdUIxMDRuSXIwNjZRQ3pQb0JYbG12eUJyNXdPeHJPbnViejJNT1U5YXNhVk41VjRPZURWV1NtUXZzbVZoMk5iczVUMGVDUVNXNHEvWVNZY2ZXc1hTWmZNdGxPYzVGYXRyOHNuNDFET2ZxVzlUajNSWkhwWEVhbkhpUTE2QmRydnRjKzFjUHJDWWtOYTB4TXd5dk5KVWpEazFHYTJKSzA0cW9SelZ1WG1xNUZJWkhpbktDRG1uYmFYYnhRQnZhUGY4QW1wNU1oK1lkSzFPUWVhNUdKMmlrRElTQ0s2R3h2bHVJOXIvZnJscTArcU8raFcwNVdYdDNGVnArVk5TczFRU3VLNXJIZnpYUlVodHcxeUdJeUFhNktGMUVZVTlLeFltdzFYRW16am1pVGJRb1dUTDBsdXNtYXpiaXd5RGc0cTZzeElwMk4vVVZsek5HL0ttYzlOcGtuVU4rZFYvc0VucFhZVzJuQzVrRzg0RmRMWTZMcDhjWTN4cXg5NjNqSzVoS21lVW14bC91bWdXRXpIRzAxNjFkNlhwNWpPMkpRZllWejF6WVFvK0l4VDVtaVBaM09WdGRHR1FaSzFZNGtnR0Y2VmVOdHRIU3FrNjR6VU9UWnFvSkRqY1lIRk1hVU4zNXFuSXhIUTFFSlRuclRzSnNzeW5QTlZwSDlhVnBSdHFyTEw3MDdFdGtFeEc3TlZuYk5PbGZKTlYyYXRVakdUSFpwTjFSN3FhV3FqTmsyL0ZWTHE2SEtxYWpudWNEQ25tcVJKUEpyU01UR1VoV2JQVTFFN1VydHhTSkUweE9PZzYxc1lHdHAya3hYZHFaV2t3M2FvRFBjSktJM0xGRmIwcExHNUZ2Q3lianViaXV0dGRIaXV2RDdTRkR2QXp1eFQzSjJMSDJFWFZsYTNNY2VDQ00rdFI2K3U2Nml0b2lRU3VXOXFsdWJzVzNodUVLelJTcjBIOTZxZGtKNzNVRW12QVdCWGcrMU9WbUtOelNzakpCSFl4QWZOdkZlMFdBTFdNUkkvaEZlTmVHdDkxcmkrYnpGRzVDbjhhOWRPdFdGcEVpU3pvcEF3UnVyaHhHck8yaG9pK3kwdzB5MnY3YThQN2lWV1BzYXNPZ0FybHNkSlVjRW5pb21HQWFuYW9uSEJwQVZpM3pVdTRZbzJITkJqTk1BQjlLbVFjVkdpMU9CeFNBVEZJVGluMHhxWURRYzBvb1VVNFVBUk54VEExU1NqQXFOZXRBRWtkVFl6VWFMODFXVUZBRWZsa2RxaVlFR3JUTmlvK0RRQkNGeWVhZjVXYVhqTlNkcUFJbWdHT0JWU1czeTNTcis0WXhVTWhBelFCblBiZWdwRnRjOVJWdmNDYWVvRkFGWkxUanBWcTN0d3JjaXBBT09LVWNHZ1pQNVM5cWNFQzFHcjBTTjh2RlF3QjhFOFUwUjVOQ21yRWVLRWd1S3NlRjZVeVNNVmFMRHk2cnNjaXFaS0srM0JwUU0wakhtbFZxbEZYSEFZb0lwYzAxbUZPd1hFNUZKazAwdlFIRkZndU9PVFQxanlLYUdGT0Vnb3NGd2FQaW9tWEFxUnBCNjFYZVg1dXRGZ3VOSU5BakpvOHdVdm1DaXdYSEJEVWl4K3RRK2FNOWFVVFk3MFdDNWJWY0RpbmdWVVdlbmk0QXBpSjJIQnhWYVFHbmVjR05PeHVGT3dpbnprMHc5YXROSGp0VVpTZ0NJakswaVIvTlU0U2xFWkJwREVDMEVZRkJEWnBlY2MwV0M1QzVwZ1lsdWFjeHhUQnlhQUxjZkswU0w4dk5PdCtWcFpoOHZGSmpNNTErYXBJK0tqa0IzY1ZKRXA3MDBERmxmQTRxZzgvekhtcnR3TnFjMWp5U2p6RHpWR2JOWkpRT3RLMHdKNHFzQVRUMVEwcnNxeFpUNTZ0eHBnVlZpUWpGWFkrMUs0RXlMU3MrMmd0dEZRU1AzTkFDbVVEazFCSk5VY3N2cFZLYTQ1TklkaVdlZkFOWlYzZFl6U3pUbGhXZGNicERnVTBPeFN1cmt1M1dvRWpMMU9iVm1ma2NWZnRiTElxaVRNRmlXNkQ5S3NKcHUzR1JXNUZiQWRSVWp3alBGREdqT3RyUGJqRmFjRUpBcVdHRUExWkNBZEtnWldkRFZhUkRXZ3c1NXFOMEZBekw4aG1QU25wWmtubXRHT0RQT0t0SkFLQkdmRFpZcTlGYmJhdHJDQXRHeGljQVZRaGdpeFdMcmtlWW4rbGRJa0pDL05XTnJjWDd0dnBUU2RnaTlUemlSVDVoK3RLcW1wcEZBbVllNW9DaXJ1VTBDVk9ncU1BQ3BFcGsySHNPS3J5Q3JMVkRJT3RNUlVZVkE0cXk0cUJ4VEFydFVMbXAzV3E3aXFJWkU1NHF0SWFtZW9IcWtReXRMMHFuSU9hdVM5S3B2MXEwUXlQRmRSNEtJUy9aajBBcm1NVnUrRzV4Qk81WTR5S2lwcWh3M1BSYjI5SDJDUSsxZVc2akw1bHpJM3ExZGZmMzQvczE4SHFLNG1jNVkxTk5GMUhjcHkxQWVEVTBocUJxMzZIT2RqNGV1ZDBBWDBycFlmdkExd3ZoeTQyVGJDYTdpM2ZLZzFtektSdDUzMmY0VnhtdHgvdkRYWFd6N29pUGF1YjF1TDVtTmFRTW1jcTYxRVJWbVJldFFNSzNKSzBpMUR0cTA2MUVSU0tJZ3RLRnFRTFFSaWdCdTMxb1IyamNNaHhRekNtN3MwRE5pMnZ2T1hhMzNxV1Z5S2kwV0h6N2dBYzgxMlMrRWZ0MXVTaDJ2aml1V2NVanRwVlpQUm5IcExnODFZamw1d0trMVR3OXFHbE9UTEV6UmorTlJ4VkMzZjhBZURkeFdWanFVamFnNUF6VjZNZEtvVzVHMzJxMmtuelZqSkhUQm1yYnRzeFdoSGVGY1lOWVluMjlhY0xyUFEwa3k5elpudnNxYzFubHd6YzFYTndOdkpwbjJnVmFJTE1oQVdzeTVma2lwSnJ2cGcxUm5sM1pKTkFybGFSaFZkbkFwWnBNVlFtbndhMGlqQ1RMRFhBQXFwSk9EVmQ1U1RVWmZOWHltYmtTcythakwxR3o0cUY1d085V2tRNUVyU1lIUEZWWnJuUEMxREpLWGIycGdyU01UR1V4ZmVrSm9KcHZVNHJReEdNVFZpM2NDRW9xL00zRkN3QnBSR3B5VDNyV3NkTVZOVmlqM3J4eWMweEErbVIyOWpFemcrYkljaXVwYlVVMDN3NEZHVmNyakJQV3NqeERjN2IrSlFGeEdPTnRSWHpYT3BhYXNoUUJJejFBcDZyWVdqSTdpUzYxR09FTUNZWXoxQXJvTCtSckszdFJiZ0JuWGJ6OUt0V2FyYmVIRU55a1pCSEdPdFp0NWRmYjlXdEkwVGFzWndUMk5QUVdwYTAxcDlPMHU2My9BQ3lMOHdZZDY1eVhWWkpaQzBzck1UM0pyYThTYWtxQnJLUEFmamN3cm5Zb292NGhtczVwTXVEYU9vOEtlSXA3WFVZMFdSaUMyTVpyMisybWE0dEkzUEc1Y212QXREYTF0OVNpa2NZQVlWN3JwZDliM2RsR2Jkd3dDamdHdUtyRzJxT3luSytoYTI4MDd5Y2luTHllS25DNFdzTEd4UWFMQjRwaFhQRlhIVVpxRXFBYUJFSVRCcHg0cVhhS1k5QUVSYkZSdTlMSWNDb2QxQXg0ZW5yVUc3RlBSK0tZaVYrUlRZNDhtbUdTcEkzNW9BbldNZzA4dUZGSXJnclZhV1RtaGpKSGNab0RaNlZWMzVxU0xKYWtCTXVkMU9ZOFU4UjhacEN2clFCWFo5dFY1SmQzRldKaFZYeXlUU3NPNDFDZDFXbHFOWXNHcDBXbUljS2NEU2RLS0FIQTB2V2hCVW15bFlMalZXcFY0b0M0cDJBS1loU2ZseFVUbmFwcHhhbzVPUlVzYUs1YjVxVld4U0ZlYVJqaWhhQXliZnhVYkhOUjc2YVpEUmNWaHpIRklwNXBBUzFPVmFkeDJIRThWRTB1S2N4SXFHU2k0RGpQbnZUUzI0MVd5UzNGVElEZ1V3RllrVkg1MVNrYmxxdXk0YWdra0V0UERacUFLYWxRSDBwZ1NnMGJ1YUZVbm9LWFljOUtSU0pveGtpcmtZN1ZVaUdNVmRpRk1RcnhaNlZGNVZXMnhpb3ppZ0NFUlZJSXNVL2dVaE5BREdRVkM2Y2NWS3pZcUpwUmpyUUJXa2pQZW9DTU9LZmNYSUFOVXhjWmZta0NOV0ZzS0tsZkRDcVVNd0lITldpY3JRTmtES04xSmtDbFljMUd3SW9FUVhrbVVyQmtiOTRmcld4Yy9kTlpEcGx6UWhHeVNGTlRSeUthYjVPK25pTGJWTUV5MG1Lc0k0QXFnSnR0U0xOdTZHb0tMRHlacXZMSWFWbXdLclNTODRwREdTTVNLclNLYXMvZUZSc2h6UUJTYUxQU25SMmVlb3E1SENDUlY1SUFGcWx1Sm1UOWlIcFU4VnFFSXE2eWhSVVc0WnFtU0N3Y1VwdDZuaTV4VWhROXFnb3FlWGpwVDFXcHZLOWFjRXdLQmxmWmswR09yQVROTDVXYVFYR1F4WkhTclVkdWMxTmJXM3kxZEVIeTFjWWtTa1ZWZ0dPYWtTQVpxVmwyaW9XbTIxb29tYllreEM4Vmc2dGhrWSsxYWswdVNlYXhkWG0yd242VTJPTzV3bDJOdDFKais5VVFhbjNMYnBtUHFhaEhXcFJ1eWJOU0llYWhCcWFQclRKSmlNaW9YSFdwaWVLaGVtSWdZVkE0cXcxUVBUQWdZVldsV3JMVkJKVFJES2JpcTcxYWZ2VldTclJESzBsVkhITldwVHhWUmprMWFJWTBWWnRKVEZKeFZmRlNSY05TWWthMHQyWkxiYWF5WlQ4MVdTZmxxcExUaU9SV2VvV3FaNmlJcXpNczZYTjVONGg5YTlDc3BOMFNtdk5ZanNsVStocnZkSW4zMnlIMnFHUlBZNlMxZkIrdFptdEp3ZnBWMkIrbFY5V1hkSHU5cXVKem5IVEw4eHFBaXJjNjRjMVhZVnFCWGNWQ1Z4VThuRlZKcGR2UTBoZzBnUVZBOXhWV1c0eTNGUWJpMURaYWlYRFBtaFpNbXF5KzlUSU9hbHMwVVVkajROaUVsNE0xN0hwOFVNTnNHa3dveFhrWGcxMGdjeXZ3QnpYcTJoV3N1dTJyc3BJUWNManQ3MXlPOHBIVEcwVVhqQmJhdENiZFkxZmR5MkJuQXJ6ZnhYNGQwNjIxYnliUnhDUXZQR0JtdlJORGNhUGNYY0RZTGdaK1kxNWJyMSs5MXI5dzcvM3lPS3BYMkRTOXpOU09TMmZZL0k3TU9sVGVaZzVCcmZGakduaDgzVDRZa2ZsWFArUkJIcGIzTjFMNUxFbmJuOUtoeHVheHFjbzVwOGlveGNZYms4VmlEVlVmaFhHZnJUeGNTTkh2Q3NVOVFPS1hzelQycU5kcjBFa0ROSjlxeU90WWh1am1rTjBhT1FQYUd5MDQ3bXEwOXlPY0dzeHJwajNxSjVpZXBwOG9uTXRTM0dmZXFFc21XTkk4Mk85VjNsOUsxU01aU0pDNDcxRTg0V29tY21valZwR1RrT2VjbnBVUk9hVTBocTByRU5pVW1hVTlLUUFzZUtvZ1E1cVNHTGV3SnA2VzdOMXF4SERzWEJwaUNKZktuRHIyOVJWeEpKcDdzRlZETy9BeHhpcTdRa2dBR3A3VjJ0WlEvQkk2VTBKazM5bTNEMzZRVGY2eGlPcDdWMU9xeHg2VnBNZHRzMnV3R2NIaGhYTlcycCtYcUJ1cmtieU9nejBxUFU5UnVkVXZJOE15eDV3dWFkK2hOcmw3V0w0M3NOdERZbGxUZ042VmVZUmFkYlJtY2ZPb3puUGVrdXJXQ3hzTGY5NEIzYjFGYy9xV3B2ZnpBZndyd0Q2MGJEM0lacmlTNXVubWtiY1dQWDJwNm1vWTFKNkROVzRyU1YvdXFhbGxKRGtmYWMxMVBocnhSTnBkeWdaeVlzOGpOYzh1bnk0K1lWS3RuSXRaeVVaYUZ4NWxxZSthUHEwR3AycXl4TUNTT1JtdE12a1Y0aDRkMTI1MGU1WExFeDU1RmV1YVRxc09xV3F5Uk1DY2NnVnh5aHluVkdWelFZNXFFL2VxUW5OSUJ6V2JORUg4TlF1RFZqaW1PdElaVVpDYWlNUkJxOXRGTWRNOUtBS2ZsazB1emFLbnhpbzNHYVlFSk5Ba3hTc3VLaXdjMEFXa200cUdZK2xOVElwK3d0U0FiSGttcmtLNHFLS1BCcXlvd0tZRmxSbGFZVjRwQTJCVVVrcEZBaUtYR2FnemcwMldZNXBzYjdqelNBdFJydUZUQk1HbXhjQ3BNMEFSdU1OUUtWaGswaDRvR09XcFFhaEJwNnRRQk9EeFRXTk4zWUZOTFpvRU82MGpMeFROeEZMdnl1S0JrYmNWQTJTYW02bWpaazBnSXdtUlI1T2U5UzdLWEdLTEFSckNWTlNpUElwd09hY0RpaXd5Sm9PS3J5eFZjWjZnbDVvRVUwZ3kxV2ZKQ3JUUnhVZ09hQUl2THF1NmZOVjQ0eFVESjgxTVJHa1c0OFZianR1S2JFTVZlakFJcGpJRmd4U05HQlZoK0tyTTlJQUM0cVFTYmFyaVRta0w4MEFXdk9Kb011S3JvOUtUbW1JbTgybW1iRk4vaHFGNkFDYTR4MHFsTGRZRkxja2lzaTZsY2RqU0dTM0YxblBOVjF1Y3RWRjNkK2xMQnVFZzNVN0FqZHRaU2NWcUpJZHRadG9nMkFpcjRwQVAzNU5OYy9MU2dZcGtoNG9FVkp4a1Zuc3Z6R3JzOG1LcGwrYWFRcm1xc3A3VWpTRWlpSmNqbXBIMmhhTGhZejVwR0FxYTBZdGptb0ovbUp4VXRud2NHcFpSb25rVlRsWDVzMWJBNXF0TWNOUUExS2wyQTFDS2VNMEFUeGdDckcvYWxWVUJGU1BuYlFoQ1N1Q0txcWZtNW9MSGNRYVJGTE5UQTBJY0VpcmloY2pOVXJmaGVhbTM0cERKWkNCMHFBeUFVanNUVUVweFF4b3NKSUNhblJ4dUZVSVhxeWovQURDa0RSdDIrTUNyaXFNVmx3VDRXcjBVNFBGYXhlaGhKRVZ5ZlNzaTRZNXJXblhPY1ZuVHhGdWxOdGpTS2hCYXN2VnJkakZ4NlZ0cGJ0M3F2cUVQN3JCOUtsRnJjOHl1MDJUTXA5YWdBclExUmR0OUo5YW9kS3RHakhDcFViR0toQnA2bW1RV04rYU1aRk1YclVwNFduWVZ5dEp4VlZ6Vm1VMVVrTkF5Sm1xQ1EwOXpVRHRWSWhrVDFYa0ZUTWMxQklhb2dxeWppcWpkYXR5OUtxdU9hb2xqUlVpZGFqRlNKOTRVQ0xIOE5WWkJWb0Q1YXJ5Q2hBeXF3cU0xTTR4VUpxeUJoNjExdmgyZk1BWDBya3pXcHBGNzVEQmM0eWFYVW1XeDZEQTI0VSsrRzYxeldUcDk2SGt4dTdWcVNTbzlxUm1xT1d4eWwwUDNwcXE0d0t2MzBZRWhJTlkxM2NCUVJtdEVWWWd1WnR2UTFselRsanhUcDVpN0hGVjhaTks1cEdOaE1aTktCelNoYWVCU0xCUlU4WXlhWW9yUjBteGt2citPR0ZDN01lZ3FXeHBIZmZEM3dqY2E5RzV5VWppR1Q2bXZSL0NlclJhRE5kYWU4YWxrSkFMY1pxcDhQWi8rRVlZMjkvSHNFeEF5UjdWbWZFMk9DenZrdkxHZGN5ZFZCclBwYzA2Mlp6Zmk3V1piblg1MmhZeGpwKzdQV3NjYVhOTll0ZGg4NDVQdlZWbWx1NXhzVm5kdW85YTZ6U3AwZzhPVEM1aUdVQnlEMXFHelN5S1V0ODhmZ2RnMFk1QjVEZnJYbXVwNjFjM1ZvdHN6NWpGZEhydmlDM24wZjdKYlpRNTZWeExqSnJXRWVwaE42MkkwVnBKRlZEeVR4WHJXa0tkUDhFeVF6UXh0dlEvTTNmam12T05Bc3pkNnhCR0JuTFY2djRyaWJUOUNoZy9kbE51Q1FlUmdlbFd5VnFlWHl1VWNqUEdlS2FzcE5NWnZOa2NxRHRCcG1lYWkxeStZbkxuRlF1eFBlZ3RUU2FMRmN3aDVwdUtVbWtKcG9tNDAwdzA4bW1HbUlZYVlhY2VUVXR2WnkzTWdTSlN6RThBQ3FKSVZHYWtWU08xYmR0NFZ2NVpkb2pLc09vYnRXdmIrRHBaMkN1NEJYcmloU1RCeGxiVTVXRkdaaDJxd1Joc1YzcitGclRUYkREUjc1Q003cTVjV3NEeUh0enhSem9mczJaVEtWNHBoM1Z0VFdjWUlSZnJtcVFqVHpja2NacDg2RGtaQmFScE5kb3M0K1RQelYwQ3JiTmVLMFNxYldBYmlmU3VhZTRXQ2I1VGdFODQ5SzJEbTlqamlzY3h3bGNTSCs5VFVsYTVQSzcyUlQxblVuMWU4OHExVDkwbkNrZHhTMnVpTXlocFRnZWxiVnBwOEZyR0ZSUm5IV3B3dFpTcU5tc2FTVzVUaHNJWWdOcWpOV2xqVlIwcVFDZzFGN21uS04yclNGQlFUZzBubVlvQmpXU3Rqdy9yVXVsWGE0Sk1aUElOWlFjR2duSElwTlhKV2g3ZllYY1YvYXJMR1FjaXBuQUhTdkwvQzNpRjdHNVdLVnlVWTl6WHBNYzRtaVdSRGtOWE5LTmplTHVTanBUU1JUZC9hbW1vTEpWSW9PQlVXU0tOK2FBQ1NvaUtlM05NSU5BRWJMbW1oT2FtN1VLdVRUQVJJaFUzbERGS3NacVRHS0JFWVRGT1BIRk1rbEMxRTAvTkFFK2VLZ2s2MDVaZ2FheDNHZ0NzeWJqU3h4Zk5VakllMVBqVTBobGlKTURtbnN0UmhpS2xCeXRBaUttc0tjYVVVQU5DOFVvR0tjRHhRM0FvR05Kb1UwWnBWR2FRQzdjMDRJQlFPS1VqTkFFZXpuaW5MSG1wRUdCelVnRk1CbXpDMUM0QXFhWTdWcW5KSmdVQ0pNaWdzQlZRVFpvTEU5NkFMQmJOSndSelVLbXBBYVlEVDFvQm9aYUtBQWswd25tcEJUV2o5S1F4OGZQU3JjWjI4MVZpRzBjMU1Hb0FXYWJnMVRlVE5TeTgxWEtITklCdTdCcVE1SXBVaXllYWxDVUFScXBOVEloeHpVaW9NY1U0TFRBalphWnRxd1Y5YWFRS1lqUG5oM1ZWbHRBeThpdE4xNXFGMXpRQml0WnFwNlVpV2Z6ZzFyR0VIbWxWQm1pNEpETGEzSVVWWk1aRlRXNEdLZktBQlFCVEp3YVpKeXRQa0dLZ2NtZ0NuTWhJTlZkalZwYk1ubW95Z3pURlltUWtVN2xnYWFtTVZLampPS2taWEVHVHpVc2NJUnFud0QwcEFQbW9BZm1xOHE3bXFZOFV4aUtCa1JRMDhEQzA0YzBvWE5BaDhhNW9sTzBZcDZEYUtaS04yYUxBVTVEODNGVFFrZCt0TVplYVdQaHFCbDFNQ25rZ1UyTVVNcEpvRVJ5dmdjVkEyV0ZYZnMrUmswQ0JhTEFVWTFJYXJVYW1sOHNCdWxUWXdPS1ZpcmowY2lyRWN4QkdUVlVjVTVXcGttbXN3WWMwMXlvRlV3NUI2MDltSlhyVkUySGlRYzRyTTFXVUxFYytsWFVIemMxazY2MklteDZVMXNVbHFjSHFUYjd5USs5WjdIQnF6ZE4rK2Y2MVRjODFVVVZOamcxT1ZxZ0JwNm10YkdMWmJScW16OHRWNHFsWndGb3NLNUJPY1ZTa2FwYmlYbXFUTm1qbEh6REpIOUtyTzVOVFBWZHFkaWJpRnFqa0pwU2FZeDRvQWdrcXMvV3JMMVdmclZJbGpjVStQNzFNRlNSL2VwaUxLajVhcnlqRlhZNHlWcXRLdk5TVVUzRlFzS3NPS2dZVlpESWp4VG9uMlNLZmVtdFRUVEpOcTExTHlITEZ1TVZjLzRTTUJOdk5jeHVOSlRNK1ZHM2Nhc0pPUWF5Ymk0TWhPRHhVWXBDS3E0Y3RpUEZLQlRzVUFVaWdDMDhMUW9xUVVBSW9yMFA0WHJiV21zcmUzMGVVVWZMa2Nacno5Qmx3RDB6WHZmaHR2RDBQaFMwU1JGV1FBRnNqQlByV2MzMExWanJOWmZSdGQwcG80ZHFUWXl2WTlLOFAxYUtlSFVwTGVkeTIxc0E1N1Y3QnJWdHBHb2FVTGpUcmhZWnd2RzA5NjhyVmdOV2YrMER2T2R1Y1ZHdDdta2JXc1hMVFR2N0orejMwVEIwZmhzMVExL1c0TE0zRVJHNHpLU0N2YXIycW03c3ROODJJTTFxZW5IU3ZQOVJhYTZrTTAzVEdGK2xFRmRqbmRJeXBtM09TZTVxdXdxdzRxTXJrMTE3STVOMmR2OExaYmF5MXBybTV0RnVOcTRHN0h5L25XL3dERkhYSU5VdDFTMXNoYmxEeXdZZFBUZ1VmRHpRdnRGZ3p4UlpZcnl4cmxmRml5eGF0Slp5WlYxZkJHY2lzWHBxWEhVeW80QkZwNExZeTFVSFhER3RPN2JiR2tlZWdyUGNab2pzVkloelRUVWhXbWtWVmlSbElUVGlLbWhzcExqSGxqY2M4QVVCdVZTYUVqYVJ0cWdrKzFkbHBuZ0tlL2pVcTRFaC9nTmROTjRQaDhNd0w5dWhBbHhrTWVlYXpkU0pvcWI2bm4ra2VHYnpWN3RJSUkyQko1SkhTdlI3WHcvWitFN1pFdVlnOXd4eUhQT0t1K0g5WnRkTnNibmZhQjVwQjhqampGWTE4ZFMxV1I3aVFTU0pHT1RqaGFIZVhvQ2FXaHBTWHlUU0ZvbEFjOEU0NjAyMmRFdjFUb1NNa0dzelR0UDFEVkNScDhUUytXTWtqdFZXTzllMjFKaGY1RHA4dTNQSU5KcHhkeXVaUzBKL0ZlcnVpc2tYSEcwVnlFTTNsU0RmelZqWEx3M2QrVVU0QTV4bXN0NWRweDFOTldCbWxkdkVrQmxERU9lUUt4WmJwZ1RnOWFXNm5lV01CdWkwelRyUnI2NUNxRHNCNU5PS3Nyc2h2V3hQcHVtUGZ6ZVpJRHNCL091c2h0MWlqQ3hxQUJUclcxV0NCVVFBQUNyQ3Bpb2JOVkd4RUVwZHZyVTRqcHBURklzZ0lBcU5qVTdMVUxpbUt4QXg1cUZtTlNPS2dmaXFSREY4d2lwRmw5YXJGcVFQaW5ZenVYMGsyc0Nwd2UxZWhlRU5iKzBXNHRwVytaZW1UWG1TUzFvNlZxRFdWNmtxTVFNODFFNDNSVUpXWjdXaVo2MDV4aXFtazN5WHVucE1wQk9PYXRNMmE1WG9kSzFFN1ZIM3FVZE9hWTQ1NHBBTHRwQWxLdWNVM2R6U0dMczVxUkl4VWU2cEVlbUlsQXhVVWo0TlBMVkRKaWdDdE1jazFEbk5TeURJTlFoR0pvQWxUclU2ajFxdkdqYnFzaGVLQUZPUFNrMzdSeFRsWDFvS0NnQm9relRoSVJUZG9GTWRxQUp0MU44eW90L0ZNTDgwZ0xpc0RpbnRnaXFxTm5GUzdxWUFSelRnY1V3dGlvek56U3NCWTNZcFJKVUpmNWMwMFNVV0F0YitLZkc5VVROVDBscEFXSm56VkNkc0thbWFUY2V0UVRrYmV0UG9LOWltSE82bmViaHNVemNvTktvRHRUYUFzeEVrMVkybW80WThWWUdCU0dOSW8yNXB6VW9wZ01FZURVcXg1SFNnRUUxTXVNVUFRc21LajNZNHFhUVZYUFdrQkp0M1VGQjZVcXR3S2QxcGlHaEJqaW1rWXA1YmFLaVo2VEdoeXNSM3FSWmNkYXJCK2FkdUdha1pZTXdOTUp6VVdjR2tMMVNFT1B2U2JjMDB0bW5LMUFocnJpb3hHU2Fzc0FWelVEdnRvWTBUUmZMZ1ZLNjdxclJTNWFyTzdJNHBnVm5qcUlvS3VNb05Rdkg2Vkl5czhlQnhVQmlPYXU3ZldrMmltZ1pSNlViaURVc2lnZEtxU09WYW5ZbTVlaGZQV3BjamRWT0Z2bHF5bkpwREZZWk5LSXhqbW1NMkdwNXlRRFRBUUx6VHhnVXdIRkc3NXFBSngwb0lCV201cDNWYUJGVjQvbXpTb2xUSEhlbWcrbEF5Vk9NVktNVkdLa1ZhQUpWT2VLR1hCcFV3dE9MWkZBRURqQXBqUGpBcFpaUGxPS2dBM2MwQVdrWU54VWthWmFxOFEybXJrWm9BWktOdFJpUTFaWWJ1dFFPZ0ZBRFFUeWF4OWFmOXkyZlN0Z3RoSzV6WFpqNVREMnBqanVjWGNITXJmV3FyR3JFbkxHb0dGYXhGSmtlZWFrU21CZWFtUVZvWWtxbkFwa3JIRlNMVWNnNE5OQ1pTa0JPVFZjOFZhazcxVWM4MHhESFBGVnBEVTd0eFZXUTgwaGpDYWF6Y1VqR28yTk1CSE5RdHlhZXhwdldnUXpGU3hETEFlOU54VWtJL2VENjBNRGRzclhlTUVkcXpMNkh5cDNUSFExMkdrV2dhS05pUHZDc1R4SGJlVGZ0Z1l6V2FscVhZNXVSYXJzdFc1QlZkeFdwbXl1d3FNaXBtRlJFVlJJekZGT0lwTVV4Q0NseFJpbEZBaHVLQUtkU1lvQWNLY0tSUlVnRkFHdDRYaHRKZkVWb3VvWThqekJ2ejBOZTg2dmJlSFZGbmNJMFlqWEdRdUs4SDhOMlVkN3JsckRPMnlOcEJ1UHRYdStxK0hORHNkTHQ3eUtjT0lzRXg3czVySjdsTHNOMS93NXBVMmttODBtOEVKQzVJRFl6WGtVenVseTN6YmlDZWM1ejcxN0JlM3VtRFN3ejJUcEV5OG12TDlSaXRqZFNQQU1Sa25hRFEyckZ4VGVqTDFuckZ4L1pyUXpwOW9nMjRBN2l1SDFwbEVoV0pkcUU4RDByWisweVFsaEdlUFNzZlVOc3pNOG5EVVFscU9jWFl4R0ZMYndtYTRSQU9wcFhITmFHaXdsNzRFanBYUktWa2M4WTNaNmY0ZVZyVHcrV2dtZENpL01GNHJndFZMWE92R1JpelpPU1dQTmVuZUY1TFAreWJpQjRuZVlnOU9udFhuK293dk5ybVlvU3ZPTm81ckRtOTAxVWZmTUxVWXlrL1BTcURDdTF1UEQwdHhhbVdaR2pYb0NSMU5hK2tmRHhkWTBwbGh0M2puUWJtbGZqTlVwcExVY29PK2g1b2tUU050UlN4UHBXeG8vaDAzMGpHNlY0NDhjY2RUWHB2aFg0ZFdWdGRMY2FzYzI2OEZnZU0xdlMrSDdhV1NVMmJBYWJFMmR3Ni9uVXVwcG9DcHErcDUzcHZnUzM4bHBiMWNxUjhnejByUzBidzViMjArVEdJd3B5cFlkYTFkVXU3YUs2QTBsOTBhakRianhVVTk5TnFscEhaNFJNSDc2OEUxR3NscWFOcUd3KzExYlQ0ZFVlVzd6SDVRd3BUMTlhemRUMUxVdkZWd1k0VWFTT004RURrZ2V0WHRhOEpTYVRwVVYxSklwRW44SU9UV3pvYUR3eG9MMy9DenVwSlNVWUJwcXkzSXUzcVluaFhTUmRha3NVOFR5TEczN3hjZEszdkhtcVdXZ2FZTGJRdkxqKzBmTEpHdzVHYXlmRG5peHJHRFVOYzh5M3l4Sk1KT0NQcFhMMitrYTE4U3RXdWRTc1lzUkp6Z21ydTJSWTJvTmJtOEY2RCs1bFUzTjB1UmdaSHZXRG8vaGpWL0ZqWE41YllMS1M3TXg3MWExbnc5RGIyOXRCSmRTVFhxdUZlSHFWSGV0dld2RW1tK0VmRGFSZUg3bnk3bGx4SWg3bW52dUxZOHVsMCs1R3BUeFRjU1JzUStUVlNZdzJwQm1JYkhZVlh1OVdudUxxV2RwU1hsTzVpUFdzNW1aenp6VDVSY3hhZVY3KzZFY0s3Vlk0d0s3TFN0UFN5dFZVRDVzY21zanc3cDJ3ZWZJUG1QU3VtUVZNbjBOSVI2c2VpMUtFejJvUWUxVEtLZzJJd3ROWmZhckcya0tVeGxOMXFCMXE3SU1WV2NVQVVKRnF0SUt2U3JWV1FWU00yVlRUQ2FrZmlvV3EwWk1VTmp2VWtUa04xcXVUU3F4N1VXSlBTZkFtcjVrK3pPM0I2Wk5kL3R3ZUs4TzBPK2F6MUdPUUhIUE5lMTZmT0x1emlsVTV5b3JrcVJzenBweXVpeUJUSE9LbFBGUXZ6V1JvSnU0NHFQUHpVOUJrMC95c21rTWlKcVJlRnpUakZTTU1Zb0FNazFHd3pVZzZVMGlnQmhRWTVwQW9IYW5ua1VtS1loT25RVXVUU2dVdlNnQkFUaW5xTWltWnB5TWMwQUtVelVUb0JWanRVTGlnQ3ExTXdjMU1WcEdYQTRwZ0VlYW1EVkNsTzNVZ0NSODhVek9CbWtjR2tJd3RBRHc0SXhTYnFqVmVhY2V0QURXem1uQmlCMXBkb1BXbitYOHRLd0RBeDlhcDNFamJ1dFcyWEZWSmwrYW1LeFcyc3hxeGJvUTJhRWpPZWxUeHFRYVlGdUg3dFM5cWdqNHFUZHpVakhnNUZKbm1nTU1VaWppZ1lvTlNCajYxRWVLQTFBaWM1SXFNOWFlcHlCU3Nnb0FZRGlsM0E5S1RHYWVxVXhFTGdrOFV4Z2FzRk1HbWtldEFFQVhJcE5welZqYUFPbE0yZ21rTWdPZDFMVWpSODhVd2cwd0VOT1VVd2crbFBVK3RBRWcrN1VVZ0ZPWnZsNHFCeVNhVEJENHhnMWFqTlZJelU2bkFwZ1NNNEZRbVRKcHJQVVc3bWtCWXlLVEFxTGRTZVpUQWdMWldvSkZIVTBJK1ZvYkxWUklzWjdWYmlCcXBHdURWK0R0VWpCb2M4MHg4cXVLdk1Qa3FqTlRDNHpkeFNBODVxUGRUbDVvQW1EY1U0UDJxTlFhZGpCcERGSjVweWlveWNtcG8xNG9BbWpYSjVxd01CYWdVNHBHZWdDVU56MXBqRW5wVGQyQlNxMmFBRU1lNmt4dDZWSnU5cVFpbUF3dGlwWTVjQ29XR2FRQTBnTGdrelRUelRJbHlhc0FBVXhGZHhoYTVUWDJ4RzFkZk12eUUrbGNWNGdiNVRUS2ljdTFSa1ZLUlVaRmFSSmtOQXhUbE5OTkpubXRETmt3Tk1rYmlnR21QelRFUVB6VldRVmJaYWdkYVFGUnFyeVZha0ZWSmFwQ1pBMVJzY1ZLYWlrUEZNa1ptbktLakI1cVplbEEwSVJUNFIrOVg2MGpkS1dEL1dyOWFsN0ZXMVBUZEl0ODJVTEQwRllmaktEYklyaXVxMEpmK0paR0QyQXJuL0dZeUJXTWR6UTRHUWRhcnZWcVFZSnFzNHJvTVdRTUtZUlV4RlJrVXlTTWltMDlxWlRFR0tNVXRMaWdCb0ZPQzBvSE5TcWxGd3NOVmVLY0ZxVUpVMFVPNXdCM05LNFdPajhFYWRGY2F0RkpkY1JLY212Ujllc0lMbE4ybGlRbU1BZ0EvS2E0WFE0L0pFU3Q4cVpCWWowcjBmVS9FVnRhNlZIQnBnUU1Vd1d4V1BWM05VdE5Ea3I3V2I2NGdXMm5rSVZlQ3RZN3dtVndHNEZUVHpsN2d1NXl6SG1uYjkzU3FTVDBIcWxjWjlnaEtuSkdRS2pYd3RQcWRzODhNSDd0T3JIdlZzUTRUYzJRVDBxOWIzMGxyWmxmT1BsazhvRDFvZWdyM002dytHMGwzODIxUXZVaytsZFhaZUZ0SWpkWUlJUk5JRXd6ZGxySHVmRk4xSkVzTnQrNGpBd2R2VTFHUEVjMXZZaTJzRjJ1eCthUTlhTlEwV3gyOGVqYVhhVEdGSDh5Umw1MkhnVkRQUG9lbFgxczFuYnhUVHI4ckFyMEpyZ3JYV2RRdEp5OFRFcy9CSnJTa3NiN0F1Ym1OME12ekJ5TVpvdGQyWXI2SGIzTmxacUh2TlVtakdDSkVnQjR4V2ZxdmpLeHZydTJodFkydHJkUmlRcDh1UlhKeFEzbW8zaXhzN1B6akxIaXJOOW96d3VzY1RLWk00OHZ1YU5CYWt1dmErcVNmWTlJbVpyUng4NE9UVlM4MXk1a3Mwc2RPa2FLQWo1d2E3RzA4UDZSb0dqaSsxbDBjdXZLOTFOWW1qV0VIaURVMnVCRjVXbjI3RWVZQjk2bFpCZDNHNkw0VFM5c0htdVo5bTBadzNHYWRvTmxiSnFMM01rWmt0WUR5dWZTcTNqVHhmYVFNTkgwOWdTRHRFaWNZRlVkWTFIVDlGOExvdHBlbDd0eG5jclp5ZmVwNTI5QytWYmkrSnRlc2RTOFRRcFlYSGxReGNsV2JqSXJOOFhlTTIxdXpYVElveVNwMkYxNlk5cTV0OUQxWk5PYlZyaUliSkRuY2V1SzdUd2Q0ZTBtUFJIMURXMzh1ZjcwWWJnVTFGTGNUa1p1b2VCdE9YUXJSOU92R2t1cGNCNG1QWDhLN0t6Tmw0QThMdFBhMzNsWFpUTHhOM3J6VFYvR1NSNjhaa0lieU1yRVkraHJsZGM4U1grdTNKa3U1U1IyR2EyVVd6RnMxdFE4YlhVdXRUYWpDUUo1T00rMWMxZjM5eHFOMDF4ZE9YZGprMVhORmFxS1JtMkpnazgxcGFUcHh1N2dGaDhncXRhV3IzTXdSQnozcnM5T3NWdElWVURudlV5bFpGd2pkM1phdDRsampDcU9BS3NLT2FSUmpwVHdLdzNPa2tTcGxITlJJS21YSW9HUEFvSUZLS2NWeU9LQ2lCMUJXcXJwanBWMGlxMHd3VFFCUmtIV3Fjb3E5SXRWSmxxa1F5aElLZ05XcEZxcTRxMFpTR0drb3BPOVVac21pWXF3T2E5WjhBYXNMaXlOdTdaWmVncnlOVGl1bThJYW9iSFdJOG5Dc2NWbFVqZEdsTjJaN0pLOVFFbW5oeEpFSFhrRVpxQnljMXlNNlNTUGxxdEwwcWpIbk5YSXprQ2tBNG1tRTA5aGlvbU5JQnVhTWltc2FhT1RRTWZUYzgwOExtbWxlYUJDZzgwL0ZSZ2ZOVWdOTUJDS1ZSU0dnR2dDU21OanZRVzJqbW9YbHpURUpMeFVSYmlpV1FWQ1pCVEFtUTBwT0tyZVppbkxKazBETEJKSW9DRTBpSGlyQ01La0NFSWMwcGg3MWEyMDA5S1lGWGJUK2kweVE3V3BOOUlDUWpOUkdBRTVOVEtLZVBlZ0NGRUE3VXJBQThWTnRHS1l5anRRQkNXTk9XbkJCVFg0NlVBT1Q3MVRqRlZSa0hOU2hqa1VBU09nSFdtcW9OSzJXcDZwUUE1VndLUmljOFZLcThVMlRDMEFRak82cFZxczhoelRra0pvQW5KcUpxQzlNTFpOQWlSZnUwaEdLYVdJWGltaDg5YUJqbU5OeWFZVzVwNE9hQURkNjBOakZCQUZSeVBnY1VnR3VmU29tYWszWk5QVk9LWUN4OERwVW1UaW93K0RpbmI2QUkyQkpwQURtcE1VdUtBR1UycFFPS2FSUUJscG5GVExUbFRDOUtVSjgxTVE5RnpWbU1oS1loVlZwckgwb0F0ck1EM3F2TTJjMUdoTzZwU202Z0NwZ2h1YXNScm5GTmFNNXF4YnhuUE5BRXFJTWNpbVNKVmtwaGFoZkhPYUFLdzYxTURpb3lPZUtjdVRRTWN6WVhOUmVielVqOHJpcTVqSzBnSlZrTE5pcGxPQlZhUGcxT21UU0FuQm9MVkhuYUtidjVwZ1NFVTVVSjdVSmdnVk12VGlnQll4dHB6SE5Sbk5BSnBpRm1QN2c1OUs0VFgyK2ZIdlhhM1Q0Z05jRnJqNW54bXFLaVpCcGg1cFR6U0FWb2laRFNLWWFsSzFHeTFTTTJNSnBwTkthYWV0TVFFOFZCS2VLbUo0cXJNZUtCbGVScXFTR3BwVFZWMnFrUXhydFZhVnFrZHVLcXlOVkVYRlUvTlZsRytXcVFibXBrZWswVW1XQ2Fuc0kvTXZJMTlXcXJuTmJIaDJBemFuRjdHb2xzYUxjOVQwcUxaWW91TzFjcDR5YjU4ZTlkdmJSN2JZZXdyZ3ZGNzdyakh2V1VDMmNYTndUVlo2dHppcWpDdHpOa1o2VkcxU0VVeHFveklqVGNVOGlrSzB4Q1VvcGNVdUtBRlFjMVlYZ1ZDdkZQRFVnSnQxYldqMlBtTUpHSEZZOXRFMDBxZ0RqTmRwcDhBaXQxR01Hb2JMaWl3cWlOQUJVVTAreU01NU5Tc2VLcU8yeHd4R1FEa2lvdGMydlloYVpOcTdjN3oxQjdWZnR5SGo0SXlPdFV0YW5ndUpJNTdWUExJR0dIclZPSy8yZkx1NjkvU2xzOUNYcWowL1FmQ3NXb2FlMTdxay9sUXFNcXVjWkZXb3ZEMm02eVZoMCszekVqQXRMMlByWG1OeDRuMUFXaTJ2MmxoRDZLZW9yYlg0aVBwM2g2T3kweEc4N0dOMktybWIzSXRZNmpWTkkwYTFFbW0ya0xTWHpINWNjNHE3cDNnYlQ5TXRYdWZFRXFnc21ZMXoxT0t4L0RIaTNUN0xSNUwzVXBFbDFCaHVCYnJuMHJMdHZpQkpxbmlFUzZ6R1RaUm41RUF5TTAxSjlTWDVIVTZENFdzcDdwNy9BRkJERmFBNWkzY1o5elVPditKazFLY2FMYUtySkdjZVlvKzZLeS9Fbmp5WFhJdjdPOFAyc2pJVnhnREdLNE5YMURSN3B4Y0Y0Sm1ITzdxYWwzZXhjZTdPNDhRZUlyUFF0UGp0cmRWZTRBenVXcGZEZXRXUDJKdGR2THFNM2lnNGlhdUFPa2FocUtQZFN1b1FESTM4YnF0ZUVQRFVtdFhUaTRmeVlZK3BQUnFTaWxxVTIyaXo0aTFuVS9GbDNMUGJ4U3JiSU1sRTZWVjBmeE5yVUtIVGRNWGlRN1NBT25hdXkxM3hKbytnYWFiUFMxUkxvRFl3eDk2cWR0cU9oZUc5RGUvdFpZcDd5WmQwaU42KzFWYm0wTW5MbE9jOFFlQmIzVHJTTy9tdTBrdVpqbnlsUFBOYlBoL3dwWjZkcGcxUFdkdDA3THpDeDVYOEs0di9BSVMyNjFEVXpjWE12bG9yWlFNZWxHcWVNNUpjcEM1YzlNNTRxbkZnbWpwN25WZHQwV256L1p5OHJiazF5WGlUeGRQcVROYTJqZVhhS2ZsVDByQ3U5VXViM2lXUWtlbFU4VnBHSGNpVXJ2UVE1TkpqbW40cFFLMU14Z1dwWW9HbGtDcU1rMCtHQjVwQWlESlBwWFdhVG9xMnNZa21HWFBUMnFaT3hVWTNEU05NRnBBQzZqZWV0YXlyaWxBOUtjZUY1ckZ1NTBKV0VIRlBGUkJzMDlNMGlpVlRqaXA0eDZtb1ZxVlJ6U0dpZGVlS2NCaWtqSHFmenFUQTcwaWlCd2R4QUZWNVI2OWF1T01rK2xWNVFPOU1EUGxIRlVwZWh6V2hLTThnVm56ZGNWU0laVGtGVlpCVjF4aXFrdFdqS1JYSTVwTzlPTk5xak5qaFZpM2xNVXlPcHdWT2FycUtkbkRVbnFDMFBjZkROOE5RMGFOczVLakJyVGFQQnJndmh4cVdXYTJadXZTdlJXWGRYRkpXWjF4ZDBRS3RUb01DazI0cHdJRlNNVnVsVnBSaXAzZmppb0d5YVF5TE5LT3RCR2VsSU9PdEFFNHBDRFRSSUtHZjBvQVRvYWNPbFJnRTA4WkZBQzV6U01jVVp4VENjMEFSeXk0RlU1YnJiVTA0K1dzaTVQelZhSkoydXN0MW84N1BlcUlCelV5cVRUMEdUK1pVc2JjMUdrUk9PS3R3d1ZJeWVIdFZsYWFrT0ZwV0cwVklFb2tGRE9BS3FCOEhyVXBPN0ZBRWNqQnFZZ3llYW1LWXBpOE5RQkt2QXFWUm1vZnBUMWJpZ0NROFZIM29aczB4c2lnQ1FETkpzSGVrU2xaOEhGQURKR0M5S1p2cFpCazFFVGcwQVdZbndlYXRxNEsxbks0cDd6N1J4UmNDNlpRTzlSVE9HWGlxTWs1SzV6VEJJU3ZXaTRFclNnSEZTUk51cW9xRm01cS9FbTFCUWdCaGdVd1lCcFp6Z1ZYVmpubW1CT1pNbkZKbkFwZzVOU0VaV2dCbWNtbkEwbUFvcGhZZXRBRDNhb0dQclN0SnpURDh4b0FralhOV0ZRQWMxRkVBTVpxVnpoZUtBSzh1ME54UWhGTVlaYWxVR2tCSXhGUmVaaHV0RG5GVjgvUFFCZVU1WE5MaW9vejh0UDNDZ0NJTG5yUVJpcFF1ZWxOa0dCUUlpNkdnc0RUWE9CVFU1TkF5WkJ6bXBoVVMwdTcwb0FsSUZXSWh4VlJHeWVhc3E0VmFZaVNSc1ZUbWs5S2ZMTG52VlIzTFBRQktqL0x6VXFQVmNENWFralU5YVF5d0Z6VWJKVWl1RjYwbThFODBBUUt2elZPZ3hTRmNuSXFVQVlGQURYR2FZUlU1KzdUQ3RBQ1JWYmpVMUFpa1ZhaVlkNkVJR1dvenhTeXRocWhsZnBnMHdJZFFjQ0g4Szg5MWVUZmRuSGF1eDFTNS9ka1o3VndsMDIrZG05NnRGTFJFWTVxUlY0elRJeHpVekQ1S29raVk0cUpqVG5OUm5OVWlHUk4xcU1tcFNLWVJUSkkyTlZwVDFxZDZxU21xUWl0TWFwdWFzU3NLcFNOaXFSTEdTTlZaanpUM2VvcW9nS2tRMUhVaURwUU5FOGRkdjRKMDh5VGVhUjM0cmpiU0pwWlZVRDd4cjJEd3BwbjJhMGpHT2NWejFIME40bzI1UjVOcitGZVorS0gzWFJyMUxVb2l0dWZwWGxQaVgvajVhbERjY3RqbXBlYXJzS25rTlFOVzVsY2lhb21xVnFpYWdRMmtvcEtZZ3BhYnptdFRUTkprdkhCWUVMUmV3V2JLa0Z2Sk8ySTFKcll0ZENja05MVy9aNlpGYW9PQm1yRGdBY1ZtNXMyalQ3bVpEWXgyNUdBT0sxWTIvZGpIRlU1VGcxTkMrNlByVWxXU0pHYkZWWlRtcG5OVnBHcGtzbzNMRlFRS3psVXR1VVZvVFlQV3FhQUNjSDFOT3dyajdTMEZ6Y3h4VE41YWs0TEh0WFZUYVpvbWpXck5QY3JMTmpjbU9jMWhiU0lpNHh3TzlabC9KdldLVFlldVNLZnM1V0k1NDNzZFA0ZDhQTnIrb0c1a1RaWmhza1YwR3RRYVJBVjB2U29oSThod1FPcSs5WVVYeEVzclRRZnNjTm04VXUzR1Y3bXVKWHhQZFJha2JxT1ZsbHp4bm1rb1NFNmtWc2UzU1htaStFTkFSdGlpNEMvZTc1cmxUUGIrSWdkWDFXNGlVSVNWajQ2VjUxcXZpUzgxWVl2SlN3OUt4bnVKOW5sckkyMDlnYTA5bTJadWZVN0h4UDR0VzR1QmEyWi8wZFA3dFZrOGYzbHJwNXRMTlJHcEhYdlhJYkhIekVIM05NM2MxWHNraWZhTXUzTjlOZDNCbG5rWm1KemttbitmdUlCYzR4NjFRelViRTd1RFYyc1RlNXNMSEcyRkpHS3piak1jekRyZzRwRWRoam1sWWIyeWVhcm1ZV0ZUa1ZLQlRGR0trRlNNTnRTeFF0SzIxQmsxTGEyc2wxTXFSak9lcHJzTk8wbUd6VlNWekpqbWszWTBqRnNwNkpwRFczNzJkUnVJNEhwV3kzV3BDYVllVFdMZHpaUnNDaW1UdnRXcGh3dFViNThLYVF4MFQ3dWFzcWVhb1dCekR6NjFmU2dFVHFha1NvaFVxRWRhUmFMQUtnRElwMjdKR0tpQjRxUWNjMGlnY2dqT2Z3cXJLVGcxUElmbHFzK0IxTkFpdkljQ3FFdjNpVFZ4K3RWWk9BYXRFTXFTSE5VNWF0dmsxVmxGVVpzck5UZTlQWVV3MVJteHdQSXA4bkZSZzRwOGgvZGcwTVJzZUY5UU5ockVUZzRCT0RYdWR2S0pyVkpCL0VNMTg1Mjh2bHpLd1BRMTdaNE4xSVgyam9HT1dVWXJDckd6dWJVM29iNWJtbXNhY2NacGpjVnptd24xcGNDbTV6VGdEU0dOWVlxS1ExTXd6VU1nNG9BalVrbXBsSEhOTWpUSFdwQ0RRQWJzR2d0VFQxd2FSamltQUZxVE9hWVdwQklBZWFBR3pLV3FsTmFsdTFhTzRIcHpTbGM5cUFNcGJJN2VsV1liWGprVm9SeFpYcFFJeXBxaEZYeWRwNlZaaWpBN1VNQUtiNXVLa1pZTEFERlZKNWdvTkk4dWMxVGxrelNBRm5EUzFkVnM0eFdYREdmTXpXcEFPbEFFbmFtRVlxWmlNVkNUelRBRk5TanBTcEhrWldrS2tHa0FacER6U0ZUU3JRQXVjQ21OMXB4cGpkS0FHTS9Xb2p5YW1DanZTWUZBeG9YRlJ5WlBUTlQ5UmlqYmdjaWl3RklnaW5ybXAyVUdrVlJtaXdoWVFjaXJhNXFKRjVxWUhBcGdSeWtkNnJaeTNGV1pGM0x4VllyZzBBT0J3YWxCeUtyYnVUU2VZYUFKcEc5S2dKcHdKYWxNWkpvQWg1elNqTlRDT2d4KzFBQWpWTGtrWXFNS2FrVUdnQm5sa21uYmRvcVRwVFdZWTVvQXJ5TG1vUDRxbWxrQjZWWDVKb3NJc1JuaW5ZcElSeHpVK0tCa0NTMDdmdXJPV2JhY0dyQ1RESEpwQ0pwQURTQk1DbTc5M1NwRk9hQUhxdUZ6VUx0ZzhWUC9BQTFDNCtVMERGUmpWakpLaW9iY0R2VndSN2w0b0FwU1p6eFNKRVMyYXRtREo1cDRoMjBBVmlsTGdxS3NsUU90UlB5Y1VBUU01cGhmbnJVa2kvTFZZb2ZlZ0MxSEthbTNjVlVpR0tzRGtZb0VTQ1FWSXJaNjFXS3RtcEZ6VEF0cmdpcEVHTWtWRkY5MnBsT09LQUlwdVR4Vk9keXRYbVhrMVF1bHdDYVlIUGFySmlOaVRYS1NkZnhyb3RaZjVkbzlhNStSYXBGUGF4R3JiVFVubVpXb1NDS1FkS29nY1dwcElOTkpwaGJGVWlXS3hxSjJ4U2w2cnpTZ0EweVdNa2txak5MMXBacCtUVkdhYXJSTFkyYVdxa2ttYUpKTW1vQ2FzZ1VuTkZJS1dnUW9GU29NMUdCelZxM2lNa2lxdlVtazJVbHFkSDRUMHczZCtya2ZLcHIyblNMTVJ3cVNPMWNiNE4wZ1FXNkVqazg5SzlEaUhsUkFEMHJrYnV6bzJNelZ6aUpoWGtuaVhtNGV2VjlYYk1iVjVONGk1bmY2MWNOeFMyT2FrcUJxbmVvR3JwT2NqYW9qVWpWR2FBRzQ1cE1lbE94bXRiU2RLYTVrRHVNTDcwbm9OSnRocEdqdGN1cnlqQytocnNMZTJqdDBDb0JSYndMQkdGVVZLeHJKdTUweFZnYkZRU1ZJV3FKK2FSUlZscGx2TGdsVFQ1ZTlWQzJ4ODB5R1hYYm1xMGpVN3pOeTVxSnpRU1ZabXFvejRjR3JFcHhWSjIrYXFKWnV4YWRkWEdtR2RZbWFMcHVBNHJuOVUrMVdMS3MwUkNFY1pGZGpvbmkxN0hUNGJTVUs4S3RrcVY1cmZ1dFc4TzYrc24yaUJVWUxnQS9TcmpLMmhqT04raDVDdDlFOGdNaWdBQ25JdG5LaFlnYnMxMk4zOE9vL3NjdHpaM1VUQUFrTG11UmswYVMxVW5ITmRDZDlqbmFhM0tVdHJISklSRXhKSjRBRmFMYVdOTnMxa25YTXIvZEZkQjRPOExUYWc3WHNzVEdHTThISFd0TlBEZDE0bDhUQ0MxaVpvWUQ4eEE0b2JRV09abDBsaG9MU3lJQXpESTQ2Vnh1Q0dJUHJYdjNpVHdwUFlhT3l5UXNBcStsZUZYRUpTOGtYMFkwRElsakxkS1g3STUrYkhGVHhEYTNGYU51SkpnRUNBajZVYUxjV3IyS052cHNzcEFYblB0WFIyZmdXOG0wOTd1WDVJMUdhdTZYYXl4TnNqaUR1M1FZelc4eWEwbWt5TDltbVdGUjg3a2NDb2MxZlF0d2xZOHV1b2ZzdHkwWU9RRGpOYUdsYVpKZXlBc3BDZHpWWFVPTlIya2RXNlYyK21vaTJjZTFjY2VsVEtWalNuRys0K3pzSUxSZjNhYzQ2MVo3MFpOSm1zVG9BbjBvWHJUU2FjbEFJbGJoYXk3OC9LYTAzT0ZySnYvdW1nb1d3NGgvR3J5R3M3VG16R1I2R3RGZWxJU0owNlZJdFFxY0NwQXdwRkluQjR3YWVHcUZXcVFIaWdvVnFyeVp6elU1enVIdlVMNEpOTWtxU2NpcTBuM2F0U0tlYXJ5ZE1VeVdVNUJrWnFwSXVjMWVjY1ZXa1hyVklobEpscU1yVmgxcUxielZvelpIakZLNS9jMDhyVFdYS0VVQ0lFYjVoWGY4QXcvMVR5YnJ5SGJBYnRtdlBsUE5hK2pYaHRMK09RSEdDTTFNbGREZzdNOTZKN2lrSXpWTFRiK084c1kyVmdUdDU1cTVnbXVObzZrS0Z4VHh6U2RxY3BBcERHc01VaFFlbE9KQk5PUDNhQkVZVG1uRUFEbW5EcFVNamZOUU1qY2ZOVEdITlNNMlJ4VVo1cGdReVNZRlZIbEpiaXA3aFRWTFlkMUFGNkNUam1yNllZVm1XNkVOV2tCdFVHa0JJbUFhVmlCVWF0elF6QTBDR1M4aW9jRW1wbUhGTlZhUXlJeGsxRWJVazlLdmhhVUx6UUJTanR0dmFyU1I3VnpUeXRGQUVSNjBiTTlLZXk0cDl2R1dibXFFUGhRaW55UmQ2c3BEeFJJbVZvc0s1bW1tc1JpcHBRRnFxeHpTSGNlRFFWelNJTTA4SGFlYUJqQ20wVXpHS25ZWkZKNWVhUUVlT2FVcm1wUkZ4UzdlS1lGY3JqaW1vbVdxd1V5S0VTZ1FLTVV0TzJuRk1mSzlhQmpYUEZWMlUwOTN6MHFOVGlrQXdxUVRTS1BXckN4N3FQTEFhbUJHbzVxVUNtOGJxZVRpZ0JjQWltbGxBcEN4SFNvbjcwZ0Jwd0dvKzBnVlhaQ1RRSXpqcFNIWXRDNERVTVN3K1dvSTR5VGlyY2NPS3BDWlVLTm1uUnB6eUt1R05lOVJ1RlRtbUliamFLTnhvTWl2MHBRbElERm1nWUhQYW1veEE2MW92OHk4Q3FiUU1xazRwaUpZbitXclVSeUtvUXJ1WWl0U0NMNWFrWTcrR29wQmtWWUtHb0pWSzB4aklEaHNHdE9Gd0Z3YXlRU0d6VnFLVEk1cEFYaTJhZGtZcXA1bTJwVmt5QlFJVit0UmtacVU4MG0zaWdaR1V5dFFNZ0lxeVQ4dFFkNlloa2FmTlZsSXhtb28rSHFjNUhTZ0JXUVVxcDh0TjM4VXF2bW1CSXZGT0xZcVBkam1tcythUUVyU1pXcUY3SnRqcXlEbnJXZHFjZ1ZEOUtZTGM1ZlVaUE1tSTlLem1YTldwbTN6TWZlb0dPS3BHa2lxNlZIdHF3NXpVWkdhb3laWGNZcUZqNjFhZE9LclNxZWFwRXNydTNXcWMwbldwNWMxUW56elZJaGxXZVNxVXIxWWxWaVRnVldhSnU0cTBRUXNjbW1tcENqRHRUU2g3MVJJZ3B3R2FRQ3BGRkFDcU9hNlB3dHBodmI5V0s1VlRXRkZIdWNESGV2VlBCV2tpM3RrWmg4emMxalVmUTFpanM5RXNmS2hYQzR4VzBVK1dtV3FpT0lDcGkyVklGWUdwZ2F4L3FYcnluWHhtUi9yWHF1c2NSdlhsZXZFRm54NjFwVDNGTFk1aVNxN1ZQSWVEVmRqWFNjeEcxTVBXbk5VOW5hUGRUQlFQbHp5YUJvbDB5d2E3bUJJK1VWMmxyYkxiUmhWSGFxMWphSmF4QUFZT0t2cWNpc1c3blJHTmxxTG1rSXBPbEtXcEZqRFVVaHhUM2FxOGpacGlJcERtcXMvU3AzYXEwaHlLQ1dSeHpiVHRKcDd2a1ZUbHlweUtFdUFSZ25tbUlXVnFuMExUMTFYWExlMWQxUlpIQUxNZUJWU1JzMVdGdzl2S0pJMktzRHhpbVF6MXpWUGh4YVcxMlk0cnFJalp1VWcxblQvREc1U0NHVHpkclM4Z0Q2WnJqN0h4aGNSTnRra1ozSXdHSk5kVlpmRXU3dDJoTnhHMHFvTUFIM0ZYb3pMMzFvWW1vYU5xbW5YRDI4TWpzQWNZQnFoOWpsbWRZYmhXRDU3aXUyc3ZIdW4zV3ArYnFkb3FSc1Nmb2FXNjFudzVlM0Vza0RpTXRJTm5IVGtVWHN0QlBYYzlOMERSTFBSZmg3SEg1UzdtaTVPT1NUV3A0TDhQVzJrNlo1cVJEelptTEZpT2VhYUdpdmZERm1rTGhrSUZiY2wxSFlhY0NTQUVYam1rcGEzWk1yMnNqbWZpUGRXME9oU0xLRkxGVFh5VmQyVXMrb3p5UXJsQzV3YTlmK0tmaTlyanpJVmx5U2NZQnJnOUp0OThDSnhsenpRcDYzTDluYU5tVmRMMEMyYUVHOEpESHBYVzZWYWFOWVdlMlJRMyswZXRQazhQU09vK3pTTEp0R1Q3VTIzOExYVjAySkgySlRjbUNqRTF0SG0wV3oxaUc0YVZBbWNuUGF1cDhRZU90Slh3anFGblozRUJNaWtBWTVQRmVlWFBnNldPNEVjVG1UTFlCQnFuclhoaVBUYkIvTndaQ3VSODFWSG02R2RUbFN1MmVmWGN5U2FnRDJMYy9uWGMySnphcGpwaXVBVzNkdFI4dFFTZDFlZ1dVWmp0WTFic0ttcHViVVZvV2MwMG1uVTF1dFptekdFODFJdFJNY05UZ2FZa1NzMlZyTnV4dUJxMjcxVG1iT2MwaWlEVHp0ZGg3MXFLMVpWdTIyNHJSVndEaWdSWlU4VTRITlFCcWVId2VLUlJaVThWS0d4NzFXamZOVHFhQUhGczFFd3hVdlgycGhIUEhhbUJYa0hHS3JzcHE0NjFCSUNmcFRFVW5YaXEwaTFla1dvSFhLMHlDaXlDb21URlc1QlVKV3FSTEt4V20rb3Faa3FNakJxak5sSmh0a0lxZUZpRHhUYmhjT0dIY1VSOFVDT28wUFc3dTN2WUl4SWZMSndSbXZZTE4vTnRZMy92TFhoMmxaTnhHUU1rTUs5czBseStuUkZoakE2VnoxVWtiMDJXbUZOelVwR2FadHJBMUdqbHFtT01Vd0pqcFR1YUJqR2JGUVNQazFKTjBxcVR6UUJMSHoxcDVRZHFpVWp0VXluaWdSQkxIbXFqSmhxdnlISnhVWGw4NW9BaGpCRENyZTc1ZWFqQzR4VXUzSW9BWm1sb0s4MDhMaGFBRzA0ZE1VVUhpa01YcFM1cG1UU2c0b0FmMXB1YVU4VXVCak5BQ2c1NjFQR1FpOFZWVTgwcFlpbWhHakZKbnJSTktBcHhWTlo5cTFGSlBtbmNteEZkM0dNMVJOenpVZDlQdHpWT0tRdTFJWnRRVEFpcGVyVlNnR3pGWGx4dHpRTWtBN1U1VnBzWkJOUzV4UUFtM0ZOWWdVNW15S3JzMldvQWNHeWFldFJnY1U0TmlrTW1BcUdiNWhUeEpUR2NVQVUyWGFhY3E1cDdwdWYycCtOcTgwd0ZUZ1VPbmNVTHpRVG5pbGNMRU8wbHFjeW1uS1BtNHB6SDFvQWg2Q21oTjFTTmloU0tBQkxjR250YmdDcFl6U1N5VUFWaEdGNXFaRGtkYWlhUWM4VkdKQ0I3VUFTU1NZUEZVcHB5VGpOU3RJTTgxU2tiTW5GSUM3Q3U3QnE0SXhpcWx0bllNMU1aQ0tvUkZGSG5yVExvQlVJRlR4bkhXbVhJQnBvUlFoTzF1YTBvSHdCbXM3QTM4VmNpUEFwQmMwVnczU3E4NkRCcDBiWUlxVjBETFFCa3R3YWxqUEZMTkZ0Tk5pNjByREpzWnA2Y1VMMHBBMktCbGhEbWxjNEdLaVZqVDJiaWdDTnVPYWlCeTFTc04zU2tTTEI1cGlIeHBtcDJUNWFZbkhTcENjOFVBVm1IRkxHY1U5bHhRcVpQSFNnQnc1bzIrdEgzYVhPYUFFMjk2d3RZZkNHdDVqdGpOY3ByVS9VVXlvYXN4VHptb25IRlB6U0hrVlNMa1ZHKzlTZ1ZJMGVXcGRuRlVaTWhiRlZwTUdyRWd4VldTcVJES2NxNXFvOFdhdlAxcUZoVkVsTTI0UFdtRzJXcmh4VWJtbUt4U2t0VjI5S3F5MjR6MHJSYzFVbGFxVEUwVURGaWxWYWxibWxqUXV3QUdTVFJjU1JwYUZZbTZ2azQrVlR6WHMyZ1dteUZNRGdDdUg4SzZUc1ZHWmVXOXE5T3NiY1EyNEFIT0s1cE83TlV0QzRoMmltR1E3alNvcE5QTWVGemlwR2MvclQvQUxsL3BYbDJ1SDcvQU5hOVMxcGN4UFhsdXVmZWY2MXBEY2N2aE9Za05RTlV6MDJLRnAzQ29PYTZUbEd3VzdYRW9SQm5tdXQwM1RsdG9oa2ZOU2FScEsyOFlaeGx1cHpXcVJqdFdVcFhONFJTMUl3dFBIQW9KeFRkMVNqUnNVbk5OTkJOTkxjVUNJcERWZG16VXNoelZkelRBamtOVjNhbnlOVmQycGtrY25JcWhMbEd5S3VPOVY1aHVGTVJINStSVU1qWnFCeTBiY2RLYVpBdzYxUkRZK1BpNFUrOWRORmd4cjlLNU5YSWxYSHJYVVd6RnJkZnBVc2Nkek0xRzVJbEtMd0JWQmJpU05zcTFhRjFaeXkzQklIRk5Ha3lOMU9LdFdzUTR5Yk85OE4vRkdTeTB1S3p1dHhhSThIUFd0SHhIOFhEYzJmbFdvWXV3eGl2TkUwZHh6dTVwODlyTEJHRzJoc2VsWnRLK2pLVVdpdGYvd0JvNnRkRzR1QVFwT2VhMWJDN1MzalVsMURKNzFsVDZyTWJjeEJjZHVhekVXUm5DaGo4eDlhcmxGZEhZVGVML0xtSUQ3T09TcDYxY3NmaUg5bmcyRWVZUGV1SUdsU1BjS3BCSVBVMTBkdG9WcXNRM0prNG9iUUtMWm8zWHhBZVkvdVY4cGljN2hXSnJIaU9TOGgrZWRwSkRWNlR3L2F2OTFjVlhtOE5Ra2Z1eVFhcU03RXlvM1ZtWWVpSTBtcXE3RE5kd3E4Vm02Ym95V1RiMitZOXExTVlxSlN1emVNZVZDWXhVYkhtcERVYlVoc2drTklKTUNrbE9hcU5LVWJCcGtsb3ZrVlRtZnJTbWJBNE5WWlpkMmFBdUlKdHNvUHZXbXNnSUJGYzlQTHRQcFYvVDdzU1JnWjVGRmd1YXdmTlNJYXBySmxxdFJqTklkeTBoNHFaSHhnSG1vWTF6VmhFSGVnb2NQbXBQVVZJQjZZcE50QUVMS2FqWmFzbE05NmliR2NVQ0tqTFVMclZwMSthb1hITk1SU2tYdmlvR0JxN0l2QnFCMHFrUXltd3FGeFZ0bHF1NDVxaUdpQ1ZjeC9Tb1U2MVpJeUNENlZWNk1jK3RNazZMd3EwZjlzUmViZ2pOZTJRN1ZoVUlNREhGZUE2Vk9ZYjZOeDJOZTdhWE1MalRZWkFjNVVWejFOemFuc1d3YVFnNW9QRkxuaXNEVVZhVTVwRmJOT3pRTXJTQTdUVmJhVFZ1WnV3cURGQURWVWlwQlRrWE5LUUJRSWFGelR0Z0ZHY0NrRFo2MEFQUkFhZVVwcW1wUTJSVEVSbE1VMG4wcVJtelVYZWtNTWQ2YWFlVHhTWUhVMEFKakFwbk9ha09EVVo0b0FjV0ZBYlAwcUluTkc3QzBESkF3elNsczFDbE9wQUlXelRYKzZhWTdFTnhUU3hOTVJCTGJlYU9haFMyOHRoaXRCRkpwR2krYWdCcURBRlM3c2Q2YXk0R0JUQ0RVdGdUQ1hCNHF5amJscXBHbWFzeDVBb3VBOWo4dUtoSTVwem5GTkdTdWFZRGtQclNPMkd4U0E3YWJqTFpvR1A2aW1kRHpVeUxUSFhtZ0JNMHJjMHpPRGluWjRvQVhPQlJtbTVwdzVwREFkYVJxRHhVWmVnUWpVaXFjNXB5dG1uNHBnSnVJNlUxbXpUeVJUQ00wQVJOVER6VWppbWQ2QUVaZmxxTFl1NnBpTTB6WnpRQTlHMmlsM1UwOUFLU21Bbm5qUFdtU3pGbDRxa1hZSHJVOFNGaHpUSUkxQkxWb3dSNTYxVFpkamNWY3Q1Q1FLR01tMm5QRlRxU0J6U0tSVFMvd0ExSUJrcWx1dFY4Ykt0bHhqbW8yUU56UU1ZcHpTN2hUVHgwNlZHVDgzRkZndVdFYW45YWlpR2FsZjVWb3NGeHdvSnFvSmp1NU5UUnlodXRBRTZISFdubHVLaUQ1cDRPZXRJQUIzR3BBdkhGTUJWUlRsa3lLWUNNdE5CdzFQM2MweHVNVUNJYnVZcEdhNDNWWmQ5eGp0WFVhbExpTTgxeGQyNWtuWTB6YUMwdU5YbW5ZcU9NMUxUS1kzYlRHR0JVd0ZSU0NxUmt5cEpWYVRvYXN5OWFyUFZvaGxTVHJVTEdwM3F1OVVSWWpMVkV6VTlxaGMwQ0dPMVZKRFUwajFWZHZXcVJJMnRqUUxIN1ZlcWNaQXJKUWJtd0s5RDhINlZ0alYySEo1cUtqc2h4VnpyOURzUWthNVhHQlhTeDhLQlZPMWhFVUlBSE5XMDZWejNOaXpFTTFJMkNEVmRYSXA0T2MwWEZZeE5aUWVVL3dCRFhrK3VqNTVQcWE5VjEyVllvSExFQVlyeWpVcnVKNW5BK2JtdHFjVzJUVWtsRTUxTGQ1cEFvNDU2MTBtbWFkRGJxR2JCUHZXVjlyaWliaEQrVldZdFR0M0lEa3JYUzQrWnpLcGJXeDBXNEVmTGpGTUxWVGdpZWRkOW5LRzlzMHYyaDRYOHU2UW8zdjNyS1ZOeE40Vll5MkptYm1tN3FHY1l5RFVMUDZHb05HU0Y2UW5JcUhmNjBlWnhUSkNScXJPM0ZPa2VxOGo4ZGFZN2pKR3FySXhwMHNudlZhUi9lZ2tHYW9uZmltTkp6MXFKbnozcWhYSVorZWxVWFlvYXR5TlZTYmtHcVNNMk5XZkxENjExMWkyNjFUNlZ3elpXVGoxcnN0S1lteVhQcFJKYUJCNm1pS2VCVVlxVmF4T2dYcFNNb0l3ZWFEbk5GQXpLMU96WHl5NkxpcUZqYm1TNFVnY0RyWFJPZ2tCRERJcElJSTRzN0ZBcStaMk0zQk5ra2NhcUJ3UHlxZFRpb3dha0I0ck0xUklHcDRJSXFNTUdOU1l4VEFYR0JTTDFwU2Mwek9LWWh6dDZWQ3g5YWN4SHJUR0pvRVFTVlN1RkxESXE4NHl0VlpCa0dxSVpsdE1Zemg2aWtrRExsYXQzRUt5TGhxeVo0WllDZHB5dE5FTVNjbHU5UjI4N3dUQnUzZW9XbVA0MHd1VDNxckUzT29zNXZQWVlyYWhXdU4wYWRoZktwUEJOZHBGMHFHck0waXllUGcxT3VUMHFCYXNJQ0ZwRmk3Y2NtbHdNVTdncmc5YVRIWTBBUi9wVEh4MjYxSTY0cGhHZUtCa0RyelVUcDNxMHkxQy9RMEF5bzQ0T2FnZkI2VmFjREZWM0dLcEVNck90VnBCVng4WXF0SlZJaGxiUE5WNTEyeWZYbXJEZGFqdUZ6R0c5S1pteElHMnVEWHNuZ2UrRjFwUWpKNVd2RjQyd3dydi9BSWY2bVliNFFzZUdyT290QzZiczdIcUpXbW1weUFWQkZRT0RYTWRBTHdhZVNDS2dMWXB2bUdrQTUrdE1OS0RtbkJhQmd2eWltc2VhY2FhVnlhQkNFOFV3ZGFsMkhIU21DTWhzMEFTTHhVbys3VEFBYWVCUUJHeE5Sbk9NMUtSVFdBd2MwQVFOS1JTQ1VtbzVtQXppb2xjNW9BdUsvclNNZlNvbHlhWEo2VUFLVFNFVTVWTFU0cDhwcGhjYW5TbjR6VVNaenpWbU1BMGhsZDR1ZWFGVG5tclpRRWRLZ1pTR3BDRlVZcHhRSG1oUmpyVERKemlnQjRqQjYwL3lsMjVxUGRTN2lCMXBoY2NGQXBDZG80cHU3MU5NTGZOd2FCQzUzR3BWUVl4VEZ4VXlIQXlhUXhoaXFJQWcxT3pacUYyeDBvR1NxL3k0NzB4bXBtY0xtbTVKb0FRdGswMHZTQVVoNjhVeER3eEpxUmMxQURpcFEyQlNHTEljVkNUelJJU2FhT1RRQTdPRHhVbm1mTFVacEMyS0FKZzROSVQ2VkNHNXAyYzlLWUNOVFFhVWlrSXhTQVFrMEEwVUFHZ0J1VFNiNmNSU2JhWUZKVTNQelZ0UmdZRlJnWUp4VDRlRzVwa0N5UlpBTlBRaU1VN2NYNEhTbVR4NFdnR1RDNkZTQ1FNdVJXRExPWVpBQ2VDYXVXMTFtaG9FYU9RVFVnQUk0TlFLUXd6VGxOSVk2Uk1DcStNTlZna3RUY0RiNzB4Q1I1QnFaK1ZxR05pRHpVbTZnQ25LTnVjVTYzem1uU0x2YmdWSkZIdEhTZ1pMR3ZQTlBQWGlrR2NVZ0J6elFBNG5LMHdNUlFRZDNGTHQ1cERKSXptcERnaW1JS2NmbFFtZ0RBMWlYYXJWeWpITEUxdjY1TGtrQ3NEdlRPbUs5MEZITlRxdWFZcTFNZ3BraWJlS2lrRldTT0tyU0hGVWpObFNVVlVrRlhKRG1xa3RVU1ZKT3RWbjcxWWxxQW96ZEFUVkVGZGpWZVE4VmZGcEsvUmNWUEJwWUxmdmFZck13dktra1B5b1QrRk8vc3k1YitDdXRpZ2lRQlkwQlAwcVVROXlLTGk1VWN0WjZYS2x3alRLUWdQUEZlbmVIN3V4alZGTGhjRHZYTjNFcWVTRlZjR3FqUEdrUHlnaC9VR29rcmxwV1I2NURjd1NnZVhJcC9HclNybGVLOFpnMUc2ZzVTVjFQYm10bXg4YTMxcmdTbmVvOTZ5Y1pEUFVGU2lhVklJaXp0aml1T3QvaUJBeTRrVEJyTDFYeFE5OHhFTEZWTkt3RHZFbCsxOU9ZWTMrVHZpdWQvcytJZHNtcC9QQk9TY21sRWltdDA3SVZrVkhzWWY3Zy9LcWsrbVFPRDh1SzFqZzFHeWowcHBpY1VZS3hYR216Q1cwY2pIYnRYU1FhaGFlSUxEeUxoUkhjcU9EM3pXZGNLTnB3S3hyaG10SmhOQ2RwQjdWY1pNd3FVMTBMcG1rc2JzMnR6Ni9LZlVWWkxaR1IwclAxQ1pkVDA4VEp4TWd6bXF1bWFnWkU4dVEvTUtjNDlVRk9kOUdhalBpbStiaXEwc3VEMXFFeitwcUxHdHkxSkptcXNzbUtpTTJlOVF5U2U5TVZ4WkpLcXl5VTJXWHJWU1NYM3FraWJranlVd3lWV2VYM3Boa3ozcXJFM0pYa3F1NzVwak9UM3B2Sk5VUTJMczNNUHJYWGFkaExWVnoycmt4V25ZM3JvNnFUa1ZNaHhPb1ExTlZhQnQ2Z2cxWVAzYXhPaENEclRzVXdVN3RTTEVOS0RTRG1nOFVBUFUwOEhpb2MxSXArV2daSWcrYXB3YzFCR2NtcHM4VUFPemltRVVVakgwb0VJM1NvMk9hVmpVWnBpR3NlS2dlcEdKcUZxWkxJWlZ3TTFUY1o2aXJjaHF1OVVTWjF4WUxKa3J3YXpwYmFXTHFwSTlhM1RTaFEzREROUG1KY1VaT2tOalVJOCt0ZDNFZmxybllMV0paMWNJQVFhNkdFOENwZG1WRldMS2pnVk1wejBxTlJ4VXE4ZEJRVVNMeU9SU2tZTkFKeHhRVG52U0dOYkhGUnNDRDFxVXJpbzJINVVGRVRHb0hQQnpVNzhlOVYzejZkYUJFTG5uZ1ZYY2pOVFNBK3RRUFZFc2lma1ZXa0hXckRWWGtOTWhsZHFhUnVqWWUxT2Vtcjk3RlVac3FLZm1yZDBHOE5ycUVUZzQ1ckVkZHNwSHZWaTNmWXlzRHlLVFYwSlBVK2hiRzRGell4dURuSzFNeTVybnZCZDZMdlIwQk9Tb3hYVHF2SE5jYlZtZFMyS0xvYzFFUmcxZmtUMEZWaWdwREdMVGhRQUJTNDRvQVRxYWtqWFBXbWdWS3BBRkFDbEtRb050UEREdlRYWVk0b0FpQXBSbWszWW9EWm9BRHgxcUtWaGppbGQ4VlZaaXpVQU5iQmJtbEVZN1VCQ1RVcXBqclFNYjkwVWljdG1uUHlhZEdCaWdST2lqYmlrZGRxa1VpNUJwekhORndJZGxUUkpUZ21SeFI5enJRTVZtMmppb2p5TTA0ajFwTncrNkJTQWhaaU9sREFiYzA5d091S1lPZnBRQWlqTk1ra3cyS2NHK2FxMCtRMjZpOWlSczF5VjRGUGhjc0FUVko4c2MxS2pGUUtMM0dYMGY1cWUwNUM0RlVXbTJkYVlKaTlBRjBUbk5TS04xVjRZeXhxZGlWRkF4emVsSUthWCtYUGVtcWMwQU9JRlJrNHBHSjVxTTVwaUpBTXNEVSt6SXFLRVo2MWNHM1pUc1MyVTM5S1JlT3RQblpWcXQ1bWU5SWFaTVdCcU04MDlmbVhOSnROSW9SUlR3TVVvWGlseFJjQnA2MG1LRDFwUVJRQWJSUmluWnBoUE5BQnRvMjBoYWpOTUN1bzRwRHhUbDVBcFcrWHJTRVN4SEM1UFduU2Z2RTRxSlRuaXBCa1VDTWJVTGRuNmRSU1dhc29BYXRTU1BQYW9saHczQXFtN29MYWxpTGtWTUtqalhhT2FsSE5TTUFlYUJuZGltZ2ZOVXNmV2k0Zzh2QnBvRldNYnVsTVlZcDNBUkVHNnBDdnBUVXdEVXhJMjBYQWhKeFRjMHJNRHdLUlRSY1k1Um1uNHpTS0tjS0FIQVlGUlhERlltK2xXQUtxM3h4Q2FBVzV4K3NQbVlpczFSMHExcVRicnMxV1NnNlZzU0tLbFVVMVJVcWlxSllqZmRxbk5WeCtsVkphcEdiS2JuRlZwS3NTVkNzWmtjQWV0VVNWMWkzc01qaXI2d2pZQkduNDFmZzA1VmlEUzBza2tjTWV5TWMwYjdEUzdtY0l5bkwxRzhtOXNMd0swYmUyV2E1UnJqaVBQTkdwdzJzRjUvb2h5TVZTVEUyV2RQaHRiZUVUVE5sOGREV1pkWElhZDluM2M4VTRRU1NKdU9kdFZKWWpuNWVLQkR6R1c3MG90MTZrMUd1NUY2MUZJNyt0QUZrd1JrWUdLcVhFUlE4VkM4cnIwTlF0ZU5qQk9hRVN4V0pISU5DWEpYZzFVbHVjODlLci9hQ1Qxb2FKdlkyVnVNOTZjTGdqdldRazVIZXAxbTNEZzB0aXIzTlNPOXdjTWNpckluVjE0NXJubWxJNzBrZW9tSmdDZUtZcm01TmdyV1Zkb0dVNXE0TGdTd2hsT1JpcUZ3K1FhYUU5VVp0cGNHRzVhSS9kYXFWeEliVFVOeW5BSm91MjJYQ3NPT2FacVB6UXEzZXVoYXF4eXZTVjBhMzJrU3doZ2NtcXp6NFBXczIwdWlxYlNlbEpMTnpXZGpibTBMNXVjVkRKY2dpczh6R21OS1Qzb1NGekZtV2ZOVjJselVSSk5OcTdFWEhGczBtYVNnQ2dRVTRDbFZjMXBhZHBOemZ6TEhiUk01SjdDazJoMmJLY2NaWWdEbk5kaDRYOEYzT3F6TEpNakpGbnVPdGRYNFUrRzJ3cGNYNDNOMUM5aFhwMWxwOEZuQ0VqVURBOUt3bFU2STJqQzI1NWhyL0FJYVhSN2FPU0hwMElyQWI3dWE5YjhUV0F2TkxrWEdUdDRyeVdaREd6SXd3Vk9EVXAzTk5pSUduWk5SZzBvcWdKRlBYRk8rOEtZblUwNVRTR0tGNHA2cmlrV2hqZzBBS1BsYXBnZU0xRXZOU2M3YUFFTFlwTi9wVEhwZ2FtQktlYWpKcHdPYVJoUUJBNXhVTFpOVE9DS2pZVXhFREQxcUZoVTc4MUd3cGtrR005YVVDcEF0R0JRSVdNNFlWczI0eW8rbFlxakRDdHUyUDdzZlNrVVhZeWNWTGdudlVVZldwZ2FZeHd6dDYwZ2IxcGNFQ2s1UGZGSVpKOWFpZmdFZXRMa2swMGdab0dSc01EQnFDVHA2VllKd0NLZ2s1Qm9FVldPR3FDU3AzSE5RU2M5S1ltUUhtcThsVHRVRDFSbXl0SlVhdDg5U1MxQm5EVlJEQzVINzNQclJHZWxPdStWUTFFcDZVeUQwejRjNmtFYzI3bnFlQlhwdm1BQ3ZDZkNWODFwcThaQjRKcjJsSk44U3NPNHpYSlVWbWRVTlVUdkxucFVET0tVOUtydGttczdsa29JcDQ2VlhVRW1wMTRITkFoNHBlbE5IV25VQUJxTmppbjk2UXJrMEFRczFJRDNwMGljOFUzR0tBR241alRmTHdha3hRb3pRQTVVQUdhQ00wdWFDZUtCakF1VFNxbk5HYVVPQjBvUUNzY1VpdG1tbmtVTHhURVdJMnhVTTBtV29WcWF5a3RTWXhDekU4ZEtWQmprMHZTa0lPNmtBcmM4VWpEYXRPQndhWktlTTBnSUFmbU5LOGU5YUVJTlBMamJUQXJyYmdaRk44c0EvU3JDSEpOSVV5ZUtMZ1o4Njc1QUJWaUMyT0JtclNXZ0pCTlhFaVZGb1RFUlF4aFVxR2MrZ3EwNUFIRlFFYnFZRkVNKy9CNlZhUkNRS2Q1WXowcTFHbnkwaGxmeXMweG94dXE2eTRGVjNHUWNVQVJBaGFqbG4yamcwa3NiWXlLckZDZXRBaUc0dVdacVlrcHlCVmdXMi9uRk9XMkN0a2ltQkxHZmtGU2hoVURuSEFwRTYwQVd3ZUthVFN4bjVlYWFXR2FReE5wSm8yRWRhbWpHNnBqSGtjMEFVODRvNjFNWWdLYXdBSEZBRUpGR0tmak5PMmlrQlVqNG9jN2pUMXhTT0FGeUtZaHFuRENyQU9ldFVseVh6VnJJQzFJd2RobkZDMUgwT1RUb3pscVlFbWFrWDd0UmRhV005cUFIMCtOdWFZUnhUUXdIRkZ3TERTNEhGVm5rTk9MYnFpYmcwQVNwTGtZNzFLcjFWVVZLdEFFdmZOSjNwU09LVlU3bWdDUWRLbFFVeFJVeUNuY1E4RGlzN1UyQWlOYWhJQzhWaWF3K0l6VEd0empMczdybHZyU0lLYTUzU3NmVTA5QlFkSk1vcVZSVEU2VklLYUlZeVFmTFZLWVZkYzhWbVgwNGlXdEl4YmRqR2N1VlhJbUFKd1RpdFRTTERlNGRoa0N1ZnQ1ak5OejYxMXRwS2x0WUZpUm5GWE9QSzdFMDVjeXVNMUNhR0xJUEdCV0xhdUpMZ2x2dSt0TnZMZzNOMWhjNHBkM2tRN2R2SjdpaUt0cVZKNjJSTmR6cytZNE9WSGNVMjJWWlB2am52bW5XdHNXSG1KMzZpcEpHVU5oQnozcHNsSUpuMnI1YTFCSmI3VStia0d0RzJzSGxYZVJWZlVHOGxDb29LTXBnSW13ZWxWcFhDNXhVTnpjTVc1TlVwSit1VFNBbG5seUt6cFpjSGcwazAvdldmTmNjbm1ta1EyV1pKY2lvMGZubXFabjk2czJuNzQweWR5MmxTQnNVbXpBcHJacVJpU1NkYXo3bVVpcmJrODFuM05Xa1p5WmUwelVkcW1LUTFibGt5SzV2Y1ViY0t2UjNtNlBESG1ueTZrcVF6VUc0L0drbGNTV2Erd3F0ZHk3czAyR1VHMzI5NjFpWlRJeHczRk9KelRTUG1wMktSUTFxWlR5S1RiUmNMRGNVb0ZTTEdUMnFlTzJaaU9LVndTS3dRbXJ0bHBWMWZTQkxhRm5KOUJYVmVGL0NjV29TcTl6OHk1KzdYcnVqNkJZV0Zxb2hnUmNEc0t5bFV0c2FLSGM4dzBINGJYVjA2dmVqWXY5MnZVZEU4TDJPbFJLRWlVRUQwclJFaXhjS3VCVVp2UVd3RFhQS2Jac2xiWTFFQ291QlRnTW5pczlaZHd6bXJFYjhWTnlyRXMwU3l4c3A3aXZJZkZ1bm14MVZpQmhKT1JYcm5QV3VMOGYyWG1Xb25VY29jbXFpOVJIbS9UclRnYzBqY1UwRDhLMkpKUWNHbnJVSXFaQmtVREhMMXFRZ0VWSGpGS1dJNG9BVE9EMXA2djYwenJUV0ZBQ3MyV3dCVERrSEpxUUQ1YWljNHBnU28rV3hVanFRdWFvUElVTzRIbXJNTjRyeDRjaklwazNFWmdUelVVZzVwc3N5Rmp0TlJpY0hpZ0xpdFVaRk9MWnBwb0FURk5weE5OTkFBUHZDdHEzLzFZK2xZZys4UHJXeEMySXhTR2k4amdDcFZiZFZKSEhyVWl5ZTlCUmRGQmFvVWw5NmtVZ2RhWVhITnl1VFRjSGRrVXZXbmJjMEFRdU9jMUM1eUttWWRmU29KQnh4U0FxdjNxdko3Vlpja2pKcXJKMXBpSUhKcUJ6VXIxWGMxUm15R1RwVVBWcWtrTlJmeENxNkdiSmJyL0FGQ2ZXcXFtck4xL3g3cjlhcUEwMFN6UjA2VXhYY2JnOURYdU9pWEgyclM0VzYvTFhnc0RZWVY3RDRIdWpOcElVbjdvckNzamFtM1k2a2cxRnR5ZWxTOWV0S01DdVkzR0JOcDVwNSs3UVRUV2I1Y1VBQ25tcEJtbzFHS2Z1b0FlQjYwTUFCVVc3NXV0TWtsOTZkeERtUHBUTWM4MUVIcDRiY2FCajhqcFRhYVd3ZWFjT1JRQTBBZzA4ajVhZUYrWDNwTUVpa0JEelFvcCszbXBGVEZBRGRweDBwTnBGV0FLR1VVN2lJRlNwQ3VNVktnQTYwcnFNY1VnSUNnNjFHZnZWSzFNSzRvR01QclVVbVR4VTJNMUd5MEFRQlNEeFQxak9PYWtSTW1wOW1hQUs2cnowcVJFNXFVUjA5WStLQUdyeFRuUHlVRmNWR3hPNmdCbkpwVldnMUg1b0RZb0FzQkJVcXJpcXF2em1waEpoYW9RNlRKcUlvY1U4dnVwUXdBNXFRSzdENWVsUUZLbmRzdHhVWkJ6UU1aZ0xVYnlBVkt3N1ZTdVZ3ZXRGeERXaythblJ5YzFWem1vcFpHUWNVQWFYMm9EZ0drODljODFndFBJR05Xcll1N1pZbkZPd0hRUXZsUVZxZG53S3pZWlFpVTJTK0FQM3FMQ3VYbVltb0paTUdzNlRVMUhRMVF1TlU2L05UNVd3NWtqZlc0VlJ5YWhhOFhjZWE1ZDlZd2Z2VldiVi9tUE5VcWJKZFJIWng4MHJqQXBzZkFwNTVyTXNZaTg1cDVRbm1sVWVsUHpSWUxrRGc3Y0NueERIWHJUanpUVHdlS0F1U0NrQncxTlU4MDhETkFEczVwaFhtbnFLTnVlOUt3Q0tLZnN5YWFCam9ha0hTZ1kwSnpUdHRLRFQ2QkFGNHA3Y0xTRHBUK281b0dOVS9MbXBVYk5SaW5nWTZVZ0pnNDI4MXordVNqeTJ4V3d6NFd1YjF5UUNOdldxUlVWcWMyT1dQMXFkS3JxZWFuVTB6Y3NKVWg2VkNocVFuaXFSbkprTXJZVTF6R3NYVExKN1Z2Mzgva1FNM3BYSzZoY3gzVUp4MXpYVlJWbmM0cTh1Z3VtWG02YkI0cm9CY3RMRnNCcmwxVVFJa3NiQTU2aXVoMDhoa1VudlNyUjk2NDhQTFRsTDFwWTV6Sy9BSHJVbHJadGUzSkE2WnF4Y1RKSFpCRjZtcnVpUEhFTnpkYXo1am9hMEdYdHVMQzIycU1ISFdzeXhpODJmNXU1cTNyMS93Q2EyTWdWUnNydFlEdVk5S1RlbzB0RHBKWkZ0TFRBSTZWeCtxWG05bXovQURxZlVkV013T0c0cmxOUzFBcm41aFJ1TFphamJ5N1dQSkovV3NwdFJWeWVheWRRdjNsWXFwSk5WNG9KMitZNUFOYlJwM09lVld6c2FzMTRQN3dxazkwQ2VEbWxXMTlUbWwreWpuaXRGVE12YVhJRGNaUEJyWDBad1pjRTlhekRaYzVVVmYwMktTTzRRNDR6VXpqWkZ3bGRuUlBia2pOVnlvNkd0cUszTWtZNDZpbVNhWTJjNC9TdVpTT3h3dWpDbGg0NHJNdWx4WFNYRm04YW5JckJ2b3lPMWJSWnp6alpHVko5Mm1Cc2RLbGxHQmlvaU1ETmFuT3lLWnZscElEemltU0hKcXphd2x1Y1UraEc3SEJTVFR0aHF5a0hyVXF3anZVR2lSVFdFbnRVcTIzclZ3SUIyb0lvR1JKQXExWWpVQWpGTVdwVTVZZldreG85QThGa0xHTjFlandTS1lSZzE1cDRUVW1OYTlGdFlqNUFybFp1aEpueWVLaGppTFNacTRscGsxT3R2dE5TVmNpVkR3S3R4cVFLUUpnMU9QdThVckJjYnppc2J4RmJpZlNwUXd6OHByYkhGVU5YQWF4a0h0UWdQRnBZOE1SNkdvd3RYYm1QTTBnLzJqVlVqYlhRdGlPbzNIcFRoeFNoYzgwRVVBUEJ6U3NNaW1DbmsvTFFNYU90TGlrR2MwR2dBSnhVVGMwNWhUT2U5TVJDNHlhcFhNRFlKallnMWZkYzhpbzJGTWxtRTA5MUMrQ00rOVRXODhqTjg0SXJTZUlOMnFGb2dEd0tZaHl5WkZPM1V4UmlnOWFReCs2a0xVeWtBWW5DZzBBU0JodUZhc2JnUmo2VmxwYXpPYzdTSzBWaVlJQWV0REdoVE1BZXRLTGtldFJQYk0zZkZRdGFTZzhOeFNIYzBvNXdlOVcwa0JBd2MxanhoMEl5S3Z3c1NvTlVLNXBCdUtlQ2R2RlZrYlBXcGdTUlNLVEd1M3JWYVExWmsrN2tHcWo1eG1rTWhmcFZTVEdhc01UM3F0TVBTbWhNcnVldFYzTlN1Y2RhcnVhdEdiSVhOUnJ5MU9jMGtmV21ac2t1K0xkUHJWTmF0MzNFS1ZUV25IWW1XNVlpUE5lbC9EdTZHMW9pYTh5alBOZHA0RnV2SjFJS2U5WjFOalNudWV0VW1hYXJiaHhUc1Z4blNJeHBjY1VZcGNjVUFOemdVemZtbGJyVGNVQUtXK1dvSEJKelZqSEZNSzBBUnA3MDdKQjRGSmpGTzZpa0FNdTdtcEFjQ21CY1V1YUJrb1BGRzZvOTNGTmQvbDRvRllsQkdha0J6VllNYW1VNG9HVGRGcUZwQURUOTJWcXJLZm1vRVdFa0JPTTFLVGtDcUNFN3EwWWx5Z29BaVlHbUhtckxyeFZWamg2QUUySE5PS1pXcGtHUlR4RDNwaUtxamFlYWVYSGFsbFdxNU8ya010SWMxWVZmbDVxbkU5VE5MeHhWSVRDWmdvcW8wdVdOTE0rYXJBa3ZRSWw4d21vbXptcDFUanBSNWZ0U3NPNHhDYVZuNHFRcUZGUU93QnFoRDBZazlha3p4elZaSkFHcVVTQW5yU0tBL2VwNjhpazNpbU5LQjNwQ0pHWGpOVUpVeXhCRk9sdlF1ZWFwU1gyVzRORm1LNDhRNFludFVNMFdSVHZ0WXdNNHBqWGFjNU5Va0RaWGFFS09hVHoxaXFLNXZWd2NIaXNPODFISENtdFZHNWxLVmphbjFWWTE0UDYxbFhHcTViaHF3WnIxM2ZyM3FJeWxxMFZJemRRMm4xTEE2MVJ1TDFuQndhb2xqU0VtdFZCSXpjbVA4NWllV05HOCt0TlJTYW1FVlh5azNaNmdEanJTczR6eFNoVlpjNXBoajJ0elhtbmVTcFVsUXFlY0NwbDRQTkFEbFFtbXZHUlZpUEZPZFJpZ1JVVkQ2VklGeFRxT2xBd1VmTGltNHd0UFhtaDFQYWdDT1BxYzFJT2ZwVWYzYWNyRHZRQS9HS1hkZ1V6clFSaWdZNFNjMHBtNHFCbTIxSDV1VGlrQmNqazNIbXAxYkE1cWxHU1NLdGlrTWJLY0tmcFhKNjQveW5udlhWWEgrcko5cTQ3VzVNc0I3MVNMaHVaUzlhc1IxV1RyVnFPbWFOazZBMDQ4Q2hhVi91MVNNNUdQclJQMk5zVnlQZXUwMUNMenJkbHJqcElqSEl3STZHdXFEME9LcXRTSkZiZmduZ211bXN6dGpYNlZ6b0dLMW9aeUxjSFBhcHE2b2REU1JxeXk3OW85S3R4VG1LSHJ6V0hCZGgzd2UxVHpYNkx4bmdWem5iY2JxRjBTL0pxbzkzdFhyaXFWL2ROSWN4VnZhUG9NZXM2T0pDMkpWNjA5bUxjNStlNVpzZ0hpdVgxVjVOK0VZa24zcnM5UjBkOU9abGM1QTcxaWYySk5kdVpXWENkcTFwMnVaMWVaSXc3V3grWHpKT1Q2Vm9MRU5vR0tzR3psdC92REsxWWhpV1RHUHlycVd4NSt2VXFDMHlNZ1V2MmNEcUsxVmh4MEZLMXVwNXhWcEVObWFsazVHNEQ1YW1XRVJFVmNFaGhqS0VaVTFDUnZYanJXYzA3bWtHcmFHL29sK2hrV0c0NkhBQnJ0azBaWklBNnFDQ00xNVhETVI4aCtWbDZHdlJQQ2ZpWkpiSDdMZE9CSXZIUGV1S3BHenVlaFJxdCs2eksxbXc4b3NBSzRqVkl5akhpdlN0ZWtXUWtvUVFmU3VBMWlQcWFLYjFMcXJRNWlVRHFhcXlOdTRYcFdwOWk4N09EVGswMVY2MTFJODltVkJhdEkvSU9LMUk0bGpRQUNwdkxFWXd0TlBXZ0VyRGVsTFJRS1JRK2tORkZBQUttaEdXSDFxSEZUd2Y2d2ZXcGV3MGVpK0U0RDVLa1Y2RmJSc0lSeFhFK0VWLzBaSzcrRGlJVnltNEl1M3RTN3NVNG1tRVVnRnprMDlUVWFpcFZ4UU1DMVorcnZpeGtQdFY1K0RXZHJJLzRsc3AvMmFCbmt0eTM3OXlQN3hxczV6VmlmbVJ2cWFya2MxdVIxRlRwVG01SEZOQXB3cGdKdG94VDhmS2FUR2FRREFPYVVqTkhTbllvQWpZNHFJazFLNDVwajlPS1lFWFNtR25rVXcwQ0kyNHFKdXRUc005S1dPMGVVOU1DbUlxSHJ4VDBnbG1QeUwrTmEwV21vbkxqY2F0cGJnRDVSZ1VYR29tWEZwbi9QUTVOWFk3TkVIQy9wVjBRMDhSMHJscUpXV01BY0NnUmM4Q3JRaXhUaEhpZ2RpbjVHZW9wclE0N1ZlMkhkVFdqM2NtaTRORkh5T2VsU0pDUWF0aEJTaVBISU5PNUZpSkkvU3BCd01DZ2pCem1rZHNZeDFvQWE0MjlLclNObGFsZC9XcThyZWxJb2drUHBWWno2MUxJOVZaR3BpSVpUVlYycWFScXJQVm95WXdtbGo1YW1FMUpEOTRVeU9vdCtjTEdQYXFhMWExQTVrVWY3TlZWcHgySmx1VFJtdDN3OWNmWjlRallISE5ZS1Zlc3BOa3FuUFEwcGJEanVlODJNZ210STNIT1FLc2ZwV0o0VXV2dFdrb001SUZiaEdLNEhvN0hZaHBPS2NEeFRDQ2FVVWhnUUtUYnpUcVROQUIycGhOS1RURFJjTENHZ2UxTGpOUEMwZ0dZT0tNWXFURk1Jb0dKbWtJelRzVUt0QWhxcWMxS29QZWxVWXA0d2FZQ0UxQ1l5VFZrS0tObWFZaXVpYlR6VnlNOENvVEZ6bXBVOUtBdUxJMVZXKy9WbGx6VUpUYWNta0JJa21CeFV3azNEbmlxZTdiVHQ3WTRwZ1N5WXh3YXFzdTVxa0c1alNsQ090QWlQbGVsREUxSnR3S1ZVeXVhWUVEUmxxVlVWZXRTbkpCcWxjVGVYbm5wUUlzK1lGUFdtdGNvTzRyRG0xSUt4M0dxa3VyS01uTldvc2h5c2IwOTZxOTZ6cGI4RnNCcTUrZlZTN2NHcXh2VG5PYXRVMnlQYVdPa2JVQU85SU5TeC9GK3RjdkpkdVQxcUkzemp2Vit5RjdVNjl0VkFYN3dxclBySUE2MXl4MUI4ZGFnZTdkKzlKVWhPb2JrMnNaNzFCL2F1ZTlZMjR0MU5MbXRGVFJIdEdiQTFJc2Z2VTQzMlY2MWtJS2VXd0tmczBIdEdUVDNMTVRnMW55QnBEbXAvdkduK1hnVlNqWWx5dVo1aUlQU2xDSDBxMDZnR21nclZrbGNvZlNnSnpVNUFvQzB4Q1J4OXp4VTRVWXFQSUFvMzBBZWxSNEZPbU9WQTcwd0Q4NkNjMTVoM2lvMk92V3BRMmVhaHhtblp4eFFNc3BLS2VaTTFWWHJVZ29Ba3ptbll5S2pBcWRFeW9GQURVcHh5VnA0aXhUd3VFNXBvUlFteXRRSmNBdGdtcEwyVEFOWTZTN3ArdkdhYjJFZEZIaGw0cHhTbzdNcVZCelZoMkdlS2thS3p4azFGNWZOVzF3V29NUXpTTEdSTFZqcDFwRlFDa2VnQ0s2Zjl5Y1Z4V3NObWNmV3V2dXppSTF4ZXF0bTRQMXBta0NySDFxMUhWVkRWbU0xUlRMSzByZEtSZWxLMzNhcEdjaW5PT3RZOXpZTEl4WlJ6M3JYblBXcWJOZzVGV3BXTTVSNWtZTWxveXNRS2RHQ3FGRFdsS3lzZWVEVWZsSWVocTNLNWh5dUxNVjVudDduT0RnMDY1a096Y3A0cnNMQzNzSjdmYmRJdVIzTlo4OWxwNlgyd01ER1QwclBRNlVybzUyMVF6cWExN0xWcGRFaU8wNVZ1MWFsenAxbmEyL21XN0w5SzVMVVovT3VRZys2S2xxN3NYZmxScFQ2cEpxdDBxdU1LVDNycFBzYWZZa1dOQnlPMWN2cDl0SmNUeGtvUWc3aXU2aGpDV3lyN1U1TGtzWnFUbnVjWnE5dUxkOGRqMUZZd0d3N296eFhTK0lyWmhMdkhJcm15aFg1azZlbGRkTjZIRlZWbVR4M0dmdkNwdzI1Y2lxS2pkeU9EU3JPeWNWMFJaenRGaDB5S2dJS05VMFV1L2lpU1BjSzBjVkpFS1RUSW1qMy9BRERyVVBteXhQdVJpckR2VnFFZ05zays3Mk5TWEZtVkdTTnlub3dyaW5IbGRtZGNKWDFRKzIxK1JzUlhMSDB5YWoxQnhMRVNweURXYmQyckFaRlZrdldqQmprNUhTc3VSWHVqbzlvN1daUGJqR2FrWTFGQWNydUhlbk1hMFJreU42aU5QWTB3MENFb29xemEyTTkyNEVLRWoxbzJHazNzUUNqclhTVzNoa0FicmhpZllWZlRTYlNJZjZvVkRtalZVbWNhRk5XTFlaa1g2MTFFbG5DT0JHdjVWVk52RXB6NVk0UHBVdVNaWHNtanR2Q2k0dDQvcFhkUW45Mks4cjBmeENkT0tySkdHUWVsZHhwM2k3VExwUXJTZVUzbzFjNzAzTE9oMjVwQ3RNaW5pbUFhSjFkVDNGU2tpa2hEUU1VWXBUMHBBTTB3RTZtcWVzSm5UWk1lbFg4VkRmUjc3R1FlMUFIaVZ3Mnk0Y0grOGFnTFpOV2RWajhyVXBrUFp6VlFWdXRpWHVTcjBwd05SZzRGS0dvQW1EVWdOTUJwYzBBTDNwUWFBS1VxYUFFTlFzTUdwOXZGSjVKYnIwcGdWbVhkMHBWdFhmcnhWNUlRbzZWT3NRSzBEc1ZZYk5SanVhdUpDRkhUbW5vbUtsMjk2VnlraU5VcHdqTlM3TzRxVkUrWE9LUlJYQ1k2MUo1ZUZ6VW9UbnBUd3VlM0ZBRUNwMHBTT2VsVEJlUFNtL3hHbUJINWVhYVFCbm1uc1RqQnBwQzdUaWdSR3dIWTAwNTcwN3AzelRHUFlVQ3NOSi9Hb25iQnB6TlVETjF3YVlyRFhiTlY1RzYwOW42MVhsZk5BaUtScXF5TlVrajFWZVROTWxqSE5RdFR5YzFHMVdpR1JtcDdZWmZGUUU4MWF0Ujh3cGtkU3RmdC9wR1BRVkF0U1hiYnJwL3JVWTZVNDdFc2tXck51MkNLcUNwNGpnaWhnZW0rQWRRK2N3RTE2S0U5YThUOEs2aDlqMWFNazRVbXZhcmFZVDI2T09oRmNkU05tZFVKWFE0eGpGTUtnVks3WUZNWVpXc3k3a0xVd21ua1pwdVBXbFlCTVVZcGNFbWwyMFdHS3ErbE94UW80cFRRQTBpbWxLa0FwY1VXRmNpRWRPQ1lGU2dVcEhGT3dYSzc4VTFXTlBkRG1rU003c1VnSlVHYW5DVStLSDVhazJCUmsxU1JMWkRzcGpNRjZWTXppcU54TXE1NW9ZRXZuWUJ6VEQ4NjFURnp1YXJHL0s4VkpRb1FacVZRTWNWQjVnVTgwZmFWRFV4RnBWeHpUbVVkVFZYN2NvNHpVTTJvQmU5QXIyTGJFVUNSUUt5SnRUQ2REVlY5VkE2bW1rSnlOaWU0Q3J4V0xmM0lDazU1cXRjYXV2UUdzZTl2L055QWEwakM1bktSRGQzRzZRNE5VWkhKNm1sWnNubW1TTU1WMVJqWTU1U3VNWW1taHFhWHpUQWEwSkpDOVJ0eWFLY0JtbUloWVUzYWFuS1V3MGhnb3gxcGFURkhTZ0NlTVVrbkFwZ2Y1YWlrYzVvQWVyZk5VelNxcSs5VlZKb1k1b0FaTEtkMUNNVFRTaExWSWlZb0VQQU5MakFwYUtZRVpvcCsya3hRQjZhdWU0cGRvcFFhR0pBNHJ6VHZFNEZOeitOUkY5eDVvM1liclRFVHFjbXBsTlZsYkpxWkRTR1NacWFLVEdNMVZkOGRLWUp1Y0dnRFZFaW1teXlBUjhWbmlUSGVuaVVzdURRaFdNN1VwV3djVm1RN25rR0sxYnlQek1qMXB0cmFiU01pbXhscXpES3ZYQXF3WHgzcG9YYXVGcGRoNzFBeWFBNU9UVmpHZWxRUnFGRlREZ1VESDlxalkwdTdpbW5tbUJUdmppRTF4R290bTZhdTJ2OEEvVmtlMWNMZkgvU24rdEJyQWJIMnExSDFxcEhWeUlWU0d5eW9wSk9CVDBIeTFIS2NWYU1tVVoyNU5VcERWcVk5YXFTMHdLa3BxSU9RYWtrcVBGTkVNZUxoa0hCTk5TU0V5Wm1INDAwaW9aQndhZGliMk5SaGIzS0JVbHg3RTFCOWl0MnVGaENCaWU5WmtPVEtPU0FEMnJwdEd0RnVKeEszOE5OS3l1VGR0Mk5TeDArT0NGVlZSOWF2K1g4dnBVME1ZYkFGUG1qMllBckc5MmJyUkhOYTFDV1Fucml1UmtUREhGZWhYYUtCKzg1QjYxeTJzV0N3U2lTRS9LL09LM3BTc1lWb21JWVFlbkJwQkEyN0RESTlhblpjQVo0cDZraGZhdWxTT1Jvb2JDalpYdFU4Y29maHVEVXI3TnZBNjFSbCtWc2l0SXlNM0V2ZVRucFZpQ1l3amE0M0o2R3N1SytLY0hrVlpXNVIrK0swdkdhc3lOWXZRMDJzN2U3VE1iQlcvdW1zbTgwRnVUNWY0aXJDeWtZMnQrVlRwZnlwd1RuNjFpNkZ0bWJScmRHWUMya2x1TUZlS2pmanJYUlBjcko5K01HcXJKQkkrREVlZmFvY0pJdm5pWVI5cVdLR1Nkd3NTRmlmYXVtaDBTQzZJQWp3UFd0eXkwdTJza0FWQmtkL1dzWlM1VHBwdzV6bjlNOExsc1BlZE91MFYwVVZ0RmFwdGpVS0IyeFZreUFMaEJVVGJtckJ5Yk9wUWpIWVk3Y2NWQTVKcXlZaXdwclcvSFdwTEtMcWFnZGM5YXZQRGpwVUVpWTYweVdVbVRGTTV6d2Fzc2xSN0FLWk5peFo2cmZXVEEyOXc2NDdaNHJmcy9IZC9EZ1hLTE1QWG9hNWpiaWpGVHlvVFI2TForT3JDY0FYQ1BDM2YwcmR0TlowKzhBOGk2USt4TmVPRlRWclQ0NUpydFk0TjNtSDdvRkxsWk5qMmRuU09FeU13Mmp2bXN5NzhSYWJCRzZUVGdISFFFVjU5NHoxVFdMYUd6c1JoQ1Y1WVpCL0d1Ymp0bmZEM0VqTzU1UE5YR1BjaHA3R2o0aGVLYlZIbHR6bEg1cktDdDJGWHdnMmdZL09uQ1AycTdyb05SN2xSWUhQYXBGdFQvRWF0aGNVcFdpNVNpVjF0MUZTTENNOUtrQzFJRXBYSFlpOHZIYWtLQ3A5dVRTaVBubWdMRmJ5NmNJOFZhQ0QwcFJHRFRGWWdXT3BnbUJVaXA2Vkpzb0dSckg4MVNoTTA5VTcwOWZsNjBoakFucFQxWEhCTktXNHlEVE53NzlhQUh0d0tUY01jVkdYNXhUR2JGQUVyTm5pb3M0YlBhbUdUMXB1L0ZBRG5mSkpGUmx0My8xcWF6OWMwd1BpZ0I3c1IzcUptcEMrZXRSdWVhQkE3YmVneCtOUU8rYzQ0cFdhb1hZVXhNWTdkYXF5UHhVcm1xc2g2MVNJWlhsa3dhZzNGcWtrR1RUQXVLcEdiWVlxTjZrYW9uTk1rai9pcTlhakM1OXFwTHkxWGMrVlp1M3RUQXpKRHVtWSs5QXB2VTB0TkVNY0RVeUhGUUExS3BwaUx0dE1ZNUZaVGdnNXIyWHdocVl2ZExRRnNzb3J4Rkd3YTcvd0JxZmwzWGtzM0JyR3JIUTJwdlU5UXdXYW40NHhTWkdCaWtMNHJsTnhyREZSSGswOG5OSlFBWTRweUllOUFwNnRRQVk0cER4U2xxaWMwaGo5MUxuTlJxYWVEelNBa1duaE1qTlJHUlY2bW9wYnNJdE1sc2xjZk5Ua0FMWTcxbXRxQ252VTlyY3EzZm1nRGJoQTI4MUJQSjFGQ1Q0WGcxVXZKY2REUTNvRnRTS1NiRGNWVHVIM0Rta2FYcVNhclMzQUtuSnBKTXJRZWpETlN5WElST3RaVXQ2a2ZRMW1YT3BNYzgxYWcyUTVwR3ZQcVh6WkI0K3RWVzFRRHEzNjF6MDk4eFBCcW84enQvRWEzalNaaktvam9wZFpDNU9hcVNhMHo5Q2F4Umx6eVRVNngvTFdpcEl6ZFJrOG1weUU1T1QrTlYyMUNSczhtbzVWeFVBSE5YeUpFOHpaS2JsMjdtbUZtSnlTYUFwcDIycVNTMkp1dzNaRlJzeE5LMlIwcG81Tk1BSE5JVnFjSXVQZW1PdE1SRVFhZXVjVTVGcVRaUUJFZWxSbnJVNVROSjVWQUVISXBweWFzZVhSNVFCcEFRcURUdkpKcXdxWUZPd0tBS2hpMmltRVZhWmFpWmFCa1lGT0FwQ01HbkxRSWRpbEFveUtibk5NQUlvMjBoUE5PRkFIbzROT3p4VVFhbDNWNXAza2NndzJSVEZVN3NtcEdJSnBLWWg2SDVxbUZRSjFxVmlkdElZcHhVSjVrNG9MNDYwOUNPdEFDbENUVWk4VTBjOURTbmlnQnhWVDFwVVVEcFRBY21uRHJRQk1vcDJLaVU4MU1PbElZdWNVL2R4VE1kelNqbWdBTDRGSjVoN1VNS1JjQ2dDbnFFaEVaSjlLNGU3YmRkT2ZldTExTnN3c1BhdUptSDc1dnJRYncyRmlxOUVLcFJDcnNWV2hNdEtQbHFDZXAraTFYbDVxak1veURrMVVrVTFvTkhtcThzZE1SblNKaW84VmJsWGlxcmRhYUpaRy9GVjMrYmdWTTVxU3h0R3VKY2djQTFSREk0YlJuVWRzMTFHandtR0lnOFUySzJIeXJzSEhldEsyUURqRktVazFZSVJhZHk3QTJNSEZPdUpCamNldFJrN0Z5S296WEpZNHpXVmpXNFhreWVXZDVybmRUdTRKOXNRWUFqcFZ2V0ptRm14UTgxNS9kNmc1bEpMWUlyYWxDK3BoVmxZM0ptS1NGQmdqc2Fha2dJMkVqUG9hNTBhdSs3azUrdFhJcnNTakxIbjFyZlk1OXpZYU1NdkhXcVUwWjNjMUhIZW1Od0hiSXEwMGlTY3FjZzFWeVROa2dJUEZSZlBuQnpXb1k4OU9haWVBZW5OVXBFdEVNRndVSURWcFJzSk1NcEZad1FGc1ArZFRxSGpHVU80ZTFXcGs4cGUybG13Qml0S3h0RllZa1hOVU5PdkZhVlJNdVJuQko3VjBzY0todjNRNE5aMWF0a2IwS1hQSWRCQ3NZMnhyZ1ZZK3o3dXVhbGloMnJub2FmSk1zYThHdlBjdTU2OFlwS3lJQmJnRG1sOGxCVUxYd0dlYWdTK00wNFJlZlhGUmNybExySW9IRlFTTDh2RlRaSkhGTktFMDBEUlJkU09vcXRLUGxyVGxpd3RVWlU2OFZabXltVnBwUUUxTnR5dE4yMENzUkZLTmxQSXBEVEUwTUtnMXNlRTdqN0Q0bXRKQUU1Y0xseG5HZTlaTzdGV2JLYnlMeUdZZFVjTitScFBZaXgxdnhkdEk0cml4dW83aHBDN2ZNQ21BUHBYRkpIbnRYcTNqcTFpOFErQ0lidTJEelNRcUhKVWZLdnRYbDBPREdNQ3JsMGFJaGQ3amRsS0VxYmJTaGNValN4R0VwNFNwQXBOUEVlQlFGaUx5OGRxQW1lbFRVS09hQUdDUDFwZkxxU25MUUlpQ2dWSUV6VHZ3b0dhQURZRnB3NHBwY1lwdTRab0FselRTM2Z0VVJmYjN6U0ZnUjk2Z1pLWHl2dFVaa3lhaVo4RGcxRVh3ZWFBSldmNXMweDVEaW9XbHdhYVpQU2dDUXlaNjBtLzBxQXk4MHp6TWQ2QUpqSlRESVIwcUZuOURVWmVnUk9aS2FYcUJwS1laQ1JpbUlsWnFoZCt0TU1tT3BxRm45YWFJYkZkK2FnYzVCcFhlb1dhcVJEWXh4VENhVm54VVJhcUlZTTFSTWFWMzRxUHFhWWlXSVphcHI5OWx1c1k2dDFvdGwrYko2ZDZxWGszblhCSTZMd0tPb1BZaEZMVFFLV3JNeHdOUEJxTVU3Tk1DVldyWTBPK05wZnh5Wnhnak5ZaW1yRUxrTURTa3JxdzA3TTk5MGpWWWI2MFRhNDNZSGVyNTVyeFhTZGR1TlBtUmxZN2M4aXZUTkU4UjIrbzI2NGNiOGNqTmNNb3RNNll5dWpkNjhVdUJWVTNhamtFVXczeSt0VFlxNWRKQ2lrODFSMU5aVTJvcUQ5NnFiNm9vUDNxcmxiSjVqZWFaQjNxQjdvVmd5YXFQNzFWNU5XWDFxbFRaUE9kR2J4UjZWRStvQlIxcm1KTlc2NHFsTnFqc09LcjJUSmRRNmk0MVpSazVyR3ZmRUJKMnFhd3ByeVIrNXFzeEo5NnVOSHVadW9iY2Vyczc4bXRpeDFNREdUWEZydUJxMUhkTkhqQnFuU1FScVczUFFWMVZkdjNxclhHckR0elhIRFUzMjRwcHZaSk8rS3o5aXpUMnFPaWwxUWV0VVo5VHl1QldVWFp1cG94bXRGU1JtNnJaTkplTTFWMmtaZ2QxTzRGUlNIMHJWUlNNbkpzamZCTk1MNDRxTjNJTlIrWnpWV0VXNDI1cXlyZkxWQ0lrbXJjZlFVd0ZkZDFNTVlIYXBzcUIxcU41UXRJQnVNQ21ta000TkN2bWdCalVJTTFJVnBWUUFVd0ZDNHBoNjgxTUJ4U0ZSUUExQUtjVFNkS1ROQUFhVHBTRTAwbWdCU2FVR28rYzBvYWdCNWFtbGpUTW5OTDJvQUMxTkpvTkoxcEFOeGswOFlBcEFLWksrQndLQUVlVEI2MGl0bW9ja21uazdSUUE4dFJ2TlY5OUx1cGdlbENUTk9MOFZFQjFweW5tdk9zZHdvWTk2bFFiaDBxTXJpcFVQeThVQU9WRG5tbnNmbHBDZmxwcGJpa01qZjZVNUNLUThtbFZlTTBBU2J2U25qSkhOUmdVOE4yb0FlQUtYSHBTRDd0T3owb0dJTWlwRWJGUi93QVZTZEFLQUpWWW5nMFl4VFZOS0RrMEFLd3pUTVlwOU5Jb0F6OVRZZVUzMHJqWlBtbFkrOWRacXAvZHY5SzVNL2VOTHFidzJKWTFxMUZ3YWdpNUZXRUdEVmtTTEIrN1VMTGsxTjJvMjVGVVpsVmxBelZTYkhOWFpoak5aOHg2MHdLY3BxcS9XckV0VjJwb2xrV3d1NFVEclhUNmJhckZaOEQ1ajFySXNZVnlybmsxMGxyamIwcHNrbmlpVlllYWlBZmQ4b3FkanRYaWtEN0Z6VUZvWkxkSWliWkRpc3FlNENzY0VFVlMxbTRZeVl6Z1o3VmxYMDhrVnVHVmpuSGVyZE95TXZhWFpEcldyRkpBdWNqUFNzcVN6dGRwbmxIREROYUNSeFhjUWVWTXRXVnJVMjJQeVU0QXJTUFpHY3U3TU85bWlNcDhnWUFOVFdFelBJcUJkeEp3QjYxUktBTnp6WFovRGZSVTFYV2c4cEcySThEMXFwdXlKaXJzNkswK0dGeHFHbHJkUlRtT1VqT3c5S3dydncxcW1qVDdidUZpbWZ2Z2NWOUJXOEt3UUxHZzRVVVhObkJlUmxMaUpYVStvckNOVnJjNkhDTDBQbjRySEM0QmNISTZHa2wyT2NwWG9uaXI0ZjJra1RYRm00aFljNDdWNWpQSEpaWEJoZGd4SGNWMFJrbVlTcHREbWpCSE5Ja1Q0TzA1cDBiN3h6VWdHRk9QU3J1WjJOSFJ2bVFwTEVyQW5xUlhRVzQrYmFyWXhXSG9VamJXUTRJeld5b0N2WEhWbGQyUFJ3MEVsY3ZUek5IQ09SV1ROZEV0MXFTOW1ZUkVBOUt5TFdScmk3OHB2enJIYzdVN0Z0WVpibVRDOER1YTA3ZTBXM1VCQnozTlQydHVxS0FLdWVXRnlhRWhOM1pDa1IyOGpGT0RiVk9hUjVqcytsVTVMaGpqNjFXaUk1V3laM0JxaGNNTjFTU3N5TG4zcXBjeUhkUmNYTFliaWpiU1J0a1ZNQjNOQVdJVEdDS2hkU0t0TjhxbXEwaHd0TWxvZ2JPYWtpUE9EVVJKM1lweE94UXdxak5ucnZoWVE2bDRBdUlaSGxkMUJYeTR6WGxOckVZWGxnWU1HamtaU0c2am12VGZoV3R6UERlUndUTEVoR1d5dWMxd21zMnh0UEYycFFHVGY4KzdPTVUxOENNb3YzMmlBRDFwUlJqQnBHTkkzSENuYnUxUkFrVWJzVUNKRVBKcHdQclVDdWM4MEdVaWdSTnU1cGQyS3JsOFViemptZ0N4NW52VERManZVTzg0cGhlZ0NmZDNwRExqcWFydEllMVJPNW9BdEdZRVl6elVSbHcxVnpKVFM5QUZocFNlS2pNdmFvdCtSVWJOam1nQ1l5WTRxTnBNVkNYcHBZOTZZaVV5WnBwZkhlb0drTk5NaEZBcms1bEZSbVRyaW9DNU5SczlNbTVPejFHMHZ2VUJjMUdaVFRKYkptbHFKcGNuclVKYzB4bnBpdVN0TFViU24xcUZtcGhiTlVTUGFUSnFNdlRUUUJ6VEpGRzVqZ1ZJaTg4OWFkSDhpNTdtblJqdlJjTEJOTjVVTzFlcHFoVnE1VEs1cXJWUklZWnBRYWIzcDFXU0xTZzBnb29BZlVzYllOUWlwRTYwQVgxa3dxL1d0UFRMeVN3dmtlTjhLM1dzT1ppSU1pck1FakdCU1R5S3phdVduWTlKR3RaUUhQVVZFK3NramhzMXoxcEswbHNwUHBVcEpwK3pSRG03bDZYVTVHemcxWCsxU04zcURxS1FuYlZLS1JMazJUbTRiMXBQTkpxRUhOT0F3YWRraWRTVGNhYVRtanJTWXBnTklwS2RTWXBnSVdBcHU4VXlUZzFDejRvQXNpUVZJa2dxZ0pUVXlNVFFCZTh3VWhtSFkxWHljVWdOQWl5SHpRUmtWR25OVHIwcGlLeng1NjFGNVhQU3J4QXhVWldpd1hJVUcwMDh1UU90S1JVVWdvR0k4cEhlb0hrWW5yVWhYTlJFZk5pa01XUEpibXJrWTRxQ05jVllCd3VLQUZ6UUNmV295MUFhZ0N3Q2FkVUlhbmJzVUFQSXpRVW9WNmZuTkFpRmhnVkVSVmhoVUVoeFFBMmtOTTNVNEhqbWdZQSt0UHp4VE90SVRpZ0FMYzBBaW1acE0wZ0phallacVJCa1VyQVVBUWJBS2hrem1yRENvaU0wd0dKSG1weEh4U0tOdFAzbW1JLy8yUT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvY3VsdHVyZS5qcGdcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBa0FDUUFBRC80UkQ0UlhocFpnQUFUVTBBS2dBQUFBZ0FCQUU3QUFJQUFBQVBBQUFJU29kcEFBUUFBQUFCQUFBSVdweWRBQUVBQUFBZUFBQVEwdW9jQUFjQUFBZ01BQUFBUGdBQUFBQWM2Z0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHRjFkR2h2Y21sNlpXUjFjMlZ5QUFBQUJaQURBQUlBQUFBVUFBQVFxSkFFQUFJQUFBQVVBQUFRdkpLUkFBSUFBQUFETlRZQUFKS1NBQUlBQUFBRE5UWUFBT29jQUFjQUFBZ01BQUFJbkFBQUFBQWM2Z0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFESXdNVGc2TURFNk1EY2dNVFE2TXpBNk16VUFNakF4T0Rvd01Ub3dOeUF4TkRvek1Eb3pOUUFBQUdFQWRRQjBBR2dBYndCeUFHa0FlZ0JsQUdRQWRRQnpBR1VBY2dBQUFQL2hDeUZvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2QUR3L2VIQmhZMnRsZENCaVpXZHBiajBuNzd1L0p5QnBaRDBuVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtKejgrRFFvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWo0OGNtUm1PbEpFUmlCNGJXeHVjenB5WkdZOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2TURJdk1qSXRjbVJtTFhONWJuUmhlQzF1Y3lNaVBqeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSjFkV2xrT21aaFpqVmlaR1ExTFdKaE0yUXRNVEZrWVMxaFpETXhMV1F6TTJRM05URTRNbVl4WWlJZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWk4K1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUluVjFhV1E2Wm1GbU5XSmtaRFV0WW1FelpDMHhNV1JoTFdGa016RXRaRE16WkRjMU1UZ3laakZpSWlCNGJXeHVjenA0YlhBOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOGlQang0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREU0TFRBeExUQTNWREUwT2pNd09qTTFMalUxTnp3dmVHMXdPa055WldGMFpVUmhkR1UrUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SW5WMWFXUTZabUZtTldKa1pEVXRZbUV6WkMweE1XUmhMV0ZrTXpFdFpETXpaRGMxTVRneVpqRmlJaUI0Yld4dWN6cGtZejBpYUhSMGNEb3ZMM0IxY213dWIzSm5MMlJqTDJWc1pXMWxiblJ6THpFdU1TOGlQanhrWXpwamNtVmhkRzl5UGp4eVpHWTZVMlZ4SUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK1BISmtaanBzYVQ1aGRYUm9iM0pwZW1Wa2RYTmxjand2Y21SbU9teHBQand2Y21SbU9sTmxjVDROQ2drSkNUd3ZaR002WTNKbFlYUnZjajQ4TDNKa1pqcEVaWE5qY21sd2RHbHZiajQ4TDNKa1pqcFNSRVkrUEM5NE9uaHRjRzFsZEdFK0RRb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3L2VIQmhZMnRsZENCbGJtUTlKM2NuUHo3LzJ3QkRBQWNGQlFZRkJBY0dCUVlJQndjSUNoRUxDZ2tKQ2hVUEVBd1JHQlVhR1JnVkdCY2JIaWNoR3gwbEhSY1lJaTRpSlNncEt5d3JHaUF2TXk4cU1pY3FLeXIvMndCREFRY0lDQW9KQ2hRTEN4UXFIQmdjS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpci93QUFSQ0FJOEEwTURBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEc3owcEFLV2xyNnM4RVNrSXBhS0xBTnhSVHFRaWl3Q1VVVVVXQUtLS0tBQ2lpaW1BVVVVVW1BaEdhVEZPb3BBTndhTUduWUZHQlFBMGpGTnpVaDVwbTJnQW9vcEtCaTBVVVVBRk5JcDFGQURNVVlwOUppZ1kybG94U0VVQ0Npak5GQUFSbW1rVTZpZ1l5aWx4UmlnQktLS0tBQ2dpaWlnR054U1lwOUlSbWdRMmpOTHRvMjBERXpSbWwyMGhHS0FDaWtvb0dLZWFidHAyYU0wQ0dVVTRqTkppZ0JLS1hGSlFBVVVVVTBJS0RSUlRZeHVLQ0tkUlVnTXhRS2VSU1lwZ0pSUzRwRHhRQVVVbWFXbUFVMHJUcVRQclFJVGJTWXhUc2lnODlLWURhU2x4UnRwREVvNHBkdEcya01UaWlsMjBiYUFFb3BhTVVoQ1VVdEpUR0ZGRkxTQVEwbUtXbHBnTXg3MFk5NmZSUUEzSHZTWXhUNlEwd0cwVXVLTVVBSlJTNG94U0VKUlM0b3hUQVNpbHhSaXBHSlJTNG94VkFKUzBZb3hTQUtLTVVZb0FLS01VWXBBSlJTNG9vQTJLS1hGR0tvZ1NpaWlnQW94UlJRQVlveFJSUUFZcE1DbG9vQWJSK0ZPb3hRQTJpbElveFFBbEZMaWlpd0NVVVVVZ0NqOEtLS0FFeFNiYWRSUUJIUzAvRk5ZVUFKUlJSZzBEQ2lpaWdBcE1VdEZJUW1LYWFmU1VBTnpSbWx4UmlnQk0wVXRGQTBOMmlqQXBhS0JqRDFvcDlGTVF5aW5VaEZBaEtLQURpakZJb0tEelJSUUFtMm0wK2t4UUEzOEtNVS9GSWFBRzBacFNLTVVBSlNZcDFGQURDS1NuMGxORWphS2RTR21NU2lseFJpa0FsRkxpakZJWWxJUm1sb3BqRTJpbHhSUlFJYXdwS2ZSaWdCbjRVZmhUOFVZb3VBMmtwMktDTTBBTnBhVURGR0tRQ1VVdUtNVURHNHBjVVVVQUppamFLV2lnQk1BVTN2VDZURkFEUlNtbllvcGdSMFUvRkg0VWdHVVUvOEtQd3AzQVpSVC93by9DZ0JsRlAvQ2pGSVF6TkZQeFRUVEFLS01HakJwRENpakJvd2FBQ2lqQm93YUFDaWpCb3dhQUNpakJvd2FBQ2lqQm9vQTJjVUVjVXRGV1FNd2FNR24wVUFNMm1qYWFmU1lvQWJSUzdhTVVBSlNVN0ZKUUFsRkZGQUMwVWxGQUMwVWxGQUNFWm94VHFNMEFNb3B4Rkppa0FsRkZGQUJSUlJtZ0JNVVlwYUtRRGNHa0l4VDZRak5JQnRGTHRveFFBbEZGSlFBdEZGRkFEZndveFRxS0FHNHBLY1Jta3hUQVNsb3hSUUFVbExTVUFGQkhGRkZBeHVLTUduMGxJQmxGS1JSaWdZbEZGRkFCUlJSVEVJYVFBMDZselNBak5GT0l5YVRiVFFoTTBkYVhGSlRBTVVZcGFLUUNZb3hTNW9vSGNhUlNZcDlGQVhHWW94VDZRMEFOcEtkaWt4U0dKUlM0cEtBQ2lpaWdBb29vb0dGRkZGQUNFVVlOT296UUEzQm93YWRtak5BRGNHakJwMmFNMEFOeFNVK21rVUFKbWpOR0tNVUFHYU0wWW94UUFab3pSaWpGQUJSbWpGR00wQUdhTVViYUtBRXhSaWxvb0FURkdLV2lnQk1VWXBhS0FFeFJpbG9vQVRGR0tXaWdCTVVVdEZBR3ZSUzRveFZrQ1VtYWNSeFRjVUFHYU0wWW9vQU0wdWFURkdLQUZ6VGNacGNVWW9BYWVLVE5TWXBObzlLQUdab3ArMFVZb0FaUlFhWEZBQ1VVdUtNVUFKUlJSUUFFWnBOdExSUUFtMmtQRk9veDYwZ0c1b3pTNG94UUFsRkZGRmdDaWlpaXdEY1VFVTdGSFhyUllCbEZQd0tURkZnRzBVR2pGRmdDaWpGRkFCU1lGTFJTQVRBcENNZEtkU0VVQU5vcDJLTVV3RzVvcFNLU2tBVVVVdElCdTJqYUtkUlRHTnhUVDFwOUdLWURNMFUvQXBDS0JEYUtLS0FDazIwdEZBQ2JhTnRMUlVnTklvcDFKaWdhRzBacDJLTVVEMEc1b3AyS1FpZ0JCUlNnVUVVQUpTWTlhWEZHS0FFd0tNQ2xvb0FUQW8yaWxvb0FUYlJnVXRHS0JpWUZHMzBwY1VZb0FaUm1uNG94UUF6TkdhZmlqRkFETTBacCtLTnRBRGFTbE5KUUFVVVVVQUZGRkZBQlFCUlJRQVVFWm9vb0FUYlJ0cGFLQUFjVUVab29vQVRiUnRwYUtBRTIwYmFXaWdCTnRHMm5VbEFDYmFLV2lnRFhvb29xeUFveFJSUUFVSHBSUlFBMmluWW94UUEyaW5ZcE1VQUpSUzRveFFBbEZGRkFDVXZGRkptZ0JlS09LVE5HYUFBamltNHAyYUtBRzROSFNuMDByUUEyaWwybWphYUFFb3BhS0FFeFFmYWlpZ0JNVVlwYUtBRzBVdUtNVUFKUWFYRkllS0FDaWlpZ0F4UlJSU0FhUWMwbURUOFVZb0FaaWluR2syMEFKUlJpaWdBcE1VdEZBRFNLTVU2aWl3RGFLZFNFWm9BU2lseFNZb0FTaWlpZ0F4UmlpaWdBSXB1S2RSd2Zha0EzQnBLZmdldElWOUtRRGFLY0ZvSW9HTm9wZHRHMDBBSlJTN2FNVURFb29vb0FNQ2tJcGFLQmlZb05MUlFBM0ZKaW40b29FTm9wMUdLQUcwVTdGR0tCamFLVWlqRkFDVVV1S01VQUpSUzRveFFBbEppbllveFFBM0ZHS2R0cENNVUFKaWpGTFJRQW1LTVVVdEFDWW94UzBVQUppakZMUlFBbUtNVXRGQUNIcFRjR24wbjQwQU54U2lseDcwVUFOd2QxT28vR2xvQVRGRkxSUUJxN2FDTUNuVW1Lb2daUlRzVVlvQWJSVHNVWXBnTm9wMktNVUFOelJTa2MwbUtBQ2lpaWdBSXpTYmFXaWdCQ01VM1B0VCt0SmlnQnVmYWpQdFRzVVlvQWJuMm9wMktNVUFKUlJSUUFuNWZsUitYNVV0RkFDRVVtMm5VVUFNcEtmaWpGQURLS2N3cEtBRW9wYVNnQXBDTTB0RkFDRmNVbjRVNmpGQURNKzFHZmFuNG94UUEzTkZMaWtvQUtQODlLS0tBQTAzYlRxS0FHN1Bla0l4VDZRak5BRGFLZGlqRkFEYUtjUlRhQUNpaWlnQnUzTkcyblVVQU4yMGJhZFJRQTNiaWsvQ24wbUtsZ04vQ2luWW94U0FibWluRVUyZ0FveC9uRkZGQUJRUlMwWW9BYnRvMjA2a29HaE50RzJsb29HSVZwdFBveFFNWlJUOFVZb0FaUlRzVVlvRU5vcCtLTVVER1VVL2JUVFFBbEZHS01VQUZGR0tNVUFGRkdLTVVBRklSbWx4UmlnQk50TFJpakZBQ1lvMjB1S01VQUp0bzIwN0ZKUUFtMmpiUzBZb0FUYlJ0cGFLQUUyMGJhV2lnQk50RzJsb29BVGJSdHBhS0FFMjBVdEZBR3BpakZMaWpGTWdURkdLWEZHMmdCTVVZcGNVbkZLNEJpakZIRkhGRndERkZIRkhGRndHZ0hOS1JTL2pSUmNCdURSZzAraW5jQ1BIdFJUeU0wM2FhWUNVVXVLU2dBb294UmltQVlveFJpaWdCdUtURlBvSW9BYlJTZ1VFVUFOelMwWW9vQVNpbG9vQVNtNFBwVHFXZ0JtS0tmVFNLQUcwVXVLTWU5QUNVVXVQZWpGQUNVWXBhTVVBSmlqRkxTVUFJUlJpbG9vQWJSVHNVbUtBRW9wY1VZb0FTa3g2VXRGQUNZTkdEUzBVQUpnMGhGT294UUF6QjlLTUgwcDlGQURNSDBveFQ2UWpOQURhS1hiUnQ5eFVBSlJ4UzdhUWpGQUJ4UnhSUlFBVWhwYUtBRzRveFRxS0JqY1VZcGFLQmlZb3hUcUtBR0VVVTZqRkFyaVVsT3hTYmFBRW9wY1VZb0dKUlM0b3hRTVNpbHhSUUlTaWlpZ1lVVVVVQUZGRkZBQlJSUlFBVVVVVUFGTnh6VHFYaWdCdUtXaWlnQkN0SmcrbE9vL0dnQm1ENlVZUHBUL0FNYVB4b0FaZytsR0Q2VS84YVB4b0FaZytsS0FjOUtkK05INDBBR0tLS0tBTlNpaWlnZ0tLS0tBRUl6U2JhZFJRQTNiUnRwMUZBRGR0RzJuVVVBTnhSaWx4UzRvQWJpa3hUOFVtS0FHNG94UmlqRk1BcEN1YVhGRkFDYmFOdExpakZGd0UyMG1LZGlnaWhBTW9wMktNVXdHMFU1aFRhQUNrMjB0Rk1CTnRHMmxvb0FaaWxwMUdLQUcwVTdGTk5BQ1lveFMwVUFKaWdnR2xwTVVBSnRveGlsb29BYlNVN0ZHS0FHMFU3RkJIRkFEYUtLS0FDZ2lpbG9BYnRvMjA2a29BVGJTZEtkUmlnQnRGT3hSaWdCdEZPeFJpZ0J0Rk83VTJnQW94UlJVZ0ZCR2FLS0FHbGFOdnZUdXRKU0FUYjcwYmZlbG9vQVRiNzBiYVdsRkF4aHBCVW1LVEZBRGFLZGlqRkFodEZPeFJpZ0J0R0tkaWpGQURNVVUvRk1QV2dvS0tNVVVBSFNreFMwWW9BVEZHS1hGR0tCaVlvMjB1S01Zb0FUYlJ0cGFLQkNiYU50T3BLQUUyMGJhV2xvR04yMGJhZFJRSWJ0bzIwNmlnQnUyamJUcUtCamNVYmFYRkZBQ1lvMjB0SE5BQ2JhTVV0R0tBRTIwVTZpZ0RVeFJpaWlnZ0tLS0tBR2tVWXAxRkFEY1VZcDFGQURPbEZLUm1qYWFBRW9wZHBvMm1nQktLWGFhTnBvQVRpamlpaWdBNHBoSHBUNlRGQURjVXVLWEZCRkFDVVViYU50TUFvbzIwYmFBRW94UmlpZ0JNVW1LZmlreFRBYmlqRk94UmlnQnVLTVlwMktDTWltQXlpbDJtamFhUUNZb3hSUlFBWXBDUFNsb3BnTXhSaW40b3hRQXlsSFNsSXBOdEFCaWpGRzJqYlFBYmFURkx0b3hpZ0JNVVlwYUtBR1lveFQ2VEZBRGNVWXAyS0tBRzRwS2ZUY1VBRkdLTVV1S0FFeFJpbHhSaWtBM0ZHS1Vpa29BTVVZb29vQU1VaEZMUlNBYVJSaW5Zb3hTQWJpakJwMktNVUFOd2FPblduWW9Jb0FiUlM3YVRiUUFVVWJhTnRBQlJSdG8yMEFGSmluYmFUYlFOQ1lGR0tYYlJqRkF4TVV1S0tLQURGR0tLS0JoaWpGRkZBQ1lveFMwVUNHRWVsT0FwYUtBRUk0cG9GUG94UUF6RkdLZlJRSVppaW40cGRwb0doZ0ZPeFJpbHdUUU1Ta3ArMDBiY1VCWmpkdEdEVHdNMGJhTGxwRE50SmlwTnRKdHFMajVSdUtLZHRvcFhEbFpvYmFOdE9vclF3RzdhTnRPb29BWWVLTTA0ak5KdG9BVE5HYVhiUnRvQVRJb3BkdEppZ0Fvb29vQUtLS0tBR2xmZWpiNzA2aWdCdTMzcEtmU0VVQU5vcDJCNlVZSHBRQTJpbmJhYVJpZ0Fvb29vQVRGSnRwMUZBQ2JhUWpGT294bWdCbEZPeFJpbUEyaW5ZcER4UUFsRkhGRkFDWXBObnZUcUtBRzdQZWpiNzA2aWhBTXhSVHNlMUdCNlV3RzBVN0E5S01EMHBnTm9vUFdpa0FVRVVVVUFKdHBOdE9vcGdOMjBiYWRSUUEzR0tRMDRpamJRQTJpbmJhTnRBRGFLZHRwQ01VQUpSUzBVZ0V4bWsyKzlPb29BYnQ5Nk52dlRxS1FEZHZ2UnQ5NmRSU0FidDk2UWluR2lnQnRGS1JSajIvV2dCS0tYSHQrdEdQYjlhQUVvcGNlMzYwWTl2MW9BU2lseDdmclJqMi9XZ0JLS01Vb0ZBeHRGS1J6UlFBbElSbWxvb0dKdG8yMDZpZ1kzYlJ0cDFKUUFtMmpiUzB0QURkdEcybG9wZ0p0bzIwdEZNUW0yamJUZ00wdTJvdWtVazJNMjBiYWtDZXRMc3FYVVNMNUdSaGFYQnFZSlJzck4xRFJVeUlMbW5BWUZTQmNVWXBlMEtWTWp4U0ZjMUx0b3g3VXVjYWdSQktYYlVtQlJ0cXVhNGNxR1lveFQ4RDBwTVVjeURrRzRvcGFLTGk1V1hNVVUvOEFHakZibkVNb3BTQ2FUYWFBRW9wY05SdGFnQW9vd1JSUUFVbUtXa3hRQVlGR0JSaWpGQUJnVW1CUzRvb0FiUzRwZndveFFBbUtNVXVLTVVBTnhSaWpiUnRvQUtNWm8yMFVBSnRIcFJ0SHBTMFVBTUk5S0tkajNveDcwQU5vcDJQZWdpZ0J0RkxnMFlOQUNVaHhUc0drMnRRQTNBcGNDbDJta0l4UUFZRkJIcFM0cGNVQVIwWXArS01VQU14UmluWXBlMU80RE1VWXBkdEcwMDdnTklIcFJnZWxPd2FNR2xjQnUwZWxHMGVsT3dhVEdLQUUyajBvMjhjVXRGTzREY0dqRk9vL0dpNERjVVlwMzQwZmpSY0J1S01HbmZqUlJjQmxHS2NSenhTYlRTdUFtQlJnVXUwMGJUUmNCTUNrd0tkdE5HUFdnQnVCUzRGR0tLUUNFVW1LZGlqRkFDWXBNVTdGR0tBRzRwY1V1S01VQUppakZMeFJ4UUFtS1NuRWVsTnhRQXVLUWlqYlJ0b0dJUlFLVXJSc29BUWdVbUI2VTdiUnRvQ3czQTlLTUQwcDIwMG1LQjJFd0tNQ2xvb0dJUlNZcDFINDB3RzROTDJwMktOaFB2VXVTaXJzRkZ0NkVkS0JtcktXek91S2xXengxcmxxWXVsRHFkY01KVmwwS2dqOWFkNVdhdmZaVnB3Z0FGY2J6Q0wyWjJSd0Q2bEpZTTlxZUljVmJFWUZCanJuK3VOczZGaFV1aFdFVkhsaXJIbDBoWEZVc1EySDFkRUcyalpVeEFwcEdLcjJqWkhzMXNSN2NVMHJVaEZKV3NaTXpjRWlQRkxpblk5NlhIdlZjekpzaVBHS1RGUFlHbTRxMDJadXdtQlNZcDJLQ0swVElZekh0UlR0cG9xN2tsdWluWW94WFJjODhibWluWXBwR0tMZ0ZGRkZBQ0VacE50T29wZ04yMGJhZFJUR04yMGJhZFJRQXcwdUtDS1VVQU14UzB1S1hBb0FiUlRzQ2pBb0FaaWluWXBLQUVvSXBhVEZBV0V4UzRveFJRRmd4VGFmU0VVQU5vcDJLTVVBTm9wMkthZmFnQW9vb29BS1FqTkxSUUFtMmpiUzBVQUp0bzIwdEZBRFN0SlRqUnRvQWJSVHR0RzJnQnRGTzIwYmFCRGFRak5PSXBLQUV4Umlsb29BVEZHS1dpZ0JNVVlwYUtBR2tVbFBwTVVBTm9wMktNVUFOb3AyS1FpZ1lVM2JtbEZGQUNiYU50TFJRQW0yamJUcUtBRzdhTnRPb29BYnRvMjB0TFFBM2JUYWVhVGJRQTJpbmJhTnRBV0cwVTdiUnRvSFliUlR0dEcyZ0J0Rk8yMGhGQXhLUWpOT0FvUEZBYmpOdUtDS2VCbW5Sd3ZJZmtISHJVVktrWVJ2SXVGT2MzYU9wRGlwWW9Ia1B5cnhWeU8xVmNlWjh4cWZPMWNLTUN2QnhXYzA0ZTdUM1Bhd3VVem43MVVyeDJZSDN6azFNRWpUaFZvNTcwRVY4OVd4OWVxOVdmUVVjRFJwTFljR0E3VUZoMkZSOTZNMXlPck43czYxU2d0TEQ5MUx1cG1hQWNVS28wOXdsQld0WWt4UmltN3FYSnJxcDFKUHFjODZTUWg0cGg2MDg4aW1tdlJwdVRPR29raGhGTmFwRDBwaHJ2Z2NNdHhsSVJUOXRJZUs2SXN4a2h1MmtJcDJLSzBSaTBOcHVPYWt4UmlydVp0SWoyMHUwZXRQeFFSVnFRckladDk2S1dpbnpDNVN4UlRzVVlydFBNRXBLVTBsQUJpakZGRkFCaWpGRkZBZ3hUZndwMUZPNHhtRFJnMCtpaTRETUdqQnA5R0tMZ01vcDIyakJvdUEyakZPd2FURkFDVWxMdE5CR090VUFtS01VdUtLQUc0b3hUcUtMZ054UmluNHBNVVhBYmlrcDFHS0FHMFlwMktNVUFOeFJpbllveFFBM0ZHS1hGSlFBWW94UzBVQUlSVGNHblVZb0FiaWx4UzRveFFBbUtLWEZHS0FFeFJpbHhSaWdYVWFSUmluR20wRERGR0tXakZBQ1lveFM0b3hRQW1LUWluWXBLQkRNVVU4aWlnQmxGUHBNWm9HTm9vd2FNVUFJQlM0RkdLTVVBR0JTRVV1S01VQUppakZMaWpGQUNZb3hTNG94UUFtS1Fpbllvb0FaUlQ2U2dCdUtNVTdGTGlnQm1LTVUvRkppZ1kzRkxpbG9vdUliaWtPS2VPZWxTSkF6OUJXZFNyQ0M5OTJOSVU1ejBpaURIcFVpUXZJM0M4KzlXNDdSRSthUTVJcXhpTkluYVE3RlFFbjhLOFhFWnhHTDVLU3V6MTZHV1NrdWFwb1ZGdFJIeklkM3NLc0xnTDhvd08xVnJmVWJXNWJaSEtwa0FHVTNjaXJKd0Y1NHI1ekU0cXZVbDc3UG9jTmhxTk9QdUlSdXVlOUpSUlhBKzdPOUxUUVNscEtLVjBNTVVoK2xPb29BYmlrcDVwcHFXTkNjMGJ1S0RUUU1VNHlhWXBLNkhnOFVtYVNqRmQ5REZLT2pPT3RocjZvV21rVXRLYTlpbFZoTmFNOHF0U2NSbEJHYVVpaXUyTE9TV3d3akZKaW4wWnJaR1l6RkxpbjBVN2kwSThVdUtmU0VWYVpEc014UlM0b3BrMko2S1hhYU1ZcnZQS0VJb3hTMFlvQVRGR0tVMGxBQmlqRkZMVEFURkppblVsQURhS2RpakZBRGFLZGlqRkFEYUtkaWt4UUFsRkxpakZBQ1VoR2FkaWpGQURkdEdLZGlqRkFEY1VZcGFLQUc5S0tkak5KdG9BYlJUdHRHMnF1QTJpbmJhTnRGd0cwVTdiUnRvdUEya0k1cDVHQlRhTGdKaWpGTFJSY0JNVVlwYUtMZ0ppakZMUlJjUW1LTVV0RkZ3RXhSaWxvb3VNU2tJTktheHRTOFZhVHBkMHR2ZTNTbzdISDBxWE5MY2NZdDdHdm1qTk5pa1NlRkpZbURvNHlyRG9SVDhWU2Fld05XRXlmV2pKOWFkaWtJd0Nld3BraVVtS2RpZ0RQU2xkRHNOeFJpbkVjVWdwM0FRclJ0cGFLQUdZb3g3MC9IclJnVUNHWTk2TWU5UHdLTUNnQm1QZWpIdlQ4Q2pBb0FaajNveDcwL0ZHS0JqTWU5R1BlbjRveFFBekFGSVJtbmxhTVVDSTl0RzJwUkc3L0FIRkxZNjRGTkl4MTYwcnJZZG1NMm1sQzA0VVlGRjlSZW8wclZLMzFheHVyNlN6Z3VVZTRpKzhnNml0R09GNTIyUnJ1SnJrazBTNjBqeG5OcVYzQVdoa1hZcjlBRDZWejFxOGFiMVp2VHBjK3gxR3ducHlhbGp0M1AzdUJWbUh5MmlWb3dEa1pCcVFrOThWNEdLem16Y2FTUGR3MlViU3FNaldHT05TUU00OUt6Tkg4UjJtdHpYVWRvc2ltMmsyUHVYSE5jdjhBRXJ4ZFA0ZWdnaHMyMlBLR0phcWZ3YnY3bldvcjB6RE1za21TMk1acnlLbFN2WGh6elo2bEtOS2xKd2l0ajByY0t4OVp1THMzMWphMmlnb1dMUzd1aEdPUDF4V3ROYjNWbnFIbFQ3UEtLRXFSMXJPMVdPWDdQTkxHZUZoUDE5YTVxVjZkUzhqcW5hcEIyUEx0SG1PamVNSnBwN3I3Vkp1d0ZRNURNV3dmNVY2UHErcDN0bzF2SmFSUlNSRS92ZDc3ZG9yeUQ0ZDZhTlo4ZVhIMmd1RmlWcFYybkhPYTlBK0lOMjJqYVZENUw0V1Y5ckE4bHExeE5wU004R2xHR3JPenQ3aExtSlpZamxTTWcxS1RWSFI1bG4wZTBsUlNpdkVwQ250eFYwMXdTM3Nkd1pvQnBLS2tvZG4yb3pUYUtDUjFKUlJtZ1lVbExtaWdZWXBEMHBhUTBBTnp4U2JqM3B3RkcydEl6bEg0V1JLTVpmRWd6UmpOSWVLQWE5S2htTGpwSTRhMkJqUFdJdUtNVUNscjJhV0toVVc1NU5TaEtteHRGS2VhTnRkaTduRzl4S0tYYlJ0cXliRGNEMW9wMjJpbVFXeWxOS1UvUHZSbXUyNTVqUkVVTk4yR3A4aWppaTRyRU9NZGFURlNsYzBiS2ZNRmlFaWt4VXhTbTdNVlhNRmlQRkdLZmlqRk80bU14UmluNG94UmNCbk5HS2Zpa0lvdUEyanJTNHBLQURGR0tXaW1BbUtNVXRGQUNZb3hTMFVBTnhTVStreFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmx4UzRvb0FhUm1rMjA0MG9GQURkdEdLZFNVQUppakZMaWtvQVRGTlloVnlXQUE2a21uSGl1TytJR3JMcDJtS0pabWhWczhxZVRTYlVkV1JOdExSSFVRWDFyY09VZ3VJNUdYcUZiSkZXTVY0bDRFdDdsL0ZFRThNMGdWbnlRQ1NDUGV2Ymd1QjcxRk9hbXJvM2xTbEJMbURGQkhwMXBhTy9OYUdXeEpCYW1mQkF3dlZuUFFDdkQvQUJ4cHNQaUx4VFBhNlVqU3pnaFZ4MEpQRmVvZU4vRXMzaDN3N0ZIWmtMSmNIWjc5Szh0OEwrSUJvM2lFM1UwZm1pWWJKQ092SjZpdkN4RlhucWI2STl6RFUxQ09pM080OEV6NnhaeXlhRnFrY1pGakdBc2lIcjdWMlJGYzE0ZnZZTlI4UzM5emFOdWlaRjVJN2l1b0E0NlY2bUdxYzBMbzg3RXc1WjJHQ3VYOGU2bHFXbDZLMXpwanhyNWZMNVBKK2xkV2VCeUt3L0ZPbTJtbzZPeTNoWmZtQUd6a3Q3WXBZdHlWTnVKT0hjUGFKVE9kK0hYak9ieEhISmJYMkZuandSbmpOZDllM1ZyWldBWlZFOCtDUW9jREZjVnBIdzgvc2JXZjdUaGRnam9Da2ZRNDl4WE56V3JhejhRSmRQc3JsNG85dVczT2VjZWxlT3NWTnhVRnVldExDdzVuSjdIcHRoZlIzbG45b2JLcUQ4eTU2VmdYZmo3VEYxaExLQkdSUyt3dXd6azEydWxhSllhUm9xTFBncUU1M2Q2ODd2TFhSYnZ4N2FHM3R6SHVKeGpveEZkTHhNM0pSUmpIRHhpcFNlM1E3VUhkeU9oNlU3Rkx0N1k2VVlOZTBub2p5R3JOaVlvSXB3b3hUdUlqeFJpcE1VbUtMZ014UmluNG94UmNCbUtNVS9GR0tMZ014UmluNG9vdUF6RkgrTlBOSUFOM3pmZDc0cFNsWkJ1N0ZQVWZFVU9rYWZjUmJDMDdMbkpPQUJXTDRROFF0cnRqSWJtVkduaWtJS3g5QU8xYzE0LzF5M3VSZHZFNnAveXlVWjVJQXhuOURYUGZDTytraTE2U0J3eFNUcVIwOXErZmppWEhFT2NuN3A5ZFh3Vkw2akJRWHZ2YzlxQzVQQXFaTFptKy93QUNwOXFvUGtGTDFybXhXY3UvTFNPYkQ1U3ZpcURZcmxMTzRSWXNHUTlNOXZldU0rSi9pQzMwNTdTT1M3SitmZFBHaCs2UFd1dHVJc1JTT293eFVqZDZWNUJyc1VtcjJjRm9VVTNOek9ZOTVHVGdHdk9wNG1kVk55WjMxcUVJV1VFZWsrRjc2QzUwaUpyTzQrMFFIbFpNL29mZXR3OWE1M3dWNFZpOEo2TDlrV1Y1MmtiZXhib0Q3VjBXYTg2ZGxKdEhvUnUwangvNDEyOXhlM21tVzF2YXlTcXdQektPK2EyZmhKRExvdW1oNzBlVzBKWXVGNU9Pb3pYZGFoYUxkTmIrWUFkc3VjRVZWMDNTMHM5UTFEQkhrVE1Nakh0elczdHBjcWoyTXZZeDVuTHVXN1R4QkY0Z3VKN2lJSGJHMnhTZlNyTHFIVXFlUVJnaXM3UzlMaDByemx0MnpISWM4K3RXMm13U0FDVFdGU2JjN204S2FVTEk4NzByVDU5SCtJY1RXRmtFdFpHa2pkbDlQVTF2ZU90R2JYdExodDRFTE9KT0d6OTJ1a2lqVHFJd3JaeVRpcGNEUFFaK2xPVlhtZk1FS1NpdVVxV3F0QmF3UmJjN0VBL1NyUWJjT1JpbHhSaXNHOVRkSldDaWlpZ0JhS0tLQUVvb29vQUtLS0tBRm9wS1dnQktLV2tvQU1ab3hSUlFBbEZGSnpWeGs0dTZaTW9xVzZIYmhTZ2cxSFJ5SzlIRDQrY0hhZXh3VnNER2Z3N2p6UlNLMU95Szkyamk2ZFRxZVJWd3RTbnVoS0tkUlhaekk1Zlp2c1QwdExpakZkeDQ0bEpUc1VtS1loS1VHakZGQUM1cEtLS0NoTnVhWFpSbkZKbWdRRktUYWFYTkx1OXFMaXNSNHgxcGNVOGM5cWRnVVhDeENSU1lxWXJUZG1LcE1MRVcyamJVbTJrMjA3a3NadHBOdFM3YVFqRkZ3STlwbzIwK2lpNEROdEcybjBVWEFadG8yMCtpaTRETnRHMDAraWk0RE50RzAwK2lpNEROdEcybjBVWEFadG8yMCtpaTREZHROeFVocE50RndHMG1LZnRvSW91Q0tXcFhRc0xHVzVZWjh0YzRyeXhOVnR2RmV2elJhc1RMYjI4UmNSNXJ1dkh0MHRuNFB1M1k0SkcwYyt0ZUplRGJ3ZjJ0cVhuRUs4bHV3VG5xYThuSFZKZkNqMWNEQ0xlcVBXL2gxb2FhZlpUM1NCZkx1R1BsZHlvOUs3WEZZL2hBTC93aXRudHg5M242MXRnQ3U3RGFVa2NtTGszV2FHVVl6eFQ5dEpqRmRGem1zY3Y4UTlCZzFIdyt0NlpHV2UzUWlNRG8rYThnVzFuMDNVNG83bFJ2V1JUdFBJeG4vQ3ZhL0ZOL2FSUTJ1blR5RUM0VXF5NFBKeDYxNGxNMHE2aElzckU3WDI4a25IekN2bXB2OSswZlJ3dDdGTkh2bGpwOXRab0h0WUk0dDRCTzBkYXVCYWlzbUJzWWNIY0RHQ0Q2OFZjMmpGZlF3dEdLc2VEVWJsSnVSWEl3S3RhZFlXdDVPZnRpbG1Dbnl4NkgxcGpLTVZvYVE1aEV6cEVaSENmS0t3eE12M1pkQ0s5b3JuSGF2WjZqNGN0ZFF1N3UrYWFOMEt3Qm16dHoycndQVGRYMWRmaUJaM1RCNHd0d0ZQSHlsU2VjbXZUZmpKcnVxcGFmWXRvdHhMOCswSHRYakdoWDJvM3V2MjhBbWR5Vys3WHp0bkZPYVBvVTFOS0RQcUh4YmVSTjRkSlM0YmFJOXgyZE9sY2I0ZlJMeld0SW5tRzAvWmlZem5xMmNWUzhUYTNKYWVGSW9KbFptQ2JXQXFsNER1THE5c2JTK2JQbDJkempuakN0d0sxd3pia3BNMHhHR2RPazR0bnJJSHpIUHAzcGNVdk9NbnY2MFY5UWo1SmpjVVlwMktURlVJVEZJUlRzVVlvQVp0TkcybjRveFJzQXpCb3hUOER2bWpZVDBGUTZrVXRTMUNUMkl6UitGVGlJOXppbitVZ0dldGNGYk1hRkxyYzdhV1gxcXVwWEVUbm9LZDVKVlMyZVFPUHJWamR4d0tiMVAwNlY0ZUl6aWNrMUJIdDRmS28wNWMwOVR3MzRnK0hKbjFTeW5FWmp0cmlOdDducy9QOEFqV3Y4S3RGZVB3KzkzQXU2UnJvS2Y5a0x4WGYrTDF0UjRVdXplS0NxTDhuSGYyckgrRnRzOXY0UlVTTHQzU3N5KzRKcnpwVm5LbGQ3bm9SankxTExZN05SajYwOGlrSFdndFhEWTdCcnB1UnZjWXJ5NnpRV1BqK0p0UlZvNGQ3ZVh1SEFOZW9sc2R4V2JxRmpGZXlJWFJXQ25na2NpcmhMbFRSRHA4enVhQ2xTTW93SVBJeFM1OWFwV2tUVzBleG4zYzhmU3BqTFdOOVRma2RoKzJYemlXS21QR0FNYzU3MENJS3A5K1Q3MVhlWndTVjVIcFRGdkFlR3l2MXBYWWNoYXdvSEZKa0NvdzI4WkhUMXBjVVhMU0g3L2VqY0tqelJtZ0xFbTRVdWFpelM3cVE3RDkxRzRWSG1seHhRRmlUY0tOd3FQT0tBY21tRmlUT2FLYm5GTHV6UUlNMGJoVFRSUUEvY0tUZFRDY0dqTkE3RDgwWnB0Sm5GQXJFbEZSaVNuQjhpZ0IxSVJTZzVvb0VOSXBwQnFRODAwMERHZ0VVWk5PbzRxb3ljWG94TlgzUW9iaWltMFYwL1dLbmN4OWhTN0YraW5FVTNGZm9CK2RoUlJpakZBQ1lveFM0b3hRQW1LTVV1S01VQUp0cE50T29vQVRGSVJUcVRGQURSa1V1VFM0b3hRQW1UU2MwN0ZHS0FFcFB3cDJLTVV3RzBFWnBhTVV4V1EzYlJ0cDJLTVVCWkRkdEcybEFOT3hSY2RrTTIwWXArS01VcmhaRE1VWXArS01VQlpETnRHMm40bzI1b3VGaG0yamJUOFVsRndzTjIwWUZLUWFUdFJkRHNHMmpiUzBZTk80ckNOeFRPMVNFWnBNVUJvY2g4Uk5JMUhXZkRvdE5NalZtTDdtTE5qcFh6N2RXT3A2RHJ5ZVo1YlNxM0lRNUh1SytpUEhtcXk2Um92bXg3Z3JuWVdBKzZhOEMxWnJoTHp6N29aa2M3ZzNyWGpZcDNuWTlYREswYm51SGdLN210N2R0TnZZekc3QVN4WjdnaXV6d2V2YXVNMCszdWRhOE5hSnFkcHhkUXFvY3FlcTl3YTdaUVFvQjY5Njc2RjFGSTQ4UjcwdVliUzhiZVJUc1VoSEZkVnpuc3psZkc5dHQwZVM4RVpkays2Yy9kT0s4WEY4WWI1YmlTTU9RNFlvZWh4elgwQjRrM2Y4STNjRUFFS09RUlhsK20vRDZUeEJwYmFoSE9BNWtPMkk4QmhYemxhRW5YZktlOVJhVkZjeDZYNGYxbTIxdlI0YnEwSVViUUdRZndIMHJWQkl4WGxHa05xZmhmV1lyUVIrU1hjS1kreEhyWHJDajVSeGpJcjJNTFc5ckhYZEhtWXJEK3lseko3aXNjKzFVdkV2aU9Ud3g0ZjgyMjJtZVRqRGVsWFNQL0FLMWNCcnJ2L3dBSnZiLzIzdWV5UCtyWHNLeHgzTnlwSTJ5L2tjbTVIS2VPcis5MXpTN2UvdmJkaEkwUlVLRXhuM0dheGZoOTRCOFJ5enphbU5IbVdGWVNZNUpBRkI5eDYxOUMyZmhpeDFXOHQ3eTdqUjdlM0dVVXI4cHF6ck92cmJyY3cyaUtJYlNJc3dUQXo3VjVNNEttdVZ2YzlEMmlxVHVsc2VBWGRyZVNpWWJwWldWRHVqR1R0eFI4TTdhOXZ0WW1zRXVHanQydzhxL1E1QXIxWFJiQ0tLMWwxSzV0MVNhNHpJNEl6OHZwWE5lQXRQVmZGbW8zc0NiSVNUZ1k5VFhUU29lejVTcW1Kak9EMFBRdHVBQjdDazIxS2V0THRCRmU3ZXg4NWE1Q1JSZ2Q2bDJVR1AxcUpWb1FWMnk0MEp5ZG9vaU9LQUJVb1JlOUtRZzZWNTlUTktFT3AzMHNzclQzMElmTGZQVGluckYzZmdVN3pNY2NVMHVCM3J5YXVjMUpPMEVlclN5aW5INGh3VkY5NlVuMEhGUW1ZVTB6aXZLcTR1clUrS1I2ZFBCMDRLMFlreEdhUUFDb2ZQOEFTbStjMWNsK3AxUnAyUlp6VFMxUWVaanZTRnM5NmxzcmtaVjFmUzdmVjRSRmRsdktEQnRvNzFOWndXK24yd2h0VTJJT2dwNVB2VERSek94U3B4SlduUGFtZWV4NjB5bTQ1cWRTMUJEbWtKTkpta3hSbWxkbHBMb0tXcE01OWFScUZvdU1YYms1bzJnRGtEOHFXa0o0b0FRRUw5M2luNUpxS2x6eFFGaDVhamRVUkxVZ3ozb0N4TnVvM1pwbEt0QVdIZzB1Nm1acGMwQ3NPcFJ4VEIxNjA0VUNzTGswb05KU2ZqVEZZZG1qTlJrbWdObW1GaC9Xa3BBYVg4YVF4YzBVbjQwVXdER2FPbEdjVVpvRU8zMDRQVWROT2FBc1RieFM1QnFFWnB3T0tCV0hFR201cHdhamlnUTNKb3AyS0tlb0dsU1Ura0lyOUhQelFiUlM3YVhiVEFiUlR0dEcyaTREYUtkdG8yMFhBYlJpbmJhTnRGd0l5S05wcCsyakZPNEROcG8ybW4wVVhBWnRORzAwL0ZHS0xnTTJtamJqclQ4VUVVWEFqcGFkdG8yMFhBYlJUdHRHMmk0RGFLZHRvMjB3RzBVN2JSdG9BYlJ0Tkx0cFRTdUF6Qm9PZi8xVTRqUDA3MXdIaTd4ZnEzaHU5bFVSeHRId1lpeW5HS3hxMVZUamRtOUdqS3RLMFR0TDNVclBUWVJKZTNNY0lKNDNzQm44NjVPUDRqV3plTGpvMXpicWtia0NLNFZ4ODFlWGVMbzlTOFdhbC9hRHl1cXgyNnlHRkNjQWR5UFNzV3dnY1JTWGMzbkY0U0ZpY0FuYXdQYzE1enh0NXByWTlhbmcxeU9NMXFleGVQUGlSTDRWdS83TnRMSXlYTWtSa0U3bmdEcHg2MTVwWS9FUFc3YTZra3ZOUWtVTU9WMjlmZkhhdldOSTB2VC9BQjNvTmxjNnhFcjNLTnNFZzY1NHdQeHhtdWJrK0dFVjFydC9jM2pEN0xaeUZGVURHNnM2OWFTbnpKNkVVcU1YRnh0cWR4NFAxVTYxNGJodXBMbGJsaWNGd3VEbjNyZUNuSHZYbVhoelNydlN2RXR2Rm9jeGlzbXkwOEpiSy9XdlQ4ZjVGZXBRcWM4TG5uMTZUaklidE5CSHJUNlFqTmJYME9mbE0vVnRMdDlZMDJheXUxM0pJdlFqT0Q2MTRCNDkwSTZMcXNjSWl6R0JnTnVQTmZRMTVkUldOdVpwM1ZFSFVzY2ZoWGpmeEduazFyV0xlMnRZbWRueGhRUDFyenNWeXRvN3NPNUk5SzhFV2NkbjRRMDlJbENneEJpYzVPVDNyb0twNkhhTlphRFpXMG4zNDRWVS9sVi9iWGRUc29wSExVYmNtTXhTN2VLWEZLT3ZwNzFiZlVsSnQyT2M4YlgzaytIeFpSajk1ZEhyNkFHdEhROU5UVE5IdHJaQU1JdlB2V1A0anRYdS9FdW1SNXltTUVINjExSUh5akFyemFGblVsT1I2T0pVdll3akJIQWVPNG5nMXpUcnhGd0F3R2NlOWQxQ3dlRkc5VkZZM2pLMVdidzdMSXdYZkRoMDMrb05IaFh4QmE2enA2RGQ1YzhReElyZjBvcDFhZEtidXlxbE9wV2hGSmJHNFFPOVpXdGVINDlmaFZKR0NTeHNHV1FkaFd4dmpBNVlZcUdlNDJ4UDltWWVaajVUNkdzOFRqYVBJMWU1ZUd3TmRWRTdXSU5lOFRRK0hQRDYyNDJsd2dWZWVTZld2SklQR0YvcUhpQjlIc2RpZmIwL2VQSnpnK2xRZUtiM1VwZFdlUFVsWU1EOHZQeWtldEw0SjBWWDhRZmJ0a2NoaUhBZnFLOFAyK2wyZlJQQ1J0N3Aybi9DUlQ2Vm84bGxydHU4Y3l4bEkzWHBKVmp3SFBidG94bFVHT2FSaVdCcVRXN002eEhERzRWUkcyV3o2VStLUk5PQ3h4VzRXTlJqY085WC9hVWxacmRHSDluUWFhTjgzYXEyTUVuNlVoMUNOY0FxYy9Tc3VQVTQ1VDhwd2ZlcGZPOU9heG5tbUlrWERMYUVlaGVPb3J6eCtsTU9xUmRDMkRWVHp3T3RSTmJwTWQzSVByWEhQRlZhanUyZGtjTlRpdEVYL3RhdHlDYVVYT2VCV1lGbWk2RXNLY3Q1dGJEb1JXRGszdWJLS05FdWU5Tno3NXFCWlJKOTFnYWtGU2FLS0hrNXBLVE5HZldpNFdGcE4xSVNQV203alNDeEpuTkZSN3FYZFFGaVNrcG9iTktEUUZnTkpTbWtwZ0ZHS0tLQmdSU1lvSnBRS1F4TVVoQkZPMjBFWUZBWEdVWXpUZ3VhVUxpa0Z4dTJreFVtUGFreFFITU14Z1VVOGltN2FBdUpodTJLVEp6VCtsR0FhQjNHYmpUMWYxcE50RzMxcGlIN3gycHA1cE5ub2FUT08zNDBBa09veFRkNDcwNEVVQUxSUjFveFFJS1VOaWtveFR1RmdQTkZHS0tMaUZCeFM1cHRCb0FjZUtBYysxTXg5YWNPYVlEcUtLS0JDNW9wS0tBc2JHTVVsT3hTNHI5R3VmbWZLTW9wK0RSZzA3aHlqS0tmZzBZTkZ3NVJsRlB4UmlpNGNveWtxVEZHS0xoWWp4bWt4VXRKK1ZGeGtlS050UzRwTVVYR3lQRkdLZVJ4U1VDNVJ1S050T29waHlqY1VZcDFGQWNvM0ZHS2RSUUhLTnhSaW5VVVhDdzNGR0tkUlFGaHUya0lwMUllS0FzR01maldMNHU4TFM2M28yK05CdWlPN251TzRyY0R4UktaWjJDeFJqTGs5Z0s1eC9IRFhNZXFYZHRJdjluMjBaVlBkcThySFZvOHZJZW5nYU1yODZNRHcvNGZzTDdUOVVudWMvdWtNQUhUWW9GY0o0a3Y3TzBzSWZEK2p0dWhnT1pwVi81YXYzckp1UEdPcFc1dmtqdW1STG9reUtPaHJFMGlYN1RPSGxkaHpYa0pjMnA3Y3Bjc1QyUDRYM2R0YVhnRjNkSkRiUVJtVGJJZmxMOUIrUE5WZkduamMzR3JYRnJwRXUrUHpBUUUvaUk0NVBwV0pwdGxhMzl1TEpybnlSTmpMa1ZkdHZDdHZwVzRSUytlZVJ2Szh0UlhxSnRJaWpCcDdibTc4TklKN3lHK3VOU3l6dEpzNDZEMkZlZ3hvVmpDOXE1VHdOSFBZMmx4QmRSbU5DKzlNajFycS9QVDFyMHFPTHBRcHBYT0d2aEtzNmpkaCtLUmdRcFlESkFKeFRmdENqcHpUSHVUa1k0cXBabFNqMUlqbDFXUzJQT1BFWGlCUEUrb3hhRjVFbHNxVGZQdU9HT085TzhNMlBtK1BwSGtYekZ0bzl1NXgwUGF1aTFEdzFhM3V2UmFvSE1jeVk0WG9hbjAvU1VzTlFtdVlHT1pqbHM5Njh4WTlPVGtla3NDMUZST2l3QjF4U015S09UeFdlOGtoQjJFNXFxOFZ4S01OTVI5S1U4Mm05a1ZIS2FXOG1hclhNUTcwMFhjUjQ0TlpLV0RENzg3dFREWnVIK1M0WUQwTmMwc3hyeTYyT3FHWDBJN0lzM2RySGM2bEJlQmlzc09Rdm9LdG04Sis2Y2NWbWlIYUNYbWRqVldlMmtrUHlYRGl1WDZ4VWErSTYxaDZhNkdwYzdMMkV3M0dHUTlSVk9IU3JDQnQwTUtvZTVYak5aUnQ3eTJPK0tWcFBZbXBJOVdsaVlDN2lLZy93QVdLeWM1czFVSXJvYkxiTnUwTWNlbWFoZUk0L2RPUWFpV2FPZEEwYmc1OUtWU3c2Tm1zbktab294TWZVOUZOOUc3M3BRSXFuRGtaeFhMMjlyYytIOVNVazVFaS9MaitJVjNMM2tWN2VKWnB5cS9QSitGWndzMHZ0UW11cnBjcUR0algwRmRNWkxsMU0xZTlrUjIydkpNd2pkQ0NCMUZhY1Z4RmNJT1ZiMk5VSmRCaVp0MERGR0hwVU1tbDNsdU4wVEJ5UFR2V0VyUFlhOHpSbDA5Wk1tRi9MWTFYQzN0aTNQN3hPK2FyVzJzdkUvbDMwWml3ZnZHdG1LNmpuWEtzR1g2MU4zMUtzbVVocWtIbVlseXRYb3AwY1pqZmNQclZhNzAyQzdYZ2JXOWF5cGRPdnJRbHJWeXdIYk5WcFlsSm82WU90QlZXN0ROWU5ycTBzZUZ2SXl2Yk5iRU02eXJ1UnR3cWVwb1NHSEkrWGo2VXFNVVhETVRTaDZhNUI2VkpTSkE5S0d6VmZKcDRKOWFBSnFLajNkS2ZtZ0JhVlJtbTd2YW5CdUtBSEFZb0p4U1pwdldnUUdTbkJzMHpBcGFZeHhwdTdtZ0dsMmlnUTdHYWNPS1owcHdPYWR4V0hVZGFTbHBDRXBhU2lrQXVhTTBtYVEwQllYRklSU0Q3MU9vQWJSaWx4UlFVQW9OSlJRQVUwbm1uVW1LQUdrZzlhVGp0VGl0TnhpaTR4UWFOMUZJVnpTdUE0SE5PRlE1SzBvazlhWUV0Rk0zWm96UUlmUlRRYWRtbUt3VW9wS00wN2hZZFMwMFV0QWhhS1NpbUJ1MFV1MmpiWDZIYy9OckNVVXUyamJSY0xDVVV1MmpGRndzTk5KdE5QeFJ0bzVnc00ybWphYWZpakZITUZobTAwWXFRclFGOWFPWUxFZEFVbW5uQXBLT1lMRGRwb3hUcUthWVdHNG94VHFLb0xEY1VZcDFGQU5EY1VtS2ZTRVVtN0NzTjJtamFhZFJVOHcrVmpjVWRxcDYybDIybHkvWUcyVEtjajN4MnJQMFBYSnJ1RFpmMnJ4eXB3ekFjTlhOUEYwNE96WjF4d2s1UnVrYkRUUnJJRVp3SGJvcDcxUWZ4QnBzZXEvMmRKZElsMS96elk4bXEvaUN3L3RLUzNtc3BYaGxoYk9UMzlxZ3ZOSHQ3Kzhpdlo0WXhkSW9IbUFjbXVPcm1kT0tzanVwNVpPYnV6UDhmYTB6V1A4QVl1bEF5M1UvTGhlY0QwcmdOU2puMHZ3N0ZvTnFyTSs0eTNMQWZ4SCtIOEs5TGowTzNqbWViSk1yOVg3L0FKMVlnMGl6aERFeGgyWTVZc01rMTRWWEY4N3V6MjZXRlZPTmtmTzBIaHpVZFN1ai9vekVFOUZGZHQ0ZCtIRjNsWkxoZktUMFBXdldvTE8ydGhpS0ZGUHN0VEVnRHArVmM3eEVyRzhhTVV6bnRPOEoyTmhoakVKSlBVOXExMXNZaGdoVkJ6NlZZSnBNMWk1U1p1b29GUUEwNm1jMFpxYnNxdzRuUEFwdEZNYVFyM3BCWWZ0elNGZ3ZVMVVlNWZjY05WZHBuYk9UUVVrelE4OUFmdlVwa0IrNmF6TjViclVpdVFlRFFPeGYzY1ZHejlzYzFCNXZZMHZtQ3BLU0ZZTWZwVFFuemMwN3pGcGR3UFNqVXNUWUtZOElaY01xc1BRaW5scWNPUlMxRFFvLzJmRXI3bzh4bjJOV2tqN3VmeHB4VGppbUJ5cHdhTHNWdXhRdnZzOFNTR0VCWm1HTnc0clBzOVErejdMY2xYYjlhMTdpM2l1UVJJTWoycWdkQWdXUlprbDJzT2hyVG11ckVXYWR5MmwzR3pZUHl0NkUxTUpPZW9yT210WkZIN3hmTUEvaVhyVUNTTkdwOG1iTERrSTNXcGlITWFrOXBEY3FST2l2bXN4ZERlM204eXltS0tUeWg1RlJXMnVLWkNzaDJuT0NyZHEySUx1S1JSaHV0VlppMFkrTlhXTUJ4akZUS1JqaW01OWVsR01jaXMyckdxMVFQYnhTOFNJcEgwcXNkT0VQTnE1VStoNlZhRFk2MDVYRG5pbVRZeW52WjdaOXR6Q3hYKyt0WExlN2luWEt1TStsV1hRTU1NQVI2R3FzbW13TTI1QVkyOVZORjBHcGFVWjYwNG9LaWhSMEcxcE53N1U3bWtVaFNNVXd1UWNWSVBlazJpbGNvUlRuclVvcU1yNlVtU3RLNFdKczRwQ2Mwd1B4elFEUmNMQ21uQ2s2MG80b3VGaGFLUTBab3VLdzdOTG1vODBFMGN3V0g3dlNqY2FpM21uN3VLZHc1UjRQTk96elVRTk9CcGs4bzQ5YUtRYzB1S0FDaWpORkFCUlRTYWNLQUNpaWlnQW9vb05NQXBDTTBVdEpvWTNiU1l4VDZLVmdHVWhVR25GYVlWSTZWUUJ0eFNqSXBNNDYwb09hVEFXZ1VVVk53SFpGQTVwdEtLcE1CMUZKUzB5UW9vb3AzQ3gwbUtNVXRGZm9OejgyRXhSaWxvb3VJVGJUU01VK21rZ2ZlSUgxcE9TVzVVVTI5QktLcnozME1KNWJjZmFzNjcxZVFMaUpjRDFyanFZeW5BN2FlQ3JWT2hya2dkU0I5YWpsdklJaDgwaTU5cTUrTzZrdUdJbGR2YW5HMTM5SHlmZXVLV1pQN0ozd3l2dXpVZldMZE9tWHFzK3ZLUDhBVnhmbWFwRzBmSFVVdzJUK3hybmxtRlJuVkhMcVVkOVN5MnV5azhJdE4vdHVmc0ZxRmJITkt1bmt0em1zL3J0VHVhckEwdXhZaTFxVGQrOFVZOXEwSTlUdDNVRmp0UHBXWU5PNDlLbFN6UWNIbXJobU1vNzZrVHkybkphYUd3a3NjbytWZ1I5YWZ0RlpLUkNOc2hpS24rMXNxNDNaK3RkWDlyUjdIRzhwbDBaZjJpbWtxT3B4VkEzUmJqZFRHbFk4WnJHV2NQb2pXR1VKL0V6UU1pRHZUV25SZXRaelNIMXBwbDllYTVaNXBWa2RrTXNwUjNMelhZN1UwM2h4NlZUejZValpQZXVPZU5yUzNaMHh3bEdPeUxEenU0d1R4VVlJSHBVV2NkNk4rUFg4cTU1VGxMZG5VcWNVdENVa21tNVBUTk0zNTRwUVBVMUYyT3lIVUZzVVUwbHUxQlZoUS9QZWxMRTlCVE10N1V1VFFGaGVlL0ZMVEQ3bWpmaWdkaDlJVGdWQTl5RTk2cnZkczNBNEZTRmllUzVDOFZYYVFzZXZGUjVCcFFNZEtaUWZoUmdVNGRLYXd5T0tBSXlCbWc4ZEtYYmpyUmpOQWhRZU9hUSt1YU9sQm9DNDBkZXRQREVVMFU0YzBXTHVQV1FmeFU4UG1xenFkM0ZBSlgrZElhWmI1b0hQV3E2ems5YWVKS0JqMmpYSHk1cUpsS0w3KzlTZWJqdFR0d2NkS0FLNFlqanFmZW9aYk9HNCtXU01FbitKT29xMlk4MEtWVHFLZDJoY3Faemw1NFdZa3Zidms5Z2V0WjZpODB1VGJjeE0wWTdqdFhjQ1FIcCt0TmVGSjF3NnFSN2lqblpMZ3JIT1cydElUdDNoaDZFNE5hOXRleFNqaGhuMHFuZWVHcldkaXlib245VjZWbVQrSDlSdHhtMm4zRHRWTGxaRGNvblZERERCcGhYSDNPdGNsSHErcjZjMjI3Z1owSEhJclhzZkVsdGVOdGJNTW4rMTNwT0ZpNDFFelczc3YzdWFjcjdqUXNpeUxrWVAwTktVR01qaXB0WXU5eDNIYWpJRk13dzZHalByMXBBUHBCbWdIaWwzWnFXaWtGQkdldEtPYVhGSVl6YUtUWmluOTZkUUJEbGczTkx1TlBLZzBoV2dBQkpveFRlbElYb0FjM0hTbFRrYzB6ZlJ1b0FlUnpUTTBaTkxrZHhRQW1hWHpLWEFOTk1mcFRBa1ZzaW5acXZramdVNUh4UmNWaWJKb3lhYXJacDJhTGhZTTBab29wb1FvSkpwYWJSbW1JZlJUTTBab0FmUlFLS0JCUlJSUUFmaFIrRkZGQURTb1BhbTdjSGpwVWxGSmdNb3AyS0NLa1kya0lwYUtCaWJpS1hkVFR6UzA3anNMdUhwUlNiYUtvazZ1alBhczU3eHowNHFFenlmM3Erb25tZE9PeDhoSEs1dmRtcTBxTDFjQ3E4dDdHdkM1Tlo3U252elRmTUo2ZnlybG5tczM4S091bmxjVnVXSmI2Vmx4R29YM3FuSTAwamZQSVRVbm1EdlNGd2VsY004YlZrdHp2cDRPbERaRVpnM0wxeWFUN0lEMU5TRm03WXBoTW5yaXNQYU43blR5SWRIYVJvY21wZ2lMMEZRQm5IM21CRk9MOGRham5ZMUVrSlVVbTlmWVZGdkRjQ2tiSTZBVWN6SzVVUythQjB4VFRKenhVUmZiOTZtQzV5ZHFyK2xKdGh5RmplMUJZMUdIeU9sQllucFMxR29pdHo3L2pTYysxTkVvWDd4eFRoTW5ZMGgyRFkzcUtYYVIvRmlrOHdIb2FZMjgvZE5JZGlYQStwcGNEMEZSTDV2Y2luYmlPcEZBQ3N4QTRxUE1ub0tma0h2U0ZOM2MwREJTNTZnVTdCNzAxVkNkNlBOVWRLQUY0b1p4amlrMzhkQlRTU2FrWTdkUzVwb3BDUU9wcGhZZmtVMTVGUWMxQTl5cTlPVFZXV1JwRGttZ0xGbHJ3ZEZxQjVTM1ZqVUtnNW9QV21BODBtRFNpaW1NVWNVN2NNVXlpa0EvT2FPbEMwckROSUJ2WHZTR2wyMG1LWUNVWnBjVW9UTk1rYlMwNHhZcFBMSUZBd0dPOUljRTA5VjRwQ2hwREdGYWJnZzA4S1JUc2V0QTdEZC9ZaXBCakhGTjJnamlrd1JVbEVtVFJqZFRWZjFwd1BwUUFGU1B1am1sRG52eFRoOWFRak5BRGdRZTVwU00xR1JqcFNoc1ZJQThhc3BWMVZnZldzbTU4TldWeDh5Z3h0Nml0Y1BUczFYTXlYR0w2SE9EUnRSc216WjNKWmV5bXA0N25WTGNadUlSSW82N2V0YmdOSVJuclR1MkxsN0ZDSFZvSmlGY21OdjdyMWNHMWx5RCtWUnkyY015L3ZVQjk4WU5FVUloWGFuM2UzT2FCcTZIN1NLVlJpbkNpZ29VVXVhYmlqRkEwT281cHRMbW9HQTRQTkJvTkpSWUFwakx4eUtmUmpORmgzSWR1ZWhvT1IzcVFyU0ZhTEJjYXIrdFNaWEZRdEVlb05OK1lVV0M1SXh4MHBNc1JUUTJUVWc2ODBnQVoyMFU0cWFOdEFET1J6VGd4RkJGTUlvQW1WOGptblp6MHFBVTVTUlRDeExSVFEvTk8zVUNGb3BNMFp6UTJLd3RHYVFVcHBYRUtEUzVwbEFvQWZqTkxpbTV4UnVwaHFPemlreUthVG1rcWdINUZHUlRNVVlvQWZrVWhwdUtXcGFBS0tLS0xGQ0dpakZGSUM3akk2bk5KdjdjMDNmaWp6UGNWc2N0aEdtUmVEMXBBUzNLdGdVdVVQWEZLU2dIQkFGQXhONEgzbkZHOE45MWhUVDVaNjRvRFJweU1mbFFNZUFUM3BjVkh2M2QrS1JnNSs3U0N4S3pCVHlLVGV2cFVPeWIrOStsT0FZRDVpVDlLTGhZY1pBT3gvS2w4eks1d2FqeDdOUzBYSFlZMDJQNERUUHRCQjRqcVZpK2Z1aWdIKzhvb3VBaVQ1UEtrVkxrR21BajBweGJIU2dCckl2OTNOUk5DdlVuYVByVXBPYVI0dzY0SXBER0lZazZQelV3WmZXcTR0bEJxVHkwSGVnQ1FrR21sVjlLWVZRZERpZ2UxQUQ4RHNLT2Fia2lrMzBpckQrdldrMmowcGhreFRHdVFLWWl3Q0tZemdkS3FOT2UxTTh6UGVtQlllNHgwcXU4N1BTWnpUU3BQU2l3RENlZWFYdlM0OXFVTHowb0FWZXRMaWphYUtRQlJSUlJjQXB3R2FiVGxwZ09IRkZGSlJZQmNVdTJrelJuRkFYRndLVVlwdTdOS0IzcGdTWm9KNHBvTkthUURhVVVob3BEUS9hR1dtbUVpa0J3ZUtremtVaGtXQ08xRzd0VWxJUm1nWXdqTk53UjBwK0NEUWNtZ0FEaWxEaW1iQm1rS0VHZ0NiTkI1cU1FMHBreDFvQUN0S09LVlh5S1VpZ0JvTk9CTklRS2J1eDFvQWtCelM0cU5YcDI3TkFDbW1ucFMwVUFORk9vb3dUU3VNTTBVYlRSelRBWDYwZlNrNjBZeFFJT2xGRzZpZ0FvcEc2VTNQRkFDbm1rSyt0R2FLQUUyK2xOSUlwL3dCS09lOUF4b2tJcFJLS1dtWTU0cFdIY2ZuTkdNMHdNUjFxVFB5OUtWZ3VOSzBvcHk4MHBIRklZeWx6U2JUUnQ5YUFGelRnYWlKeDBGT0RjVTdDdVNnODB0TUJwYzBBT29wbk5HVFNBZlJUTTA0R2dZdEZGRkJOZ29vb3FyaFlLS0tLTGhZYms1cDFKVGVhQkQ2S2JtaWxZb21HNUI4MndmalI1OFErOXlmWVU4eER2elNDQmM1eFdwempCTkVUd3BKK2xQRHIyV25lV285S1BsSHBTR05JRGZ3MGJCNlU3aWo2VXJnTVpYL2hPS2FBNDZ2K2xTbk9LYVdic3RBRFNKTy9JK2xPVlQ2VTBtUTllS1Q1L1dnWkwrTkptbWpQZWduRklCV2ZucG1rMy9XazNZNlV1K2dCYVQ4YWpKYzU1R0thTnc3MERKaGs5Nk9SM3FQZmlrMzBEc09OSVdBSDNjL1dtbVFWR3o0RkF4eDVibGNmU2wzaGZhb2pMaW8yZmQwcG9sRmd5Z2Q2aWVmUGVvU2MwMGpQU25ZZHg1bHpuTk0zR2t3ZTlHS0JEdDFMVE1lOU96bWdCdzRvM1VtS01Vd0hDZzBDaWtBb05Md2VwcEtLQUhDbHhUUWFmdUZGZ0c0cHJVOG5OSnhRQXpGS0tmdEZLRkZJYUdqTkZQNmRLT085RngyR1VDbjhVcFhLMFhDdzNORkp0b0F4UmNMRHdlS1EwVVUyd3NGS0RTVWhxUUpNMGJlOU5VMUxuaWdZem5OR01VdEl6Y1VBRk5JcGMwRTBBTXhTVTZpZ0JoSjdVbTdIV25rWnBOdEFDZzhVdE5LMGd5T3RBRDZLVE5LS0FEUE5PelRhS0FIcWZXblo5S2pCcGMrdEt3MFBwRFRkd28zZWxGN0RFYnBTQ2xKcEtMaFlLTTBVbUtZaHc5NkQ3VWdvb0VGTnAxRk1BQm96VFNLWEZBQzBVbTdtbHBBR0IxRkkxTFJRQWdGTFJSUllkeDJlT3RBUHZUYUNjVXJEdU8yNU5OS1VvYWx6VEpHOUtOeG83MEhwVUZDR1RGT0Q1cUZnVk5KdTIwMnRBTEhXbHFGWk1WS0dCcEJjY0tYTk55S1FtZ1kvTkozcHVhTWcwQVB6Um1tNG94UUFVVW1hV25jVmdvbzRvb3VCSVJOM2FreEozelV1YVhkVm1OaUlBOTZVQUduNUZHUlFBNVNCU0ZxWVRtbHh4U0FRODlTYVZlT2xKU0U0b0FjU1IzbzNVeko5YVRQdlFNa3pTSG1tYjhVYnMwRldGSnhSdXBoSnpTRnNVQVBKNHB1ZldtZVo3MDB2bnBRSnNlV0dhWVdGTno2MDBqSnBpdXhkL05JeDNVaFdtMHdCaDcwM0ZQSFBXamdVQUpSUlJUQU0wY1VVVUFKeFFBQlMwVUFHYU0wVW1EUUE0R2xwb296UUEraW1qTkxRQWRLWE5BR2FkZ1ZJQ0Rtam1sK2xMelFOQUdvM2VsR01qbW1oRG1rTWR1cFEyYVNpZ1lwYkJvM1VuV2xGQUNpaWdVVUFIUVVtN0pwYVFqdlFBdEZJUGVnbWdBUDNxQS96VUFacE1ZNlVBUzVwR05SK1lSd1JUd3dJb0FUTkZPeFRXNDZVQUZGTnlUVHFCaFNnMGxGQUM1cER6UlJRSVRiU2RLZFJqTkFEYzA2akhyUWZhbUFVVWxLRGlnQW9vem1pa01LS0tLTEJjVURpa1BOT0hTaW1JWUJ6UzBVVWdDaWlpZ0FwUU0wbEt2V2dZMHFjMG9wNXBuZXBXNHdvb29xaEJSUlJRQUdrd1RTaWxQRkFoaDRwUWFVak5OeHpRQTdxS0tibkZHYUxJZHgzMXBwVVVab3pRSWFWcE00cDlJVnpRQW04MDRQVWJERk56ZzBXR1dPRFFLZzNtbmlTcGFDNUx1Tkc0MHdObW5VZ3VIZk5MdU5KUlFGeDJhS2JSVjJRRmpJb3lLWmtVWkZNekg1RkwxcVBpako3R2dCNUlIZWszZTlSayt0SVNNVUFTYno2VW1jMUh2OEFlamVmV2dDVE9LYVRUQzJlOU5MMEFQTDAzZlROMUlUNlVBT1p6bWszbW1qM29wc0JhS1NpZ0JhVUdtMFVBT0pCcE5sRktEVEFUR0thUmswOGltNG9BVElvUE5HMmdERkFDWW94VHFLQUc0b3hUcUtBRzRveFRxS0FERkdBS0tLQUNqRkZITklCd3AxUjd1YWRrWXBBUEZMVWU3MG8zVUZJZWNpbTdqU2J2V2pJN1VoaWgrZWFlQ0RVVzBuMG81RkFpU21rNFBTa0JKNjA4RVVERytaelRnK2Fhd3ljaWtBOWFBSDVGS0RUTWlnR2dCL3JUQm5OUEJ6UlFBeWpudFNrWk5HS0FFd1RTajVldEhtSHBRVG5pa3hvZUh6MHBQclRRYVhOU01XaWdVVUF3b29vb0dGS0JTVUhQYWdBSW9wVjk2VWltZ1kyaWx4UnRxcmsyRXBDS1hHS0tMZ042VXRMUWVsRndzQU5GSUtXaTRnb3BOMUc2Z0JhS0tLQUNpaWlnQW9vb29HRkZGRkF3b29vcWJNQW9vb3FrSUtLS0tMaUNpaWlpNHh1S01VNmcwWEVOb3BDS0tMakZvcEtLQkMweGw1cDFGQUVXMDBaeFV0TklGQURkOVBWelRDUFNnSEhXZ0NVTmtjMHVSVUphbEdhQUpjaWltY1VVd0pjMEUwemRqclNGeGlxTTdqOTFHNm9kMlRSUUZ5WE5JZWxSRWtVYmpRRngyYVROSURtbG9DNFpwYVNpZ0xoUU9LYnVORzQwQmNkUlRkeHBkeG9HTFJSUlFBVWhOTFJRQUNscEtXZ0F6UlNVdEFDVVVVbzYwQUpSVHNVMDlhQUNpblk0cHUzMXBBRkZGT0FvQWJTOVRTNG9BRkZ3RGJUVDFxU2t4UmNDUEhOQjVwK0tOdWVsQUVZR0tmUVJpa3BBTFNVVXRBMEE2MCtreGlscEZCUlJSUUFsTFJSUUEwcnVvNkNuVWhvQVFOVDkxUjBab0FmdTVwM1dvdDJLY0dHS0FINEZKajBwdTRVdThWTEdoZHROeGcwNVd6UzRwRHNJRFMwVVV3REZGRkZBN2hSUnVvcEFLT0tOMUprRHJUUzRvR1AzVXU2b3QyZWdwTUgxb0VTazVwS1lvTktTYUFIVVVEcFJRQVVVVTNOTVZoU3RONlUvdFJpbmNMQ0EwdEFGR01VWEN3VVVVVXhCUlJSUUlLS0tLQUNpaWlnQW9vb29ZQlJSUlVGV0NpaWlnWVVVSGdVM0pwaVlwcERSUlRzSzRsTFJSUmNkcmhSU1V0TzRyQlNHa0o0b0JvRUcybUZlYWxwQ0tBSTl0R2FmVFNLQUc1b3BjVVV3QW1rb29QU3FNUk0wdE5BNXAxQUJSUlJRQVVVVVVBRkxTVVVBT3pSbW0wVUFPNHBEMTRwQU0wNGNVRENpaWlnWVVVVVVEQ2lpaWdBb29vb0FLS2NGcENNVUFHYVVkS2JTMGdIMFVtUlNCczBBT3hSUlJTQUtLS0tBQ2lpaWtBVVVVbE1CYWFSNlU2aWk0RE9hY0J4UlJuaWdhRE5OWnZTbHdhUWpGSW9OOUpuTklldEpuRkFFZ29OTURITlB5S0FCYWQycHVRS1hJb0FZYUtjYVQ2MEFKUlJSak5BQzVwd3FQRktEUU1mdXhSdk5NelRnZldsWUxpN2pTZzAzSW96UllMaWxzVTRISzAwSE5KdXh4U3NNZWFUTk5COVRTNXowcEJjV2t4N1VacEMyS0JqdWFNNHBvZWpJb0ZjWGVhWHJUYytsRzRpZ1k4TFM3ZmVtYjhMelNiaWU5QXlUR0tLWXVRZVRUaDBvRUxSbWlnOUtBRE5JN1lGTnByY2lnQlErUlRzMUdvcVNxdVN3cFFhU2ltSWRtZ21tMFVBQVBOT3pUYUFjVUFPb3pUU2FRR2hqUStpbTVwd09hZ29LTTB3OWFjRFFBbEZIZWltQWxMUWV0RlZ1U0ZGRkZLd1hDaWtwYU5ndUZHS0tLRXhCUlNFNG95S1lDMG41VWhJcEtBRm9wS0tBSTZLV2lyTVJLS1dpZ0JLS1dsQW9BYlJTbWlnQktLV2w0eFFBMmlsSFdseFFBTFMwWW9vR0ZGRkZBd29vb29HRkZGS0tBRW96VDhDakE5S0FFQnBUelJqMm9vQWFSaWxBelM0b3BBSmlrNlU2akZBQ0EwdEdLS0FDaWlpa0FVWm9vb0FNMFVVVUZCUlJSU0N5Q2lpaWdBcER5S1dpZ1ltMFV1MFVVVUFKdHBDcHAxSVdOQURDRDNwTTAvZGtjMUdldEFtTHVOSm5OS0FhWGJRSzdHZzFLcEdLaTcwdWNkS0NyazJBUlRTdnBUTnhwUXh6elFBdUtNVW9iSnAvR0tBSWpRS2R0RklSaWdBQnBEN1VoT0tVR2dZbk9hZUZwQWFSbjlLVDJHaDVJRk1KTkNuZDFwK1BTcEdNb3ArS01VQ0dnNG82OGlsSUhwVGxGQTBSOG1uQVlGSzJCMHB1NmdCMU9YcFRBUjM0cFRJbzRGQXg5Tkpwdm1VbTZnUTdOTlkwWnpRQm1nQlU0cHhOTUpwM2FnbGlicUFjMDJsSEZXaERxQ2NVM2RUWGM4VUFQM1VicWp6Um4yb0Fsb3BnYWwzVU1CMUtEaW85MUxtb0tIbWtwdTZqZFFGeDFGTnpSdW9FT29wdTZqZFZJUTZpZ0drUEZBQzBtYVRORk1CMmVLVGRTWm9vQUNjMGxGRkFCUlJRYUFDaW03alJRQW1hV2dBaWx3YXN5RXBSU1lOS090QUMwWm9OTkpOQUR1S09LallrQ21obVBTZ0NiRkZSaG03MDhIam1nQmFXazNVVUFMU1VVVUFGRkxpakJvR0pSUzROR0RRTVNsRkdLQ01VQU96Um1tZ1pwUjcwQU9vcE0wWm9BV2lpaWtBVVVVVWdDa3BhYVJRQXRGSmlnbkk0b0FXZ21tVXRNQmFTaWx3YUFBR2xwcEdLVlQ2MGhvZFJSbWlrV0ZGRkZBZ29vb29BS2FSVHFLQUlqMXBNMUx0QjYwMHhnOUtBQkQ3MUtBcEhOUUdNcnlLVldidlRBVjFBcVBQcFRueWFaZ2dVQ0Z6Um1tMG03dFFBOHRpanpEU0JjOWFjcTBoaGswcGIzbzIrdE5aTWRCUUF1YzBVaWluWW9BU25jVW1LTUdtQXZIYW5LYWp3YWNBUlVzb2tvcHVjVXU2bFlMaTBtU3ZKUEZMVWJqT0tMTUJ2bWJqd09LZFFveDJwYUxNU0dzTTAzWlVtS2NxNUZGaWlOUmlselRqdFhxYWpManRTSlk3TktQYW1ad2VhWGQ2VTdDSEUwaFBGTTNjMDdQRk5BSURUZ2FiM3BRY1V3RnB2ZW5icWJRQVVVVUU0b0FLS001b29BWFBGQVBOSm5GR2MwQU96Um1tRSs5RzZnQlFmbXAyYVpuTkwrTkFEczBacEFmV2tKb0FkbWpOTXpSelFBL05GTjVwd1ByUUFVdEoxb29BS0tLS0FDZzBVVUFOb3AyS0tBTEJqSGFrOHIycVB6RDJOSDJoaDNxek81SVk4VW15bW1mQTU1bzg4R2dBS2ZOVFNvcEhsNTRwaXlNemNpZ1E5MHlLYXNkU2R1bEtweDJwQU0yR203RFZrRVlwUVY3MEFWUXBCcDJEVm5ZaDcwZVd2WTBGRmJCb3dhc2VXQjNwQ29waUloUzBNTWRLVE5BQzBVVVVBSWFhVG1uVW1LQmlBNFBTaW5ZcHA0b0FNMG9wdExRQStpbTVvelFBdjE0cGFZVUQ5YzA2a0F0RkpTMGdBMHdyaW4waDZVV0FaUlJSVEFVVTdQRk5vcGdLVG1tMHRKU0dod1BGQk5KU1VoM0haTktEVGFNMEJjZlJUTTB1YVF4MUZOelJtZ0JjMG9OTkJwQ2FZRW02Z3NEMnBtNm1zMUFya2dVR21PdnRUVmNpbmJ3MUFETnROTWRTN2ZTa1pmV2dFSXZIRlNxb05SVktuU2tNZHN4U05VbmFvbTYwQU14elNVL0dhYWFBRW9vb29BS1dtbWxGQUJTQnVhV2tJeDBGTUI0T2FDdVRURlBOUFU4VUFHMDBsUHpUU0tBRTNnVXd5dC9EVHNVbUtRRE1rbm1sNHBhVWppbFlCbTRVekpKcCswZWxHQlRBUUNuanBUY1U0R2dBb296UVRRQUU0RkpuaWh2dTAzUEFvQVhQTkRVMFV0QUNyVHVsSUthU2FBRkp6U0EwVVVBQjYwaHBSMW9iZzBBSjBwd2FtMHRBRHQxSGFtMFpvQVVHbkRwVEJUeFFBVVVVVXJnTG5GS0RtbTlhWEdLTGdMUlFEUzBYQVNpaWxvdUFsRlB4UlRBaU5KaWxORldZaWJhTUQwcGFNMEFKam1uclRSVGdhQmo4MFpwbWFYTklCMjdGTkpKTktENjBoOXFCamNrZDZRenN2U2x3UjFwakxtZ0I4ZHdUOTQwN3pxcWhjTnhUODB4WEp2TXAwZnpacXZtcFVPS0JvbE5KU0JzMDdGQXhLS1hGR0tBRW94bnFLV2xCb0FZUlNjMC9Cb3hRQXpta3FURk5LblBGQUNab3BLS0FIQTA2bVVtNmdDU2t6VGMwVUFCcEtXa29BS1drb29BS0tLS0FDaWlpa0lLV2t6UnVwQUxTVVpvelFWY0tLTTBab0M0dEpSbWpOT3dDMDFxWE5HYUVTTUFwZWxMbW5BQTBpa2hnY2cwNHZtbitVS1k2WTZVRkJrRVU1U1F0TkE0NXBRMUltNDhTSHBTbm1tWkZMbWdhWVUwZzA4VThjOXFCa0dEUzROUzRBNmlrSkZBRVhYclJTbWlnQktLRFNEUGVnQUk5S0ZiQXBlRFRUeFRBZm5OR2FRVklFeU9LQUk2S2tLVTBxUlFBM0ZCUEhGRk43MGdDaWx4U0dnQXBEd0tXaWdCZ3oxTktEUTNXa29BY2VWcHZXbEJwTzlBQmlpbmdVMGlnQlJRdzQ0b0ZIVTBBTTVvNXFURkdLWURRS1J1dFB3YUNLVEFZS1VqaW5Zb3FiZ1I4MHZOUHhSaWk0Q0FVdEFwK0tMbFdHVW9GT0swbUQ2VWdzR09hZHR5S1VDbHpRRmhtTWRLVVVwQk5PQXdLQXNNeFJpblk5cVRGQVdDaWx4N1VWWXRDcGttazNFVTRJYWNWd0sxT2JVajNFMHVhR3BNWm9ld3lSV3BTY2RLUlU0elVnRlNVTVVrOWFkbW5CTTAwcGcwQUFwMUpTMEFnNjBvU2twZDJPMUEyT0VReFRHdHNuZzA4U2V0UFdTa0lyUEE2ZHFZQTNjVmU4d1UwbU05ZUtCbFZTZTlTcXhJNkdwUWlNZnZZcDRnSFk1b0dRYnFNNXFieWlPdFJzTVVnRXBwSnBjMHhzNXFnRjMrcG9FZ3FGbElxUExBMENMZThVQWc5NnJicVVQaWdaUFNVd1NVOE1EUUFVRVVacGFBR1p4VHNpamJtazI0b0FYSW95S2JTVUFQb3B1N0FwUE1HYUFIMFVnWUdselFBVUdpaWdCTVVIaW5VMXVsQUNVVUNpZ0Fvb29vQUtLQ2FhV29BZFNacHVjMFVBT3ptbEJwZzRwZDN0U0FrM1Vwa3gxcUxkVFQwb0FsTDVGTUxWSFNqSm9BZmsrdFBEZHpVVzFxZUFUMXFXQTRNYWVKTVZHUmdVd2s1cWtORm5ma1V4ajZHb3R4cFFha1lielM3NlkzQjRwT2FCc21CQm9JelVhZ2luZzVvQVhHS2JuTkt4NHBvRkFEc2luS3hGTXhTZzRvQXNwSjYwNDdUMnFCV3FRUG1tQTBvS2FVcFNlYVR6TVVnR01DdEprK2xTRmcxSVNLQUdVbFBOTnhRQTFoVGNHcEtRMEFNSXBkdFBIdlJ0elFBZ3BjWnBRaHBRdnJRQTNiUnRwKzBVNERpZ0NMQm9BTlRZOXFVRDFwWEdpSEI5S01lMVQ3ZmFqYlN1VVE3YzBvakZTaFRtbmJhUXJJaDh1alpVdXcwNEo2MFdZYUVHeWwya1ZPSVdicFMrUzNjVVdmWVhNbDFLK0NhTnBxd0lDM1NucmJ0MEZVbEo5QmUwaXVwVkNuTk9LMWFOdVZiR1FUNkNwVnRkM1ZmMXAremtRNjBUUE5PVVo3VnBHeVJmdkNsUzNUcUZKQXFsU1pMeEVUTmZDSnlEMFBhbHQ0eEpHR2JqOEswM0NoZ05tQlR3aWxldy9DdEZUTW5pTGxFV3lrWjNVVmIyaWlxOW1SN1ptRlREelR0d3hUY2pOUWpjVGFEMXFVSWlya21xc2t1SHhVZHhOdFNudVRjdU5OR3ZRMUI5clZwTm9xaXMyNnBFWDU4MFdDNW9pWUJhVHpsNzhWVzdVMXFWaWtXL01IYWxEWnFsdUlxZU5qdHFRSnlmbHB0T0F5dElSanBRTVNsRDRwS1FtZ1k0dlVaYzBZcEdCOUtCRE41elI1N2pveG94VFNsQUU2M2I5Mk5LYmpQV3ErekZMajJvQXVLNFlVcE9hcm9lS2xEWUZBd1lacGpKeFR4elQ4Wm9BcUZEbmlrS0dyb1FVL3lrYWdaU0MwNGNHckgyWFBRMDM3T1JRQXdVdFBFWjlLWHk2QUl4VGl2RlNDTEFwaEJVOUtBSTlwb0tWSnpSbjNvQWdLRTFHMGJEcFZ1a1B2elFJcEZ5dkJOU0xJYWtlTkc1cEZoejBPYUFBU2V0UERnamltdGJPS1ZZaW83MEFLRFFhYmtyUnV6UUZ4UlJTYnFOMUF4YUtUTkxRQTBubWtwKzNORzNpZ0JsRkdEU1VBQnB0TzdVaG9BTTBwNlUyZ2U5SUJRTTA5QmcwTDdVdEFEOGluSnQzYzFGU01jTG1rQllaVVBlb0dqSFkwemZTaDZBRjI1NzBvUTA5VDYxTXBGQTF1VnRwelVua2sxUDVTbm1wRlVEdlNLSzZ4RWRhWXlGV3E2ZG82MURJVko0b0FyTUNhYUFSMXFjZ0hwVFdqNG9Bam9GT3hpaWdCYU1taytsSE5BQzU5YVpRUWMwVUFGQm9wTWoxb0FYZFJ2elRnTWltK1dldEFEc1VCYzA1UWNVOEErbEZ3STlsTHROUzdEVGducjFvbHNHZ3dLYVhaVWdRMDhvcUFGemoxQTcwUmkyVE9haWlBcDNwVlE0cVM5bWt1UEkreFJLcUtjT0c0SnA0M0pnYmVUNjFyN043R2FySnJVaThzNG8yRWRxbFptQ2xtNmVpanJVRnJmUGNOTkZGYVB2UmNxemRDYVhzU1hYU0pGakpGUDhuM0FOVFBJWU1DWUJTZXVEMHFwSmZxMGhpUmNqKy9RcUpQMWhzbFdJOFp4VDVWalJlUG5Qb29wSTVHS3JrQWc5elVrcm5mZ1lYMTIxckdrbHVaeXJTNkRJUnZVWVFqNmpwU1lWSCtjZysyYVBORUsvd0FXVDcwbmxSdTJYd1NlNXF1VkluMnJMSUNqSWpkVGtWSEV5TXpidW9vVHk0MkNqQngzRlNqQmI3b0E5YTBTUm01TmtlOVY5czl6VWhZQk9PbnRTOEhxQVFQYWxpUU51SUFINFVFREUrVERBWnoxelVnY0huSUZCUXR3S1ZJZ294amsweERHY2VZZHVXd0tlWE1lQ1NSbWtHNVdQUVVqTDVoK2RzMFdBbGpLdXhMQW4zelNPUW96bkE5NkVqOUNSVDNVRmVSbWxZQnYweGlpbHl2cFJUQTV2aW1GVDNxVlZ6MXA0UUhyWEVla1VkcE1nNzFEZnI4bjQxcmlPTmVhcjNVS3pLTnRYY2kxekhqamJiMHF6R0RWNUxRN0J4VGhiZW44cU9ZT1VxRFBlbmJjbXBwSWlncXV4TkhNT3pKMGdEZDZuV0pVWGsxUlYyWHZUdk1keFVGbGg1Vnp0VTBzYXMzMHFHQ0RNbWEwb285cTgwRElsaEhlbzVZd3BBUEdhdFNTb3FjYzFqYWhQSkpjeDdjZ0NnVFphUEhTa1BOSkVmaythcEZJb0FqQzB1MnBDTTBtMmdCbTJqWlRzVVlvQVp0OUtjb3hTMFVEUXVhVU56VGFLQmtvYjFwM21ZcUF0Um1nQzJKS2Q1dWFwYmpTNzZrVnkwWlI2VW9tWHVLcHM5TVp5Qndhb0xtajVzYmNad2ZTb245TTFRTWxLSmVLZGd1VytuZW9tT0toV1QzcGZNelJZTGp6TGlnU1pxSmp1cG9CcEN1VE9jajVjVTNKRGMwMmtMWU5BRC9PWWNacDNuRURnMURqUFNsb0FrTW00YzBnTkppbEMwQUxSUjBvb0FCMXA5TUZMdW9HUEI0cGQxUmc1cDJLQmo4QWppbStYbWhUZzFJQ0RRQkN5NHB1MnJCR2VvcHUwSHZRQkVGbzJWSVU5S2FGcFhBUlZ4UzRwMk1VVXJodU54UVZ6VDhVb1ROQTdFWWl6UWJmdURVb1hIV25BVUFSSkV3NjFNcWtkcU1rZDZUekRRVVNoc0Rtazh3Q290KzZtbk5JQ1ZuelVEN3NacHdKelUyQVY2VUFWRlk5Nmszazk2ZExGdCtsUmdZNlV3SDd1T2FYYmtjVXpPYVVISFNnQlFDRFRzVXFyVWdXa0JGdEJwQWxTN2FVSlFCRnN6VEREaHFzYmZRVXUzUFdpNEVhSUtlWXFVSWMxTUVKV2xac1RhUkFrWTcxTXFKejh5cWZlbENCV0hKeWUxU0ZGQ2ZPQlc5T24zT2VwVnRzTmpSWDZ0ZzFJVVFNQVdHZnBVYW5QQUJGTmJLZXArdGJlemljN3F5WStVaER0eXZQU2tHQXA4ejA0cEJBSk1Oem50VDFUQndSK2ROUVNKNW15TVRBRGFCdVBRSEZNWGFzbTZWam5zQ2FsWUFaQ1lERHZUVXQyYkxOOHhIUE5VSXF6ZWUwaEVSd3Y0Y1VrYzl4YmhUSEhJeFBEQmF1aUg1c2pHYW5VYmM0Ymtqb2VSUUl6akxkWFVpbWFCdVFjYzlLVzNzUWpIREVuUHpaRlc0eHRQQUJiMXhVbU9oNUI3Z1VBVjJqYU5TMFIzRDB4eWFXR1Y1WTFhU0lvU1A0bHhWd3Z5QUYvT201TFozTDA2ZTFBWElsaDNjZ1o5cUhSMEdObVJVd1lnNVRnZXBxUlN6ZGFCRUN4cXFaQ2NkODBua3U3WkpCSFlZcTFnNHhtbFZsakhjbjJvRzlpUHlXWURQSHNCVWlvY1lIQTcwMTNjWUk2ZDZjcDNLZldnZ0FwSkl4MG9Dcm41OENtbVVnYkYrOTcwRGpHL2tuMHBqSDVRbjdveDYwM2NNL0tuUDg2UWpJNzBuTWpBZzRVY1VYQVZtWldHUHU5NllaVHl1eGhqbkpGS2NDVGJuSnBYUXR6amdVWEFWU2hVSDVqUlRmdEVhOGJnTWRzVVV3c1lZSHRRVGdWWFdaeWFrVmkyYzF3bm9qdDJhVEZJZWxOelFQWWxFaFNwQmM5c1ZVTEhOUEI0b3NCWWFSSEdDdFJOYlJzTWpJTk0zR2tMR2hnQnMvUnMwcVFCRHpqODZpa2RndkJxakpJMjdxYVpOemVnajI4OGZuVSt3a2NWejhjOGdIM2pWaExtWEgzelJZT1kxZklYK0xqNm1xdDFCR0YzY1pIdlZScHBHSExHb0dkajFOTkNiSnd4STRweUVodWVsVjRuUE5XRlBBTkRRSmtoUE5MdTlhWURuclRoelVGaTU0b0ZKUm1tQTdBb3dLUlRuclM1b0hjUWlrcDFOb0M0VVo5YVFtbWswQ0RORkZJYUJDR2tQU25Zb3dLYUFpSXBOcHFRaWpIRk80RWVLZVBlbEFGTGdVcmpFQzFJcVpITkFxUkRTQVlZalRHaVBlcnlVNTFCSElvSFl6bFQwcVZZaWFtOHRhbmpqVVVBVmxoT09hY0lhdWJBQlVUOERJb0FxbUE3dWxJWVQ2VTh5Tm1wVVk0b0dWZkxidUtQTHE4QmxlYUNvNDRvQW9iU0RTbmlyMnhUMnBra2E0NlVnS1djMDlUaXBHalVkQlRkb29BTnhOT0hOQ2dVN0ZEQVRGTHN6VHNWS0FNVWdLeFFqcFNoRFZrS0RSdEZBTFFyN0RUdG1LbUtqR2FBTXJrMGlyNmtXMG1qYmlwUjBIMHBTS1Z3WkNWelRUSG1wOFpwcEhKb0dRK1hqcFNoT0trNkxtbkx6VEFZRXA0QUZQeFFWRkFFVXE3MXFydFpHd09SVnhoVUdBRzRwQmNadEo2VWJTS21RL3pwK2NFOEQ4cXUxeE9SRkcvd0NOVGsvTDBwdHFQTVJpM1k5cXVKQW0zcCt0VW9FODZLYWhpYVVnS3dCUEpxMHFnRWpGS3NTRVpLZ21xOW5jemRXeFhWY21uTXFyeTFTcWlwbkFxVVlJR1FEVmV4Um02ektzVEs1R3dINm1wU004ZWxPaytRRGFBT2FmZ1ZwR0NSbEtvMlI5QnpqSDBxck1wKzhyWkE1eDYxZkNncHlNMUNUc2Y1UVB5cTdHTGs3a0tPVHR4OTQ5c2RLa2NZaDlXSjU5cVdOdHhKSUZKY2Y2c0FjVUR1S2orV2cydG1uczVKKzdVRWE0aTRxZFJuazgwQmNRTU9RRlVIMU5TYkFzZTUyUHZpaEVVTm5ITlBQS1lQU2dDTkVUeXhzNkh1YUJrdHgyNzBzZkxGVDB4US9IQW9BRzJnY3FTMVNSc0F2STU5S2ozbnA3VkowQXg2VUFDdU5wSUdEbWxCSlhQcjFwd2pVb08yYUZVYlNLQkpERDZiZUtVY2RCVW1BT2xNWmlrWklvQVRuZHpTL2Q0QnFQY1N1VFQxVUVjMERleEo4cFhrazBiZ09CVWNqSEFxTU9WNUZESnNTbmF5a0Q4YVJzb29DcWNmV28xKzhhZEVlcFBOQ0tzUFU0WGs0QjlhWTdrQW5CSTlxamwrYmFUVW1Bc2d3UDRhUUVjZVd5K01IM3B3WittL0k5TVZDV2JlZWNjMWFVZnUrZWFZRlpwVHVPTGNZK3RGQm1ZRWdCUVBwUlRBLy8yUT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvbGFuZHNjYXBlLmpwZ1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFrQUNRQUFELzRSRDRSWGhwWmdBQVRVMEFLZ0FBQUFnQUJBRTdBQUlBQUFBUEFBQUlTb2RwQUFRQUFBQUJBQUFJV3B5ZEFBRUFBQUFlQUFBUTB1b2NBQWNBQUFnTUFBQUFQZ0FBQUFBYzZnQUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdGMWRHaHZjbWw2WldSMWMyVnlBQUFBQlpBREFBSUFBQUFVQUFBUXFKQUVBQUlBQUFBVUFBQVF2SktSQUFJQUFBQURORFlBQUpLU0FBSUFBQUFETkRZQUFPb2NBQWNBQUFnTUFBQUluQUFBQUFBYzZnQUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURJd01UZzZNREU2TURjZ01UUTZNams2TkRFQU1qQXhPRG93TVRvd055QXhORG95T1RvME1RQUFBR0VBZFFCMEFHZ0Fid0J5QUdrQWVnQmxBR1FBZFFCekFHVUFjZ0FBQVAvaEN5Rm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZBRHcvZUhCaFkydGxkQ0JpWldkcGJqMG43N3UvSnlCcFpEMG5WelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0p6OCtEUW84ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJajQ4Y21SbU9sSkVSaUI0Yld4dWN6cHlaR1k5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZNREl2TWpJdGNtUm1MWE41Ym5SaGVDMXVjeU1pUGp4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNKMWRXbGtPbVpoWmpWaVpHUTFMV0poTTJRdE1URmtZUzFoWkRNeExXUXpNMlEzTlRFNE1tWXhZaUlnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJaTgrUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SW5WMWFXUTZabUZtTldKa1pEVXRZbUV6WkMweE1XUmhMV0ZrTXpFdFpETXpaRGMxTVRneVpqRmlJaUI0Yld4dWN6cDRiWEE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM4aVBqeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTRMVEF4TFRBM1ZERTBPakk1T2pReExqUTJNVHd2ZUcxd09rTnlaV0YwWlVSaGRHVStQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJblYxYVdRNlptRm1OV0prWkRVdFltRXpaQzB4TVdSaExXRmtNekV0WkRNelpEYzFNVGd5WmpGaUlpQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aVBqeGtZenBqY21WaGRHOXlQanh5WkdZNlUyVnhJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrUEhKa1pqcHNhVDVoZFhSb2IzSnBlbVZrZFhObGNqd3ZjbVJtT214cFBqd3ZjbVJtT2xObGNUNE5DZ2tKQ1R3dlpHTTZZM0psWVhSdmNqNDhMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNDhMM0prWmpwU1JFWStQQzk0T25odGNHMWxkR0UrRFFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHcvZUhCaFkydGxkQ0JsYm1ROUozY25QejcvMndCREFBY0ZCUVlGQkFjR0JRWUlCd2NJQ2hFTENna0pDaFVQRUF3UkdCVWFHUmdWR0JjYkhpY2hHeDBsSFJjWUlpNGlKU2dwS3l3ckdpQXZNeThxTWljcUt5ci8yd0JEQVFjSUNBb0pDaFFMQ3hRcUhCZ2NLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lyL3dBQVJDQUtyQS9BREFTSUFBaEVCQXhFQi84UUFId0FBQVFVQkFRRUJBUUVBQUFBQUFBQUFBQUVDQXdRRkJnY0lDUW9MLzhRQXRSQUFBZ0VEQXdJRUF3VUZCQVFBQUFGOUFRSURBQVFSQlJJaE1VRUdFMUZoQnlKeEZES0JrYUVJSTBLeHdSVlMwZkFrTTJKeWdna0tGaGNZR1JvbEppY29LU28wTlRZM09EazZRMFJGUmtkSVNVcFRWRlZXVjFoWldtTmtaV1puYUdscWMzUjFkbmQ0ZVhxRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVIaTQrVGw1dWZvNmVyeDh2UDA5ZmIzK1BuNi84UUFId0VBQXdFQkFRRUJBUUVCQVFBQUFBQUFBQUVDQXdRRkJnY0lDUW9MLzhRQXRSRUFBZ0VDQkFRREJBY0ZCQVFBQVFKM0FBRUNBeEVFQlNFeEJoSkJVUWRoY1JNaU1vRUlGRUtSb2JIQkNTTXpVdkFWWW5MUkNoWWtOT0VsOFJjWUdSb21KeWdwS2pVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmdvT0VoWWFIaUltS2twT1VsWmFYbUptYW9xT2twYWFucUttcXNyTzB0YmEzdUxtNndzUEV4Y2JIeU1uSzB0UFUxZGJYMk5uYTR1UGs1ZWJuNk9ucTh2UDA5ZmIzK1BuNi85b0FEQU1CQUFJUkF4RUFQd0RwQUtYRkFwd3BrZ0ZwZHRPRk9GQXlQYlM0cVRHYVhiUUt4SFM0cCsyazIwQU5wY1U3YlJRQWxHS2RSUUEybEZMUlFNQlNpa0ZLS0FIQ25DbVpwd05BRWdwd3BnTk9Cb0FlS2VEVEFhV2tNbUJwUWFpQnB3YWdDVE5BTlI3cU4xQUVoNXBoRkc2bG9BYlMwN0dhTnRBRGFLVTBsQUNpbHpUYzBsTUNRTlR3OVE1bzNVV0FzQjZYZlZmZFM3cVZndVQ3L2VqZFVHNmwzVVdDNUx1cE4xUjdxTjFNQ1ROR2FabWdHZ0IrYWNEVWVhY0tBSGcwOEdvZ2FjRFFCTURUd2FoQnB3YWtNbUJwd05RYnFjR3BBVFpwUWFoRFU0TlFNbHpRRFVZYWwzVUFTWnBjMUhtbHpRQkptbHpVV2FYZFFCTURUczhWQ0dvelFBOG1relRjMFpvQWRtZ0dtWnBjMEFTQnFlSElxRUdsQm9BbkVsTDV0UWc1cGNVckFTQ1E1cFRJVzZtb2NHbktLQUpCN25OU2lRQVZFTVU3TkF4KzdKcE92V21nMHVhQUhBRHZTRmM5S1RkU2hxQUc3YWNBS0tEUUlVVXVhWnVwUWFBSDBVMEduQTBBR0tTblVtYUFDaWt6Um1tQXVhVE5KbWpOQUM1cE0wVWxBaHdwYVFVN0ZBeE8xR2FXa3hRQW1hVE5LUlRUeFFJZG1relRTYU0wd0YzVW02bWswaE5GZ0hab3pUYzBoTk1RN05KU1pwTTBBTG1relNFMGxNUTdOSm1rb3pRQXVhTTAyaWdCMmFNMDNORkFEczBacHRMbWdCMUxUTTB1YUFGTkpta3pTWm9BWE5HYVROSm1nQjJhTTAyaWdCYzBacEtUTkFIQ2dVOENrQXBSeFNBV25DbTBvTkFEeFMwMFV0QURoUzlhUUNuQ2dBMjBtMnBNVW9XZ1pEaWlyR3dZcU1yZzBDSThVdTJuZ1VvRkFFZTJseFV1S2FhQUc0cGFXaWdCS1VHa05GQUR3YWNHcU1HbkNnQis2Z05UUUtlRm9HRzZqZFJ0cEN0QWh3Tk9EVXdBMGMwQVRCcVhkVUlOTG1rTWx6VFRTQTBacGdGRkZGQWd6Um1rTkZBQzBacE0wWm9BWE5MbW01b0JvQWZtak5OcGMwQU96U2cwMFVvb0FjS2RUUWFjS0FGelM1cE1VVURIWnB3YW9zMG9OQUV1NmwzVkZtblpvQWtEVTROVU9hWGRSWUNZTlRnMVFocVVOU0FuRFV1Nm9RMUtEUllaTHVwZDFSWm96UUJOdW9EVkVEUzVvQWxEVWJxakJvelFCTG1nR293YWNEUUJLRFRoVVFOU0thUXlaVkZTaFZGUm9hZVRTR0lRS1VBVXpOTHVvQVUrMUptZ3RTRWlnQjJhTTB6TkxtZ1E3TkxtbVpvM1VBU2JxQ2NpbUEwb29BQUtkaWtCcDFBQ2lscHVhTTBBT3pTWnBNMGhOTUJTYVROSm1rTkFDNXBRYVptbEJvRU8zVXVhWm1qTk1DUUdsM1ZIbWt6UllMazIrbDNDb00wYnFWZ3VUYnFEZzFGdnBRL3JSWUxpa1UzQnBDMUlXcGdPcHBOSm1rcGlBbWt6UlNVeEM1cE0wbWFLQkM1b3pTWnBNMHdGelJta3pSbWdCYzBsSlJtZ0JjMFpwdWFNMEFPelM1cG1hWE5BRHMwWnB1YU0wZ0hacE0wM05HYVlEczBacHVhTTBBTG1qTk56Um1nQjJhVE5KbWt6UUJ4NFdnclR3S1hiVWpJYUtsSzAzWnpRQTBVNFV1eWwybWdCVnFSUlVZQnFWQlFNY0ZwMktVQ25ZcEFNeFRXRlBOSXd5S0FJd0tkVGNZbzVvQWRUVFJtaW1JU2lseFJRQWxGRkpRQTRVNEdvODBvTkFFb05MbW9zMHU2Z0NYZFM1cUlHbEJvQWt6UzB3R25BMERIVTRDbUEwNEdnQUl4U1U0ODBtS0FFcFJTQmVhZUZvQU1VRktjQlR1S0FJQ0NLTVZNVkJwTmxBV0lzR2xBcWNKU2lPZ0NJUms5S1h5ejZWYVFBVThwbnBTdU94UUtrVXYwcTIwVk44ckZGd3NWNmNEVWpKVE5wN1V4V0ROQk5JUmlrb0VMbWlrNW9vQWRSbWtwTTBBUHpTNXFQTkxtZ0I0Tk9CcU1HbEJvQWxCcHdOUkEwNE5RQkxtaW1BMG9hZ1k4R25DbUEwb05JQjlLRFRNMG9OQXlRQ2x4VFFhY0RRQTRDbktEUU1VNGUxSVk4SEZMdXFQTkc2Z0NUTkdhaTNVYnFBSk4xSVdxUGRTRnFMQVNicVhkVVc2amRSWVJMdXBjMUVEVHhSWVpJRFRoVEJUNkFIQ25HbUNsSnBBR2FNMDBta0pvQWZta3pUTTB1YVlDNW96VGMwWm9FTG1selRjMFpwZ0xtbHpUYU0wQ0hab3pUYzBacGdMbWlrb3pRSVdpa3pTVUFMbWlrb29HTFNab3pTWm9FTG1rcEtNMHhCbWpOSlNacGdMU1pwRFJRQVpvelNab3pRQXVhTTBtYVROQUM1b3pTVVpvQWRSbW01b3pRQTdOR2FibWt6UUE3TkdhYm1qTk1CU2FNMDNOR2FCRHMwbWFUTkptZ0IyZmVrelNacE0wQWN5S2RTQVU3RlpsaVlvQXB3Rk94UUEwTFJpbDZVbEFCaW5VbWFXZ0JRYWNEVEJTNXAyRmNmbWtOSlM1b0FZYVRGT05KUU1hUlJpbjBob0VKUlMwVUFJUlRjVStqRkFFVkxUOXRKdG9BYlNpbmJhVUNnQnRBcDIyazJtZ0JRYWNEVEFLVVVBUEJwd05SNXBjMEFTZzB1YWl6VGdhQmttYVVHbzgwdWFBSk0wb05SZzA4VWdIaW5Zb1FldFM0elFNWUtlRkpvQ1ZLbnZTR2tOQ1ZNb3dLVEZQR01WTnlocFROTllERktXNXBwTk1RM2JTYkJUcVdnUXdvUFNrTVFxVUNseFJjTEZjeDQ2VkVVUHBWemJRVXAzQ3hSSUlwQ0t0UEh6U0NLbmNteFZOSlZsb0JVZmxHbmRDc1JnMHVhVXJnMG1EVEFVR25BMHpHS1dnQ1ROTG1vODB1YUFKQWFjRFVZTk9GSVpLRFRnS2pGUEJwQVNLS2VCVFVZZDZmOUtCaWppbmJxWm1qTklZN05KbWt5S2FUUUlkbWtKNHBwTkptbUEvTkdhWlMwQUxtbEZJS2NLQUhDbnJUUUtmUUE0R2x6VE0wdWFReCs2Z3RUTTBtYUFIazBtYWJtazNVQ0g1b0pwbWFNMHdIWm9wdWFYTkFDNXBhYm1qTkFEcU0wM05HYUJEczB1YVptbHpUQWRtak5OelJtZ0JhS1RORkFDMEUwbWFUTkFBYU0wbWFTbUlkbWtwTTBVQUxTVW1hTTB4Q21rcE0wbWFBRm96U1pwTTB3RnpSbW01b3pRQXRHYVROSm1nUXVhTTBtYVROQURzMFpwdWFNMEFMbWpOTnpSbW1JZG1qTk56Um1nQmMwWnBNMG1hQUhab3B1YU0wd09kelRnYWpKelNnMWlXUHBSVWVhY0RUQWRta296Um1rQTZnVWdwMU1BcGFRVXRBQzBVVVpvQVlhVVV0SmlnWVpvelNVQ2dCYVhGSlMwQUdLTVV0RkFCaWx4U1lwYUFEQW94Um1sb0FURktCUzB0QURTdEpzcVRGTGlnQ0VqRkpWamJtazhxZ0xFUXB3V24rWGlsMjRvQ3hHUmlnYzFKaWsySHRRRmdXcEZGSXFtcEZXa01lS2NwcGhOQU5JWk1EU2hxaUJOT0dhUUU0YWxKNHFFWnAyNmtNRDFvb294bW1Bb3B3cG9CcFJRSWNLVVVncFJRTVdrb05OelFBcHBLTTBVQUZMdEZJS2NCUUJHMEc0MG4yWVZZQW9ORjJGa1ZXZ0hhb3pEVnltNHpUdXhXS3BpTkpzcTN0bzJDbmNWaXVzWkpxZFlmV3BGVUNuMGgyR0NJVXZrMDhVNFVDSWhGaWwyNHFRbW8zYWdCcE5KbW1rMG1hWUR5YVFtbTVwTTBBT3pSVGMwdWFCRGhUZ0tZRFR3YUFGeFRnS2JtbHpRTWZTNXBtNmpkUUEvTkJOUjdxTjFJQ1ROSm1tWm96VEFmbWt6U1pvelFBdWFNMG1hVE5BaDJhWE5NelM1b0FmbWpOTnpTNW9BZG1pbTVvelFBNmpOTnpSbW1BN05MbW1ab3pRQTdOR2FibWpOQUM1b3pUYzBacGlGelJtbTVvelFBdWFNMDNOR2FZaGMwbWFibWpOQUM1b3pUU2FUTkFEczBacHVhVE5NUTdOSm1relNab0VPelNVbEZNQmFNMDNOR2FBSFpwS1ROR2FBRm9wdWFNMHhEczBacHVhTTBBTG1qTkpta3pRQTdOSm1relJtbUJ6Z2FsQnFNR2x6V0pvU1pwYzFHR3AyNmdCK2FVR21acGMwQVNBMDdOUkEwNEdnQ1FVNENtQTA4TlFNQ0tNVXVhWGlnQmxLZUZwNEFwajhVQU1OSlNFMFpvRU9wd05NcDFBRHMwQTBsRkF4YVhOSlJRQW9wYVFDbkNnQXBSUUJtanBTQVhOTG1tMDRjMEFTSVJqbW5rakhGUWlsb0dMUnR6UU9hbFZNaWdDUEZLS2NWSXBLQUZIRk9CNHB0S0tRQlRsRkptbkthQUpRQlFGNXBvYW5CcVJRN0ZJQnpTZzVwYzBBSmluQVlwTTBoYmlnQmNpZ0dvODBicUJFMmFNNHFQTkJhZ0I1YW1rMDNOR0NUUUE0VTZoRUpOU0xHYUIyWXdVOFZJa082bU9wVTlLVngyWUNscEJTMHhDYmFYWnhUaGluQ2dDQWpGQUZTc3VhTnVLQUc0cFFLWEZBRk1Rb3BhS1FtZ0JIYkZRc2MxSTV5S2hOTVEwMGxLYWJRQXVhTTAyaW1JZG1sQnBtYVhOQUVnTktEVWU2bERVQVNacGMxSHVvM1VXQWt6U1pwbWFNMEFQelM1cGxBTkFEODB1YVptbHpRQS9OR2FiUlFBdWFNMGxGQUM1cGMwMmlnQithTTAzTkxtZ0IyYU0wM05HYUFIWm96VGMwWnBpSFpvelRjMG1hQUhVWnB1YU0wQUxtak5KbWt6VEVMbWpOTnpRVFFBdWFNMHpOQk5BRHMwaE5Ob3BpRnpSbWtwS0FIWnBNMG1hS1loYzBsRkpRQXVhTTBsR2FZZ3pSU1pvelFBdEZKbWpOQWhhS1RkU1pvQWRSVGMwbTZtQTZpbTdxTTBBT3BLVGRTYnFBT2JGTFNVdmVzVFFXbEJwQlNpZ1l1YVhOR0tNVUFLRFRnYVppbEZBRWdOT0RWRUtjS0FKQTFQRFZEVGhRQk51d0tpWnNtaWtLNW9BYVRSbWpiUmlnQmMwNEdtN1RSUUEvTk9GUlU0R2dCNHB3Rk1CcVFFQ2dZdUtlRXpqbW1oaFRsYkJ6U0FtRVhITlJOR1FhR2xKK2xKdkpvR0ppcEVIRkxISHVQTlNiUU9CU3VPeEdRT0tRQ3BQTHpRSXptaTRXRlJmV3BSd0tFVEhXbmhhbHNxeEd5WnFKaGlyTDRWYXF2eWFhSmFETkdhRVhjYWZzVUhrODFRaHRLRFFGcFFocEFPQnB3Tk5DMDRBaWtNZURTNXFPbEo0b0Fma1V4bTlLU2w0cGdJT2FjS0FLVUNnQW8ybW5aQW9MVUFJRU5UeHg1eDcxRWttRyticFdqYm9qWVlZeFVTZGtYRlhZNkcyVUxrOWFjWVYzWUhXb3ByenkyS1JqNm1xM210bk9UbjF6VVdiTkhLSzBOQklSbWxrdDFaRG1xRWR4SWo1Qit1YWZMY3N4Kzl4N1VjcnVIT21pS1JTc21PMUlEVFdiTFpOS0RXdGpHNDRHblpwbWFXZ0IyYUtibWpOQWgyYVVHbzkyRFJ1cGdQSnBEVGQxRzZnQU5NTlB6elRTS1lpUEZJUlVtS1FyUUF3MDBpbmtHazIweEVkRk8yMGJLQUc1b0JvSzBZb0VMbWdHbTB0TUIyYU0wMmpOQUQ4MG9OTXpTaWdCK2FYTk1wYUFIZzB1YVptak5BRDZLYm1pZ0IxRkptak5BQzB0TnpSbWdCMmFNMG1hTTBBTG1qTkptaW1JV2ltNW9vQVhORk56Um1nQjFKVFNhVE5BRDgwbWFibWpOTVF0Rk56Um1nQjFKbW03cVROT3doMmFNMDNOSm1nQjJhTTAzTkdhWWgyYVROTnpSbWdCYzBacE0wbWFCRHMwbWFibWpOTUIyYU0wMDBtYUFIWm96VGMwVUFPelNacEtLWURxVE5KUlFBdWFTa29vQXdkdUtNVlkyWnBESFhQYzJzUTRwUUtrOHVqWlRFTkZMaWwyMHUwMEFOMjBiYWVBYVVLYUFHWXhTMC9aUnNvQWJTZzB1eWpZYUFETkxta3dhWEJvQVhGTHRwTUdseFFNWGJUU0tlQlM0b0FoeFNnVkxnVWJSUUlqRlBCcCt3VWJLQmlBQTB1TUdsQ1UvYng3MGhqTVU1QlNnVTlSaWdDUmVCVHNWSG4wcHdhcEtKQlRoVWU2amRTR1RBMHU4Q29kMUZGZ3VQZjU2aktVN09CVVR1VFRRbUtEc1BGSVRsdWFabWxGVVNPM1ZJclZFRk9ha1VVZ0haSk5TaGVLWXB3ZUtmdXFTMEo1ZE5jWXFUZFNFNW9BaXB3RkxnRTlLWHBUSkcwdWFXakFwZ05KcE4xT0lwQXRBQU9hbFdSbEh5bW1CZWFrMmdpalFCTjJUelNocVFyNlVuU2tBL2Y2VWJxanpUcVlDNXB3TlJtbEJ4UUJLRFM1cUlOU2hxQUhab3pUYzBab0FjVFNacE0wQ2dCYzB1YVNnMHhDNXBNMFVsQUM1b0J6U1Vvb0FDS1E4VXU2bWs1b0dKUVJSbWwzVXlSbUtTcE9LWWFBRzBsT29waUdHbHBhS0FDbHBLS0FIVVpwdWFXZ1E2aWtwUlFNS1hOSlJRQXRMVFJTMHhDMFVsR2FBRm9wTTBab0FXaWt6Um1nQmMwWnB1YU0wQUtUU1pwQ2FUTk1CYURUYVROQWgyYU0wM05KbWdCMmFUTkpta3pURU9wTTAzTkdhWURzMG1hYm1qTkFoYzBacE0wbWFBSFpvelRjMFpwaUZ6Um1tMFpvQVhOR2FTaWdCYzBVbEZBQm1qTkpSVEFYTkdhU2lnQmMwWnBLS1F4YzBab29waU0wQ2x4U2dpbHlLNVRvRzdhTnRMUlRBVEZMUlNpZ1EzRkxTMFV4QlNpaWx4UUFDaWlsRkFDWXBjVVV0QUNZb3hTMFVBSmlrcDFKM29BQUtXbHBhQUFVb0ZOcGMwQVBGTFRBYWRtZ1k0VVpwb05MbWdBR2Mwb3pSbWlnQnc1cGFhS2RTQWNLS1ROR2FReHg2VXdyUzVwYVlBRkFITkxnZHFTbG9FSE5LT0tUOGFYTkFDajlLWE5KbWpOQXgyYU0wbWFLQUZ6U2cwMmxwQUxtak5KUzB3RkZMbWtwUlFBQ25VMFU0VWhoUm1scEtBRVBGR2FkU0VlMU1RbElhVUNrTk1RbWFVR2t4UmlnQjJhWE5NcGMwQU96Um1tNXBjMEFPelJtbVpvelFCSm1qTlI1b3pUQWt6U1pwbWFYTkFnTFUwbW5acERRQW1hTTBocEtZaDI2a3pTWm9vQU0wVVVVQUxSUlJRQVVVVW9GQUNVdEdLTVVBTFMwZ3BjVUFGRkdLS1lCUlJSUUlLWE5KUzBBTmtkWTBMdVFxcU1rbnRXZlk2N3ArcFhEd1dseWtzcURMS0RXSDhROWRHbCtIWHRvSC9BTkt1aHNRRHFxOTIvcCtOZVllRmRVazBYWFlybDhsTjJId2UzZWdEM3lpb29KMHVJVWxoWU1qZ0VNTzlTWm9BS1NscEtZQWFTaWtvRUJwTTBVbE1CYVNpaWdCTTBtYWZ0elNiYUxpc05vcHhXazIwQllibWlseFJpbUZoS1ROTFJqTkZ4V0VvcHdXbkJNOXFManNSMFZKNWZGTW91RmhLS1drb0VHS0tLS0FDaWlpbmNMQ1VVdEZJTEJSUlJRT3dVWXBhS0xnWkFhbkJxUUNsQXJBMUhBMG9OSmlnVURIVVVsT0F6UmNCS1duK1h4eFNpSWtVWEN6R1V0UytXQXZOUTlLTDNEbGFGcGFTaW1TT29wTTBvb0FLU25VbEFCUlJSUUF0TFNVVUFMUUtLS0FGb3BLV2dCYVhOTnBhQUZ6UzAzTkdhQUgwNEdvZ2FjRFFNa3BNMG1hS0FGelM1cHVhVE5BRWxMVVc2bHpRSWxGRlJocVVOUU1mUzAzTkdhQmpzMHVhYlJRQTdOTFRhV2tJV25VMFVvb0dPcFJUYVdnWXRLS1NnVWdIVVVsRkFDMHRKU1pvQVdpbTVvcGdMaWt4UzVvb0VKaWtwU2FTbUlXa3pSU1VDRnBNMG1hVG1tQTdOSm1pa29BZG1qZFRLTTB3SDVvelRNMFVBUHpTVWxGQWhhS1ROR2FBRm9wS1VVQUZMUlJRQUNuQ21pbHpRQXRMU1pvelFBdUtYTk1MVTNKcGdTWjk2TTB6TkdhQlhKS00wd0dselRFTFdUNGc4UVFhRlpHV1REU2tmdTA5YXIrSmZGVmw0ZHRTWlc4eTRZZkpDdkpOZVU2ak5yZXYzRFhqMmswZ2s1WHNBUGFwY2tpNHhiSTlaMU9iVjc1cm03azN1eDZkbEhvS29BQWRpYWludGI2QjhUMnJCdlFNS1QvU2xYY2Jac2ZVVXJvZGp1ZkIvaTU5TVpiUytZdmFzZUNlc1o5ZnBYcUVVcVRSTEpHd1pHR1F3N2l2bmI3WjVPMXBJNUZEZERpdTM4RytOa3M1RnM3dWZOcS9BTGY4c3ovaFRUUkxUUFZLS2JHNlNScThaREt3eUNEbk5QcWlSdEppbjBsQURjVW1LVTB0TUJ0R0tXa3BBUEJ3S2JubWtvelNLdU96bWpHYWFEUVdvQVVyaW1tak9hYVRUQmhTaWtvRkFod3FSYWo2VTlXNHBNcEN1ZXdxTjQ5b3pVZ0lwc2pacElic1JVVXBwdWFzekZvb3pSbWdBb29vb0FLS00wbWFBRm9velJtZ0FwYVNpZ0RNcGFadW8zVmhZMUgwVTNOR2FZaDQ1cVFZRlJBMDdkUVVTcStEVW5tZ2lxd05MbXA1U2xLeEt4eXRSWU5LR3BRMU5LeEwxRXg3VW5OUDNVbWMweFdFcDRVbnRTQ25oOFVCWVlRUjJvMm4wcDI2bDM0bzFDeUh4b01jaW15akIrVVVvZWdtbDFLMHNSMGxTNUZCQXAzSnNSMHRPMmlrSzRwaXNKUlFBVFFRUlFLd3RGSlJRQXRGSlMwd0NsRkZGQURnYVdtMFVBT29wQlJTQVhGRkFvcGdLS0tLV2dBQnB3Tk5vb0FmbWx6VE0wdWFReDlGTnpTZzBBUHBSVEtXa01mU2ltWnBjMERIMHRNelM1cEFPcE0wbWFUTkFEczBacHRGTUJjMFpwTTBab0VMbWpOSm1relRBZG1relNab29FTG1rcEtLWURzMGxKbWlnUXRGSlMwQUZIRkZKUUFZb3hTMFV3RXhSaWxvb0FURkdLV2xvQVRGQXBhS0FDbHBLS0FGb29vb0VBcGFTbHBnSmlrSXAxRkFodEpUaldEci9pelQ5QlVyTS9tVDQ0aVE1UDQwd05xU1ZJWXpKS3dSRkdTekhBRmNSNGsrSXR0YUs5dm83Q2VibzB1UGxUNmV0Y1Q0ZzhhNmhyeE1UT1lJQi95eWk3L1gxcm5oeXBKYjNBTlE1RktKZHU5Vm52cjFwWm5Nek55V0pwMzlyM0xSZVdranhwMDRQU3NtR0tRc1ZTWENrOXFmNUpreWlzelk0T1R4bW9kbVdpMUJkTEpjZnZHWnNaUEo1cWVlN1lINWNBZGV2U3MrNGVPTENZdzV3RFVSM2JRdTRIUDZVaGx1ZVlOZ0hqcmdpbGlkQ21KbFVnK2c1RlYxYU1KdGtiazlQZW1vN2J6ZzhIM29BOUk4RmVNSU5LdFJZWDd5dkR1K1NRblBsKzMwcjB5QzRpdVlWbGdrV1JHR1F5bk9hK2Q0SjlvQWZvYTZmdy80bHU5RWxEUXlHU0FuNTRXNUdQYjBOV3BrT0I3TFNHczdSdGVzdGJ0dk10SlBuSDM0ejk1YTBqV2wweUxOQ0drcGFRbW1JU2twYzBob0FNMFpwdEZBQzVwTTBsSlFBdWFNMGxGQUM1bzNVM0ZCNG9HS1dvREdtNXBNMEJjbDNVaE5NelNicUxCY2Rtak5OM1Vab0VQelJUYzBab0FrQkZPSUJYaW9jMFpwREhZb1BGTkRVRnFZQzVvelRDMUp1b0Zja3pSbW85MUlYcDJGY3pNMG9OSlJXUm9PelNnMDJqTkFEODB1Nm01cFFhQUhicVVOVEtXZ0I0YWwzVXpOS0RRTzVKbWpOTUJwMUlManMwdE5wYzBBTFNpa3pSbWdCd3BhYm1selNHT29wTTB1YUJpaWxGSURTNXBBT0ZOT2FNMGhOTUF4UmlrelNacGtnYUFLS2NLWWhPUlJtak5KUUE2aWtwYUFGcGFhS1dnQlJTNXB0TFFBdEZHS0tBRnpSU1V0QUM1cGFibWxvQWRtak5OelJtZ0IrYU0wM05HYUFIWnBkMU56UlFBL2RSdXBtYVdnWS9ORk5CcGMwZ0hicUNhYURTWm9HUHpTWnB0TG1tSWRSbW01b3pRQTdOR2FiUzVvQVdqTkpSUUFVVW1hWE5BaGMwbEdhS0FGelJta3pSUUF1YU0wbEZBQzVvcEtXZ0JhS1Nsb0FLS0tCVEFXaWlpZ0FwYVNsb0VKVHFTak5NQmFpdXJ1M3NyZHA3cVJZb2w2c3h3QldONGc4V2Fmb0VaV1YvTXVDTXJFcHlUOWZTdkpmRUhpeS8xK1kvYVpDc09ma2lRNFVmNDBuSkRTYk90OFZmRWxTcjJ1aGtoZWozQlhyOVA4YTg1dWJpZTlkcEpKU3pzY2x5ZVRVUlhjM1FrZHdhVnlVMmhFd0Qxd2F6YnVXbFlhbnlqQURrWTdVNVdCeHVBSjZrRVVvR1R1eVZYcm5IU28yZmRsbWZvZVFLUXhzZVpwbmNJQUFwSkc3dFRvZDNsbllGeDNHYVpnTEVTTzQ1OTZWUDNjWVhkOTRkdTFBQmNxeklqdUZHRDBQZXEyNGtsMFg4cW5kdjNpbHgwNEdlLzFxR1NWT1VYMXpRQXd5YmdCdE83cWZTaUdiNXlNWTVwalppNVpTM2NNZTlLb0pRU2JlL0k5RFRBdXhTTWpBYmlBZW1lbFhJcHdxa1p5ZXZTcWNRM0tPUnM3a25vYWxqWVNxb1Z0cnFlbzcwZ043VGRXbHRKMW10Wm1qbVhvUi9GOWE5TjhOK003YlZvMXQ3eGhEZWRNZHBQcDcxNDRBVk83UHpad1FLdHd6dkd5a0VoMUlJSVBlaE93TlhQZjgwaHJ6dnduNDNielJaNnJMbER3a3JEa0gzTmVnbzZ1Z1pHREt3eUNEd2EzaTB6RnBvZFNab3BEVEVHYVFta0pwTTBBTG1rcEtLQUhBMFUybkNrTkMwMXFVbW1FMEliQ2lrRkxWRWlHbTgwL05OTklMQ1pvelNHbTFRaCthTTB6TkptZ0NUTkx1cVBOTG1nQlMxSVdwRHpTWW9BWE5HYWJta3pURU96U1pwTTBtYUJGSE5MbW0wdFltbzdOR2FibWxvQWRtbHBncGMwQVB6Um1tNW96UUE2bHpUYVdnQndOS0RUS1hORmdIN3FYZFVlYVVHbFlMa2dhbkJxaXBjMER1UzdxWGRVUU5MbWl3WEpRYVhOUlpwZDFGaDNKTTB1Nm90MUxtaXdYSk0wbWFabWx6UllWeDFGTnpSbWl3WEg1b3pUTTB1YVloYzB1YWJSUUE3TktEVGFNMEFPelM1cHRGQUQ4MEEwMmpOQUQ4MFpwdEZBRHMwWnB0TFFNZFJta3pSU0FXbHB0TFFBdExTVVpvQVhOTFRjMFpvQWRTNXB1YUtBSFpwYzB5bG9BWE5HYVNpZ0IyYU0wMmxvQVhOTG1tNW9vQWRSU1pvelFBNmltMFVBTFM1cHRHYUFIWm96U1VVQUxSU1VVQUxSUUtLWUMwVUEwVUFMUUtTbEZBQzBDaWdVQUxSUlJURUZMU1Z6MnZlTk5NME5TanllZE9QOEFsbkdjL242VUFiczl6RGF3dExjU0xHaThsbU9BSzg0OFVmRXpEUGJhRVJ0Nk5jRWNuL2RIOWE1WHhENHUxTFg1VDVyZVRiZy9KRXA0K3A5NjV3NEp5UG1QclVPUmFpV1o3eWE3dUdsbWxablk1TE56bW90cHlXWWdrZEQwL1NtREkvZ0tFakhOUFVIQkpicjNxQ2g0M2JTVlVubnNldERyemdOalBOQmxLcWVjNUdmZWtVczdZajU5RFFNUitoVWM0R2NnOFZXUkdZSGtFZWc0cVo0blZpRlRjb0hIdlNmTkh0QklWajJvQUVBQ2tIQnlQV29tS0pJM0lLOWpqZ1ZNd2RveVplVzloVUxkUWcrYitsQUJMdGFIR2M0UFVjVkJ0YVlxd1g4TWYxcVNRb1FGUThudjcxSkVrZ1lqYUdiR0FEeFFJaTh0NU54UHpiZUJnNUZSeG1VNUV1UXYwcXkvbUtXaFlsVDFHT01VTEI1b0xITGV1YUFJVjh4RjJaNmpyZ2RLbWk0S3VWK1Vub0tyeWxZWk52UEhUMnBTWEpHR0lIWDYwRE5WSlFDTW41bDdudlQ0MkpiMXowSk9NVlRpSVlmTnd3NmU5VzBVZGVtZU90U01zQmoyQlBQcDFycS9ESGpLZlNZL0l2RmFlQW41UnU1VDZmNFZ5Qzc0MU9lVjl1MVRCdzZrTWNzT2hGTk5vVFZ6M1N6djdlL3RsbnRKRmtSdTRxYzE0MW9uaUc3ME9jdmJuZkd4K2FOdWhyMHpSZkVkbnJVYStTKzJVakpqUFVWdkdWekdVV2pYTklhWFBOSlZrQ1VacEtTZ0IyYVhOTXpTZzBXSGNVbWtOSVRTRTByRHVMUm1tNW96VEVPelNacE0wM05BRHMwbWFibWltSURTVUUwbEFncGMwMmltQTdOR2FiUzBBRkpTNXBLQUNrb05GQUdmdXBjMHlscklzZG1selRLV2dCK2FNMDNORkFEODB1YVptaWdCK2FVR21Vb05BRDgwQTB6TkxtZ0IrYVhOTXpTZzBBT3pTNXBtYVhOQUQ4MHVhWURSbWdCK2FYTk16UzVvQWZtbHpUTTBab0FmbWx6VE0wVUFQRkZOelM1b0FkUlRjMFpvQWZSbW01b3pRQS9OR2FhRFJtZ0I5R2FibWpOQXgyYVdtMFpvQWRtbHpUYzBacEFPcGFibWpOQURxV201b3pRQTdOTG1tNW9vQWRtbHpUYUtCanMwdE56Um1nQjFGTnpTNW9BV2x6VGFNMEFPelM1cHVhTTBBT296VGMwWm9BZG1pa29vQVhOR2FTak5GZ0hab3pUYzB0QUMwVWxGQUM1cGFiUzBBTFNpa29vQVdscEtLQUZwUlNVdEFCU2lrcFJRQXRBb28rbldtSVdvYm03Z3NyZHA3cVZZbzFHU3pIRlpYaUR4Tlo2QmJreXNKSnlNcEVEeWE4aTE3eEpxR3ZYQk4wK0lzNVNJSDVRUDYxTGRpbEc1MFhpbjRpWEY0WHR0SDNRMjV5REwvRzMwOUJYQlNOSk94ODVqenprblBOSStRUG5BejJ3YWlkOTU3Z0R2anJXYmR5MHJFakFxZ1VuOWFhclpiYU9XUG9jWXA0TE1jOXV3STRwR1dOQ2ZtejZsZXBOQXhHRWhQemdrRGtaTlR4NFpTVytVZzlLcnN6TEh1T2V2SzR6VW5tanljdHh4NlVBSkk1UElJVWpqRlNBT1VIM2srWHIyeFVLSTh1R2pIZm1wakdFejYrL2ZOSUNNdVZUNU4zR0FNVklubHlxTnkvTmpCd2NZUHZRa1RQSHRPTnk5TWQvYW13U0hZeGJBQTR3YzBBUnpueXpqRzNCNElxTnNDUXZubnJ4M3FWd3pLR0lWbEFOT1ZDVU1nSVZSMUJITk1DbHQ1M01OaHo3ODA0U3Q1b0tnNDdCajFwemwxaFhJUExkUU9vcVJvZ0ZCd1EyT0EzU2dCekV5VEFFNE9NOU1qODZZaWxXWldiZGc4YmVob2lJYVl1U2NrWXdhV1J0cW1UQUlIQXh4UUF5VmkyUUFjNEdXSE5WNHd3SldUUFR0VTl2SThrak8zeWhqengwb1VONWtnQnlGSVBQSDQwQUtpWUhCT1IxQnEyRDVxcTBMRElIS25pb0F1SEJWZ3k0N0hwU3h6aFNBd3h6MnBETGlTZVduVTR4K2xPVTR3VlBPT0NPbFJjN0dhUEJYR1FLYkRQc1hCSERkT0tReTJKVHVPNDhWUGJYRWxwTXNzRXJLNm5JeDFGVk1rNElHZVBYcFQwYkxBNUhBNlpwZ2VqZUdQR2pYY2tkbHFJektlazNBQit2dlhhQnM4anBYaFJiYTI0RGFSejZZcnJ2RFhqTjdQYmJhZ3pUUk1mbGtKNVQvQU90V3NaclptRW9kajBjMGxSVzl6RmRRckxieUIwYm93TlNWc3ZJeUNrb3BLWUM1cE0wbEpRQXVhTTAzTkJOQUM1cHBOR2FRMEFLV296VFNhTTBBTG1qTk5vb0FmbWt6VGMwWm9BZG1qTk56U1pvQWRSbW01b3pRQXRGSlJRQm5ab3B0TG1zeWgxTFRjMFpvQWRTMDBHbHpUQWRSVGMwdWFBSFVDbTVwYUFIVXROelJta0lkbWxwb05GRmd1UG9CcG9OTG1pd3gxS0RUYzBVQmNkUzAyak5BRHMwdWFibWpORmdIWnBjMDJpZ0IrYU0wM05HYUFINW96VGMwWm9BZm1pbTVvelFBL05HYWJtbG9BWE5MbW0wWm9BZm1qTk5vb0M0N05MbW1ab3pSWUxqODB1YVpRRFFGeCthWE5NL0dselNzTzQvTkxtbzgwWm9DNUptak5NelJtZ0xrbWFNMHpOR2FMREg1b3pUTjFMdW9BZG1scG1hTTBBUHpTNXBtYU0wQVB6Um1tWm96UUJKbWpOTTNVWm9BZlMwek5HNmdMajgwVXpkUzVvQzQraW01b3pRRngrYVdvODBvTkFYSDVwYVptbEJvQzQ4VVUwR2x6UllCd3BhYm1qTkFEcVVVMm9ycTdoc3JkcDdseEhHb3lTYUFKMklVWkp3QjNyaS9GWGo2MjB0V3R0TWRacm5vWHpsVS93QVRYTmVMZmlCSnFHNnowc3REQnlHZm96MXdtMTJPWEJPVG5pb2N1aGFqMUx0M2ZYV28zVFQzVW5tTkljbG1QTlFrQlZiYm5rY0E4VWY2c0FaeVFPdzZWRnVEbmprOSsxWm1neDIycVNkeHoyNzFJa0pNZ0xZd1Z5QURRRUE0WVlLOEFrMDROKzZ6akgrMW1nQjdNMnc3VStVRG5CNjFHdTBmTVJnbm9PdUtsQ2dGT3h4eDcwMW13bTBqQTc1NzBBUW81M1lBQlVuSk5TTkc4a3E3bVhBR1RrVkdxa3NjWWRjNEl6aXBWWGRDUmphY2taTkFEWGtFY2hDa09jZmhUMWtJWUt4ejlCeUtqMkpHeXNxN2gwRlN0SUJ1S3R0YlBGQUJQSis3ZFkySzhZeU85UmZPa0N3WjNaT2VnenorRlBqL0FIdDBVa3crMFpKUEhOUGFFQ1E3RVVkOFpKb0FpWVppR0J0d2VNOFlwbHR2Wm1KbFhQZGFRelNKY0ZjSDczS0dsVE1mZGN2emcwQ0hTSEVTN0NkOVBiL1ZuekFNbWx1ZHBpVlZ3R0g1SC9KcXJPVWFQYmphM1RuK2RNQnJueVdEOGxWT1F1S1dXVlpYMmtGVkl6OGxJSFJ4aHo4d0dDQi9PbWxHZkpLNHdNZ2lnQkpGV01vRjNLYzRJSSs5VHBiZG13eFppTWNoZ1JWWVhhbGlzbWQyN0F6elYyS2JkR3U5TWdjak5BREJqemNJZHBBKzluTk1Fdk9KQ0czZHNkNmdFelJzMlYyNDdVOUpvM0pKNWJIQTlLQUwxdE9ONFhKWDBPT2xXR0N4TXpBRXFlNDdWblJ5Z0o2Y2pJSFVlOVhoS0FuWEtkd2FsalJOR3FzeHlWd1IzUEJvYUlLdnlDbzRreXAySGNCemdkcWsza3g3aDFIVmZTa01rais2Ukp6Nm1oc3hnRk1FWjllbFJLMjVobmdkcyt0QjNsemdkdVFPOUFHM28zaWE4MHR5MXZJU09yeE4wTmVsNko0Z3RkWnR3MGJCSlJ3OFJQSU5lTmhmTE81ZnlxMURkeTJreXpRTTBVZzVCRmFSbTBaeWdtZTNVR3VWOE5lTDQ5UzJXdDZSSGNZNGJQRC9BUDE2Nm5PYTZVMDlqbmFhZW9acERRYVROTVFVbEZJVFFBdEpta3BNMEFLYVNpa3pUQVdrcE0wWm9BWE5HYVNrelFBN05GTnpSbWdCYzBacE0wWm9BWE5HYWJtaWtCbjB0TnpTNXFCaTBvTkptak5BQzVwYzBtYVdtQVpwUWFTak5BRHFYTk5velFBN05MbW01b3pRQTdOTG1tNXBjMEFPRkdhYlM1b0FkbWpOSm1qTkFEczBacHVhWE5BRHMwQ201cGMwQU9velNVVUFPelJUYzB1YUFIWm96VGMwdWFBSFpvelRjMFpvQWRtbHpUTTA3TkFEczBacHVhS0FIWnBjMHlselFBN05HYWJtaWdCMmFVR21acGMwQVB6Um1tVXVhQUhacGMwek5HYUJqODB1YVptak5Ld0Q4MFpwdWFNMEJjZG1selRNMFpvc0Z4K2FNMHpOR2FMQmNlRFM1cG1hTTBXQzQvTkxtbVpvelJZZHgrYU0wM05HYUxCY2Ztak5NelM1b3NGeCthTTB5bHpSWUxqODB1YVptak5GaFhINXBjMHpOTG1pd1hINW9GTnpTZzBBT0JwYzB6TktEUllkeDlMbmlxbDVmMjloQVpydVZZMFVaeVRYblhpSDRoVHp5UGI2UWZMai93Q2VoSExVbkpMY2FpM3NkZjRoOFlXV2h4RkZZVFhPT0VYa0Q2MTVicjNpbS8xdVZUZHovSXVTc2FjS3RaVHpOTklYbGtKZGprbG02MUVCd1Q4b09jbi9BT3RXTXBYMk5ZeHNCTDR5eHg3OFpOUGlET1F6dG4rNkR3S2JoY2p1VDYwOTJKSFhhbzRKQnFDeFdqd3U1a0MrdnJUU0FRQ3gzQUhPMEdvSGtKQXdTeDdaNlU1YzRCWWJjOGRhQUhsQkxsand2Y0hKeFQ0NVZCYklDb1J5TTB4WXlIQ3hnNGJ1VFR4bFdPL2dEMTcwQVBBUjEzNXp4a1o2aW9QbWtaZ0NvUWRTUitsRXNtWEhsQUVkOFVwYU1qWVNFejNQZWdCNVh5d0czRG5nRmV0TG5iR1Fxc295TURIVTk2UkQvQ3Z6WjZFZHFjMHBRQkJoK3ZvS1lBUVNNSzJWSFVBVXgxQTJyc3pqc3ZlcGZOMnFNTGtnWkp6ME5SeU5uTGhzTjF4anBRQWpOc2I1a3l6OGNIRkppYUtUR01LNTZFMGpTeVJoTjdaQlBVam1teVRoaUQzNjR6MG9BZEpDelhBZHR3WWp1ZjVWSXNZYllvQUk3a0NrQTN1UDRCZzRQWC9QYW03ZHNvQUoyOXNIdlFCY250VnVJc09DcnFPQ08zMHJOZUFvM01nWVorcHE3TGRva2NTSWpGbjY1UGVxcnZ1WncyTXQyQjZVQVF0dERGOFlKN0VWWmlaTm43dzdWUGNjR29ZU01zT0dCWEdQenBZMHdDVDY5Q2Z2ZlNnUlF1SVZXWnBWSHk1NlpIWDZVc1Z3VUEyb1NUMUhwVnFSVUxHTUtNbHZ4SHJWYVhiQXhEY3FlNXBnU1BLSlhCVlZCUE9lbjUxR0lnckJsNUk2Z0hqTk9pa1NTRHltVGFTU1FSVThjZTVUdllLY1pPUlNBYWpLMldNZTNqQkJHY1Ziajh0MUMvZElHY3RWVU1UR3dWVmJCL0hGUEh6TGs0QlBITklaWUJlTnlFT0RubkhPYWxqZjVqaHZtL2l3U0tnZ09OdTE4a2REamluRi93QjhHQUFJSTZDZ1pjWlYzZktCeU9mZW9DcksrZlE4bnBVak1zaVpIeXN2WFBHS2xSRWJoamc5eFNBVWZ2QUFjWkE2SDBwQ29IeXNTUWZmdFNiREhrT2NEK0doMlZXVU5ubWdZQnpDeWtJTWRRMmNZcnVmRFhqQWhJN1RVM0xFOEpNVCtocmlEamNWT0NjY0FtbVJsbDY1R0RuSHJWeGsxcVJLS2U1N2dIRExsVGtlb05HYTg2MEh4YlBZcUlyc0dXMjZBOTFydmJXN2h2SUZtdDVGZEc3ZzlLNm9TVWptbEJ4SjgwbWFDYWFUVmtEaWFUTk56Um1nQmFTa3BNMEFPSnBNMG1hVE5BRHMwbWFUTklUU0FkbWpOTnpSbWdCMmFNMDJqTkF4MmFUTkptaWdDaG1sQnB0RlFBN05HYWJTNW9BZG1qTk56UzVwZ096UzVwbWFYTkFEczBacHVhWE5BRHMwdWFabWx6UUE3TkxtbVpwYzBBT3pTNXBtYVhOQUQ4MFpwbWFYTkFEczB1YVptbHpRQS9OR2FabWx6UUE3TkxtbVpwYzBBT3pSbW01b3pRQS9OR2FibWpOQURzMHVhWm1selFBN05MbW1ab3pRQS9OTG1vODB1YUFINW96VE0wWm9Ba3pSbW1ab3pSWUIrYU0wek5MbWdCK2FNMHpOTG1nQjJhWE5NelJtZ0IrYU0wek5MbWdCK2FNMHpOR2FMQVB6UzVxUE5MbWdCMmFYTk16Um1nQithTTB6TkxtZ0IrYVhOTXpSbWdCK2FYTk16Um1nWS9OTG1tWnBjMEFQelJtbVpwUWFBSDVwYzB6TkFORmhEd2FYTk5CcGMwQVBCcFFhanpWTFVOWnNkTFF0ZVRxaHhuYjFZL2hSc1BjMFNRQmtuQXJtdkVIalN6MGNHR0RFOXhqb3A0WDZtdVM4UStON20vWm9iUE52YjlPdnpONy9BRXJrdHp5dHV5VHp6eldNcHJvYXhwdnFYOVgxeTgxaTVNbDlPemVpSDdxajJGWmJNQWVHNmRGcDJReHh0enh3YVFRamRqR2NlaDZWbDZtdHJiREFRV0kyNExmdzAzQkdRT0NmUTA5ejVqRUx3QU9UbkZFYWJHSlVrbFJrSHRTR04yS28rWnNOam5pbFVuN2lydU9PT3dGS1ZXUk00RzdQVW5GS1d3Z1VydUFHY2lnQnFieGtLckVaNU9jMGhRNHo5NFp5TVVieklUdERxdmIzcFVqVld5MGpIanFPY0g2VUFLcmc4Z0hkbjhjVWp1WGtFWUJWTy9PYzFJTmhUY3hCT2UzQnByL2RJTW1UMkZBQ1NLVktydCtadlE1cGpxNjdlY2dkUjF4VWlMR0VWbXl6WjRHYW0yR1BNcXA1Z0h2UUJFSXRxQ1JoblB1UmdVaVI3OEdKZ04zT090VE5NR2kyU3I5NmtpS3hnZVh3eEJ4eHpRQXJreHNXS0lUZ0RBOWZyVUpqTW56ZmRIb1A4YWRPUUdPR0x1M09QU2lRZVVJa1FaT2VRVDNvQWhZek9Gais4QWZsSFhIK05TZVdoeUpBTWpsbElBQXBZeUViZUJodzJDVDBGQ3FyTmxtR091UnptZ0NWUW00SzIxajBPRDE0cUpraVJpcTdlbU1BZGZla2huaUxtVEQ3Vk9GeDYwakJwR0xvRlVqZ2VyVUFPa0dHWGVSSTJNREl5TWZVMEcwRWNlNDdXRzc2ZnlwSlppb3dEam5rK2xNbFlnZVdzdTROenVIclRBaURHT1pqaFFEOXpucFNQSXpSa3JrSHR0SEFwQnVXYmNQblFjdFU3N1k5cDdOemdIQXhRSXEzQVozVFp1SFE0NllxS1JEc0xTWUtodW5XblhKM0FrQWtBOGxjMDFqbTJZS0NUd09hWURJMVJnMk9BRHdOM1NyWWNtSXg0UmZjTjFxamdnRWNkZU81TlN4c0Fuekt4UGJnOFVBTjM4a3FweDZqbk5TUXFQdm96RW5xQ2NmaFRWVW5PMWd4QjZBNE9hUjFrS0JUaGVjWXh6UUJidDdqZXpTS2NBY1lBcTRzaXlFN2M3eU1rWUdDUHBXVEhHWW4yazdDQjA2azFadGJsaXh3Njhlb3FSbG90dStiRzA5Q1BXcDRaaXVDR1BIVUh2N1ZXVHpKM01oeDdqcG42VkwvQUJmZUhYcFNHV3BMZ3M0Snp0N0RHY1UxenlQN3VldnBTeGhIR01nRThubnBTU29SSGtOdVhOQXh1Zm1BVjl3N2tHcHppUUFad1I5MXZXcXdqOHRoZ0hiNjRxUThISFE0b0FjU05vM0VqbkJPZTlhT2themNhWmNHU0NZZ2o3eW5vdzk2b2hRd0JJOXFhVUVaempJSFFpbW1KcTU2cHBHdlcycVFxRllKTmptTW4rVmF0ZVBXdHhKREtza0RiQ0R3d09LN25SdkZLektrT3BZamM4TEowQnJwaFZ2cEk1cFUydGpwelNacG9ZTU1nNUI3MFpyY3hGelJta0pwTTBBTG1qTk56Um1nQmMwWnBNMG1hQUZ6Um1relNVREhacE0wbEdhUUM1b3pUYzBab0FwMFVsR2FnWXVhWE5OelJtZ0IxRk56UzVvQWRtak5OelJtZ0IyZmVqTk56UzVwZ096Um1tNW96UUlkbjNvQnB1YVhOQXgyYVhOTXpTNW9BZG1selVlYVhOQWgrYVhOTXpSbWdCK2FYTlI1b3pRQkptbHpVV2FOMUFFdWFNMUh1bzNVQVNacGMxSHVvM1VBU1pvelVlNmwzVUFQelM3cWozVVpvQWszVVpxUE5HYUFKZDFHYWp6UnVwaGNrelM1cUxkUnVwQVM1b3pVZTZqZFFCTG1qTlJicVhkVEFrM1VacG02amRTQWt6UnVxUGRSdW9zQkx1b0JxTGRTN3FBSk0wdWFpM1VCcUFKYzBacVBkUzdxQUpNMFpxUGRTNW9BZm1selVZTkx1b0FrelNnMUhtbHpRQS9OTG1tWnBRYUFINXBjMUh1cDJhWURzMHVhWnVBRlVyL1dyRFRWSnU3bEl6L2R6bGorRko2RHMyYUlOUjNGM0JhUkdTNGxXTkFNa3NhNG5VdkgrWXl1bjI1WFBBa2svd0FLNU85MUs3MUY4M016eWM1d1RXVXFpV3hwR20zdWRsclhqMkpBMFdrNGQ4WTh3ci9LdlA3dS9sdloza3VIZDJZL01TMU5aNGxVaEZiZDZnOFUwYnhqQUdUMXJCeWJOMUZSR2JWVmZtSlk5aG5yUUdNamZjQzhkQlMrWDgyNVIrZmFuTEVGQWJia1orOEc1cEZDRlFpQXR5M3RVRGhpeHdNRG9NMUpLNjd2dkE0N1pxTmpsdWg5dlNnUko1V1VEQkZVOVR6ak5Nd0N4SUhIb3A1cDJ6QVVTSDN3dFBSZmxNbU5vNkFaNVB2UUJBTXAwVnVuQUl6eFVnT1VCWjhFZndDZ2JpMmM4LzdYQnB5cjV1ZkxVZStlRFFNSW9TM1RDOGNsajBxUW9jREgvd0N1bXZKSENjS1NDZUdCNW9SZzJaTW5qb09wSm9BaEtxUWZsVnVNSG1taE1qT0NBT2dIZXAwS1RTYmg4cEhVQWRLVEFaM0RPK0VQUTk2QUpZaUN1WFFqNWNESnA2enFFQ2puR1NReFBOSWc2eU5uWVJ6elRDVW0yK1dwNmR6bjhxQkVFbzgyVmlvTE5qcjAyMU5JWkZYZEt4UUtPUXAvV3BBb0VmemZLVHdjOGNWWG1ZRUtCd09ob0FpaUc4NWtPNG5rTDNxUXlGVDF5dU9CMVA1MUd6K1hHTnFBT0Rna0dud3hwNVlrY09COU90QUVMcHZVWkxJdWNubkZPamdIUmNGc0hOUGxWM2NPc1oyQWR1UUt0TEtrYTViYjA2QThpZ0NrcVBHU3VXeW83SGpyVTBjVGNNeklTdzZFOVByVmQzWDdReEdXM2NubXBXdWxDYldRYytnNmZqUUF5NE8wWklBeWVpc2VlS2ZiQlFBWFVEanJubkZWNVptOHJLb0dBUEl4d0tWTHBwWXNpTlFRZVFvelRBa21KUnNxVDh4NE9mZnVQU216NUVZNFhjaHkyMGNuNmVsSlBPSk1iQnpqbjM5ODFHQzhuM3NqanF0TUIwekVzcU1pcXdISjlhaW5nSnc2N2N0d0FEMytsTnVITzlWMk9TUmtsdTlJdDA4U0tTQVFHNms5cUJEU3JyR3Bkengxd2VhVkpGS2h1Q3k4QUQ5YWlhWHpHSVFFQW5JQzgwNElyRGNwQXg2OUtBSkdhT0dUZEdwSjlDMlFhY3JEYXltTGR1endPNTlLcVhHN3p2a2JLamdFRElxV0dTY1l4eUNPYzlxQUpZamprcnoyRE4ycGlNWThGZUIyTkpLeCs4eUFFOEhpb3k2cUZXUWZMMXlQU2tNMkxhWVNEelI4cnI2OTZrZENOckFiaGpKd09ockxpeEc0Qzhqc1FlbGFNVStNTHVYQjZrbk9UVXNhSkdEeGdNb0dlK2FtUW1UREljanVNOGlvbmRodEFCYjE5NmtWZm1WMDVWdTZubWdaT1hhTUhJSlhISTlLZjU0MmhaUUdUMXgwcU55c255eUhrZHh4VDFVWjRPYzlRd3BER3NoaUpLREk3Wm9WbllFWVhCN0QxcDVQUmZ2SU92dFNGVVdUaGl4UFVZb0VCWGJ0VThkOFU2T2NLU3JjNHBqZ3lIS05uSGJQU29wRmRXSEdSamlnRHFORjhTeldPSXBYTTBQVGFUeXYwcnQ3VzhndklSSmJ5SzZuME5lUWdNR1ZsSnpqdHpXaFlhbmNXa3U2Q1F4c091T2grdGJ3cU9PNWpPbW5zZXE1b3pXRG8vaVNDLzJ3emtSVDR4ejBiNlZ0NXJxakpTMk9aeGNkeDJhVE5HYVNtSU0wWm96U1pvQVhOSm1nbWt6UUF1YU0wbWFUTkFDNW96U1VVREtXYVRKcG02amRVREg1cGQxUjdxTjFBRW02amQ5YWozVWJxQUpkMUc2b3QxRzRVQ0pkMUc2bzkxRzZnQ1RkUzdxaTNVYnFkZ0pjMFpxTGRTN3FBSk0wWnFQZFJ1b0FsM1VicWozVWJxQkVtNmpkVE1pak5BRDkxTHZxUE5HYVlFbTZsM1ZGbWpOQVhKZDlHK29zMG1SUUZ5ZmNLTjFRWm96UllMaythTTFCdU5HNDA3QmNuelM1cXZ2bzh3MFdGY3NicU4xUWVZYVBPb3NCUHU5NlhOVi9PcGZPRkZnSjgwbWFpODRVdm1yUUJKdXBkeHFMekJTNzE5YUFKTjFHNm85dzlhWGNQV2dDVGRSdnFQUHZSK05GZ0pkMUc2b3VhVEpvc0JQdW96NzFCdW8zMHJBVDU5Nk4xUWI2UE1wMkFzYnFOMVFlWlM3NkxCY24zVXU2b045Rytpd1hKdzFLR3FBUFM3NkxCY3NCcVhOUUI2WHpLVmgzSjgwdTdGVmpNcUFzeHdBT1NlMVlXcGVNTE96VXJiSDdSTDZBOEQ2bWsya2hwTnM2VnBGVmR6RUFEdVRXRHFQakd3c3lVZ0p1SkJ4aGVuNTF3bXArSmRRMUtRK2RQNWNSNlJwd0t5R2xKYkc0QWpuQTV6V0VxdlkyVkx1ZEpxWGpEVWIxajVNelF4SGpiR2NmcldETGR5Tys1aVhKNmxpVFVJQkxINVY1N1pwRitac0dQQnJGeWJObEZJbEU3RmlSM0dNQ215ZXJqSHNEaW1sa1VaSExIam1qWmxjc1NNbnVha29hV1BYNWRoL2h6VDRneXJ1VVkybm4ycC9sS2tZRVkzc2Voei9La0xHSURlU1pEengycGdKdWNrRU1QOTNHYzFHQkg4Mnc0WS9wVHp1ZGg3OWh4aW4vQUNLQnZ3RDY0NG9Bakl4eSswanRnVkdmbUJNUy9MNzFQczh4amsvTDdjMHBpOHNOZ2dIMFkwQVZvMEhKa0pBNjdjOWFra3hJMjA0UmNjWTZtbHhMY0ZTZG1Pd1NwWGlXTmdPaDdranIrdEFFUkFQSFhBNWFwSkhDeDREWjlDQlVySHlnUGxVanVjZFJVR1VQejVZREhUSDlLQUdDSndvZkpjc2UvYWxkbGpHVUcwWjVBN21wU1RIQ0RnZ250NjFCRkc4Z0R1b1Rub2VSUUE2QXVvNCtRSE9TVGswOVViekNzaExEdHgxRlNzUEpiUHk4OU9NQ21vek9TOHFidG93RkF4UUEyVzYzaFlvMUNMbjV1QWFtRXFuTWFLVGdqZ2pwVlZCbG1MeDQ3RGprVlpLaU9NQTQzWTUyOWZXZ1EwK1VrcmVaOHk5K0tqbmJMN1kyQVVEQUM5eFRXMms3bkdlUGx3S1ErV1hWUU1FOG5IOE5BRVVpUm1aWWRwRFlCem5yN1UrV1JtVUpJY0RQSU9CZ1U4NGRsVlZCR2VXeDJwREFQdEFCd3lxT2VPU0tBRnRsVUtSdUk1K1hrZEtnbVV3U3MyM3FjWXprWnJRL2NNMjJMSWJzY2RSVUR0dnVFVm13RkpJQVhyUUJUV09SbjJySGs1eWNjWTlxa1lsQzBZUlN3SGZzS3UyNnVGa2RpcGR6bllUajhhcVlLZ3UrTWs1TzBIa1VBVkYzTkdGQnp1eVdQdlVpK1pESGlQYTJEM0hUM3FjbEZoSmpSMUI2NVhGUUdSZHZ5N3NBZFFlbE1BTWY3b01XWGNlbUIxOXpUQ2lLdlAzaHlUdTYxT29KQWRUazQ2RThnVkVWTzhPaFJ0M3FLQkRITWp4NVJPTzI3a2lxMHlIZXpjNHgweWNWZmQzbFZ5MlVPTnBQWSttS2lSV2tEUkg3eWpvY2Mwd0t0c1NtWWxSUUNlNHBYaDJUYjJmYW45MVJqbjBxYUNCdWp1cXFSd3hPY2MweVJ2M2dENFlqT0Rta0JFNi9QaFE3SG9kb3dLZVFoak1hcHRPT0NLbWtVeFRBSElKYm5ieUZxUUJuTEs0VU1vK1hIR2ZlbUJCYkt1NHh5azlpTnh6bWgwQ1RESUI1L3U5YW5BWGR1ZmJrZnBVa2tNUmpEa01CamdEcWZwU0dWQ2lGaUJ3M2ZIU3BSNWlqaGh6MUs4WnBYaFdNZkkyZWVjaWthSVJ5REdYSFg1UmpOQUZpM21kZVFUSUJ3Y2prVmJMSVYzUWdqQitaVHhWWkNsdzN5QUtRUG1CYkRDcDRwSXpJTTVWVHdjbk5UWWFaS3hEbFFQdmdkKzFQUmp4dk9DcDZMeFVNaCt6eWlSUVNwNEFKNzFMNWpiUTQya1VpaVZRQW9Ec1dQclRpckJnUitWTVNkWFg1c0FlcG9hWEdGT2RuWE9mMG9BbmpDbGQzOFdlZ3FPUlJqekYrVUhyN1VpSEh6SWV2UTVxWldEWkdja2prNG9BcmhpRGdIOUtheUhjU25IUHJVNWp5eElQYmlvOGtLVGh1T01DZ1ZoMGMvSUQ5UjZIcFhTNlg0b2x0RVNPOFBuUTlCSUI4d3JtVEdHR1ZBSm9RdkQ5UDdwNlZTazR1NkU0cDZNOVR0TDJDOWhFbHZJR1UvcFUrYTh2dDc2YXpuV2EwY293Nis5ZGpvL2lhQy9VUjNPSUovUW5odm9hNm9WVkxjNVpVM0hZMzgwbE5EQTlQem9MVnNaQzBacE4xSVRRQTdOSm1tNW96UUE3TkdhYm1relFCblpvelNVVkJRdWFNMGxGQWhjMFpwS1NtQTdkUnVQclRhS0FIYnFYTk1wTTB4RW02amRVZWFNMEFTYnFYZFVXYUtBSmQxR2Zlb3MwWm9BbDNlOUx1OUtoelJuM3BpSmQxTHZxSE5HNmdDYmZSNWhxSGRSdXAyQW04dzBiNmgzVWJxTENKdDlMdkZWOTFHNm5ZQ2ZlS045UWJxTjFGZ0o5OUcrb04xRzZpd0UrK2pmVUc2amQ3MEFUNzZOd3FEY2FOeG9FVDdoU1pGUTdxTnhwZ1Rab3lmV29keHBkeG9zQkx6UnVOUmJqUzd6U0FrM21qZWFqMzB1OFVXQWs4MDBlYWFqM0NrM0Npd0U0bVByUytlUlVHUlJuTkZnTEhuZzB2bXFhclpvb3NCWjNxZTlMbXEyYU54b3NCWXpTNXF1SFByU2lRK3RBRStUUzVxQVMwN3pSUUJNR3BjMUQ1Z3BmTUZBRTFRWGwvQllRbVM0Y0tPd1BlcStvYXJiNmZibDVuQWJIeXIzSnJ6N1ZOWW12N2pmY01TT2lyMkZaVG55N0dzS2JrWE5lOFNYR3BNMFViZVhBT2dYdVBlc0dTVUtxc1IrR090SzhyRUVJd1gwT09sSUdKWWIyQjQrOWpyWEc1TnU1MXFQS2htNTVIR3pnY0VpckNScmtnQUUraHBOaHdDQjh4NTU0cVJJOXpFc1Z5UnlLV2hRQVpMQmdvSVhnazlLaWQyeGlQQjlUVmhoSHMyTWR4eHhrZGFkQmJoNDh5cUVBUEpYRklDckdyTjBHRkdNbHFWeVQxQjhzSHAycTQ4YUg3Z0FSVHhnbm1rTVhVZ2JoM0ZBRlE0UWJ2dWc5czAwbnppZXlqOUt0dEdtemV2ekVIZ0VEQS9XbUsrV0lNUzdUMTQ2L2pUQ3hCQXU0RUk1WUE5UFduK1dYYmJ3UFhqb0ttWWhtWUxIbmNPM2FvMGtLS0Y1NDY3aFNBRkozTUdiNU1kY1lKcFdiekgycHlweGc1NjFCdEp1Tm9rRzBkVC84QVdxY0x0YnpBQURqN3VNVUFNZFZnWlMvQkkvaEFGS3N3QkdDR3gwSlBTbnhGSkhKa0NnanFjMFM4eWsrV0N2R2NIclFCR0M0azVjZ1k1d0tSc1I0ZGhrTWZ4cDB6b1lpd2p4eGo1VzVGTjM0Z0FaUVdQQVFINXMrMU1DUnRyTXNXNHNwNUxaL1NqSDd0aWkvSm5BeG5paUF5eXh0RXFLZ2I3emc4aW5RQmtSajVoQzd1RnhuZDdtZ0NBQnZNUG5EQnprY2Y1NXFkd3dVQk9keDU5dWFHbFkvZjV4d3ZOR3dsUVhUWTUvaVU5UHdwQVNRN1VZczRKVmVPdjNxWTAwaGFVdGphRytVcmpGS3U5SmdGTzVUams5cWJKc1pqR0V3UWV3eURUQWdaanQzQnM1QjYvcFROcXVUSS9KNTRHT0tuVzVVN3ltTmlqa0VZL1NtUkl6T0dKQ252M0ZBaVJZR2p0d1ZmSlljZDhWWHl5S2ZNNm5nVlA1eE1tR2RBbzY1NEIrbEJSR09BeW5CNUhYUDBIYWdCbjNJUEx4bGowNXdEUVpDWXdvYmFEeHh5Yy9Xa1Zvd09KT2M0WDVjNHBvYk1lNGtnay9kQzlLQUpJMG1rbXd4M2NjNUhvS056bG44NGhBQm5IQXorVlNHOWlHeFZESjh4eVQzd0tQTWlsa0VjaWhpeDNCZ2NZRkFESkVFOXNDaEl3TU11YXB5SXFydGlKWWREVnFJQlhtQUlUUFRqclRMZmlSaVZYQk9lZWFBSWtWVTNGL2xBQXdCOWFZdzJ3QlFBQS9VMU5jcURPV2l3eXR3VDZjOTZQTFZveEh1K1pmNTBBVnNCWDJ5TTdvUWR1RDNwMFpBazJ4RExObkozWUlxUUk2b0pEemhzYmNkZmVvNVZQRGh0bTA1TzN2VEVSSTBrWnlPblJ3UlR2Sy9mQmw1M0RuQTZWTXFicEdJK1JaQnUrOXV6NzgwK0NPS0pUbDhnNUF6Mit0SUNsS215UGRrZFFXSUdDS2tVeFQvTUdjbGNZN0FqdlV6YlpHdzN6Zkx4Z2Z6cGlSNzhiVkM0NkVkNllEcEl2SmlVdXlrRVlCQjYvd0QxNkF2bXFDQS95OWczSDFxeXNVVXNUSXlzQ1Q5NDlCVmFPQ1JNZ1BzWEpJSFVta01mSmJNaXN5dHczSkJPU3Z1S2dSeklOakV1ZlFWS2dWSmNPZDZad01BNUZMTGJoWC9kSDVSd3B6ZzlPOUFpdDluRWNtWEhQWEI0eFYzQVZoNVpISzhMMk5SaDF3QUlubjZkRGo4T2FhVVluYXdLZDBKWE8wK25GQXkzRkx1R3doUVQxNzA2ZFdYRGhTakRzT21LWkJIZ2dPZ1NROU1uZy9qVXN4TFNLV1Z0b0cwc0RuSDFGSW9iNW9iSVpkclk1R090UGpWV0FBUEI5QjBOTkcxU0ZZNHgweU8xVG1QYUN3UDVDa01SVzhtUlF4QlhyeUtlSkE2NVVjOXo2VkdvTE5qY0dYSFhPY2UxU1JqREhBR01jRnVNMGdKZGptUEFZdDNCcFJ6Z0U0UHFLRVpkdVJsU1BROUtZV0RTRVBrTjZVQVNCTmtqTjE5c1UzSHpFODdQU21tY3h0aGxCOS9TcGNMSkh2NVhqcG1tQkc2N2dDckgwRkJCR0JTN0dWZUJrZXVlYWF4WWNBbGozNHhRQnY2TjRpbnRYRUY3bVNIczNkYTYyQzVpdUloSkM0ZFQ2R3ZObGtCVUU4VmFzYjJleHVBOERrRDlEN1Z0Q3Exb3pDZEpQVkhvZWFNMWxhWnJrTit1eC8zVXcvZ0o2L1N0TGNLN0l0U1YwY3pUVzQvTkdhWm1qTk1RN05HYVp1bzNVQVU4VVlxSnJ1TlR5cmovQUlEUWJ1SWZlM0QvQUlDYXg1NDl6VGxaTGlreFVYMjJEKy9qOEtQdDF2OEE4OUJSelI3aTVXUzRveFVZdTRXQklrRktibUgvQUo2TCtkUG1pTGxZN0ZHS1BOai9BTDQvT2s4MVA3Ni9uVHVnc3hhTVVubUovZUg1MG9rUS93QVFvdUZtRkpTN2dlNG95RDNGTzRoS0tkU2ZsVEFiUlR1S01mV2dWaEtTblVocDNFSlNHbG94UmRBSlNacGFLWVdFelNFMHRJYVlnelNVdUtTZ0F6Um1pajhLQUROR2FNVVlvdUFab3pSaWt3YUJXRnpSdXBNVWJhQXNMdXBOMUppa3A2QU8zVWJ2ZW0wWU5GMElmdnBONXB1RFJUR084dzBlWWFiU0hpZ1Evd0EwMGVhYWp6Um1tQko1cG9FcHFQTkdhQkV2bTBDV29zMHVhQmt2bTB2bVZEUlFCTjVsTzMxQlJRQlB1cGMxQ0NhVUUwQVRBbXMzVzlZWFNiSHpXUHpPY0o5YXVoalVkeGJ3M2FoYm1KWlZCeUE0emlwa20xb05OWDFQTWI3WG51NTJrbWN5UDJKSFNxaDFDSlI2RTlTYTlaUzB0VSs1YnhyOUVGSzluYVNqRWx0RXc5MEZjMzFkdlc1MGUyU1BJdjdSdHdCdWM4YzVvVFdyZFhPUG0rdGQzNHgwdXhqOE5UdGIyY01iN2wrWkVBUFd1ZStIT25XbDFkWHd1N2VPWUtGd0hYT0t3Y0h6OGh0R2E1ZWN5RHE5dW5RTm50azB3NjFIa2NFYzV5RFhyRGFCbzhpNGJUclkvd0RiTVZFZkNtaE9lZE5nL0JjVnA5WGwzSjl2SHNlWExyMFNxUXlGdnFhai93Q0VoVldPQTJENzE2aTNnclFIYkxhZEdQcG1vSmZoOTRmbC93Q1hWay8zWE5IMWVZZTNnZWNIeEl1L29jZHhTRHhFbU1NNTYxM3IvREhRM3pzTTZmU1RQOUtwUy9DalRRR2IrMEowVWVvSEg0MUxvU1ExV2l6bEJyMXZLbUJrbnZ4U1ByRVQ4RXNCN0NzdnhCcDhlaWF0SmEya3JTSW1NT3k0TGNWV3RYa2x1RlhPUWUySzU1Tm8zVVV6YWgxOUVsK1RKR01IQXFXYldvU1BrUitmdkRIV3VjbTNRWEpLSEdhVDdSTU9Rd3BjejZENVVkR21xeEVBUHY4QXlvZlZveU1LWDIrNHJuUHRVM3FLUHRVdWVvTk83RGxSMGlhdkg1YkRjeUU5OGRhQnFpYmd6U2tBSHNPdGMzOXJsOXFYN1hMdEp5TUFVWGtIS2pxUDdVdHY3K2Njakl6aW9ZdFFqRW00dGh2NFg2RVZ6aHZKQjZmbFFMMlUrbjVVY3pEbFIxSDlwUWNtYWNsajFDanJRdXNXeTRVc1F1ZUNSMjlLNWo3VktQU3BiZVJybnpCSUJnRGloeWFWdzVFYi93RGFzYk5nTW9DOVBVaXBCckVaVGxsd01jTlhKZWEwRWh4U204WTAwMkp4UjE0MWVCVGxtSDRIbW9ocWx1SFpoSU53UEhQYXVVRnc3SHRUMFh6bDNQMUJ4UmNYS2RVMnB3S3E3WkZ3eDVwWDFHTCtHZFZHSzVRRi9NWlZ4Z2RLazhxZGh4dE5PN0ZZNk43MUdiSmRUMkl6ajhhaiszTHN5OGlFNXdjSEJybkM4aXRnN2M5T2xTaUdjOGxWTkxtWlhLYjV2SUZpYjk5dTNjYytsTS90Q0VGY1BqdjE2MWkrVmNEK0JhTms0LzVaaWptWWNwdGkvaDh6Y1pNOCt2U25EVW9sbVhhUnQ1ckIyekQvQUpaTFNmT3JLSGpVQW1sek1YS2JyM1VaWXVKQVNPbVc3ZWxRblVRV0h6akM4NDNkYXk1WU5xNUlHY2RxcXhzZW5sNU9ldE9NNzdBNFdPZ1MvUitUdFBPVHoxNW9sdkVMYmhJdVI2R3NFeUZUalpUVE1mN242VTdzVmpvbnYxbGl4dkE1T01tbUc4d0ZVdUNNZEFhNS93QTAvd0RQUDlLY1pYSEJUOUtkMkkza3ZrVERCeGdEb2Y2VllGL2J1dVE2dGs4akhKcmxXdU52RERGQXVOMzNWeno2VWdzZGtsNUdNTnRRNDZsdlNucmNXNVl1T1FSMk9CLzlldU5OeEpqa0hCcVRNbTBZYzQ5S0xoWTdBM0xFSHl6bENldWFpYWJvU3hRcnprZHE1ZnpKTnVON2ZuU0ZuSXdYWWo2MFhRN0hUSmR4bVQ1eVdiSHJVaXpxNXp2K1hvUVQzcmxNdDZuODZmR1pHeUE3ZXZXazVJTE02WjVVaGI5MDRVSDcyTzVxekRlUXd4dVdrVW51U2UzK05jbEVIWW5May9qVWhqYkdEa2lwNTBQbFowaDFTemwrUjU4Z25qSnEzYlBFcjdSS0hYcVJrZk5YSEdIMEZKdGtUb3gvQTBjeUhZN2VZUlRoWkZmb2NFQTlLWXN5eFNHTnl6cjI1cmtGdmJ0RklXUTR4VERxVjZoR0dKeDBPYWQwRmpza2NLNUFPM3VENjFaZHQyZktBR3cvTURYRERVcnhnTnh4anBWeTIxNjRoLzFxYmw3NDR6VDBEVTZjVGtzV1BKOUFhbnpsU1QwUE5jNUhyOXRJU1NXalBiMy9BQ3E1RnJGdThZL2VnTXZUSjYwZ05kdHNrZVNCZ2owcUpBWXh4MDdWU2p2VUxIYkprbnNXNEZXMGt6R1EyMzI1b0FzQWpoMVBJNEl6U3VkeVlZWVByVmRDRXdWSWYxWDFxVkpVOWUyQjdVQVJTUk1wSTNuYU9jNXFXS1U4SE9TYUJoY2pjY04xeDBxTjEybkk1SHFPOU1DMUZKODJVYkQ1NDV3YTZEUy9FREJsaHZPUjBFaHJtTm9lTTdUeU9sUGlrMk1GWVo0NDcxVVpPTHVpWlJVa2VqQmd5Z3FjZzlDS1hOY2pwMnRTMmtnU1g1b3VtMDlSWFV3WEVWekVKSVgzS1IycnRoVVV6amxCeFpMbWlpa3JRazF6QkNlcUQ4cWFiYUJ1c1kvS2w4eWp6SzhDN1BRR0d4dGlPWWwvS2svczYwLzU0citWU2ViUytaVDVtSWkvczYwLzU1TCtWTS9zbXlKSjhwZWZhckhtMHZtVWMwaGxVNlJabi9sbXY1VTMreHJMSEVRcTRKUHBTK1o3ZnJSelM3Z1VQN0NzdWZrNis5Ti80Uit5N0tmenJSM2owbzMrMzYwK2VYY0xJenYrRWZ0ZTI0ZjhDcG84UDI0NkYvOEF2cXRQZVBUOWFOM3RUOXBMdUt5N0dYL3dqMFBYZkovMzFTRHcrZ1U0bGt6L0FMMWEyOGVsRzhlbEh0SmR4MlhZeXpvUTdTeUFmV21Qb0xZK1M1Y0gzeFd0NWdwZk1IdlQ5clB1TGxqMk1iK3c1dHYvQUI4Tm42VXc2SmRaNHVSK0sxdUNUNjBvayt0UDI5VHVISkhzWVM2TGRmeFRyLzN6VEcwZTlIM1prK2hXdWc4ejNvODBldFA2eFU3ayt6Zytoem45bGFsMjh2OEFXbW5UZFNBSHl4azkrYTZYelI2L3BTK1l2K1JUK3MxTzRleWgyT1pOaHFBLzVaSWYrQlUzN0hmanJiRC9BTDZycVBOWC9Jbzh4UFVmbFZMRlZFTDJVRGsyZ3ZoMHRELzMxVGZLdnNITm0zNEd1djNyN1ViMDlCVCt0ekY3R0p4K0x6SE5sSUthV3VSMXM1dnlyc2NvZXdwZjNmOEFkRlA2M01QWXhPS054TXZXem4vNzVvRjJlOXROL3dCOEd1MDJ4K2dvMlIvM1JUK3VTN0I3R0p4UDI5UjFobUgvQUFBMGYyaEYzV1FmOEFOZHNZb2oxVVUzeUlEMVJmeXAvWEgyRjdDSnhnMUNEdVdIL0FUU2krZ1A4Ui83NXJzVGFXeDZ4ci8zelRUcDlvZXNTZjhBZklwL1hIMkQyRVRrZnR0di93QTlQMG8rMTI1SEVxMTFoMHF5UFdGUCsrUlREb3RnZXR2SC93QjgwL3JqN0UvVjRuTGZhWUQwbFQ4NlVYRUo2U3AvMzFYU25RTk9iL2wyVC92bW1ONGEwMXV0dWdxdnJpN0Mrcm5QZVpIL0FNOUYvd0MrcWNHUTlIWDg2Mno0VjAwLzhzUitacHA4SmFjZWlFZlI2ZjF5SWZWekg0UFFqODZNZTlhMy9DSldIYnpQKytxWWZDRnAvQzhvL3dDQjAvcmtCZlZ6S0lvTmFmOEF3aU1JNlR6Zjk5MDArRVY3WFV3LzRGVCt0MHhmVjJadk5IMXJSLzRSSng5MjltL09tbndwY0Q3dDlJUHFLcjYzVEY3Q1JRb3pWdytGNzBIaS9iOFZwdjhBd2pPb2pwZXFmcWxQNjFURjdDUlZwUlZqL2hITlVIUzZqUDhBd0dtLzJCcTRQRThKL0NxK3MwKzRld21SVW9wMzlpNjB2Um9XcHAwdlcxUCtyaWI4YVByRlB1SHNKaWluQVZHYkRXMUovd0JHalA4QXdJVWZadGFIL0xrcC93Q0JDbXE4SDFGN0dSTUZveFVQbDZ1T3VuRS9RMDBIVXg5N1RYL0NxOXREdUwyVWl5QlFTcWpMSEE5YXJDYStVL1BwMG8rbEpOYzNDUXVYc1pnQXBPY2RLUGJRdG93VktWekw4UVh0dGVhUEpEQys1aXc0RllmZ0x5clcrdnZNWUx1QXhudnpXYnAyb2VkY1NXa2d5d1ZuUmgyR2VsTXRjcGV6YlNWNHJ6L2JOMWVZN1BaSlE1VDFBWEVCKzdNbjUwOVpZejBrVS9qWGxHb2F4SlpNSWJjR1NZak9DMkFCNjAvUmZFTTE5dlIyZU9aT29EWkJGZGYxanlNUHE1NnVKSSt6citkT0RMNml2UERjVG4vbHExT1c2dWNqOThhUHJIa0wySG1lZ3ZJa1VaZDJBVURyV0RlM3pYc215UEt3ZzlQV3VZbnZycFd4NWg1UGNkYW5zbWtsdVZCZHV2UE5aMUt6a3JJdW5TVVhkbkcrTnNmOEpGTUFNWUsveUZTZUhZSTNzWnkwTzZUZjhyNCs2TWV0UWVNam54SFBuKzhQNUN0andpak5vOXhqb1pQNlZ6UDRUcE15T3hqYStsRXNlOEtoUFRwNzFqT2k3MndPTThWMlNLMGN0NFU0QmhJTmNjL1UvV25UczRFTnZtSGFmRkhQZnhKS1BrTGMxcmFqcDFuQmJiNFYrYmNCMXpXZG9rMGNHcVJ2TmdvdVNjak9hMXRUdWx1cmNPc1N4amZnYlFCa1ZTRk42bUxKRW9ZNFVWWGxYQ2tWY2srOGFyVEQ1ZnhwejZEcDYzSWhHRGJsajF6MXFhemdTWE82a1VmNkwrTldOUEhEZlVVMmtLNzFDNHRZNDBZcU9sUzZKYitiOW9Qb29wOTZNUk5Wbnd3bS93QzFEL1pGWTFQaE5JTnN6bnRVTjA0ZGMwTlpRREh5L3JXaGRSN2I1dnBVVWk5SzBockZHY203bWRjUVJ4WThzWXBiZUxFTzdzV3FTN0hJcDl1dUxWUGZOUk0wanNWVUdKbit0WDBIeUNxYUQ5OC8rOVY1QjhvcStoUDJqTWxINzQvV3ROUndLem5INzgvV3RRRGdWQ05HSTNha3FSaHpUY1ZRaHBGUXpybGtxeGovQURpb3BoKzlqcVpiQXR5eE5BUHNxazlTdkZaY0MvTmozcnBYZy8wV00vN05ZQ0xpWmg3bW9vQ3E2b2lLNVluM3BObFQ3UDhBT0tObitjVjFYTWJFSGw4MDZSY3ZVdXlrWmZtUCtGRngyTXU5UTcxK2xQc296c2I2MDY5WDk0UHBVdG1vOHR2clN2cUZ0QjBxNHR4OWFUc0tsdUIrNUZSOWhVUzFHdEFvb29xQmdhbnMxeXprYzRYcCtOVjYwOUdqM3ZMeC9DS21XaUd0eDF2YWo1dHRTL1pqV3RaMnBhTmlSM3FiN0o3VmttYUdFYlkwdzJ0ZEFiVDJwcHN2YW5jRG5qYSsxUnZCZ0hpdWlheTY4ZnBWYVN6eG5paTZBd2hEeDBwREJXdXRwOG9vTnA3VTdnWXYyWlJ6dDUrbElZcTJHdEQ2VkdiUStsTzRqSTh0MWNGV1lacVpiaTRROFRQK2RYV3REdUhGSWJYMnA4ekN5SW90VHZJanhKbjZpcGwxMjVRazdWSk5NTnI3VXcyM3RUNW1LeUwwZmlTUVlFa1gxeFZ5RHhKYnRKdGtRcUQzeFdDYmY1dWxKNUhZMCtZTEhUcnFscUd5SjEybnRUSDFTMTNFaVpjOXVhNXd3R3Rud3BiV2Y5c2J0UmdXYUlJZmxjWkdmcFZSZDlDWG9YdjdkdHl1WkpBU08rZXRYZE44V1EyMHc4cVlBNTVCUEJGWDcySFFaV3dOT2h3T2hWY2Z5clBrMDdRR3ppdzJuL1pZNC9uV3ZMWjdrTjNXeDZEWTZoRmYyYTNFSnlyZGNIb2FuRXlIbzJmeHJpOU52NGRLdGZzMW91eFR6MXp6UU5ZYnptWXNjWjZBMTBLcG9ZK3pQU2QwZisxU2hvL1ZxbCt4ci9lUDVVZlpJK3puOHE4YTUxV0l3WXovQUJIOHFNUi8zeitWUEZzbnEzNVVmWm96enVZZmhSY0xETnNmL1BUOUtOcWYzeFVnczBJKyszNVVvdEVQUjJvdWdJc0wyY1VtUDlyOUtuK3dKL3oxSS9DbCt3QTlKUDBvdWdLK0QvZUg1MHVEL2VINTFOL1o0N1NmcFIvWjQvNTdEOHFMb0NFSVQvRVB6cHdqYisrdjUxTC9BR2NmK2V3L0trL3Mwbi9sc1B5b3VnSXRqZjMxL09sQ04yWWZuVW45bnYya0IvNENhRHBzdVB2TCtvbzBBajJ2L2VINTBZY2Z4TFQvQU96WnV4WDg2UDdPbjlGUDQwYURHZk42citkTDgzK3orZEw5Z3VPd0g1MG4yRzUvdVVhQUo4Myt6K2RCM0E5dnpwZnNOeG5sRFNmWXJnSG1OalFBdTF6MHhTYkg3WXBmczBvLzVadlNHQ1VkRWY4QUtnQTJONjAwcTFQOHVUMGI4cWJ0WWYzcy9RMEFKaHFNTi9rMHVKRDJORzF4UUFtRzlQMXBjUDZHakRHa0lZZWxJQmNONkdqRGVob0FQdCtkTHlQL0FOZEFDZk43MFpidG1sM1k2NS9PbEVtT2hJb0FUNSsxT0FsOURTck45YWQ1eHoxL1NrTWJ0bTlHbzJ6ZWpWSUovVmhUaFBuK0lVWEFoL2ZEc2FBMHc3TitWVGladlVmblRoSXg3ajg2QXNWOTh2b2Z5bzh5VDBQNVZiOHh2VktYekQ2citkRndzVS9Oay95S0JNM2YrVlhOL3J0L09uQWc5bC9NVVhHVXZQUGMwZWQvdFZjeG4rRUg4cVFvdmRCK1ZGd0tubi83Vkw1MysxVnJ5WXovQUFEOHFUeUl2N2dvdUJXODQ5bUZIbnQvZXF4NUVYWUNtbTNqSFlEOGFMZ1JlZTNyUjU3VklJWXZYOWFYeUl2WC93QWVvdUJIOW9OQW5QcCtsU2lDUHM1L01VN3lGN1AvQUNvNWdzUWk0OXYwcGZ0QS91MUw1QS92Zm9LUHM2K3Y2Q2k0V0kvUFgrN1MrZXAvZ0ZTL1prOVIrVkgyZEtMZ1JpYVAvbm5WWFZaUi9aRjM1Y1JaL0pZS0Y2NXhWSysxRnJIeEhhMlpDTkJNaExZNFpTT2g5eFUybzYxcDJsMjZ5M3pOSEd3KzlqT09jZHFlb2FvOHhpME9Dd3NSY0dQRnl5NGRqMXdlb3JKanR6dm5sQkFXTWZNU2ExNVptbHY1MlYyYU50ektDZU9UMXJqZkVsM0piV2MwU093RXhBWVZ0VFQ1aFNlaERjWEZ2YzZ4T2lIemN4Z2xsNXhqdFdkcFY5SFo2MkhrK1dKdmxKck1zTHRyTzU4MVJuZ2dpbE55SlF3a0hKT2VuU3Vua2FkeUhVVGlrZWxxUXlqQnprWkZQQStYM3JudERodTcvU281WTdpVDVQazRQcFRMK0hWN1c0Mnd5U3NwR2M0SnJQbVY3RDZIUXlBbGt5SzB0SmlMUEkyT1J3SzVPTTZvc1hNcEpDNXd3ejJwbGhydXRKS3NTN1ZCUEoyVStaV0N4UThXOCtKSi9aNjZMd2lqRFFtZGY0cFRuM3JrOWNsa3VOVGFTYm1Samx2clhWZUQ1SlA3TzhvLzZzc3gvR29rL2RMTE1rWldPOFBmeVRYRFNMaGNtdXoxUzZOczBxam56VUlQdFhKWEl3aWU5T20vZHNROVprZWwyc3QzZnJGQU12eWExNzJ6bGdzazNyZ0srMC9Xb1BDYkZOYVZseHdqZGE2YnhFaXJwZHJ0QVhkS1NRUHBUY210RUtTMU9Pa1E3alZhZjd1SzBaQjErdFoxeDMrdFhKM0hUVzQ1SThXUU5XTk9YS25IclRGSCtnRDZWYTBzWWpiNmluZlFqcUdvSVJDMVhmQ1F5MTMvQUxnL25VR3Evd0RIc2ZyVm53aW9QMnZQOTFmNW1zYWo5MDFoc04xQmNYN2ZTcXI5QlducU1ZTjJhcU5HUGxyU20vZFJsSmFtWGRqTFZOQW1MUlBwbW0zaTRrQUhvYXN3cC9vMFgrN1VUZDJhcGU2WnFEOTgzKzlWOUI4b3FwR21abStwclJXUDVSeFY4MWtKUjFNbGhtYy83MWFnVTRGWndHYm5HUDRxMXdnNHJQbU5iRVRJYzBDT3AyR0c0Qm94UzVtSEtpRVIxRk92K2tSQVZheDZtb0poL3BrWTlxVGJzRmtqb1REdXMxeC9ESGsxelVObk5OTVNpOE51SysrSzdXM3RSTmJORzJmbWpDOGU5VjdiU0k0VmlDeXRzaURxQVJ5YzFOT2ZLUTFjNUVRU0hHMUdPNzd2SFdoYldXU0l5SWhaVk9EZ1p4WFZ4NlNpUXhzck8zbDdsR2ZjSG1ybHRaUjIxbkpHRkh5cnlRTVo0NzFmdGtMa09EeFNNT2E2OTlBaFZybnk0MVlzbUkxSTRRL1dzNjAwTjBuaGx1QXJvWkNySVIvbk5hS3JHeExnemtyd1ptL0NwTFRBakl6em5wWFQzT2gzRStrekxCYmdGcDl5OERJU3FrZWhpMzBtNUlpTTF5c214R1VIUGJ0U1ZWWEh5dXhrWFA4QXFnS2o3ZmhXbU5MU1hSWXJrN3hJOG9pNTZlOU5sMFM1Q3UwWTNnU2JCd2NuM3g2VTNOWEk1V1p0RmRBdmhvbU9GSkN3a01wV1IwT1FCaW9tOE51aXhGNVdYelp6Q0FVNXg2MHVhSWNyTU90cnc3R1M4ekVZWEFHY2NacXRKb3R4L2FjbG5BTjVHU3JOOHVRSzM5Q2gyZUgxSkh6RzVJUDRBMU01SzJnSk81cldFQktzVGpCcXlZQjZWTHBjZTZFL1FWYk1WYzdacWpPOGdlbElZQldoNVZOTVZLNHpQOGdjOFZYbHR4ZzhWckNMbW81SXNnOGRxRXdNZGJVYmVsTDlsQjdWcExEVHZJcXJoWXlqYUQwcGhzL2F0anlQYWs4aWk0V01OclBMRGlrTmtQU3Rwb1BtWGlqeUtmTUZqRU5sN1ZFMWo3VnYvWjZhYmYybzVoV09lT241ZnBXU3creFhqcGVxeEI1UURzSzdScmJFbWNWeS9pZVBicWdBR1AzWXJXbTdzaVdpSzR1ckZ1b2ZyMHJYczRVZ1BtSUN1Vjcxek51bWJpUC9BSGgvT3V3MVJEQkRHVkgxcTVhTkltT3BCSmRBL1dxMzJ4VmJCejYxVGxaeXg3Q29KV2xpWUdWU0Flalk2MW9ETmdYWlpoODJLa2ltK1kveFo1NTdWbVJodkwzRUJRZVZ6Vm1GcEdJOHM0TENnRDZJTjVEL0FIU1B3cFB0MERmS29PZnBWUXd1VDh6OGVnRk9FQ2QrZmV2UExMUzNjT2NFNHFVWEZ1ZjRoK05VVGJ4SHRTRzFqUGNpbUJvZWJDUi9yRUgxcHZtUWY4OVk2b0N4akRaM3RTbXlqL3ZHa0JmRHhuamV2NTBiMHh4SW41MVEreW9PckUvalFiZUplaC9XalFaZmFTTUQvV1IvblRQTVQrOUgrRlZERkZubitkTDVjV2VnbzBBdGVZSDVEeC9qUzhmMzB6OWFxaUtFcjkybDJXNEgzVm8wQW53VC9HQitOQkgvQUUxSDUxQnRoSFJRS05rWEh5cUtOQUpoR1dPZk14L3dLbE1iZjg5Ui93QjlWQnRqRkp0ajdIRklDY0kzL1BVZjk5VXUxaC95MkEvR3FwMmdnRE5CUUZoeWFBTGluL2J6K05MdVVmeC9yVlBZTWRhYnRIY21nQzl2WCsrUHpvTW4rMSt0VVFnNXdUUytYL3ROUUJlQituNTB1OU8rMzg2b0JCNnQrVkhsRDNwZ2FCZGZRVTFtUTlVRlVkbnMxSnM5QWFReTltUCs0S1lWaVBZVlcyTmp2U1liME5BRm9KYmdjcG1qeTdZL3dmclZUQnp5RFM0WUhnR2dDMTVkdi9kUDUwbmtXNTZxYXEvUDJCby9lVVhBdGZacmM5TjFMOWtnUDk2cW1KRDJKL0dqOTU3L0FKMEFXVFl3bnUxSDJGT3hOVng1bzl2eG8zUys5QUVwc2x6OTdGSDJJOW5xTGRKM0pvOHlUc3hvQWsreE4xeVRSOWphby9PbEg4Ui9LbCswUy8zMm9BZjlqYjBwUHNyL0FOMm0vYUovNzVwZnRNdy9qcEFMOWxkZjRUU0czZjBJL0dnWEUvOEFlcFRjVG52K2xBdzhseC9lL09rTWNnNkJxZWtzL3VhZUpMZzlzMHdJTmtuKzBLTmo5OTFXYzNQOXlqYmRmM2FMTUN0NWJlOUtGYXJBanVjY3ArbEhsemQwTkZtQlgydFR0cmVncWJ5cHY3cHBmSW1QVkdvc0JCaC83b3BkcitsU0dDUWRNajYwdUhYclJZQm1IL3Uwb0QrbFNqSTRhbDh5SmZ2NEg0MFdHY0w0cTBTUzkxcU84a3Vab1kwd2lOR3dHeHNFL2thNWpXaGV5TmFvOTNOY0lBcXlCa0J3VDB4NjhWMyt1NmxacHVnZVhHOXpraGM0QWpQSDY5YTRueEJlV1UwZWx4aTdaVWoyRi9MejgzLzF4d0syaVp0TXc5UGltVHpHbWxhVGNDRStYakFQcjYxeC9pMVhFaUhQeTU1cjBPNHZJSm9FanQzMzdWSis2Y3JsanhrOXY4YXlCUFlpT2FDOWlSOTJSODZaSEtrRDlhdUQ1WlhKbHNlWjJ0dTkxZEpESDk1emlydDdaVytueHpSVDVlYzQ4cGdlbE1saVMyMVNVMjVZeG81OHM1d2ZhcVVvbGtrTFNFc3hQVTEyYXYwTS9kVWZNNmZ3NXFGellhWHRWSEVieVpVOWpuLzlWYXk2M2NUeDc0OXpBSG5rY2M5SzVqU3BWRm0wVXpFeUxLcGlCend1RzNlM1hGYUVKZ20wbVJaWnZLZFF1QUZ5VHo2MWhLR3VwcEdic2FaMUM0ODl0bnpxcllaMDVBNHpTdHFkejh3OHZJVUVrZ0FqQXEzcE1OcE5kWW12b3JkRDV4K1hwSVF2SHBqTlVaNVBzK3FHSzJ1Rks1UFRBM0QwQnFPVkZjeGc2cSsrK0RrWUxBRWdqR0s2cndmTUhzMmhJd1Z5MWN2ckxidFZjbnFlVFhSZUUzWVdzd1A4SzhjVXBMM0NpZlZKWTFTY1NBRjJUNWM5cTVXNWI5MnZQYXQ3V0UzTTc1NkovV3VkdXY0UWZTcWhzVDlvdGVINWxnMUF1ZjdocmYxVzhOMWIyNmM0VmlmMHJuZEhqTDNmSFphMjlReUdnM0hQeTUvU2g3a3kzTXVYdjlhelordjRtdENWdURuMXFsZFJnUUxJRDFjcmo4QlZNcUd6Si84QWx4WDZWYzB0TXhINmlxZy80OFZIdFYvVGh0aS9HcWV4QW1yY1d4K3RYZkJZM1BkLzdnL25WSFdEL28rZTI0Vm8rQ1Z5THcvN0svMXJLZndta2RpWFVrMjNYMXFuajVoVi9Vemk4QWIwcW5rYmg5S2NQaFJEM01tOUdKVDZnVmNqVEZ2SG5zdFV0UU9Kc2VvclVDL3VGNHg4b3FKYm1xK0V5YmZtVnY4QWVOYVFIN3Y4S29XeWd5TWZjMXBsZjNYNFUzc09LTWVNWnVoL3ZWc0FWbFFKbTZYSDk2dGtMMHFUUVlSODFOSXFSdUdQK05OSkhwUUF6RlF5ak9vUmoycXh0SjZWRVZ6cWFaNjdhWFFsN0hiV1dCd2VwVVkvQ2tRZjZNU2V1U2YxcDBLbmFTdlhieCtWTXR2OVN3YjJySkVJZENBWTJRZE01cFFtWWJqUFZnQUtTTS9LV0hBNC9wVXNlUGxVL3dBUXlhRllZa3piV1lnWis3L09tWENndW5HZjRzVWtoTHlIUDk1ZnlwWHdzNmpPY0wvV2pxQWtlRHZqeHd2SDhxYmNnSkdwQzR3eGI2NEZTRDVQTkk2N3FiUDgwQUovdUdrQmwza1BsMmxtdXdZZVl0akZhY2ErVzZvUjIvcFVGNEF3c1FlemsxY2lYZmNxeDZGU2Y1VStnMFFKR0ZBNHppVnY1MUpMYXBOOWtkaHdraFlmV25yRVJJNEo0WEwwczNTMFJUMllta0pzcW16akYzTkl5Ym1DNEI5alQ3UFNMY3d4VzBHNktNT3pldkpGV0N2QmIxQS9wVStuL3dESHloUFFPNC9TaTdFOWlXMXN4Yk5MR0RuQkhKSFdubE9hbmorZWFZZ1lYSXh6MTRwV1NrQlZLVTBwVmtwU0ZhQmxZSnpVYng4R3JPM21rWk9EeFFCVEVkUEVkVEtsUENVQVYvTG84dXJPeWxFZE1DazhmN3dmU2p5NnN1bjd3ZlNqWlFCVjh2Tkw1VldmTEZLSTZCRk5vZm02VnlQaXlJSFdCbi9ubXRkMDBmUFN1SjhZWkd1Y2Y4OGxyZWp1UlBZdzdhTC9BRXFMaitNVjIrcjJwbGpSVlRjY2RCWEdXT1RxRUs5Zm5IODY5SnVVQ3NyRTlCMDlhdXE3TkNwcTdPSnU3Q1dDTldWR3dlRzl4VWs5bEZMcHdqVjl6a0FxYzV4N1YwVTRMb1prWE94L2xQZjhLeVk3YVdHVWVZRGxteno2NXBSbmMwbEd4VnRyTVRXVWFSTnVsUEJCL2hOYmR2b0VGdWtaZWRZM1lZeXg2MURwdGc0aUVnajJzVGs4MU5mRmhOYStad2QvU2s1WGVnMUd5dWVydElwNzBDVlFPcHFRcU9PMzRVdmxpdWNnaTgwZjdWSG5jY1pOVGVYeFNlV2M5c1VBUStheFBRMG05ejlhc2VYN1VlVmtVQVFmdlBVVWgzOGZkcXdJajJ4U0NNZHhTQWlCZnVWNTlxTU4vZXhVb2d5UmluaUgxNXBnVndwSEc0bWwyVlA1SW84ckhhalVDREZPVmNkY0dwUkQvczBwaVBkVFN1QkYzNlU3T093cFN2b0tRTDZpZ1kwdWZRVUNROXdLVWdBOUtDT2FWd0U4M1BTamVUNlUzR1c2YzBFNDdVWEFkdkk3VW9rOVJUQVNldlQycHdVSHNUVEFVekQxeCtGTDU2NC9pcG9UUFFDblk5Rm9BUVM3bTc0cFFUbmc0RkczMnAyd1lvQUFNOVdwZmxIYy9qUnRBNlVvQW9BQTNQYW5iK2NIRko4by93RHJVcEtaNkUwRERJOXFRODA0S25yK2xPMnFlOUFFUnlGcHVXUFNwdko0UE5BaEE3MFdZRUpKQndhVUdwVmhIZHFVd2pQQkJvc0JDV3dLWnVKNkQ4eFZvUTRwUXY4QXMwV0FxN1dQYmlqeVQySXErT2Y0QlFFQjZLS2RnS0loT09hREdEMnE2VmIwcHBqWUxuYm42VVdBcUJQclR2TFBZbXJRaWJjTWdmU3JDd3g0eXcvS2l3RkFLUU9EVGxMQTg4MWRNRUpiZzBwdG95UnRseHp5S0xES3l5RTlhY0pzZmVxU1N6VlJuN1NSazhjVkViTE80RzlHZmNVWFpYSzJQODVkcC94cEZtVXNCbkErdFJHMFpSOHNzYkQxTk5keEI5NW84NDdOUnpXM0RrWmNYay9mcDIwbm56RCtWWngxQ0pjWk9CNmhxRjFPM0p3Wm1YbkdjWm81MEhKSTA5ckFjT1B4RlY1cmhrNDJDUURwdFhwVFlicUtmaUc2QlB2VTRtbGpiSG1nL2pSSm9hME15VFZHNUgyUmlPL3ltczZiVXJkbXhKWXVmb0RYVUM1WWtGMFVnZDhkcWEwMFJQTWFFSDFBcGVoU3NjZktkTXVaUG50V0JQVUFWQTNoN1JiNGdjd01PaDJZSXJyN20yMDY1d1hpK2NkQ0NBQlZLVFRiZGZtUjFIdVRTYmt0aWtvdmM0SHhQb2RsbzFuQTFuTjVoY2xja2RoelNlRVBEdHJyR25YTWx3VkRlYUFOeVp4ajNxWHhyY1F5R0dHS1JYS2xzaGVuUVZ6MmorSXA5TnQ1N2VKc2htM1k5RFdzT2FTTVh5cVI1ejRzczF0UEZHb3dROHBIY09xbFJ4MXJIMk1GeXdQNVZvK0labW0xdTdsYmd2SVdQNDFubHlFSFA2MTZjZmhPSjdub2Z3cDBDSFV2dDkzZFFlY3NaV05RUm5HY2sxNklmQStsTXNpcFloVmt4bmowcml2aHA0amkwcncrMXJLT1paeStkdWUySzlOc05jc2IySTdMdHczZEdKcnpLL3RPZTZPK2x5cUtPZms4QzZTWVVoYXp5Rk9meHFwcVhndlRJN0IzanRXRDI2TXlrRG9Selhiay9QOEFMY2NZNEd6TlU5WWJab2Q0V2tERVF0MWlIUEZZcHp2cVZMa3RzZk9tcXQveE5IR08zZjZWMmVocFpKb0VVbHZJR25LZnZWSDhKcmlkUVlIVXBNcjAvd0FCWFo2VG81MGZSVXZONGwrMW9IQ0FmZDlxNjM4SmlSYWt0ci9aYzBra29GeGxRa2VlU1BXdVd2MVJDb0hQeTU2MXRhL290MWNRSFZGWlZoejVlM1BJUCtUWE95UXlSQXJNeHpqaXFqc0szdkdqNGRhMFc5SnVuOHRRbkJQUE5hMnJYRnBjeXhmWkRuYUR1SUZjeGJXZHpkTVJhWllxT2NacVZyTFVZRytjTitkVmJVbHJVdFNvdTNyK2xaOXh5b1VQeHlhZXd2QmdNSHg3MURLamNaQjZVK3BVSTZNdk1vVzFRQnVvclFzVVAyY0VjL05XRzAwaFZVWWNMd0tzMitweXdSaFFnSXpUYkk1V1g5WlFpM1VlOWFmZ2xTRnZPT3lmMXJuYjNVbnZZZ2pJRngzcm9mQldSSGRudGxSV2MvaE5FbWtXdFRqemVnKzFVSkVJZGVCMHFmWHRTU3gxQUs2RnR5NTRyTC90NkhBK1J4eFRoOEtNM0YzS1Y4Q0xvYnZTdHRobU1IL1pyRG51aGMzU3ZIbmJ3TUVWME1nR3dqdHRxSjdtblF3clVIZWNlcHJUSVBsOVA0YXEyT0N1Y0wxTmFraXFJVHdQdWVsRExpakV0aG02WDYxcnJHU1Ixck5zdHB2RXl2ZXQxRlhjTUh2VWxsWXhmTWVhY0kxN25OVGtEUFByVGNMNkEwZ0k5aWpvS3JsYzZxUGJGWE1Ma1lVZmxWZEVRNnMzemM0SEdQZWdtV3gxMFIyeEhIWC9BT3RVY1JBdCtldVJUa0ttTjFPYzdTUlVMSGJnTHp4VVJNaDY1OHY1ZXhINlZLdlp1dzRGUjV4djlPUlRvam0zUHNTYUJneEJrYkhyL1NvbnlKMnp6aU5QL1FxZG5mS01kR2IrbEV5bjdRNEJ5Q0UvblQ2aXVTUnNKQXdQWGUzUDRtbXV3MkRQSXdRYWdzNWQ0a2MvZEdmeDVOT3VXektxSndQTFUvclNIY2JjcG1hMkdlTXQvS3Jscjh1emR4dEdLcU9NM1VBem43Lzg2c3hTYmpKZ2NLY0EvVE5GdEIzSGg5M3pzUHZSODB5NXliaEZYZ0pHQVBmT2FiSTNsc0F2STJDZ3krWmZNdlRZQVAwb0V5UWM0UDRWUHBuenl4bjFaei9LcWNCWXRJcFBBSngrZFg5SHdaSXo2QmordExvQmZnWEhtZjd4cDdDcElrWHkyS2djdVNjZDZIV29HUUVVd2lwbUhOTVlVQVJZeWFObVFmcFRnS2tWTWc0OUtZRmZaelRndFM3T2FVTFFCR0Zwd1duaGFkdG9BcU91SC9DazIxTktQM240VTBDZ0JnWG1uaGFjRnA0V2dDSmwrV3VHOFdyblhuOWtVZnBYZk9BZTFSeTJWcE5Kdm10WVpXeDk1NHdUK2RhVTVjcnVUS04wZVphY3VkVHR3RnptUWRQclhwNHR4TE1BeWJoNitsUGlzclZPVXRvVkk2RVJnWXB3azh2SUJ3U0tLaytmWWRLTm5xV1lkTmhDa2JCajNyTDhRd0pGYXBzVVpNZ1BhdFdKcFNxbmN6Q3N2eEEySUllQU16RG1zWU44MWpxa2xZczJ1blhFNFpMYUxjb0FJd3RZUGlHS1dDK3RrbWhNYmgraEhXdFBXdHhnQ3Q4a1dRUzJjYzFqNm04YlBwOGFjN1pTTTV6eFcwTnJtTW4wWjZ6MXBRS1VBbHVjL2hTa0FjRmMxbVlpWTl4VGg5S0ZBMi9kK2xLTWRDT3RBQU0vM1JpbnFQYW1CUWVCd2Fjc1dlcElwZ1BDalBJbytUY09LUVJBNTVKK3BwVmlBUEhIMTVwZ093dkJ4U2dweU9NMDdIR0tSWXdXSklvc0FueWc5S1hjQ1B1MDR4Z25pbkVBSGtacWhqVlBxb3BRRVpzRUNnOWVBTVU3Wm5vdE93RFRGRWV2Rko5bmpQUVpwK3hzL2NxUllXYnIwb3NCWE51bnBTTGFLZnZBMWNOcjh1NFNiZndyUHZZMUJHNmMvUUhGVExUVmxKWEpQc2FBOWZ6cEdzUjFyRXVaekd3Q1ArUjVxbTBseEl6TWswbWNZNWFzMU5HanBuUy9ZbEI2ZmpTRzJ4L0VCK05jMDA5NWFoWlZ1WldYZ2VXQlcxWTZqY1RqNTF5T3hZYzArZUl2WnNzK1VvT0NSUytXQjA2ZlNwbktlV052ek1mYkdLVzM1WXE0MkR0amlsenh1TDJiS3BSUWVjL2xRRkhiSnJRVmlNZy9NTThIRlFlVy9ubDIyZ2QrS3E1S2lWZHB6d3RJVlBweFY0eFJ1YzhEUG9haGxpamovakovR25vRm1WdHZxTVViZmVwQ2k1QTNkZW1ha05wd01zRDcwbFppYWFJVkhQdFRsVmNjdlVNdmx3a3E4aWcraE5RLzJoWmc0M0E0NzBYUzNIeXZzWFFzWS81YVVoQ0JjZy9wVkwrMUxSVURiamlrT3FRTWhLczJQV2x6SWZKTHNYUTM0MDhiaDJyTlRWa1hCS3Z6Mk5UcHJNTWd5cXNSMDRGUG1pSEpJdEFTWnlUeDdVNDUyOXhWSnRYUXFkc0xram9EeG1vdjdYbElCK3pzQTNiT0tPYUlja2pWQTQrWVVxcjNIRlpUYXZjTEVITUNBRTl6VWtldHlaeUxjYmNjODBjeUh5U05INXMvTHVxUlZrOXlLelA3WHZHTzZPMzQ5S2pUVnRWS3R2dGdwQjRicUtPZUllelp0R0YyeHhUWllYamp5STJjOWdLd2Y3YTFkVklkV0h1QnlLamZVZFhkVlV2UDE3TGpORGtpbERVdnkzdDhzcFZMRWdEcXhOVnBielVVd3pKc0dlQ0tybWZWeWZubHVBZXhxcEpwK3FYTW4zcFhIZFNhemJiMkxTc1h2N1F2cEZJa2NESjdHcTF3czByaGx1bVVlbWFhbWgzNk1Gd1dYSEpMWnF6RDRmYllUUGRJakRrQXRubXA1WkYzUlhlMHVKbHdMdGxZOXdTS2JIYVhLTnRlNU1nSEhQT2F2UWFVRElGbHVzL1RqOUtzRFNyVkdaQmRQMTY3ODRwOHJGZEdkSHA5MlZiWkZ2OEFUSjYwaStmYnlGWnJmR1BVVnRXNHM3WXNDOGsrMFkrWThDbzVkVFFzQWptTWprcVhPUHlwOHE2azh4RkRlMjZLR2ExQllIa2p0VjZMV2JKdnZMczQ3a1ZudnFNTWpFUzIwYWgrRElpOC9YTlZwTksweWRTeHVXVXR6aW1rMXN3dW1kREhjV2s2Z3h5cGcrckFValJ3bkpEcVI3TlhMeTJ1blJuYjU4aFVZeXc0elRvcDlMczQvd0IzZDNBWUhwdnpuOEswVnlIWTZVMlFkTjBaejZpcTh0c0ZVaCtuZk5jODNpeGZNTzBEQUdNNXdmcldScW5pUzh2OHhXOGhpQTR5dldyNVdTVS9Ha2x0OXJpaXRrUlNpdHVLOStsWTJrWFdueGFjNlhka3M3bVU1WUhCQXFQVW9KSUpTMDB4bWVSZHhMZHFOSWVGN0pra0F6dko1cTAwaUxOczgvOEFHS0pGcjh6VzY3SXBBR1ZldUt3dDVLK3Y0VjNuaS9TQlBORGR3eWxVeHNLZ2NERlpPbCtIRXZ0UnQ0SGtPMWxMT1FneUs2Vldpb21Ub3lidWVpZUJMZlJ4NGZzRnZMVDVtajNPK09wei93RHFyc0xqK3g3VERXc1dEakIrVCt0YzNaeEpwK25Rd1dxc3lRSUZBUFVpcnhWcmhCdmZBN0ExeFNuZVZ6cWpDeUxDZUlXU1FLa1JZTHhranFLVFhOZE0yaTNTeHhZRFFzR3o5S3BtM2tTUVpIdDBwbXBRaUhScnRuTzZUeVNRbmY4QUtqbXU5Qjh0a2VKM3JLMnBTazVIelY2VEcrL1FiSmV5d2dDdk01OE5mU2x1RHZPUWUxZW9TN0cwdXlXSS9kaFhPSzFxYkl4dVp1c1M0OE1xaDRVejlmd3JqdFVVRzR3bjkwZFRYWmE5TEUzaHUzaVFxWlBQT2VlYTR2VXdSZVlJOUI5S2NMcENXNTB2dzdhQkw2NVM0ZFZNaWdMazlUbXRYeGpiUngza0lYaytWbmdlOVpQZ08zMHU1anYxMVdhT0FFTHNaamdnK29xeHJKaiszZVZCZm05ampUQ1NaNkQwcEsvT0tUTUdkQ0U0ejByRWx5WEE2ZmpXL0p2d2ZtT0FwL2xXQ1pITW93ZS9jVnIxSERabHk1dGlmS3h4bGZXdE8wc2Y5SFRLZzU5UlVVM0x4QTRQeVZwMmprUXhnQWQ2ZlFneGRXZ0Z2dDJvRjU3VnVlREcvd0JEdkNlbVIvS3NuWDIrNEdYdWU5YXZoQng5aHVreGpMaitWWnorRTAreU4xaTBTN3ZCSk1uUVlGWngwaTNQSWpPRDNCcmV2WFVYSkRlbkZSRXg3UmdqcG1uSFpHVE9YYUNLQzhXSkZPTWpxYTZLWUFSc09ueS8wckJ2TnAxVDd3Nml0ZVc3aWVGeEcyVzJuZzFNcnRtdlJGV3dVZVd2MHJUbFVlUTJSL0RXYllvM2tyeDI5SzBKbHhDL0g4UG9QU2t6U0psV1NnM2ljOTYzRlZkdzZWaVdLN3J4ZTFiVWNlV0h6SDh6VUZqU0JuOGFUYm4vQVBYVHRuUEpvTVlQY1VBSnRHUnp5ZUJtcThNYmYydS9CeDh2TldCRnp3Y2ZqVlMwQkdzU1p6d1ZGTXprZGZIdEJKUDkwNC9Tb3dvMksyZXJFZnJVaWd0R2ZUSElxRlJnb3ZRYmlhaU94a1BrL2RxZmNuK2RKQTRFTW5maW5Uakk5dXRSV3d4dVhzYVl4NnNBNVBvVGo4cVNOOTB0d3g5UUIrVkpFbjczMUF6VEEzRTNxWE9Qd0ZIVUNDMHpIbzI0OVdUSlA0Zi9BRjZzam00WStrUy96TlZvempSVkE2bU5SK2dxM2pHOG4rSUFVQ0s2dVd1a1BUNUQvT3A0NUFtbnNRZm1iY2FxaGdreWsraWo5YXViVit5QWVnT1I5U0tCaUU1ZEZISTJZelNMaEwyY3NmUWZwVWNiQmxQdHVQOEE0OGFWR0htdnRPY3QzNzBDSjBJU01rY2JtNC9XcitqSmhnRC9BSE0vbWF6SitpS091YTFkSUpMdjdJQlNsc0JxVzRQazVJeGxqL09udFJCemJyK2RPSXJJc2dZYzB4aFV6RGsxR1JRQkdCVTBReURUTWNWTENBVmJOQURXVGswM0ZQWitTTVVnTkFDVXVLYXhPYVRKb0FqbEh6L2hRQlNubGo3VTRDZ0JNVW82MDRqaWtvRUdNL25Ud09hWmtWS3VEVEdQVVlXcWt6SWt3M2c1eHhWM0lDOWE1cnhIcmttbVhNY2R2RWtyT3VjSHIrUXJTbDhRbmUyaHV3M2hqWEFQSG9SbXN6V2JQKzFralF6K1Y1Y2djRkIxeDJybklkZTF1L0diS3daa1BSbzRtSVAwTlFhaHEydDJFNlJYbm54U1NqS0o1UzVOZE5vSjNzUmVkanNOWGxWdEVuRXpqQ3g4ODloWFBheGNXbHRZNlBjeHVXTWo0d0Q5SzVmVTliMVh5akZkQzdVSGhnOGUwSDlLeEpXbXVsVGM3YlJ3Z1pqOHRMa2owRG1aOVdGRHV5WE9NZEFLVlVBQjNNYWFWa1VaYkFvNHhsenpYTFlZOFJ4Z2ovR2xKWE5OeUF1UnlLUkZadW9QWDBwMkFmdUhia1U5SFhxVCtGTkVMYzdWeitsU3JiSHVvRkZnR2VZdlNrWm5IUUNwMXRCenorbFN4MndBNUkvS21CV3c3TG45YWVGSUl4MzYwdHhLa09jTjA2MVFiVVZLc3lNQ0J4eFVPYVJvb05taHR4Lyt1a0xSaGN1NjQrdGMvYzZsSUZKQlVBOUJuRlV2dHZuS0ZSaTVYazU3VXZhUHNWN002ajdWYUtlWlZ6NlpwcDFLRU44aDNMNml1YlF0anpKRzRZWXlxMHBtd3AySXhCNjhmZXFmYU12MmFPak90Mmk1SG1Fa2RzVXhkZGlJd0ZQMVBTdWRNUWt5WFhIY3JuR0tqS3RJcDh2SUdlRnpSenlEbGlkQytyQ1ZoR2VtZXg2MVN1M2tKM1c5dnU1NXkzYXNjckxHZm56OHZUYTlFTjNJUnd6OGs0eXg1cE5TWTlEV1N6Y3lFdXZCSFdueDZlKzdLb3dJN2RRYXhFdkxuZVFzempqb2FrWFd0VFZDQXpiQWV0VHlzZHpvNDdMQkc3Sy9obXJpeHdwajVXUE9DUUs0NXRidnQyNXJobFVMNjhFMHRwclY1SklWUzZaeVJrYnUxVWxiVVQxT3lMUXIxaS9NVW4ydUhhUVN4SFlZcm5vOVZ1WWwvZWt5WjlPY1ZiZzFiN1ZIdkVTODhEM3F1YUpQSkxvYXEza0FYYVF3d2ZTcEZ1N1VqbG0vRmFvaEJjQUZZaGtkY0dyRVduaGsrN3RPZW02cmpKUFl6bEY5UnpUV3ZtZkk2ODlpY1VvanRwRG5qUDhBdkNtUGFXNk50Y2M1eHpTK1JFZ094QzJPdUtIeTlScm02RXNkdEN2WERmU250Q0FEc0hIYklxRlZpQ2J0cWo4S0FDU05xWi9ERkM1UWZNeUZyYU1QbVMzRWg3RWltR0MwL2p0bHpqZ0VWT1pHU1RZSXp1cVlvV1g1a29TWFFQZVc1U1NHeFVmNnBRZlFMVW4yZXhrUEVBd2VvQzhWS2tLeHVXVUVFMU5HekRQVTAxRU9abFo3ZXpDNGRWWEh0MHBZNExFZjZ1TkdPT2NFVloyR1VEazU5UUJRMGZsS1Q1b0RIMkZIS2c1bU1FTnV1SDhvOGU0cUpvYloyUGJ2d2MxRThqWjVmSXFMY2luSXpuUHJSWkJkbDhXOXZ4bEZJeGdpbXZiUUtQa1JCL3dIcFZMZXU3a2tqM05IbnI3MFdRWGthY1ppMmJXUFBjZ0FacE5rQXdBell6bmcxbS9hMFhzYVB0bWM3VkdPMUdnWFpwdEhGamtNeDdISTRvRTVpajVpM3Q2c1JXVTJvdURnQVo5YWEyb1NkZ1B3b0RVMFdubGFIRzJGRG52azRxc1lHSlltYzVZNXlveFZKcjZUQnowK3RSUGZPK1FEa0QwcFdUZXBWN0dpWVlWeHVKWStwYW9aWkxhSmlTa1lJNkRKTlkxMXFjZytVN2M1eG5OWXQ3cVJjNGxrR000RGRxcFFUSmJaMXJhakdRRkN4RmNjOFUwNmdrWUorUUQxQXJpYlhVeXU4SnRMOWo2VTk3OTVZeHQ0WWR5ZXROeHNLNTBrdXZ4Qml2bUtwOXU5WXQ3cWpPZHlublBCckFrTndHM2dNVzlLYUpidG8xYWFKdDJlTWpwVFJSdUxyTXNWczI1L21ZRWNkcXpwdFJ1V1hPNXkzWGpubW9oSVVHWkYrWTlLcy9PM1pSZ2RxTG9mS1ZaYjI1a2pJNVBvVFZXM2FWN2o5NDJBZTliTVE4eENDb1lzZlRwVnBOTmlPQ1NPYW5uc1BsTWp5TjJSa2tOeDBxOWFhV1l6bG53dnVhMGx0SUZDcU1IbXFuaWFLQStFNzRIYU5zUktrOWo2MW02ams3RmNxU09XOFphcGE2YmVKSElTemVWeHQ1clQ4SkxZM3ZoK0dkOWdaMkorWTg5YThtazh5VEcrVm1JOVRuRldiZlViNnpqQ1c5eVZRZEY3VjBLQ3RhNWpyelhQVFBGa2Vucm83UlJGZk9MQXFvNVArY1ZTOERpeVdPNnVybVJFbFZnaXEzcGl1RU90Nm8vV2N0K05QdGRhdXJUZGlNTnVPU2MwZXpWclhMZFNWdEVleE5xMWtnSVNhRUU5TUxWY2E1YkxJU1hWdmNDdk1sOFVzUDhBVzIvNVZNbmlhM1k4cXkvaFNWR0hjajJrK3g2TVBFdHFyZk9DUm5vQldCcitxZmJkVlc0aE8yRlk5cFVua211ZEd1MlQvd0FaSDFGTW0xSzBsUmxTWUJpT3hyV05PS0lsT1QzT1B1MkxYOXcrZXNqSHI3MTJIaGllYVhSWE1yRnlKTUtUMkhGY3hjNmNQT1pvMzNiaVRuUFd0dlE5VGgwclRHdDV3MldjdGtDcXFiYUVKdG1kcmw1TkZxMGlyeW93UVBlc3k0dXBMZ3RKTHd4cWZVNWhlMzBrOFAzVHhWUDk0QmdNUlRTMEJTc1RRM2J3WjI1T2ZlclVXcXRHVDhwNTk2b2IyL2lDbjZpZ3VPNkQ4S2RoNk0xQnF3S3NHVS9NcEE0cWlXMnlLV1VldFY4cG43cC9PcG5kSFJDR09RTVlwTkZxeU5JM3NMU3FjakFYRmFOcnFFR3hCNWlqSHFhNW5jT3pZL0NqanU0cGFpNVViR3RUeHpNbTFzOWVSVzE0UjJpeHVOdk9aQUR4N1Z4cEdmNGxQNDEyWGhJaE5Mbkp4Z3k5dnBVVDJHOUZZbXZwQjlySzU2VkN6S2NZSUh5MWkrSVpKUDdVYnlpd0dCME5acHU1MTZ5UFRqc1R5WExrNmx0UlBHZWFmR3BERWtFOEgrVlVyU1F2ZHF6bkpOVzkyMkZ6bkh5bkZNb3Y2YzJJeGtNTUN0QzdreGJTWXowcmxZTlRtZys3Zy9XclQ2L0xKR3lzaTgrZ3FIRmx4WmUwOWo5ckdQNTFzb3pidWMxeTF0cTNrekJ5bGFDZUlvZjRrWWZTcGNXVnpHdUdZZjhBNnFYZWUrUHhGWmk2L2JIcVNQclR4cTltL1Y4VXJNTG1nSCtZY2Q2em9Mc3JyVzBScjg4Z0JOVExxTnNjWW1INTFVdFRCTnJFYnBJZVplQmpyVHRvVEpuY3EzK2p1RDE0NS9Xb21HMk5EM0FKcVU1RnUvdUJqOHFoUnR3d2U2NHFFWkRtNGhBUFhCcG4zY0ZSbmlueXNjbkg4S2sxR29MUktWNjlLT29Db1czRHRuUEg0MDJRZnV6L0FIaVNUK1JxV0ZTeUZtNTQ2MFRLRUl6MHdQMXA5UUlBbzhoSTE3QWo4alVzN0E3c1lBVWpQNVZXREVBZGo1aEg0YnFSM0pqa0xmM3dEK2xBa05kTnlLM2JLajlhdUl4U0lBK2d4K2RWeU1XNWFwTGxjSkh6MTJnME1ZM3BETGtZK1ZjR2tSTmtqTjMzQ2tQRnFTVC9BQWlwajgwZVFPaEJQODZPZ0RKUzI0RW5uSi9sVzVvNHcwcC8yUldHNUhtaFdQWEpINlZzNmJjUklKUTdxcmNEQlB0VXkyQmJtekVBc0tBZE1jVTdxYWcrMXdoRS9lTDkwZDZZMm8yNi93RExVSDZWblkwc3lkaHlhaklxckpxbHNPamxqOUtpT3BwajVVWTBXSHlzdUUxSkg5d2lzczZpeCs2Z0gxTk1iVUovNENGK2dvc1BrWnFzUms4MG1SV01ieTVaais5YjhoVEdubWJySy84QTMwYUxGZXpadGxnT3RNTXlMOTVsSDFOWVpMSHF4UDQwb1VlbEZnOW1hcHZiY014OHdINkNtblU0UjBESDhLek51YVhZS0xGY2lMNTFRRS9MRWZ4Tkkyb09mdXhxUDFxa0Z3YWRUc1BsUTgzMDRKNUg1VXYyNjRQL0FDMEkrZ3F1M0RVYnFCcUtKV25tYjcwamZuVUZ6NGZiVXJHYlZMTzhlMjFHeEdZajFWaGpKQnAyNnRDeTFUN0RvK3FMZ0VTUWtEUFlrRVZVWFozSnFKY3BWOEtmRWF5MHZ3MG1sNjNhU1cxM2J4Rm9XMi9MY0E4ajZFNStsWmMrazM4MnRhTnEycXVSTHFkMk5zV1B1SUNDS2ZhYWNuanE4dDB2YzJsaFpRTEJDVXh1TEFkZnpxcHFGM3FuaHJ4Tm85bjRrdUJjMk5sTHZnbkhMYlAvQUsxYjZQWTVOVWVyYXRaMmRqWlMzdW9tTXd3b1dQbURpdkRyeVNYV2RaanZCWmlDMW5uMndsVkE2R3V4OFFhcFA4UXZFa2VpNkRJemFaQ1ZhYVlkRzk2ZjRzc1l0THZORjArREcyR1FZQUh1S20vTHVWdWoyQXhaSFhKcVJZQWV2SlBXczZUWExXTjlyUDI0OTZWTmVnS2tqZGo2Vmx6SWZLelRGc2h3TWNlbFNHRWpBQVA0VmlKNGpTWGY1Y2JFcjE0eFNQNG1WWENpTThqSlBZVStaQnlzMVNadk00aVlMbjE2MDlpVlhmZ2tlbmVzVnZFY3lna3g0WCtIM3FoZWE1ZXR0QTNBTjEyOWhVYzNZMFVXMmRRc3AzY3JnWTQ1cU82dXZLangwUHNhNVZyeVo5cnJjT2ZsNCthb0h1TG1SUzBraHgvS29jcE12bFNOYWE4amVRcWtnSjdnbXErMWR4MmhRTzVCcWdzcFZ3RHVYSTY3Y1V4NTIydjVTTTRINGJxamxLdVhMdVMyajVhSlpEMTRxS08rdHRtNFE0WDF4akZaOC8ya2dFTmdkZmxBeUJVa0VqSXJDZC9NQkhKeFZLTmhYTkkzMEtRN3l1RlBUbmcxVmsxRkdJVWhVVmZtWDVxcHlNSi85V29LampKL3dwb3RaWCtmeWxmMzRvNVVGeDgycXpPaE1DaVkvd0N6VVl2N25adVZkaDdnOVFhbkZwT3NlKzIyS2V5azRBcFliS2Q1R1l3cVQvR3hiSXBwSUxzamkxS1JseEo1YkhPT0JqRldZTDNhUjVzYUZjSHRrMUtta1A1bUYyS0Nmdk1mdTF2V0dnMjdsWkxnUnNRM3k3VDFxMHV3cm1UcDBGdlBQdW1uaDVHZHBCVWl0d2FGWWxQbVR2eUZiSU5XUjRmc1VkbkVRK2JxcFBGV2xzbzQxVkk0OWdBd0NDYTBVV1pObVBMNGN0SmNqZVVUMEFvLzRSaXdpYmRBekkyTVpBeml0bGxLS2Q2REE3MUdxNTV4bitkT3lDN0tBMEMzVkJtUjNQYzQ2MU8rbTJSSHlwdGZHTTFjU1BLODVIT09uU2dJM1FxVy93QnJHQlN0RkJkc2lodDdlQmZrVERkejYxT0psSFFjK3RRWEU4TnRBWkoyd1A3bzVOVW4xcXdBK1FzM0g5MDBKcm9Lekw0WmdTV0lZazV6anBTYm55ZG82MUZhM2d1b044V0ZIdUtlemtjRnorQXA2QnFCTXZzUHdwb2VSZUEvNFV3c3hQSlA0MDNlZlhGQUV3bEtuNXBUUVpqMURsdmFvQzY5K2FiNXlyMHBYR1dmUEs4NHo5YVQ3VHoxQzFVYVVuN3h4K05RTzRJNFBGQUY1N3h2dXJKZ2V3cXU4dWM4c2FvbVhIVTg5cXJ6M2UzamR6M05Hb3pRem5PRFVlV1VuSjVxZ21vS1NGWGs5Q005S2xFeE9PTzNyU2FBbmVkVUh6bjZWR0xsQ293ZWFpZWFIbnpDQmlxVTcyNktYamNjZFJuclFnTHNsNm9CNTVIUUE1elRVdWNvTXRnNDVHS3gvdFVSSjM5QU92ZkZXVnY0MWpWd3BKUEE5cUxXQTBVbDNEK1dhaWx1bzRjZWRLRXllQmlxTDZueHVDNHJObXVwSkhPOGphVGpIV2tNMDdqVjdlUEhrdDVyZXhxckxyTXFCaDVVWVgxM1Zsekt6Wlh0ampJcW5MTExFcFVndG5wN1ZTU0RVdTNGNXVZbDJBSjcxbFR5TkpJMmVGRk1OaEpjTXJUU0hPYzRxZDRCditadVR3UlZxU2lUeXRtZEEwM25zb3lSbmsxc1dkdHZ5N09RZTFOczdGaEx5ZS9XdGVPM1NQbG1HZlNsS29pbEZrQytiR3dEQVA3aXBzTXk1Qzd2UTA1cE5yRWJNZWh4VC9NV0tITDllb0ZZT1pxb2xON1F6eUFqcUQxcDcycnh4aG13U0IwRlJyZTRrNkhIdFU2VGlSaWhKNjBjNGNwRXNnRVpBNEk2MWJnWlY1Zm44ZWxSTGJiV0x1TUFkYzFNSm8xd1FveDNwY3crVXNNcE1aOHZLbm9EaXFlcGFmSnFPbHkya3haSTVGd3pMMXEvOXEvZGhoejZFVk5Hc2x6R1Fpa1o5cWptWlhLZU1hLzRhajBlYVJWdWR3VUFvckQ1bnpWQ3cwSFVOVHQvTnNvbzV2VlZsWGN2MUJydHZIT21oYnVXS1E1S29DcHgwckhqOE1hM29Xa1dYaVBSNWQ2c3U5MVFaSzg5Q080cnJqTzYxT1J0MzBNbVR3aDRoaGo4dzZUZGJQN3dUSS9TcVUxaGZXNmo3UmJUUmM4NzR5SzlnOE1mRXkxMWlKYlMrVmJPL09CejkxejdlbGRhMm1tOVlmYUpUbHVnSTYwbk5wMmFLalpuelRqSFdoUm5GZlRLZUZ0R01lMjdzYmFjbnEwa1NuK2xZK3FlRC9DQlZ3TktoRG5vMFRGZWZ3TlBuU0dsYytmeW1Pb1A0MG0xZTRBcjFDODhBYU96SHlUUEQ5SHlQMUZZR3FlRHJLMmhaN2E4a1psR2RyS0tPZE1xenNjWnRHZU1qM3pTUHVIQ3VUelZtM3RIdXRXU3hRZ003YlFUVm0vME83MCtRaVJRd0hPVnErWkxRemRyR2NDVlVqK2xOUFBVQS9oVjFkUHZIczB1L3N6R0Z5UXJldk9LUjdDNmh3WHRaRkhydE5QbnQxSHlSWlRHM3ZGK1JwQ3NaNnhrZlNyQkdEOHlrZlVVMXRwb1UyUDJjU0R5b2ozSS9Da01VZjhBZUg0aXBRZ3oxcDJ4ZTVxdWNuMlNLL2tJZnVsVDlEVFRiRTlPZnhGV0dWVHdxNUo2VkZ0Qk9NY2ppbXBrK3p0MUlUYnQ2SDhxNkxRdFVnMC9TbmluRFo4emRrRDJyRUVaN0UvblM0ZGY0alNrMUpXRGtZYXBkcmUzelN3azdTTWNpcVpaeDNOVy9tSFlINmlndG5yR3RVbWtyRXVMSUxlZDQ1bGIwUHBWajdkbU4xWlFjcnh4VENxbnJIK1JwcGpUMFlVN29WcElnRHIzV2t5bm8xVEdGUGY4cWI1SXA2Qzk0WjhoL2lZZlVVWUhaeFQvQUxQN2o4NlR5Rzdmem8wQzdHN2ZjZm5TN1Q3SDhhREU0N1UweHRSWkJ6TWVFYzRBWEpQcFcxb2x0S3Q5YmwwSXcrVFdCZ2l0YncvT1JxOXNqazdkMVRKYUR1ZWt5T0JiZ0U5alZVUHNLc2VnNElwOG8zRUFad0tyUnNYZ1lrYzdtSStsY3lReXpOSURidXk4Ym93ZjBwSXBQS3NmbXlTQWNmV29tT1JLb1AzVHMvSUNwV1VyRGdmeEhpanFCTmFPRlZZM1BPQUQrVk12amd0ay93QVdPS0lQbWNldWNmclVFemhycHgxMmdmenA5UkFyQjUxQVhvQWFSdHZsc0QzazVxS0pzWERQMkdQNVVpdUpDRDBCZmdldldtSW1DYm8xSHZVdDBRMFgxSngrUnFPTjl1emQxMmtrZlNvbWw4NmFGQi9GR3oveS93QWFWaHNsYmExbXVEbkp4K1J4L1NueHlZVnpqSVlmbHhpcThKeFlxVDF3V3g5ZWFlVCs1S2pnaGY2ai9DbTlnRWxPYnhENlIvMXFGRHYxT1hQVGNCK2dwNmtTVCtaMS9kZ2ZyVWRuaHIrUWs4ZVoxcFBZdU81c3lLRllxQmdDa2pIQnB6bk1ocG9PMVRXUjFFV1BtcWRSaGNHcXBZaHVLczU0RkF4d3B3SUJ6VWVhQjgzRklCY2RhVEZPSnBvb0dHT2FVQ2s1SnBESXFaM01CeDNOTVdncE9NWXBkOVU1dFVzWW5DeVhDNTl1YXFTK0lyQ1BJM014OWhUNVdUekkxaTlHNnVjbThWeDhmWjdkajY3KzlVcm54UGZUTHRSVWlYUDhJNXFsVGJKZFJIV3ZuZHdlMVF2Y1JSLzZ5YU5mcTFjZDlvdkxubHJoL3dBNnJTVzhyTTI2Vmo5VFZLbUxuZlJIWHphNVlRNTNUN2lQN29yTXZOYmp2QVliY09ZMklCTzNyV0dsdEdnK2ZuM0pxNWJSS1pvakdPTjM0VlhJa1E1U2U1MmxoTWxwYXdSeEVvTnc1ckIrSU54SGVYMW5iV3orZFB0SVlkY1pOU1grb20xMDB5RGJ1UEFYUE9mV3NTeGdtYlU0YnU0RytSK2VUVVJWdFdLVDZJM2RHT3MrQTl1bzJlMjhzcFFQdEtxUHVuL1BldExYdGN0L0VHdGFUZDJzbTVHWVpIZFR1NkdydGhjcTlvWXlQdmZLVmJvYTVYVkxLUFJkZFdXMGo0UDcwUkRuQjlCU1V1YmZjVGc0cTYyUFgvTWdNcWdsTjVHY0VWT2x4RWluYXE4Y0RqRlpVK1lZZDdJVWt5Qm5HYWpFbmx2bFZrYjY4MXpPRE4rWkdtOG0xZ0FjbGpuZzlhclN4eTd0d1ZqamtnOXFpdHJoSkpOaXhPeHoxeG5GYUVObE5KbGZOa3czSUJPTVZhWGtTMlV4SzEwTnNmeWtjZ2daelN0YjViZE51YlBHRkpyVGowdVU0Y2tER2VDS2NabzdKUWx5aEwraWpyK0ZhYUlqVm1ldW5yNUkycVZVZEFHeGlwQkJBaUVZYko2Z3RuRlNrL2E1R0gyZVdKYy9MSnowcXF0dWJhV1JCREpKdUdTeDcxTXROaWxydVA4QU1zMktnaGkzWXMyY1UyUm9JbUNwR2NrWkh6Y1ZXRnJDWlBOYUtUZWh4dHp6UzdzenI1aUFKMCticm1zdGJsMlJLSkJMTXV4VUtnY3NEem1vN2hrVURZcWtFOGx6akZPbE1LeHNZNWZMUDkwQ296RXM4V3lJZjhEWTlUUlpob1JiSmxreUpVUkQyeFZ2NVNtMXBUbkdEanQ3MUUrbEZWS3JJNjQ3NUJBUHBSQm9OMU1wWVRQblAzUU9vcXVWc1hOWVVReHB0emNGeG52VFh1RElwS0hoVDBIVDYxZnRkR2tWUXM4Y2pIZzUyNE5UL3dEQ1AzVThoVm9sRVJHQ0ErYWFpd2NqTGplZVJjSktEbnJrWnhXamFXZXB2SkVJV1VjY2xzaitWYWRsb3l3TmtQRXBYR0sxV3ZyYUZjQldta1VjQkZQSnJSUVJEa010TGU4VnYzNzQ5Q0dxL3VrTDRBUFRyVWNkN3VDbFlXVVk1M0RrVXp6dlAzRjFaQXA0eTNXdFZwc1o2am1uWGQ1Y3MwYXNld1BOSjU4QmxBM2ZOakhQRlZuUzEzYjNpUXQzSkZJYmlKbUlDcDh2ZXBHVzNtZU5HQVU5T0N2elZpeWFmcVRnSDdlVlJqOXgxNXFkZFh0WW1JZTZVRUhHQWM0cHlYMXBkUzdBL21kdzI2bG9QVXJHd2t0OWo2amR4b2dQVmZtSm91dkVOaGJPc2FJQ0R4bkhXa3VyT080WmhNV2svdWxUZ3JVRDZSQXcyWWRzOTJQTkwwSGZ1VFJlSVlHM2JZMndPQUY3MWV0NzFicHNiSFZnTS9NS3c3alNZclN4MytVZk1EWkRMbG1CcUcwbWE0a2FNcGRxd0dONzVINVV2ZVE3Sm5RM0RTSzQySVpBZXJaQXgrdFFsK1NBYys0NkdzK0tUN0dtSkxsbUo0K2MxS3R5TnVDZndwM0VTUFBoZ3BERTU3RG9QV21QSWV4L1NtYm9semdINm1vM2xDcWZsSngwcEFFaHl3SmNqanA2MVQrM0xIS1VsWUFDbzd1OGVKQ3hBVUtPU1IycmxycnhCRkRkUGtaQlRqdlZKQ042VFdiZUV5RXpmTU9RS3pIMWRKa2thUWhkeDRKUFgyRmNmcUdySmNOdWorVnFndFo1WjVBUG1JNkN0VkZXSjVuYzdPSFVVU1VGSEFCSFB0VjZUVWY5R3pCSnViOU1WekxXangyeVNjbFFlY2RxdHh4WWozcVRnamtWbTJpMG1TM0Y3SUdLNzJaRDBGVUcxR1VPUU9GSEpHY1ZMR0pUaktGaG5nOXF2SnBzZDliTis3MnlsZnlwT2FpTlJiS24ycjVWSHpmTjYxZGd1WkpZMVZ0eXIyNHE1YmFjNGpYejFBMmpHT3RTdEFxS1BNeG4yRlpPcHpiR2loYmNyUmtodVJrZDZ0QzNpWkEyMDgrb3FKMzJzQ25UMHBrMXhMdHdvNDlxQUhTcXFZSklIcFVjaVJNcllYNWpUZktMSU56WUk2WnFOWVplT3BIcjcwREpQc21XVXFSakZOYXdYemQ4cC9LcEZEREc0NE5XbWJLZ3RqQTcwaGthUlJwaFZ6K1ZKSkdRd0lCd091YWsrMElUdEE2Q25OS3BqSnFic0JzYUszQlBJN0dvNTRSTDdNdnAzcER1a1lOMHhUN2RsUmRzalpOSzVSRkRaUnFDR0lKOXFzUnhRb3g2RnU5UFdCWGJLWkpxd05FYTRiZnVNWit0UzJ4cElobmhNOGV5SnVuYjFwc2VnM0V5cUErMDU1eUszclRTbzdmR1czRTljMWNZckFoUFlldFhHTDZreW11aFFzTkFqdFlRSm4zOXlLdmxyYUJjQXFQU3FrdDJaMUt4bkhITlVVMCtXYVpTMjRxRDNvYlMySlYzOFJ4UGppWVhHc1hCVThlV28vU3V3OEkyUmJ3eFlpUWZMNWZBUE9SbXVNOFd3TERyTnhHZ0pDZ2RmcFhvM2hrckg0WHNGSXgrNUhldEh0cVlRZHBPeHczalA0ZFcxN0lidlFWK3ozb2JMb09FYnY4QWdheGZEdnhIMUhRTHBOTDhVUlN1c0xZU1UvZWo3YytvcjAvVnRSaWlCQU9DQjNOZWZhL3AxcDRnNG5SUStjQ1Zlb3Fveld6SDdON283V1h4SEZxVnJGZGFmTnVnUE85VG1zbTUxQ0pUdVptYko3VjVqYzZmcmZnK1l6V2NqU1dvT0d4eXArbzdWMU9oK0tOUDFhM1NOMUVkeC9IR3g2L1NvbEhxbmMwaExvMVk2TjVVbVhjblBIOFZWZFV0clZkQXVwVmp3MnpyNzB5U1pETXFxUExWdW1hWnJyTU5FbVFmZEsxbnBvVzltZWVhS2dieDlhZW03UDZWMm12SkhjWERuZy9ManBYRmFRdi9BQlhFSGJrOC9oWGJYNVdNU3NUdXd1SzJsdlk1Yis1WXo3RklXOFBXOENrbmF6bkgvQWpVL210amdENlZVMHkybE5yQzJ6NU1Fbm4zcTYwYkk1NVVqR1ZHSzVaYmxGV1R5Qm56bFhPZnVsYVJkUHM1VnpOYVJFSDBYcFZxU0JKbTNBZk1Cd0tSSW1DZk1kcDlEVXR0Q09TOFUybHBhVzZQWlJDTmkzSkJxeFlhTFlYV21RU3l2SXJ1bVdJUGVqeGtpeFdVU2pCTE1TU085YTJoV2tVbW0yc0Jrd1RHdTRpdWh5ZkltaFhhWmtYZmhxR0tKNUlicHZsWGNBd0hOWkdsNlpKcWtrcXh5SkVZeUFTK2VjMTZCcW1sVzBkaFBLa3BrSWlZRUhzY1Z6bmdqVERmaStZU2JFV1JjbkgxcW9WSk9EWVhhWmc2cHB0enBBVTNPeGxZa0tVT2MxVlNONVlQT1FFcDZpdW4rSUZyOWx0N1ZSTUpSazg0eGlxdWh3aVR3K0F5OU1uUHJ5YTJVcnhVaE9iVE1GZ3l4cTdoZ2pkR0k0Tk1ISXlNa2V3cWFYN1k3eTJzUkx3cXhJUW5vZmF0blJiVE9ndEpJOGFOSElRNlAxQTlhcVV1VlhRMU81Z1VwSU9PS3R5Mjc2Z1p2c0tEeUxjRm5sSXhuMnF0cFZ2OXMxcUMxZkpXUnNOelZYMERuQk1kNmtLSXc2Q3VzbDhJV2l4c3dra1VEdm5OWjExNFhhRzNhV0s1M0JSbkRMeldmdElzMVV0TlRBTWFld29NSU9jRDhRYXNYRmhMYjJJdVpDcFhmc3gzemlxVHlHTkkzYnBKeXY1NHJWRTgwZXBJSUQyUDYwaGlaZTlXcHJHOXQ3Zno3aTNkSXNENThjYzFVV1pTZDJkeURyaWhOaDdvcGlKSGI4cVdOV2hrRG9GRERvZlNuZmFJOC9MK1JwL21JeWpid2ZyVHV4Y3NTNnV1NmluSG01SG9hbGg4UjNrU2xUR3JjWXJNSlUwb0txQ0NNNTZIUFNwMEs1VWEwWGlkb25jdGI3dDBoYzllOWFLK0w3U1IwTXRySW9VRWZLYTViRkdEdHpnWW9zaGNoMWR0NG8wK0lCcEJMbmN6WUFIY25IZjNwSTlac3BHM2VkdExFWkJCNHJsTnFZNlVlVkdlMktMSVhzN25Zd2FqYXN4eE9nQmJxVC9zMHkydTRwSFpTNHdxa2c1K3RjYzBYUHlzUitOR0pPMGpVN0lod1oyMDF5cGpMcWVGamI4TW1sYjVOUWpQOTJFQVkvRS8wcml4TmNxcEhtbkZTcnFGN25kNXJFZ1l6bW5aQzVKSGFBL1B0SFFZSDZVTE1GdHpJMzNTd3grWnJrQnJWOHI1M1o1eVFSMXFSZGJsK3pyRklwSVU4WUZIS2hjc2pxYmR3TFJHSEhITk4wZ2g3NWNqTzU4MXpLK0lIRWF4NEFBQUdhdldldXdXc2lTSXdMS2VocVpSZHRDb08yNTJUZmVKNlZHeCtTc09YeFhiQVlXTXR4Mk5RUDRyQWpBaGc1OTZ4NUdkSE1qYkxkUHJWa25DbHY0UU9UWEhTK0lyK1ZpRVVJUFlDcXNsNWV5NTNURUE5UURWY2djNTJ6WGR1dkx6b285elZlNDF6VDdNNTgvemo2UmpqOHpYR1pZajVuWS9qU05IZ2pBNXhUVUYxSmNtZEpMNHZ0LytXRnN4L3dCOC93Q0ZWbjhXM0VtZktoV1BBenlLeFZ0ejNGRDIrM09UbXJ0QWk4MlhIOFJhaEkzTXhYL2ROVm52WnBjbG5jazljbW13V2ZudnRpeTU5Rm9rUGxUbTMybnpBY0VlbE84ZWduZGJzWkhra2xsM0RIR2F0eEJEOHJxQWNaNHF6WjJMU1hMUlREWnRBNmU5UzMxaEZGRCs3eUhKQXlUVXVSU3NsY3pHakc3QTduakZOYlpGSXFTNTNub01WdjhBMktPMjArM2ZhTi9KSngxcWxlUUpjYTVCZ2NiQm44NmFsY3prN2FqVmlaSTk3SnQ5QWFOUkVjRnJ1VmQwempDajM5YTBkVWtDQXBnQWpHS2pnc3pMR2J1NFg1VkdGVTloVXJYVVVwdEhMUjJGeUxtSVhNaElrT05wUFN1bHVvbHMyalZPRlZjbjJxdGNydTFLMHdPZDJjQ3JPdnM4MTBZMUFDb3FnMWU1S1RUc3pMakRhamRySWNtSk94OWEwL01XS2VFT1FDUFFVdG5hbU9FbE9pampIZWw4bHBXM0tQbVgxNzFFbWJXT2gwOTRwSXN5dVFPcHdPaHJNMUNSRDRxdFRIaGxHUHhxc2tzOEsvTXJlaHFHQU1OZWdrbE9GOSsxWXBlOWN1VW55MlBkbmhzM1Ywa2xmQk80RWNacWFQVE5ObDJoQWNucHR5U2YwcVdPWFRZNERNTnJnaklKR1Q5S1pGcjlqYnhPNmdSZ2RBZUthZmNsK1JJMXREWVJ2NUZrMGprZEZIV29palN3SkhLUlpwbmNUd1NmYkZaay9pSzl1SGN3cEpIR3d3cENjSDhheS9KdUx0bDR1SkhrUHpKMXgrTk55ZDlCSkhjUTNOaDVLaU9lTGFSd2NnRTFJMFVUeEJvdkpPN3F6RE9SWEpRK0ZYbFFLcXVvVThCbXhXcGIrSC9zOFlWNytVTXZRS2YwcXVaaXNqZldLQk56S29KT08xWmQvS3UxMGd0NU4rTUJ3dkgwckltdjdqU3AyV0tPNGxSamdIQllaOWFyU2E5cUxrRmJhWVk0d0VQNTBydGhaQStsM0Uwd01peUFzYzVac0FmV3JNZWg3VWRydWFHTEJ5Q3JaTlZKcm03bWlVVDJsMHlEa2dldFVKMGtoazMrUk9OM1FrN2lLaEZ2VXVHMDBWeTZuVVpGbEF3NzlNL2gwcFZ1OUJnaThxM3VaSnBCenNVWXlmV3NtTllaQWYzTHlIZGh0MVZwZExkM1dTMWhtUjF6dXdPdnRWZE5TVGJmeE5GYk9BTGZPTytldE5rOFhYUkxTVzZZVmgwSUh5MWd5Mjg2UUdNV1VwYjFJUE5ReFdFOE9USjVzWkp5UVY0RkNRN25SUitKcDNVZWRkU0t6ZFFlS3V3NjNIYnlFdk0rMWx5Rnowcm5WMGU1ZVlUZVNXWHFDcHptcjBXajNoK2Z5V080NEpKNUE5cWZLRnpXajFpRkdLeDNFZm1FbHNNVHlLbDAvWDJMWWxCZmMzekEvd0FOVjR0QWhDaHBQOVoxM0VjL1NyRWVsUlFObkpiSi9pcVEzTDh1b1hNOGdraFdReEtNZ0lWQlA2MVZ1TmV2RVZYbnM1SVR2NHdRd0k5VGpwU2lHV05XSG1sVmJwaGVsUndSeXcydXlhWjVRRG5jL0ZEbFlMRGJqV1dtZEZZRUU4NEhGVjd6VzJlellmWTVGVmlRcmJ3TTArOHVNS0FnREgzcm03NlNTUnhIdHlWQjQ3Q3BUVnh0RiswdkxTTXlSeVdwWHpmdmJXem10UkxuVDRvVUlpMm5PUVR3MmE0SVBNakRhcDRQVEJxODE2WXRnWXN5WitiTlg2Qm9kOVpTUXpqY2lTZjhDcXhJNEJEcWpNNEhIemNWeEZwck04RGJvMklRaml0T1BXWExFSkl2VG9UK3RTN29laHBXK3FYTnRkT3QxYkJVSXkyd2xobW9wZFh1SG1PRmxSRzU0VE9CVFZ2cFdRTXF4c3hJMjVQWDFxeTE1NVlMUEhoQjM3azBiaHFVNVo0YjR1Z0U2bkFKY0pqUDBKcVdLN1JXQWx5bUJqNStLamZVL01ZRkVCandlcllKcWxmM0tTZEZ6NkRyaWtCb20rdFhKQ3VYMjhIYU9sUnpYNmY4c3dUeDFQYXNXREVJNTZua3RqR2FTZVJsa1ZrUHl0UU94TmRPczVLek16WjdkTVZpWDJuUlNucUF4T05vclRublpvZHhVWnlNR3FzY2taazN5Y2h2bDU3VlM4aDJNQ2JRR251VUVTaFY2czNwVjJQVGpZYlZqQUxidURqcldzeCtiRWJBNS9TcG9RNGI5NUg4dlk1cE9UQlJSU3RYbExNV3lCMHdSd0t0blpKRis5NmY3TlR1UXlsUWlxTTljZGFpYUxiMDV4MjlhUzFCNkRGUllZd2UzcFQ0NTJobUhsOFpQTlJUT0d5QWNGUnpTV3JDVGV4K1lyeFNtT0pyK2NyeDhISngwN1ZubG5sTEZteGc4WUZUb0gvdWhRUlRCQkxrb09jOGozck9LU0xidVJsOXFrb2NrVVFzWm1JMjhqSnpWd1doQkJZQThZT0ttdDRBUjhxNDdaeFZOb1ZqTVZXRGpjQ1FlOVhsaVpsMktjY2RUU3lRUEh3ZVNEVnBFVmx3RzVGUzVEc1p3Z0tRbmMyVDFCcFk3ZG5oQUorWHJWaWVCMTV6eGlvbGtaRStYZ1l4UzNHTVczeTJGNDkvU281SWZJSUxuSXoycXpFR2xZQkFlZURWNkRTWG1INzg1QTZERlZiVWxQUW93eHJMSG5heEhvQjFxeEhwWWw2cXlqdG52V3ZiYWRIYkxoUit0VE1GVHZrKzFVbzIxSmMraFV0ZFB0N1laSUpZZTlXMmxqUlJqajJxclBJNVB5N2xIdlNSYkpsQmJjVDJwdHJvSko5UjdUdXlaVDVUbitLcEdqYTVnS014eWU0RlRwYjd3UGx3UFFpcDQ0Y2VveDB3S1hLM3VITWxzVTdUUzF0K1V5emQ5eDYxZThzTEhra2NkcWhudklyUS92RDk3ajZWUXZOUkJ3c1pHR1BhazJsb2dTdTdzOCs4WTg2NWRrSEl4L2hYVDJkK2JUd3hhaE56djVRQXgyNHJrUEVzZ2UvdURrODRycjlKVE9pV3dJQi9kRG4yeFRsc1JUWHZzNTY4djdtU1llYjgyN2ppcWthUytlY0FoV3prdDYrMWROTHA4SlBtZFdHUUJXZGMyenhSTUNvVUhrSDByTk0zYXNVVWtlWkpJM0FLdVBtVnZTdVExN3d4OW5tKzFhWUhqWUhKai9xUDhLNll1NkZ6bkRBREF4MXFtWlpaTHdwT0dJbEcwakhTdEl0b2lTVWtZbWkrTFNzeVcrcnI4NkhDeXQvV3VsMWJVMG0wMXRoRzFoZ1lQV3ErcWVEN1RWclZuaVBsWFE0VnNkY2V0Y1hjSFV0QW1OcmZJelJEZ0E5UHFEVmNxbTdveGJjVlprOW96RHhaQ1l4bHNuK1ZkbGVJcnFaSkR0Slgxcml0QmRidnhURElwT1BtYjNGZGJmOEFFYmg4bGVnRkVsNzZNL3NsK3djSnBrR0FONnJqOVRVelhDT21Hd0c3Q3ErazJtL1RJeWNzMjNjUHg1cXBOYjNSdVNJaHlPMk9vcm50ZG1xVjBXVGRpTjBPMzczVTRwazA2VFA4akE0SEZTL1l0aWJaRGpJenpVRWVtcEhLU3JzMlQrVloyMURsT1U4WUZ4RENKVDFKd0s2NndkSXRMdHpIRXVmTFh0MTRybHZIYWJXdFYrYkpCNmpyelhXMmxxRXRMY0F0Z0lveGpweFcwbCs3UktWM3FSYWpOTTJsVDd4dEJqUEdNVnovQUlHbGRGdlkxT011Q1RtdWx2YmFSck9XM2xBVWtFS1c5NndyS0dEUmtrZ3RXYWVlWTVQR2VmYW5DSzVHaHl0ZlFsOFQ2Wi9hYlc2dk9xUnBrc2VwNXFHMHRJN2EzRWRzMzdwVndCbjM2MWtlSnB0UXRFajg1L0xNb3p0QjVGYW1pYzZEQVhQT3prbjZtdG9wcUNNcFBVemJ5ei9zMkZMMkdUZkpLeExLZWdGT2dXMTEremNBTkdRY050L3p6V0xyRjlQZFhEUURpR0lrY2NacnR2QzBNRUhobUg3dVpBV1pTT3ZOVk44a2J2Y0lybWVoblNJbHA0ZW1zOWl3N0UrVWdjU2MrdnJXRDRiQVBpZTI5TjM5SzdhY1FwQVZ1eHVpNmdzT2xaOGZoeUdEVW90UjA5c29veTBlYzl1MUtFbForWU82bHFkSVFxOEVISHIyck8xQmtXeWtYbmNCVW4yMCtYam9RY0FHcWQvSi9vY2pzTnVCMzcxbWtrelo3SE1hazRiUVFvT1AzeDQvQ3NTNEc1Yk5QYkgvQUk4YTFOUnVCSnBxUnFPUE1KL0dzeVE3cm0wVWRnUDUxMXd1WU05RzFLS0tYdzY5cThueUdMTzdIUTQvK3QrbGVVd3d6VDNIMmEzeXpPMk1EcFhTZUtOZk53aTJObzN5QUFPVjcrMVltbFhKMDdVNFp5TytHSHRWd2k0cHNVbnFrWDU5TmowM1ZMYTMzYjg3QytmVTlSWGMzR2syT0JpMlJHejFDalBTdVAxcHgvd2tTT3h5TW9mYXV1czlXZ3ZiaHJhTnZNWURkdUZaVHZhN05FMHIyT1g4UTZRTEdJeXdFaFNhNTVMamJFd2JjekhvMjdHSzczeGNuL0VsWSs0cmo0ZE9pbDBhYTZMTnZTUUtCMnAwMzd1b3IzS2tkeTV6ejJ6VTZYS05Bek5jS2tnNkl5bm44UlZSTXF6WjQ0cUZzaVExclpNWE95NEwxZStSVXNWM0d4KytPT3hPS3o5Z2IxelVrY0FCeS9QdFRjWWg3U1NOTHpCN2ZuUzV6V2Y1bURnVkNXazNIREVmalVjdHkvYU0xV0lOS2pLT3RaOXJMTVorV0ordFMzTnc2Z05nRTU5S09YV3cxVXZxWENRVHhTNFVpc3NYcmc4b1B3TldySjN1aTRCMjdCazBuRm9wVkVXTmlBL09NaW8vTFZtSHk0eWVsWGpwczRDYm1BRDhCc2QrMVN6YUJmUVlaa3lxOGsrbUtTYUU1UkkxdHRvNkNuckRqUDhBS3MyWFd5cmxZNC9iSnA5cGRhamN2Kzd0OTRQZkdBUHhxbW4xRnp4TlR5a0VlNGtEMXlhaWFXRmVycitGWk9veVRpNk1jM3lNdkJWVzRwWVlnR1lEb0FQNVVjdWhMcWRrWDN2SVUrN2xqOUt2cmF6emFiTGUvTEdrWUgzdTlZcVJ5bTlDT3Z5WkdEaXV6MUdNUWVEV1U0dzBpaXBlNVB0SGM1blI1Wkw3VUJGTWNwNkFZcnNHMCtDMnRaQ2lnbmFmdkQycmpmRHlicjRzMlJ0cnJybTczV2JLZXluRGV0VFBjMHBTYjNNL3d2YkpKY08wblFLYXFUUnEzaUc0ZEFTUE00clIwRWlDM01qZENNVlV0c1Nhdk0zckljZm5VUjNKbS9jTk5rTGFsSXc0eW9CeFZhOFl0dERxUVEyTTFkbWNSek13KzkvT29MdG1rRVpJMmpmNjFLYnVhVzl3c1h2RWR1bU0vdWh4V1RHb2JXbEE2QURGYjE5QWtubEhjUmlOUi9Pc1NHRXhhOXR4akFHS3FOcm1jdmdWelhGcDlydXBONi9JcHowKzhmU2t2cGd6TEJHdUlrL1d0TytMVzFwc2dVQ1NRWTQ3QTk2eWZzendvb2s1eDFQclEzYlFJUmNuZG1iT2l2cWxzRS9LdE80aFY1bldWZDJSMUE1cWdWQzZ6RHhqQzlQeHJlRnVXa1k5YzFUZGtOYXpabXdRK1djWndvNCt0VHd4cVdJVTdRTzU3Vk05bXlTWkp5QWNtclMyeWJUMzNEdFdmTWIyS2MwQ01tU01nTjJQV29aTENPUnM1d1FPQWEwUHN6SVhSampqSTk2WjVFbVR6bkhYRkhNSEtlcnphTThraDh5WklnT0FxSWNBZWdxMnFXVnZFc0RpTGRqcVZHVFdYSnJFY09GdUxvdWRuOEMvclJwdXE2ZmR1OGNiS2tpak82VHFhRmJvWk1tMURVck8yY0dhTU1JemxSdDR6VUgvQUFrcUNSQkJFV0Rjc1Y3Q3A1STdUYisrUG1NM1huTldwTEN3YVBDZ0FISEE0cE83ZTQxdHFpQStJMGpRTWU1K1hJeWFGMStJcDVtMXNuMFdwbzdXMERuYnRBSGJHY1ZLa05vaU5oVlArNk90Q1V1NE5yc1ZGMTBTS0c1VUhzd3hVMzlwUnRIdlYweVBwVkxVVnRKU0l2cys1V0JMc0c1RmN4TFBCYVRLa2NNc201aU1xRGdVUG1RS3pPcFR4TGJ5U3RDMkFlZzVPRFVJMStHWElNQkcwSFBIYXNFU3hDUGVrZUN4NUREa1ZGZHlUU2xURUNvVVlJQTYxTjMwS1NTTm1YV2JabGI3UEdqRUhCSFRKcXN0L3FzazI3eUkxVUhnRnYwckhTNzh0Qkc1VkFwKzkzTlJQTGRmYXQwZDBKR0svSU04Q21rNzZob2RYSGMzZ1pwTG1DTXFmdTdEMC9Pb3pxTXBpY3RhZ0FINzVQRmN5czJvRmdaYnhIVmVkaUU4VlZuMWVRaHpJV1JTTUZzOVRSWmdkTU5kbU1teElDcW5qTElRS2ovdCs4aFpnOFFhUFBEbnY5QlhNTGRYS0tXTWtralozQTU3VmVqdmNvMzJnZktWejF5VG1tOWdOY2VJcDVEczI0eU9NQ3FMNjlPWnRwdU9jNUlQYXFVZDhsdkNQTE9WQVBCb3RmS3VKTi9rcGs4azQ2aWw2ak51RFhudVNGTE1Sak9jVTY0dnBvSWkwanNCbmpOVW1rVzBtM3h3bkxZNEE0clRsZFpMVUYxRGJldzVyR1Z6V05rWTR1ekpjcklybGt4ODR6NzFkWGZKZEZnZzh2SFhIdFRyUzZ0bmxJamhYS2puSXBYdjRncnJrcUZQSUFxZFNyM0tDUTNmMnhsQ29rZWNoc1ozZTFUM2Vuck5ic25Ba1BJSTZHcExhNlYyK1lzTjNBK3Z0VTdSbVJNcndSbmdHbjd5ZHliSTVxSFNycU1Nc203R2ZsNTRxeEZwOHFFUEk0YjNYSXhXcGNQTEZHQ0ZDbkhyV2ZQSkswZnlFZ2tWMEp5YU03UnVXNDVoR3lzcGJLKzlUbThNb3c3a0FWbVdyQkVZU3Rubkl6VXhsVXc3MVhQT09LZGdKNTd0RlVqYXYrTlFXODRkamdISTVPZTlJTmswNjVUaFR4VnlXSzNLQmJkTnA2R3BsWkFWWGszRUJlR0hYQjdVZ25ZN1VZQWdIcjYwOWJSUkt6QXRnTHlTYW5oUzNpakFrUUZ2WE5JWkhORU9jS1R4em1zeVZBK1kyR0JqS2tldGJpNGtETWZ1NHFuZFc2eXA4dlU5ZnBRblllNVV0Vlk3V1k0QUp6eDN6V3h1aU1JUGYzNlZuMmtiZVZ0eDkxaitQTldYMjdDRmJvY0VlbEYwOXdKQ3dmTzBFQURtbGEyWTdTcHprOGlrUmg1YStnNyt0S1hrTFpYN3BGR3d0eHI2VkcweGNOOHg1STlhTGUyaWpZb1JqbkpKNzA1RElVSkdRV0h5NHBxUnlMbnpHeTNZVkQxS1JjTU1RWGIrVk1ZcXV4RlBCNHFFdXpxTVpHT3RPVk44Z1lEcFVvWllIeU44M0FINjFISk9ZbEhQVTArVVAxNmdWV2VWUi9yT25yUVBVbmE0YVNMTWVNZzUrYXFsNWROQ3U2TlRqMEI5cXRSUW80L2RaNUdjRTFidDlLV1lCcGxPUFNpd2Mxa1p0aE85NWJnT0gzZlRwV25aNlNmSWRaQm5jY2oxclV0cktLM0h5cUIrRlRNd1RoUnpWeGgzSWMreFd0N0dPM1RDeHFEN0NwanRYakpISEFwclNQdCtYSDFxcUpuYVQ1bnlCeGlyMFd4bnEyVHErL0p4ajY5NllXWkZPeU1jK3ZXcFFBY2JBZWU5UFMzSU9TYzRQYzFGcFNaZDRwRU1FVXNuTndGQlBZVmFpZ1hjTUFaSFFWSkZDekE4SEZLWkVqTzA3UWM5dXRhMlNSbTVOa2lSN213RGoxT2VsVnA3eExNK1hJZmxQUmozcUs1dXBBVDVad0QyNlpyRzFLM3U3MGhsTzFWUGM5YWx5R2tXNzYrZ01iYmRyT09uSU9LNVcrMUpta0piaGp5U2VuNFZwSFNtalZ0N2pKOVA1VlFhSlRKNVRSWjJubmRVZFRRNUhWNXN5eTV4a2tZUHJYWDZaZU5GcHR2bkJYeTFIWDJyak5kVURVSmtRZktHNDlxNjNTcktTYlRyZGg4eWhCa2ZoUk4yUmxTK0ptajl1U1NKaW0xaVJuQVBXcUt0SmR5c1k1Y0hCeU52U3RPS0cwdDBaUEpDZ2RjZEtTT0tNSzNrSjk0ODRxRGNxd3dMSEdKTGo1dkw1R0Z6VmlXQzNsVU9xcU9NNEFyTnZ0UmF4Wm8yNTNEa1o1cXRhNng4cFZtOWxCb2JzVHU3RnFlUmZNWUtNSDE5YXhQRWx1dHpvekM1ajVMQUxrZC9VR3J5dEt6dkllWXkyQnhVV3V1WDhQbkkvd0JXNHgrZFRHN2xjSnhYS2VXZVRjNmZxaGZUaXhrVExEYU9jRDFydEZ1WmIvVFlwTGdBU011NXNkS28rSEFyZU1BQ3U0R0p3ZnhGYWVwN1lmTVdOY0t1Y0FkcTYzSzdzY2ZMYUtaMUdqUnhRMmNDR1RPWVVQSndSd0taY3lyYlRPWUJndDM5cTgrMGp4WE5aWFJ0dFlEbFZ3cXQvRW9IVDhLN0lJbXFXWnVMU2RXR01xUWVwckNjWEY2blhCcVMwSTcyNmQzWWhBU1ZwTEM1Y0tBeURJSVlnZXRXcHJUelJ2SlJkZ3djKzFWMWRMZEJLeFVBOWFVVjNHN0xVNWJ4MnIzR3FXa2NNWkpBNFVEUGV1bG0xT0d4c3g1emZOZ2RPdlNzWFYvRUZzTGhYaHdaczdWYXByZlRBWkJQZTVuZHVWeWZsV3RucWtZSzdmdWtGOWZhaHFNRWx5anRGQW8rOHc1UDBGTzhEU2hqZVNYSkxrU0FiajE2VlBxTWlmWUpVenQ0Nlo2MWtlR3J1T3hzNzJTVndxYjg4OXpqcFNWM0YySzVWR1dwRjQrY1NYa0lYb0FmNTFhMHdnYURicm4vQUpaMXpXc2FtZFVtTW80VlNRdGROWXg3Tkh0OC93RFBJZnlyUzNMRkpuUE5xVXJveDlkdEZ0YmFEYVA5WUM1OTY2blFMVXZvZGxoc2I0dUQ3ODhWaGVMVjIyMWlQV0xQNjExbmhvQWVIYk1FakFqQitsUkw0RWIwMTd4VThRMlR3NkRJekViUU1BNS9uWExlSGRZdTRMNFc0YmRDNFB5dHorVmRsNG93M2grY2JoMEIvV3VOOExXd244UXhvM1RZeC9TbFR0eXNLeWJta2R0QzFucUNBRWVYT0R3cDR6VkhXck80ajAyUmdyTWdIVWNpcjY2ZEQ1d1orQW80NXdha2t2NHJSaUhmZkMzQnlNNHBKcTRwUWxGYUhuR29BalRZUmpIek1mNVZpM2I0YVBhY25hT25hdlM5WjhPeGF0YTc5TFpFWmNzRi9oSk5lZHlhWGRXZXArUmV3c2pBNXczZjZlMWRjR3JIUEozTkhSTEJMYUI3NjlBTWhVK1VyRHB4MXJHbFRjc2hHZUQxcm9CYnRMQzV1WkdES055cUJ3YWkwU3lGN0RkdzRCZHVCN1VLZDlXVTR1MWpKdDVtdmJtS09Zc3pNd1hJOUs5RjA3UzdmVHlwZ1RCUDhSNm12UGRNaE1maUdDRitDSmdEK2RlcDNCQ3JFRXgxNXFhcjFzT0M5MXN4dkY3WTBGOGM1WVo5dWE1dUdQYjRRa2ZnYnJqcG5ucFhRZUwyeG9nWEgzbkg4NjUrT0RIaFB6Zldjak9mYXBoOElFVThVWThPSkxzWHpQT3dUam4vQUR4VzM0ZDBiUnJyUVZuMUpFRDdtM1NGc0VWajNzVC9BUENPd1NibENtWGFGenlUanJXZkNibWRVdFlOempQM1IwRmFOYUFudG9XdFZUVFd1QkhwTUxLRjZ1V0ozL1FlbFhMYncwSk5NTnhkU3NqTUNWVmV3OTYwOUswbUt4Z0Uwb1Y1aUNBVzZMOUJUTDY4SWhrQ01PRk5ZKzBlaVJxcWExY2pqWTR5UTMxcTlaNk11b1JzME4zRXNpZ2xvM3lDUDhhcndBR044K3RTWGNDVzBFVnhiWE9KRys4Z1BJTmROOWJHUFM1QmFMaWRoMTI4VlliVDdpK2ZaYXhtUmxHNGdFY0NxOWovQUt4czlTSzBCYjNrN2JiRGZ1UERGVGppcGxwTVVkaWxGQkRiM3dqditGVS9QZzFvUml5a251ZjdOUjFqOGsvZTlhcDJ1bVBjNnA5bG1iYTI3REVjMXREVEl0UDFDVzNoM1kremtrc2U5RTNwdUViM0l0RXY3elVOU3RiV1ZNeHBLQ1dDOWg2MTZUTGJKY1FTUk1CaG8yNXpXYnBVRnBiNmZBWW9EdVpSaHZRNDVOWDJZcmJUc0RnckN4K2xZdldXZzVhSG5WcjRmbjAzV1F1b1crWWpuWStNcTNwelcxSVJIRjhwd0JuSXFUUmZFNk9ua1g2ck5FVGc3dW9xL2Y2SXMwTDNPa3Y1MFlHVEgxWlI3ZXRFdFM2Y2xIYzg1MVIvTTFTVWpwdXFlM0grbE1Qb1AwcW5jQW5VSDNkZDVCclF0RTNYUngxMzEwUFl4dmRtcXlyaU5WL3ZEajFyb05jdFB0SGhBUmxpcERoc2oyRmM2RXhjeGp2dTRycU5abUMrRlNmUmdQME5aSzl4eTNPQXNOUXVMUnVFRXFqcnh5SzNvTlZ0cnkyWUI5a20wL0kvWDg2enZEOEt5WG5OWHIzU29OenR0MlNLZDJWNHE1V2JIRG1TdWpYc2g1V2xSdjZ0VlRUQUd2WGZHQnZPZnpxVzltbnM5QXRYZ2o4emMrR0h0aXFtbFNGMjM0d0hmSkhwV01VN1hLbTlMR3pLckxNV0dEazFXbGxhU1dKV3dQbTZBWXFlYWRSSXdiblBURlp5ekNhK1FxZjQ4NHhqQXBjcnVhY3k1TEhSM1dmT0F4OHFSZ2ZwV0ZISE5KcjdzU052SEdlZ3JjdnJlNW1rbEtmTEVGQXo2OFZ6dWtlWi9hTXBsT1dWOFo5YUl4dHFaem5kS0owYmViTGRBTUNRT0FTZlNwWkl3eWo1U0dIM2xQUTFFbDZBdk9NZzk2dUpjaGdjNHlSV2JUT21OckdGY3g0MTJNRGpDTCtOZExhcXNMbG1BSlBTdWNsUG1lSUdLOXNjZWdyZDgwSGdaNDdWcEplNmpLRDk5bGp6RlpqRzBZMnRUSHQ4U2ZKd2c1cElyZ0hBT0dCcVNTNU93Z1lBUEhGWW5RRWlBNTR5VDBOUVNxWU9VNTUrWTFKQkx1WXFPUjZVN3pPMmRvQnlDZTlHdzczTjR3eFNNRlp0bjk0NDNaOXFkQ2tVYmJFaDNoamtrcjIvcFVrUGgrK04xdWt1VVZCMEZUYWcwTnNGdGJYekpaMy9BSTFHUVByVGpGbUxhRzNEbmNjcGlQc0FjMU5MZTNNVWNSdG1UYmprRWM0cWdrazBEcDlxaWxaTjIwWUdUbjZEdFUwOW5xTjNjTEtFalMyWCtBWnl3cHFJT1F4ZFRudDVtYU1KKzh6MzYrdFRwclBteCtWR1RISTM4QkFHUlZPZVMxdDVtRTBhamNmM1lKNDk2VUdLZC90TnRCbFY0TWdYb2ZyUzFRelVkNTRyY2VURXNoQ2pBQkM1K3VUU3BQZHkya2dOc2tha1lCRGRQeXFtMTV2eUlNRmlRQXpkNjBWMW0yc0VXTXJpUnVxQVpwM3VndFlveDZOTmNoaklZMUpHZHdKL2xVYmVHYnNOaU84azJubmtWckw0a3RUUHRJNTZFN2FrL3RxMFl1NW1YYi9kSjVwcElsM09Ndk5BdkxNQW1CYm1QY2NrdGdqMzlLcmVaYmhpZ0R4c1IzRmREcjExRGN4dEd0dzBSVmMvSlhHbVRZQkswdVNWd1Z4ME5iUlhNUTIwWEk3V0NQSVJteTNBM0h2U3lob1l4RGlNcmpKSU9UbXFVa3hhTldWdVZQVW5yVUNTT3NtNlY5NDl1dFY3TkJ6Rm4rMFpBRzhxTGdjWk5WemU3bVlyODIwZk5nY2dWTERiVGJXRWNaSlBRbnZWcXh0Wm9HY1hNS0tNOXU5UytWRGltMlJSeVEzY1NoVmtCSTRCSFd0U3l0WklpQXFIYWVyWjZWTW9UeStGVUVkUjdVNk9jSVNjOGVsWVNrdGphTVh1WG9yYzhlWk94VUhPS2ROKzhqS0l5cjZNQjBxcjU1bVRFYW5qZzFBa2N6T2Y0TUU1QjlLaFJ1aXJsbTNpYUJXd3FzemZlWWNVWEpobFF4dXFzdmNBMVZsKzBHSEVTNFBVODFpK1hxYzl3eGlqTEQwSDg2ZW5VUnVHWUpnSW9LZGw3TFVndUF2S3QyeWNWa3hhZGVHUm0zTmpnWWJ0VnhZdGlrS09RQjFwWFhRZGlhUi9OWDcyVCt0VW1qbExiVnlBdlVlMVRzNUI3QXFLZkhJV1ZwSEhHS3U5Z3NKSGJMSkUzWHRuTlRXdGlzYWhOeEl6M3AwRzBxY2RTTTRvWml4TzNQWEF4U3V4MlJhaHQ0dHg2RHRtb0xpTkluRElldnYzcHNDc0pGd2NBSG1wcDRWa1ZneDZuT2FqVzQ5REtMdS96ZENEZ1lwNnlPcURlQ1Rua250VTRpS1JuYmpQb2U5UmpjV0tObmFhb0ZxVFEzS3FNWUhUdjJxTjdpVHorVitYSGFvNHJSU3UvSlVnNUh2VmtrSXdadTM2MG0wRnJETFVzeXNTTWtqUEZXVmpTVDVwQms5QlVhdW8rNE9EVXE1VmQyYzVPUUtWd3NLVndWVThLTzFTRVJvbTdPS2lETjV1VHpqb2ZXbXp6WVhHT0NhQkZneTdVQUhHT3ROWnNydVhsc1ZWV1oyVTV3TUh0VEpiaG81MXlQbFBGSmdPZWNsaUZIUGVud1hEcVJ1NjA1SVBPK1pZOTNjSDFyU2gwNHpZWmh0eitsSXJSRGJlVVRwd1BtSFdwaHBLM0IvZUQ1ZW94V2hCWVF3YzhCajFQclZzbEZBNXFsQnNoelJWdHROaHRUOGk1STdtcm0wWTRQMXFONVNGQlhqMk5RRjUyWGdoZlhGYWJJejNaTkl3QUFCMmoxcWhQY1JvL3dBem5QMXAwMFRNdTNleFBxRDBwaTZaMGVRYm0rdEozSG9TUW1TVThLeXIyeU90V0Z0RnlTM0pwNkF4eGdBWUFGQmVRdDh2VEhJcHFLM0U1RW9pd3U3cjJxUURJSGZOVkpaWFFCMWpaaDZacXBOcU54dDJ4SUZKNHllMU51d3JYTk5wUXFrZEQ2aXMyVXRITG1SOTVZL2xWY1hjdWNTbENjWndLVDdlazhtQXVNZHF3YmI2bTBVa1htZmJEL0FjOU05cW8zRTVNYmJXT2V4RkUwcUZUd1Q2R29HbENMZ2djZEttOWl1VzVVa25ZS29iSk9jOERyVUR1V3llaGJuSkhTckVsMk9XWGpqc0txM0R2TkN5UThPQmpJbzVyc3Exa2NMckJKdXBXYms3dVRYVWFMcWFDM1NJRERLZ3h0SFg2MXl1cEkzbU9IeWNQZzVyc0xDempGdEVVUlYrVUhkNjhWdFBaSEpTM1phdjVnME80c1F4NTVBR1B3RlI2ZmRvOFhVQnVoNTcwOW9JVitSbTh3bjlLeTdxRklaQzhUWXh6MTYxRGFPbElicmxuSmRUaVpEaFJuNVIxTlY5RnM3ZG1WNWx5UWVDM2FuUTYyV2tLU2pDa2NHbjIxM0ZHekJHREJ2VHRTMUZ5cTl5eGV5MjluRVZpWmtCNktPYXlkVzFCcDlOWlR1R1NNRDFyVnVtVjlxcXZIZmpOWW1zUkg3R05xNEFZQTRxNFdaTlM2VE1QUUZkdkZZTWJoVHNibjE0clQxTWtPNnR5U2NWbWFNSEhpSnZLSEt4dHpXbmVoUzNtU0grSVpyWHFjdjJVYmVvK0ZOSjFlM0huRXh6bGZsbEJ4ZzRyaVZ0ZGI4SmF2NU50bVNKamtZNVJ4Nm4wcnExMWFBUkJnY2xlNVBlc3E2MVc0dm1aTFFiczhiajJxSTNXak5wdUwrSGMwTDNXOXRuRUpTQzVHUkdEbkJQYXFNT25UWDdpZlVwU2tmVVJLZVQ5ZlN1ZTFiUzc2SXBPSldhUWM0OVBwVnJTZkZHVkZ2cWkvT09CSU9EK05XbzlVUmQzOThnOFVSSkZyRm1zS0JRTm9DajYxMktSeXpRYkFRckVjZTFjVDRqazM2dGJPdkl5Q3BQZm11cGwxcTMwcUR6WkVKTzNwdTVMZHF2b2tOT3pabTZ2WXpRRm5uSlVFNFhKNm11WnNkS3U5WjFCclMzWXJEdTNPeCs2S3R6NmpmNi9xRFhUcVJCRm41ZXkxdmVFMEgyRzVaZHU3emNjOXVLZndyUXp2elBVNXJYZExHbE5IYnFRUVZ6bjE5NjZtMUFHbHdyL3dCTXdQMHJGOFp1R3U0c1k0VGdZOTYxMGNmWTRrQi9oSDhxSHJGWElsYStobCtKbitTQU1jNGk0cmYwUzN1WDBlMjhzaEU4c2NuSnpuNlZ6M2lZRU5HcjQvMVl3UWM4VjFXbFg1ZzBhelhjb0N3cmdkK2xRMTdwckIya04xcXptaDBLWm5sRWdHQVJpdWM4SXRKSDRtRFJBRWlNNUJHY2l0L1c3OFQ2VThTeUtTeEJZQStsYzdvRTR0OVhhUU1GQmpJQlBGRVkyVmhTazNNN0xVYnFSOXpDSUtBZld1UThRWFU4Tm1KUE54dU9BT2VmYXRMVk5hamdqRE1TUm5PUFd1THVMaTUxcThVTzN5amhSMlVWY0tldW9UbTdhRnZRL0VWNXBzelNibWtqenlqSGcxM2RucTJrZUk0UWwzQ3ZtZFZEZmVVKzFjSHFVY1VNRU1VUzRDcVFUNis5TnRWZUNTSzVRbklBd0JWeWluc1lwSGNhdHBFa0dteWVRdm5SQlNRUVBtWDJ4V0w0UGdoYTF1UE1ZSXhreGsxZjB6eFY1WldLOTRVamgvU3RLYlNMYTdoKzBhV1ZqZVQ1anQ2TWF6MlZtYUtUdnFlZTZveVdYaXA1Vis1SE1EOWVhOUZab1pZWVpZSkJJcDlPMWViNjlhM01HcFRDN2paR1k1QllmZStsZEY0T3VXbnNYVjJKTWVBQWEwbkgzYmtLVm0vTW44Wk4vd0FTbU1ZL2pITll2blJyNFBpajNMNXJYREhibmtqSFd0WHhrNEZqRU04R1RwK0ZjamJJdHpNRmxrOHVJSDVtSm9weHVoTjJFbnVKWlVRRXNVWGhmUVYzWGhMVEptMEx6WUZnUnBTU3p0OTdGY3pxRjNaU1dNZHBZY3JFZHhPS3FKcmVwUld5MmR0TTBjWS91Y0g4NnBwdlFhZkxxZHBjeXhXVVNyZjNOdUFvSU94c2tacm5yM1dkUEViUjJrVFB1QkJaeGpuMUZaY1ZnODU4eTZuQ2tubkp5YTFUYWFYYWFmSnRIbXlsRGgyNTVvVUl4WlRuSm94YllBd25IVFBldEMxOFBMUEY1OXhjaFZLbGdxakovR3FOb01RNDdaTmJNVndWdEN1MG5DY0VIcFNkNzZCR3pXcGgyS2Z2SDI5dUszdE12a3NKWGFZN1JJdUFheE5QSHp2V2xKQkRPdTJmZVBRcDJxWmF5RkhiUVpwc3BrMXlXVkRuTGtnL2pXa3JOSnI4Z2NuSmdJL1NzdlRiVmt2V1VjRGtoajJyUnMxSC9DUmJRUzJZajErbEVoeE9vc3JveWZaNDFKQTJqUHZ4V2xQeFlYWjlJRC9Xc1hTdm1takpHR0F4V3pkWS9zbTl6eURFUitsUXR4VDNQTmRFaldXOGRYNHlEaXVqdGJpODByOTVieWtybmtBLzByQTBDTXRkc1F1ZlRtdW1tc1g4c2xKTXFlZzcxVWszTFFjYk5EYisyMHZ4T20rTkk3UFZGNTNBWVdmNis5WUZsWVQyK29DSzVpWkpBNXlEVkQ3WkpIZXlxRGdCempCKzdXN1lhdjUwcXg2Z2R6NStWejNxbTVJejBGYTFFZDRyZ0hCYm4ycmMxWlVsOEt6WTZJUVRqNlZsenloN3lHSU1EODI3OEsyTlVKSGhlNkNwOHBYay9oMXFkYmpmeEhJNkFqbVJ3dllaQkhhdGk1dEZsZ2VWaXdLZzRIclZQd29pRzZrems0VG5GZExmUkl0ak50eGdKa2ZsU2xlNXJDMWlHV3phNDBLMUNqTzBrbjhxeDlQWE40NmdmOHREeDZjMTEybjI0bjBpQ010c3ovaFhMMkh5NnBJQzJkc3JEOWFtTnlhbHVVYnFPamFyWlhVbHphTjUwY2gzRkFlbjRWRllYVFhOMUZGTEMwVWlIa2YvQUs2N2s2ZExOQ3N2blkyOGdZNjFuYXBackZlV1JZRHpUbmMyT283VTA1UFJqa29wYUdocWtrY1Ztc2NyTW04QWJrR1NCNjRyaU5MVVJhMU1wTEVCOEExMG10ZUd0VXU1aGVXVjBHd29BaWJqaXVlMHFLWk5TbCsxREVpc1E0OUNLcEdiVmthRXNRU2JraEJuMTYxYmlrQTJuazg5Y2VsVFFOcDkvSDhrZ1pnZWpWWmh0VmtmYU9BS3l1ZEMyTWUzK2ZVNUdBK2JPSzA0UWRoRW5YT2NpcXRyR2k2eE42YnVBUFN0Y0lNT3dYQUp5UGVybExRaUh4RlpRY25BQytqQWRhZ2VmWmxUeU05ZlNyVWxyUGNMaEY5OGp0VVA5aTN6QXV6S2VjakhjVkYwYlhHUnpTWlBIQjcxTU15QUFZK1huSnF4SFlTRTRmZ0hzQlVpVzA2cWYzWGZnOWhVdG9wSHBFMXNyUjdsa3pnWkxNYzB6N0RDektRMkRqUHluR2ZyWE56YW5NbDJFVnNRaGVOeHByK0lrV1JWNTNkQ1ZQRmFXc1luVkdKVUcyTXFHOWZXbVN4Uk5DVW5iek05UmpOWTBHb3RQdFo1QjhwendldnRVOTNxMFNRZmVHN3NNMUhNVlpra21rNldXWGRER1QyM2o3bzl2U2xrbWpnVmJhenRBOEtIT1EyS3htMUszbWovQUhoTE9xbmF3UFltblFYREpFdTZRRlBVOVFLVG5ZcU1HelhlSEtzOGNNQUxENWNBWlUrNXJucmg1RXV3NS9meko4dUFUeUsxMXVSY3BoSkR0UHA2MVduczFMZkl1M25PYzFQdElqY0pITzZqY1hsdkk4a0FqK1pzTXUwL0xXQ2RTZWFkRnppVFBiMXJ0SnRHOHlZTjVuSGNlcHFPTHdsWmlmem1KM1o0QzlzMWFyUlc1UHMyY3pjVDNZaWlkUzJHR1dPY2cxQUVlZWNweXJOMXlPRFhjeTZMWVEyNnFGT1VPUmsxVm5odGZLWXFBR0E2anRRcTE5aCt6N25QeGFmTTIxdGlrQVlCUFNwbTBxNlppclFaWUViV0hmOEErdFcxcHNXMjBWQis4TERQWHY2MWRSZ3dVRThyMnFYVmtVcWFNZTIwcTRLeE5MSDVURDBiT0t0WEVEaU1iWTh0bmtrMW9TeU9qWUJHT3dxcmNYVFJnb2VRUWVhV3IxSG9pb2xwSzVPQmpIOFZQaTBqRHZKTVdHMGZnYXRJK0xQNVdJSkhGUlMzbXlJcXpET2VjMU5oOHdpelJRcW9VRURwejNwVGV4UGtETE4yOXFpTVF1dHFvMkFldUJUMDBpSzJuekV6WUk1eWFxNlNKczdscTN5ekFZNEl6elZweHNHSWowN0FkYWdYZEV1QXYzZlduU1hBa1hsZm03aGF6NVcyWGV3Mlpzcjg1WlRqZ3JXVkpNc1RNRnllYXZzZnRPTVpITkw5Z1ZDVHhuM0ZXbFlMbEllVzRZbE1OZ2RhV05ITWZsTHdDZlR0VnMyNkY4TTQvR2x3c0lYQ2pPY1pvZW9GSmZOU1FsVXdCeDlhbGpoZERsanlUbkZXQklqNVU4NFBHS1pLR09UN2NWTHVoclVhSEtOeDY4MVB0RHdaeWV0UXFwTWcrbFR4bkNnK3ZhaHlEbElwYmNrTVFjRTlEU1IybVl4SnZHT2hGV3lCdDlSVVIyS05uSVhyeFU2bElnYUR5a0t0emsxQzRMUmdlaDZWTkpNSDZrbkhlcS9tamN3WG5pcWlyaWJFajNCZ2gvT3JRQkFBNmlvRk9EbHUxUzUzREFOVTFZVzVQbjVja1V6eTFkZWVwNlZGSElkNVRCOWo2MVlodDVKNVB1TW1PdWVocUxqc09qc1ZPY2puMjcxWnQ5UEV5WWVJZ0RvV0ZYcmJUOERMVmZWRVhnZFJUVUcyVHpwSXJXMWlzU2dFL3BpcmdWVVhqcFVaYkZWNUpobC9uNkRtdFZGUk1uSzVNOGlxZmIxck92ZFJqZ09RMmNIb0tlN1JtTUFjNTdacUNOckV5YlNxcy9UQk9jMDdpSFFYbjJsdHdKM2RnZWdxd0lYbFlmdkdVKzNTcmtVU1ovY3doVnhqN3RTZVh0UFRIOWFYTDFIZERJNEFpZGNudWFsUmM1d1FjVUFCVllzNTRHY0VVTXFnaHQ1SXhucFQwUk9yRzVCYkNyejduclNQTGhzRWJBUFFVa2txSXdaTUVWWGNOSy9tRjFDWjZIdFVPb2pSUWJJYjYrQ295ZzRPT09hNTZYVW5rbmxXTU51WWdaR1NCNjF0eklKTTRRWlBHN0ZVTmlRS0NvWGQ5S3ljelJRSTFDNU1oM1pJL0trV1JZbTNLUmttbVNTUHV3dlJxZ2xjUllkeitGVGN1eGVNckFFN2h6MnFEN1Z0eVcrYkhTcXMwMkZEYnVNVlFrdkVBTzg0N1VKWEdPdXRRMmx0aThEcms5cVd6bEJkbXoxR1J6U1d0ckZKYmw1aXI3ajFKNHhVTnpONVFBakFCQXdEaW5vSzdPYjFLY3EwbTMrT1RxZnJYVTJFOGt0bXFPQ1FCakdNVnlsN2xwRUxkM0hINDExMjd5NFUzOGNkdlN0WmJITlJXckk1VW1oREdMa04xSXljVmxUM2dGMG9tUHk5RG4xcmREcTJDV09NZHFobTAyM1lOS3dRakhHOEU1UDRWQjFiR05KYndTc0ZYYUZaZmxPYWxzOU5naFlPSlNTQnp6VTl6YjJ5cWpKbmNEMDlPS3pwTGhvd1Nya2VuSFNucXlkQzdjWFhseTRCNmQvV3FXcVQrZllxZUNRNDRBcXJGSTA3b3N6ZmRPV0o0ejdWSGU2bGJXM3lCUVQyWE9jMWNZMjFNYWtsYXhXMGVONHRia3VKUVJFRkkzZE0xTnJKVjdLWFlEdTZEUHJXZGIzRTJxWG5seXUwU0tOMjBmWHBXcHFSUm9Rb0FPU09hMVc5emxhMFNNR0cybE8zN1cyVkg4Q21ydjJneFlFZnlqb01VakJVYzd1blRnMHc3V1VnZmhSYTUwSzBUWFVQYzJxYnd1VjVITlorbytIbHY4eXhGWTVnT1d4OTZwN2FPY1FydU8zSTRQclZpS2RsaS9mT0NXNkFVbEdTZWc1U2kxcWNMZHBjMjA2eFhlNE5FZmxEZWxUUkxkYTFlZVpjRStXRDh4OUsxZGV0UmV6K1pHKzBLTWM5VFdaWTJ0eEJQbUtRa0grRURyWFNyOHB5NktSMDBza1Z2b3B0N2VNUm9CakFIWDNxaG9keVlFbEFmYmwrVCtGUnZKTVZLUzl1MVZMTlNFZHQyQnVyUGxMY2xmUVhYcFB0RnloTGJ6MHpYUTdBbHVENkxYT1hnRHp3YmNuNXhrNHJwTG1SRXNXR2ZtMjlLSkxvWk42bWJQSmJUNU1xbHpqSEkvbFRZNzJORlJJMmZDL0tNOXF6VEo4dkxZNTlhaU00NkFISFkrdFg3TzVvcFdOcHJzVFFzaTk2eUhtRnJQdkk2RGdWTGFOdmM0UFB0VkRVTnpTQmUrY1lxZVZLVmlKTnQzSWJxNGx2YmdaejE0SFlWYmdqUzJUZ2pKNm5OVm80ekhHY2daUGVsY2dxQjB5SzNzVDZrazhna2pCRGJ0dnJUVWtjS05yRVZHcS91bngyTlI0ZjBPS1NRWExSbXhrT3hJSXEzcFd2WE9ra0NLUXRIbkpRbmo4S3l3ckFjMHBIR2NVM0ZQY0QwVzExTFRmRkZyOW51VVYzUE8xdW8raHFyWWFHbWh6VHBETDVrY2hCWFBVVndNYzB0dk9KSUdaWEhRZzRyczlEMWFhL3M5MXo4N3EreklGWVNnNGdVL0d4emIycXFlckhQNVZ5QXRtWnY5bjNOZDdyVmxIZlhjRUVwSzVVbFNPeHJudFUwQy8wM01yUmVaYjlwVTVINCtsYVVwSzFoTXlvb0JFallPZUtrak9GemdacHNiYmxQYW95VHVJQjZWZlVPaGFFdnFhSlpRWTNDc09uU3F3a0lRakdTZldtSEp6bXJzSzVkdFJtM0dCNm1tQ2VUNWxETUIwcXpiRUxhcjlDS29PV1dSdS9OWlIxa3kyOUMzcGlmTkptcjF4OGdVOEFrY1pOVjlMQmNTRTFMclJhT09IYjFKTlp2K0pZYWRrTlM1a2pJQklQMHEzb3orWjRpUnZWU1AwckE4MlRQM2MxdCtHOG5YSU4zY24rVmFUU3RjU2VwdWFCSTc2bEpsbTJxRHdUVzVxMGpSK0hMMWxPRHN4K3RjNzRiRERVN3NNYzR6L090cnhESnM4Sno0UExGUWZ6ckpMM2hQYzRyUjVHdDBhUmVTVGl0SWFqSXpmZWI1ZlExa1FFUjJ3T2NET0tjSkF2SkhQdjZWcnkzQlNzWnU0TmR5TVJrbGpXOXBscEZlUXY1d3poTWdqc2F4RWhiekhiYXdIVVpIYXVrMFFiSUpUMEFTaVNKSzJrMjBxNnRtUi9NVlI4cHJxTll0bnU5R0VOdklBL2RUL0VQU3NiVFhEWEJiQUJYMHE1NGp1SmJhMnMzdHo4eEp5UFhnVkQzRHFaV25JOWk3WTNCOFkyNHdhdVhXcjNNa1FpZUkvTndXeDJwTERVN2JVWkJIZGdwT3Y4WFExWnZ5WTdkZzR5RDBZZERRKzVwR1JjT29UUnhRTGJrcXFENWlPL3RXVHByYnJ4M0k1YVFuOWFtWVNXMXRFMHhCRG41RjlLYnBVZnovTjFMYzFuRFJDbXowT3dEM2xzcGg0alVjbjFOYzlxZHc4dXRSeFAvd0FzMnd1UHJYWlg4dHZvSGhkSkJ0Um5VTEdEL0V4SFd1QXR0OXpxNlN2OTRrWjc4NXB0V1FSMTFPcSszeEtyQ1IrUi9zOUs0M1QyUzQxeTVJWGNHZGllT3ZOZEJQREc3a3dNSGM3aTZkTVZ6T2piMTFXWTQyL01jajA1cVZvcmx6dFl0UzZaRXJuN01GZzU0d2M4MGkzK29hZmNMR1Y4eEdiR2V0YWJ4akF6eVNjZ21yc0duVzF5eGVlUXFoWE83cGcrdFpwM2VwdFpXTXkzQWE0V1FjYmlkMmY1MXFpNnlCNWpSdHpnSHBWYTR0bzRNR0lIQklBQi9pOTZwUk92bkVjc2M0SEhTazdnckk2bTJuaENlVU51NGpjUC93QmRYSVdpZVFJT3VPUUdQRmM3YXpsY0s2aG1iMzZWcTJxU0FpUWJXT2Z1SGc0cFdiMkdtalNrdFlHSzhzUTMrMGFndW9VZ0IyTmhkdkF6MHF2SmVQRUg4eU1odzVBNTRxdmVYTXpxRkNiZDR4dUpwcVBjTGtkeHBzeGpLdk14WnVoTEU0cGxwcGdHWW5ZbjVlYyt2MXJURjFHNHpLYytncDRsaE9TcDY5QlRjZzVTRmJYeVFHaFlraGNFZXByTnVyaVovd0RYcVU1d1ZQUDRpdDVHVmxIR0FUMUZPa3RZSmdmTVFkTWsrdFJ6VzFLc3ptcllUa3V1M2FwSjJuSGIwcTlaU1RMOGx3dTRlcHJkRnZCOW4yS1J0QnlQVVZrWExEN1E2TzJBcDYwS2FrN1dIeXRGNjNkb0pGTzBLV0dRS3R0ZE9WWTdOeEhTc1NKcHJtNVoyYkNLTUJ1NXJVaWtEUmdLY2dlcHFKSXVKQWRSQk9TU2U1SHBUVHFwRDRqalk5T2NVVHBBcFR5azNCenl4N1VybFluV1JvZC9HMGp0VXRvWk04ak9nK1luUFhCcXZJa1RLSVdJUVNjQW4xcXhjYjNRZVFGM1p6Z2VsUklyU0tGdW84dkdkeW5zS2xKc2JraXhiV3lXOGE3UDRjZ0drTnpHSlFYVExFNUZPWXhyems0eG4ycUp6R0k5NmdFZnJWY3JzSlMxS2VwMzl2RmlRczBaWDA3MUQ5clc5aEd4aTNHUVNNYzBYaVJUWUU4WVk5cWhtWjRiY0dPTWhjWkNnZGExaTlMRXRkU1FpNUtqeWVSM0hwVERwOTFKaG5ISGNrOWFsdEpXZU5XQUtNUjBJcStTNVJTT2M5YVR1dGdSV2hWN01CbzIzY2RNVnJKZFJ1Z0NvRmRoams5YXF4c2dqTy81UUtna2RIVXYzSjQrdFRaUGNiTGdDczdCbndDT1I3MUFDcHo4K0QyOVRWUnBKVElRQ1FPdFNScDh3WWRBT2MxZXhCWVZGZ3kyNDVPVHpUVGVaWGpubWlUNWx5VG1zOWdZNVJ0UEhRVXdMTTJTdS84QVNnelloQ3QyN25yVWFNOHBDa1oyODVwb3RaTHlWTjd0RXE4Y2Q2TER1V0lBV0FJQjlmclRwYmp5Wk5wUWoxeWFkRmFTeVJaaVpsUlI4K3dFc0JWYzI2U3RtVGVDUmtOSStjLzRVdVcrNGM5dGpSakVZUm1kaXBLOGUxVi91U1lWaTNPZWFCR3pZNElBWHJuclVnaGpWMWJuR09RYXoyWnBkc2R1YnlzL29LcXROdVU0UElOV1NxcW93YzVPYWllQ01zY2puMXBYR2xZejU1TzY4QThZb2pZaU1iY0ZxMFJZUkdQSStadTRKb3Q3QjJaZ1VDRHNhdU9oRE1pNGt1U3krVEV4UFF0VnV4anV6dTN4a2VoRmI5dnBQM1E3Wi9DdENLMVNFWVg5YTBTdVEzWXAyT252NVE4OEtlNFBldFJZbFJRb1hPS0ZCSExGZnlwWkdBVUJ0M3FNREZDZ2tUenNDL1BISHRUR0VoSjI0SEhhcU45ckVGcVFDdzRPQ1QyRk10dFdpdUdkZDU1NzQ0TldTTGRTNmtEaTNnRGUrYXpVMDNVVE1aNVpncnlEN2k4OFYwTVZ5dXpadUJ4MUJwSm1kY3NnREFqN283ZTlDMUVaS1dFbTNaS29QUERBL05WdXlzSTdmS2VXR2R1cElKeHpuclZqWVM4YlJnN3U0NlpxOUhuYVd4dEpIcm5GR2dYWkFVZVBndHQ5S1ZYWUtBeHl3UGFtdW43ME55eDk2ejViM0Z5VkJCSUJOWlRsMkxqSHVhanVrY1VyT2VBTTVjNXFySE9YdHd3YmcvZHdhemJpNjgrMzh1V1lyL3NxT3Z0VU1PNktOVkRiY053RDIvQ3M1U3VhUmpZMWlSdTNTSG9Na1ZVbHVFYU1oVGdkY1ZDK29JamJCeTQ0TlZwN2dCams1T1BTc3pSRXIzRHRDeEJ3ZTNOWjdYVWFwa3ZuSjVKckx2TlY4cVRabmFRYXliaTdLcVNIenowOXFhUTJ6bzJ1a0JKRzArbnRWTzR1NDVGSllnZ0huSEZZSzM3OGdnc0QwcGt0OHFoMWZnL3lxdVVYTWpUVzdsWU15SGc5QWUxQ0ZKRzN6TVZKNDRIU3FkdGR0UGhZM1VER2VhdHZ1YUVLcFZ2Y2RhMHRaRWN4YWFkSW8yV050elo5YVpLOXRjcXhrWWhoMjZWbFhCYUdOV0VtU1d3MVZXbWQyVXB5RDNxZW83NkZhNlliMEE1dytjbXVndDVHdThzcmRNWnpYTTNSK1pjK3RkSG9VOENXekZ6eU9hdWV4aFNlckx5REFPNG5CNUFQR0tTNHVaQkFVNHg2ZzV4Vlc0bWFTVXRqQzFuWGQ4aVJrbGdmWUdrbzNOWlNTMUpwWkhrWE9TYXpicWNKR1ZaK25iUEJxQkxxNjFIOTNhd3MzUExEaFIrTlNSNlF5c1RPL215OWw3Q3Jzb21kNVMyS3ozTnhlU0JVSWlVajd4L3BTeFdRZ2JkamN3NWFSaHorRmJhYVk4cWdGRVVxTUszYW5EUzVWdDUxWStiSVJ0VUtjak5VUzBvclE1U0NZdzM1ZUFFakdHSUh2V3ZxYXN5Z0tlZWxSYVZwbDFGcU1pengrVWpLY2wrS2ZkbmRjQlQxM0QrZFhiVXdleVJTaHNwSldCZk9PaEJIQXE1RGJKWmxpcFh6QU92WEgrRmFFY1FWY3F2eUhQUE5WbmlLb05vWExuZzFScnFRTzVYSFVEYjhwWDllYXFsMkNqRzVjYzVKcTNLai93QUczSGZJcUFSdWZtSlVEUFE5aFZJaGxZUlRTTnVLQmtHZWU5UkZZMFliQTN1QlZ1L21tUlVqZ3h5TXFRS3F3eTdJdm5ZdExubFZIRldpUnNxZnU5d3pnZXBxaWtZK3pPYzRiZDA5SzAzQWtESnp1eDBJeGlxVUVjaDNSc0FCdTUzRHJSMUVOaGkydkZrbHZtR09hMnJvcTlxNVhydHh4V1pFdittaE9jQThjVm9YUHkyNzRIYXM1N2k2blBOYk9TUS9DOTZYN0t2bDhaM0x3QlZraENDemtra2V0THQ4bTNMT1RsdVRudFd6ZGhNZ2dmeUpqaFFTRjVIclZhUmQwM3ZtcDdlTXZNem5na2NEMnByQnZPYlpqUHJXZjJnV3hHOE1tY2JlM09hcHl3c3B4ejByV2ZmY2JXQStjNTNjNDZWQ3lBSExqSzlEazlLMXZxREtNYWtSdDlhUlZaendUVm1RSWM3Y2daNHozcDZMR3NMdHp2eHhnVWRSRlFvMjdiMStsT0NuT0FLbWtrUVJxRkJESHEzV29Va3pLZk1jNEhvT3RVQlhtTGdoVVg1bTcrbGRaNFNpMmFmSUQxOHl1YWxaZk1BVHA3MTFIaGtsZFBQdTVyT3A4SUxjWHhISzBHb1cwa1p3eUhJclEwanhURkxKNU53cXhsdUNHT1ZZVmllTFdZWFVaejJybmR6Z0FqclV4aW5FR2QvcTNnNjB2bzJ1ZENBaG14bDRNL0szKzc2VndON1p6MmQwMFZ4RTBicjFWaFcvb1BpaTZzR0VVckY0aDB6MUZka2sra2VKcmJ5cjlFa09PR0J3eTBLVGc5UVBLbFRQV25iUm5HSzZYeEI0UHVkS1l5MkxHN3RlVHVVZk1nOXhYT0RLNXozNEZiS1NhdWhGKzBRR0FCdjRlbFVuQUx0bmptdEMwWC9ScysxVmpIazgxbkg0bVU5aTVwQ1pEQURxYWwxaVAvVmNldE8wcE5yTUIwelVtdGdqeWVPdWF6LzVlRFd4akxFUldwNGRUR3UyK2Y3K0tvZER6V3RvQURhdEF3STRjY1ZyUFdKS05IUlIvcDErY0RLdVJ4OWF1K0pReDhMWVFaM1NxTUQ2RS8wcU94ajh1NjFFa1kvZWtmcWFYeEsrelFvQVRnK2NNZmtheWp1TjduSnd4cWJUYTV4em42Vk5GWm8rOW1iR3dES3NldFJLUVQxQkJxUVo4NVZjY0hnbXRnc0pKRW9pZkRuR09BQUswOU5RSnBGMFc0K1FqUHBWQzVWWTFPQ1FEMEI2MXFXYStacEV5aitKVCtOUzJJcTZRRjg5dHJGZ2U5YTJ1cm0zdGNZSUc3ZzFuNlhBWTVpTzlhMnI3VEhBcEdTQVRpbzZoMU9ZdXJUeng1aWZKSU9tRDFxN3AxL0tzWGthZ2daT25QSU5XUmJxa1lZT001NzB3UmgyMmp1Y24zcUp6THNUM0twT3NjZTc1RlBIUFNuYWZGNU54OHpIS244NnB0RThjZ1pEaFIxVTFhUU1raFlLd0FQT2F3NXJEdGM2SFVyK2J4QmZ4bVhBZ2hVSkdySGdZNy9Xb2JjUlJhZ29iNU1INXNldFpVZDFKR1NFMjdtKzdWbTNUeTlyeXR6bm5uclRjbTBVbFkzRGJwTk0wdXlOY0tlU3U0L3JWS3cwaVdTT1NaQ3FuY1JuR00rK2FzMk04VHptSUhjdU0vU3RneWZZNHpLc1lLZWdYclRVcmpzbVlTTUxjTkhQOHpqako2YmFtZWNZV01TcWdaUURzR0ticUZ5Sm1PSWdRUndSMUFyT2hqbGFWaStBcFB5ODlLSEUwUmZhNGFKd1hmelIvdGpvQnhWUndFa0t4cXgzamNNbnBVOFVRVS9QSmc0NnR6am1uVGhXWVMrY01yMENqZzByQVJRTXlUQmlwUHQ2MTBNTjR6cXU3K0VjWkhUMnJuUmU3UGw0d3g0OWF1d1NNeUVnaysxS3dHcTIyVnNzQVJuSkhxYWh1cmhSTUN6Qnd5OFlIU29Ma29JOHhTQmdPb0E1ck1rZVR6Z3dJQ3IwSjcvaFZYdUJyUU5JV1pSMFBhaUlmdmlCbFNPM3BXaXlvSHlvVUhHMEhwNzFYbGFKSEcwZ3VSeVIzcE1wTW5TNEtRY0RQT0tuZ2w4MWN1MlBZMVFlZFVoWEFKTGNCZXRNRWtpZk02N2VPQm1wNUU5aXVZdXU3UnlZamRnT3hKeUtvVHl5UlhMcklOd2t3UVI2bXBJNVRJKzUySHNCVU9vVGtCQ29HUTRIMTVyUlJzeUc3bW1rYU1HYWR5QUJ3Qnh4U3d5eFFsZ0Q1YWdmZWJ1S28rZTg4bjN2M2E0NmR6VXBDN2dqUm1SbkJJNTQ0RlR5WEhleE5ib2t3Y3BPQ2hQQUpxZFpKcFNVakoyOXM5cXJ4MncyN3Rtd0tPZ1BXclVjeXdXKzFEdFZqMkdjMHVRZk1FWG5pWDk0VktqdU9LbkxLNjhzYzU2Vm15WGNpcXdBR1I2MUJEZFNiaWM4OWNVK1d3cjNOZ3dxd0NzZnd6VVlpaWlCeGtBOFlxSHo1U3Z6ak9CbFdGQ3pNZVpDTUdnZGl5MXRiZ0xoTnd4MXF1N3doZ05uQTV5VDBwV3VHREZTY2dEakZVNVprTXUwL1VlOVRZQlo1VlY4QWhRM1FEdFQ3ZVl1QkdyZE9Lb3pvem9UbmtjOUtqaXVCREltOTgrdVJVTkZvdDNibFhQbHNUdEhOTGJmTTY3dXA1T2ZXb2JpYUlOdmpZL1AwK3RPdHB3eExnNTdZOUtSVmkrc2JHUWc5K2xTK1lzS2JTQWNEQnBzVXJHTUVLUVA3eG9kUXFscFBYR0twZVpJZ2tSODdUK0ZaMXpJeWtxSW1rd2VvWGdWZGdqQTNQempPUm52VXh1REl3Q0tGSGRTT3RPNHJGT04ydEk5N0JnY1p4amlyYnI1aVJ1bUFXSHpkK3RQa2pNazRsenQvdXFlbjRpbnJDc01tOEhQMHFSN2hGOXBqY05ISjVZVUZCdCtVa0gxSTYvalNTUmJqbDJEQVZNY3ZuTC9BSHUyS2I1ZTVUMTNkQmpwaXBsSnNxTVVodTBEYm5zYzVwbjNuSUg0RW1xMTFNSUN6WjRIQkJQU21RM3F6UHRWZ3JIQkJiaXA1YjZsOHlSYWJlcTdlMmNnMCtJaWM3UXBKcVMxc1puUUdTNEQrNEhHSzE0TEpJVlhISjlhRkc0bk1wUldibkh6TXE5eGl0R0NGSXdBY24zSTYxSVI1ZlFESHFUUjV1M2xpdnNLMmpUc1l5bmNrenM1VUErbE1rbkdCdUJ5ZTFRUzNKWGxHQTduRlFYRS9HWTFadU1nRVZxWk5rc2wwUmtsZ2c5K2FBVm5qT1pEajJKRlpEVFRYQ3NZVjJjODdoV25ESzBjTWJTYkFUeGtqclN2cllkdExpalJiZVJ0MHlobTlLbGl0MXNMaFZqZ1ZTM09BTVVxa3Y4QU1TNm5JemdVL0Vzck8zekhQYmRtbUlrS1J5Uzc1RHd2cFVvRVkzZVdoSTZaSnF2R2t4SHlPbWZ6eFQ0WW54Z3pFbnZrWW9Bc2J2TGpHN1BORzRFYjhrWkhHYVZpSGpPN2N1QmdEamo4YVNOMzJlWGdLdU04NDVxWGNMbFc3bllBYk9SajBySW50TVRHNVp5V1BBVDFGUDFWN2hIWmJlUmh6aGR3NjFqZmFia1JIN1RPcktEd29ITlpjcHVwYUdpc3JDNEM0QVZSMXpVRjlmT2lNVU8wZ2RjVmwrZktqYnM3aDFIUFNsdkpwSkxFbHBBZDMzUUtubFErWm1ZK292NXdMTmt1ZXBxMnR4TEtvTzg1OXpXTUludUppdXc1VTlld3JZc0xXV05HQllNTjJBU08xQzBLdGRHYnFNYlhEbm41OGNESFdzcHJXYTRiYWhJSngyNjExdjhBWlROY0dYUEtqQUhYTlpjK3kxbUpaT1ZPRDJxcms2bFF3UVdWdXZtUHZmdVIwQjlLbnM5TVRWY001WU1Cd1BXcHJTR0hVTndSU0UzWkhHYTBKMnVJb1Zpd2RzSXd1QmdrVldsN2l1OWl1bWlMREdmSWtWQU01T0txdGJSUjVETXo0UEF6Z0NyUnVDUXpReWJVUEcxajNxcE5IeGtOZzlCU2t4SldLMC9sU1pWZmxHYXJGUXErV1BUdFRuWExmTTNKeno2MHo1b3p2eDh1T2Vha29wejJ6Tkt1ZU9SbXJUVEpicWRnQ3FCbHZTbmlaU0J0UEpxSTJiWGtqS0FTTnBCQzFhbGZSbWZMYlZGSjlVbG14YjJZWnlUK0g0bXJkbm80T0pMOCtjMmY5VXB3S250TlBFREJGVlZVRDd3UDZWZnRWM1NueTFZa0hHU2V0YU8vUW1NVjFMRU1NUlg1ZHNBWG5hb3huMnBQc3dOd3JKSVFNOFo0T2FrWlIzUEo5NmE3S3E0ZVRBejkwY21wUzFLdllHWWpJa2ROaEdDY21vemNSckNkck1HM2RpYUxsbzFMQjhzb1g1UmpGWkVxWFUxd0Z0bzNja2Z3aXRFUnVYWTcweWd1cVpQSTVHY2U5Wjg4UWU2VGNDRHU2K3RXdE1oa2podVRmUXl4c3ZBQjZBMCtPUEVxSDd3M0FtaG1iV29zVWVWNkhhV3dUeWNWSHRJbFpXenQ3RE9SaXRkaWtmeS9tQjBxRHF6TUU5dWxLNXBZNStZc1ptaWR5cWc1eUtvRlpFM3RuY2NqYWZTdGVWVXVieHpOOGdDam9NWnBpV2l5Snc2cXVlQzNldElzaG1ZaUEvUFBJNFlkQW96bXRPeVZwTGhqREVjK1h1Wm5HQU05TVZ2djRjdFJwQ1RpT1R6UXVTUjFQNFZVZlM3MUlrZTFTUWlVYlNyREdLdTVCelRObTRsWlQ1aExjY2RxVzZubGxkWlJGSGtLRjVIV3VvUGhtejAyeDgwU3VaVDFYUGYwck11TFhjdzJvZHA2YmozcE9TQzF6RnQybE1tV3dGeWNnQ3JOMndlRTdSa0VWYWtoVzF0NU1BYnQzekFkcXJiY294QXoycUpQVWxxeG5DTGFnZHdBUU9BS2hNYlRIY2VGejM3MWFjYjVnc2dJUUhuM3F4R2hhUW9zZXhRY0tmVVZmTWhKWE1zS0l3cDI4NTVQclVqUlF6YWw5MGlQakFQZmlybDVwOHlUSUZna3czVDVjNXAxcGFPa2lzOFpCUEIzREZEZlVGdVJKQWpnQkYyR001NTZjMVN1b0pFUUtZK3Y4UkhhdW1OdDVxc1dHRHR4MHFsZVJUTXE3d1NGR0NLaFZOUzJrYzY5cXdCUFZRY0hQWTBzTm9yTVBPSlVIcDlLMlJacklyb1Q4ekVZN1lwSU5Qa0s1azJuWTNLbjBxNDFFUTBZazFzaVNrUkRLOUtHdEhqUlMwZkRqSUo3MTA4bWxJeUJvNHdBRDh4cU1hYmlRbmR1alhnS3g1K3VLMFVreFdPWE1KSHpZeGpyeFhRNkNDTFBIKzNWZ2FaRUUrWkdjc2VDQngrZE9zcmQ3WDkxSUFwQjZBNXFadTZDeGwrSTRqTmVJQnpnVmhtMVpXMmNqQjVOZGZxRnFMaWM0QnlCMUZVallJOEkzdHNrRGRHSEdLY0hvQmdRV3pibXpuanZVMFhuVzExNXR2SVVQZm10aHJERWErWGt0L0Z4U1NXU0ZBUU5wQnd3NjFUc3dOalMvRXZuUmkzdmh0SkdDZldydC80VzAzV1kvTzA3YmJYUkhSZnVQOWZTdVdGaTdEZXBBQVBPVFdqcDJwM0ZsSXZKa0hVcU93ckpwcDNpTW8zZWozR2xCNExxSXh5S1B3UDBOWTRUQnljbjhLOVZ0TlJzTmRzZkl1VldWV0hSdXEvUTFoNmw0S210cEROcDQrMDI1eVN2UjAvRHZUakxVVE9iMGdCdDV3UVFhbjFLSXpUUmhobkM1UHRVdHJGNVVyRGFSMklOVDNLRnBCczY0R2VLaFAzeWxzWklnYmJ6Z2UyS3RhWkFzZXAyNVU4K1lNNHFRb3FxVlluSjVVa2RSVml3aTIza0JPT1hCQnJXVDBCTFV1cWhXOHYvQUhuUDg2UEVWc0p0TXRsYnA1aEovS3JVMGZsM3Qxa1kzUzUrdFYvRUVnU3h0eG5CT1NPTy9IRlpRSiswYzZMS000eW9CSFRpbE5tMHpiV0RBNCtXaUpaUzJXM0ZpT0I2MVpScGxkaWlGbFZkekhQT1BhdE9ZdXhTZXlabVBuU0hJL0hOYVduQUlyUjdnd3gwcW9VbGx3UXJBbHNJQWVmeXFXTmxXSlNtNHlJY0U0eFVUazdGS0phaFZWdVNWQUF4bkFxVzRuTHltZEdWZG96MHp4aXFxT0dZTm50aXBBTThmdzR4aXVkelljdXBUajVhVHpXenVPUjZWTE5hcWt4bGpmWmpxQlNHSWh0NUdQWTFPRlNTUGpJOS9Xb2NyalNDS1pTU1FNZy9LZDNOUExscFFvR01ubkZRSHkwSUovRUNwVWs4MjZYWUJrOFl6VTZqSGVVakFqNWh0UEE3L1doRDFVSEI2ODFLQ0k1aVc2ZzhyaXJpYkxxRUh5d0plQUg5QlR1QkhhR1R6TUV2NjVCeHhYVkl2bTZjUkh5eEdGWFBldWRpdDdnU0VuSVhIeUFER2ExNElaak1OdUl1ZVNPYXRCc1dFMHJ5eWhsUmQzRGJsUFQycHMya1J0TXpPT1EyU1R4VjVwcEVqYU45cEdQbEo3MVdtdWZNbURnN2M4a1o2VlRaYVZ4MFZqR3hNVFF4TXYzK1JrajhhejVOQmtHOGdBeGx1QjFxd2w0UTVaTTljS0RWeGRRWjRkaFBZOWU1cU9hd1dzekNtMDJLRlJJWWNNRGdFOXFJZ1ZKVThBbWwrMVN6d3Jra0tEZys5Q3lmT09EaXA1aXRDWW1OVis2YzQ1T2FwT2dZT3VNaHVtYXNTU3FGQ2prNXdQZW93R0RLUmdxdlVEdFJ6Qm9hdUpKWVNKQ1J4MEhjMURiNmJQR3U5NWR3SjRIcFJIZGJibllHMzVIUDFxNkpBZytVZk1lMWRESnNQaHNnRlBJSkhZOFUrYUxDbDJBd2VPRFZPVzZQbUREZmhUNUxrdXUzR052VW5wV2VwV2hXZTNPR01iTngwVWQ2cTNNTjNKWnlNK2Q0WUJBUlYrU2J5RUJRa3QzWnVNRDJGVkpMM3pBUVpBUjJGYVJiSmFSUG84b2xzd2pncVZKVnlUMElxd0lqTGVGbzVOeXg4RDM5YXdJWm5pdVpsRDhNZHd3ZWxYYk84TUlPU1BtUHpIUFdteG02MDVDdjVueXJqRlZCY2x0Z1BNYTlCNjFudmVQY0VlYVNFemtBZDZzQ2RGZFFSampOVHpjb2NwTVY4eG1sWEp5ZWdxV0FSeHlxNUg1MVdNNEdBamZVVW9kQ3lnY2tISXFPWXV4cHlUS2h3TWRNaXE1UG1Ba0g3eDZDbVNTanl2WDNxTVhKaUdEamtaRkZ3c1Rad21UeHgrZE1WQnYzYmZtUEFOVi90YXpzWTR6Z1k0UFlHcExlVXMyTjJlMlI2ME42RHNQdUQ1VWVDdjNnUWNldFpra0x6NEVBeWNjRTF2d3c3bUxZRzNQSlBOVGlLM2pZa2pBQjZZNlZBWGFNaXowbVEydVozeGgrbU9hdVdlblJ3TmhteXJIUFByVjRYcUsveUtyZ2ZwVWJLclB1QTI1N0UwN0JjWHkyRGxSSmxBTTR4VmRuTXBLZ1p3ZXVPbEt6bHB2a0pBWHJrVTVDUmhvRkpjOVI2MG1BMlFmWnlDU0FuNjFHaDNQbE1ramcxYTh0bk9aNHlqRDFQRk1uYUtGbFdOQ3hQVlFPaHFTaFFXVWJ0MmZRWnBWbkliSkl5UFhwVk9ScHl4allNTm80R09haVFYRWdLdHdQVWMxZTVKcEdVTWVwUDBPQlVxVFl5Q0NSVk8xdEo1R3dCa1p6MTVyYmcwMWVESm5QOTMwcUd0UzA5RFAvQUxNZ3ZQNFdBL2lVMWJ0dEp0NHlQazNZNlpIU3RPT0ZJeGphQUtYSTZLTUNxakR1UTU5aU5VU0lnNEdjNEhGU05LRlFzemNDbU1GNnNmMXBwUDdyN203UFRGYWFSUm5xMlJQZGgyd3U1dllDbVBkYlA0YWZKdUFHQW9JNjVQU3E3WEM5RGpKclBuTFVHVDc5NHlBUUQ2MG5sQm5YNTJYMEhVWW9TUk5veU1qSFkxSVlsa0cvSkdEMDZVMUs0bkd3aFNjVzdlVUY2OEZod2FraVdacllpNkt5TVdIQVhOUGlYY3paL2hQOFhlcDF3cEIvTG10VEt3MkVlU3UxUGxCNXpVZ2tWVzJuQlBjMUU4bVRnbkJIWVV3T2tYTFl6N21rM1lkaVZaOHZ0andBcHFFM2p6TUVoYks5V3hWYWFiZEZsSFVjNUlIV3MrYTRlRVlpa1ppM0h5cmptcytZMDVEWG1iK0VYQng3OWFvWDEzTFpMSjludS9tWGtrakJ3YXlaMnVYaVp6TVFTYzdDM05RcEc4bzRMRnpnTmxzakgxcWxKQzVTYiswcEoxRFhkMFpPTXFUMVdxclNDZVZpTWhBY2dBWXErdWw0YjUxRzRmZHpVZDFHc0VKOHNxSkQ2VkVwbHhocU1qaFNiR1FCanJUSkxIZEprTDh2UURQU3Mrd3V5czI2WW4zcll0Ymp6cG4yNElCeU9lMVkzWnR5aXgyUjh3UDh1TzRBNjA5YkxZUms4RTU2VTk1V1Z2a0hia1VzcnNVSFBPS1YyVWtLaW9XTzdoZWxSTFoycmdzMEt1YzhFak5Na1o5bzI4aXM3KzBYZ2N4dTN5RnZsNW9URTBiU01sbkd3amdSV0k0QVhGWXQvd0NkY1prSTh0RkpKd2NZcDkzZk1nT01zY2RCVkpaTHE1WGFFQUIvdk5pdGtaTkZKTE9HTmlXa0prYm9TMVY3aWMrUis2QitYZzVyUy9zeVR6bUpaU1IxNTZVdjJCZHBESDVlL3FhQkdFSE1rSkI0R2NyeHpURk80a2xzOFZ1alRiVXVVODA3NUd3TURoZmFyY09qMnZsTW1GNTRCOWFOQm5MaU9TUnZOalVBTDI5YTNOUHR5RDhueWxsemtjVm9mMlJCR3BVanZrQWRxc0paQldEY0xnY2U5REVVb1VNb2VGRitYR1NENjAwZ08zekwvcXh3Y1k0K3Rhb3RZNFhFaUFCOGM1UFdrdUxSTnE4STJPUUFlbFVwRXRHTXhVbFJJTURwdXgwcUUzQWptMkxubnI4dWE2Q1MwamEyWG9EbmtFNXdLalczZ0VoS2dic2NjZGFxNGpuZk9QMmh0MFpaUS9QRmJlbEMyalV0Y1J5YnBPNEhIMDRxeStucjVaa2tNWkREZGxFeHRQb2FWTVIyd0Rqb2VvNU5POWhjdDlqSTFDMnVmTllSeXNrTWk0VmR2VEIvclZXQzFsVXNIUWpiMXlLMDVMMTN2RjNua25BSjZVcTNLamRFeFlsamoweFV5bVoyNVdVQjh1Ui9FZlVkS2lVTnZJN2s4RE5hMDZqbGloQUhIeWpPU0t5bmwyY091MlFIcFNqSzVhYWtSemFaNSs3bmFUems5OFZjMCtTTFJiaUY1NGZ0RWpmS29WYzRQclRZUE5lMzNLQVNEMEo2MXMyc2NiU1JxOG14dkwzS20zdU94NXJXNklsWXVTaTl1ZzM3b1FFalA3d2c4VlRja3BsMUJLdGdjOWZYaXBMcVdVZkxLNStUa1o2Z2ZoVmFObzVaeStISmtHTUgrZEtVak1vYXc2d1FqeVV3akRxZWNHc0tLNFo0MVVnZklmdkR2WFNhcEF4dDJqd3JRZ2tobE9md0ZjdklycHlpTmp2NlZEYjZteWFzUTNZWjR6dTQ1NUdLalZIOHZhbko2MWFXT1h5eTdCdHJjQUh1YWwwK0x6NUdKaExCUGw2Z2ZNYWxTZXhtNDNZbHBwc2wvSmdvTWpHVGpuRlB1YlZiR1RFZTUxd1B2RG9jVmFrZG9aQkxHclJoQnpqL0FEK3RWek45cmhacFpCa3NDdWF2bUN4ZnNyZVNleFNhTU1EeURrNEFxdk5Hak8zbUQ1NHhXeG9sd3R0WWtTYlFTL3k3dTlVTlIxWkpIQmpnUVB6dngzUCtjVTNQUU5FVkZhQ1MzSksvT3ZPUWNWVWtmSUlkVGh2V281THRHemhkcHowb2VkU01FNVBwNlZqZlVUMUltdDR2TTg0TXk3aGdqcUtMMk9TMXQ0bkJEQ1RnR21wZUx0ZUZ3TXJrNUFwYmlYN1ZZcXVNYlR3M3BWWFpOeHFYWWQwZ2MvdTI1T0QyOUtsbDhpNWtmYjA2QUE5S3JxcStTRjQzRmNaQXFQeUh0bmlFRGIySitibnZWcVRXd2k0MHhkUElpeVVHTURHTUdvNDRpayt3bmtOelRFdXBEZEtxeGhqbjU2ZnVCMUV0QzRLN3V4eUtwU1lGOWRnVjk3aEE0d0RqTlZmc0xyR1c4eFR1UEE5ZmV0ZlNuRWR1NFpWZGlmbERMbkZMZGVUTW9YeVFvR1F3VEI1cmVMSFl4VGJtS01OdkhQek1RTWtVVHZIS3l4SGFUakpiYlY1OUxlVmlzR1hYSE9PRFZDNzB0L2xlTm15UDczYXF1RmlMZUFzYW1OUnp3d0dEK05UeGhNT1NrWno2VWlhTGROWmk0YWFNcGtBSXg1TlF6UVhjS0VSSXBjc0FGQTRPYUFBNHNtVkltRVpKNEFBOWEzckR4Qk5BVjh6Y1kxT0RJQjArdFpNR2pYcno3cm9JamhjcVF3UDFxOWIyN0psYmdaQnp6Ny9Tc3B0SlhDMXpjdWRMMC9XWS9Qakt3ek1jK1lvNGIyTmM5ZmFUUGFTN0pma0I1Ui80VCtOVG9aclRmOW1HVXo5M1BVVnMyT3JRWE1Ya1hTcVJqNW9tR2Z5cUZKTmkxUnlBaEN3YldSWkdKK1U5Q0JVbG9zYnpyNWljcXd4ampHRFhRWHVrV2l5ZWZadnVRblBsTWNGZng5S3lab1RGZnBLdHZ3ZU1CdW5OTnpXeGFKcnc0dVp5ZjcxVXRjVm10cmRRcW5jY0RQclZ1OXlidVQvZnA4d1Y1SWxkQ1JqTzRMa2puc0txTHNya05lOGN4SFoza054a2dxVUgzVHp1RmFiSkxid3JHd1dNWjVJVEpQNDF1Q0ZZN2ttZkVrTGpPOUJqSDFCUEZPblNJUjd0dTllM0hQV3BjalZHTDVFbmxoR2lHeDE2anFEbnI3VXh0R2xWWGExUnpic0JscEJqbnZXM0x2TVlTQUtwUEkzZXRMYzM5M3R4Y1J4b2crVWJUbkpxVzlCbk0vWi9KbWtqemhoaklwUTJDd3p4MEJyUWxoV1c0RG5nazRJQTYxVXZGalNZS21jRHQ2Vmk5d0k1R0lYQzg1NTVGUlJ5TXptUEk1NlZKTGNJbHFVTGZNVHg2L1Nva0Vhb1NUempqanBSYlFFRTF2S0NkaTVYUE9PMVMydHVVYnpuYmdxUjE2R2x0aUMyV2JnZmpSY0NXU1U3UUFpdHdPbWFTR2wzSkRzTW1XSlk0NHpWeUhqR3poYzl1MVVJdUxwZnRPQkdlU2UxUFNTVXM2eGRPbzdjVWdOMmZWVFpXNktwRWpaT2ZhcDlLMVlYVzlKL253TTU3aXNKSlZlUlBOTzVWUFFqMHEvcEZvalhrazhTa1c4WjdISk5DWTdHcEpmbVYyakFKUlJnRmh6Vll5T0RuQUhZWjcxWk1xQ1RhdzI4bjd3eFZXWjFNTFpVOWZsSTZVM0ptdGtrTloxaWxCeWVtT3ZTa2FjUjhna2p2M3FLWmtkUUkrdlNxc2pNcmhRUU53cWIzTTJ5MFprMnJoTTl4elVMenNWM0tlcDZWR1c4dHZsYmNjY3JqZ1V5Zk1TaVJ4OUI2VXlibHRKdHFqSUpZSGpOT1dYWkd4a0FHZXdxdEM1RVh6Yzg1R2FXVXUwWTNEajJxV081cnhLSW13NURIc1IxTlNKS0NTQVRsUm5GWFpJNGpDU21Bd09RQnptcWhBTWhmako0TmRhQmpiY0dXZmNWQjU0cVdkaVpHeDB4d1BTb1k5c2NJWlRqYWVXSnBVWGZKbU0rK005YVRra3hwTmtjd2tlSU5nRHNmV3MrN2lOdWl2M1BXdGtvR0pXUTdjak9LbzNFVHN4K1hjbzZqMW9qUFhRZG1Za2JPMHJ1TTdWWDVqVmlCVEt5RlR3VDA5NnRRVzhJSlY0MllTRGhjOUt1d1dzS1lSUGxLODgxVXFnSkZWdHcrNzFCeDlhZmhuY2JnUVFLMDF0SXBtTElNc2FrYXdkaXFxeThESFByV1RrNUYyc1pRQkVoTDhnMU5iSTRKY2doUWNjMW9RMmhHVm4yc3VSa2p1YXMrVWpzeURDcUdINGlvWXpMY3M1Wkc0eDZkNlpIQkxLT1A3cEF5SzFaclFMTUhRWkJQSXE3SEFwQy9JcWc0ems0NHFialp6MXBwUkRFdXpGaWVWRmExcnB3aUl5QXEvM2ZTcnpKRkR1OHZZNEhlTTV4VktlNzNxVmpCQlBRMDFjUks4Y2FBcWpjam5yVURZSllGc0UvenJNa3VuZ1g5NDJSbjY1cFlMbVNXUVpCMnN3Nmp0VnJRVmpTdGw4dVlzQ0dLOXFrdUhaNWpncUNld3FMZUk1ajB3d3BadzdLam9NaGh6U2NtTlJIUkIyKzhjTWFuWGNoL2RNQTNUamcxV2lsMnVPY0VEbXB4Skh1RDlRZlFVdVpoeWxoWm5tak1ET3hUQjNrcm5CcHlLV25MbmIwd0QzcU5aSWpKdUF3UFNyQldXWGI5bCtSU2VSMUovU3E1aWVVR2hVTUhkMVlnY0FIcjlhZXRxa28rZERHM3NlS3R3V0NoUXo1TGU1cTBpcWk5TStsQ3V5ZEVWNHJjUnFOZzZkelUrOERKWG5IclR3UXpFTitBRlJzUWpIY0NSVktLUVhiRUJEZ2hSejY0b0NIamZrRDY5YVVTZ2NxTUR0VWNseXB3UXVEMDVOT1RzQ1Z4OGpvb0pVVlVtdWRnSldtWE14MkhhT2ZhcVlacENSdEpQdjNybmsyOXpkSkltTTVrWDcyS3JpQjM1M1pIYXJNRnBMSVFUOG83akhGWEZpUk9GSFBmaWlLMTBGS1ZpRzB0OWk1Yms1cTBlQjdVbmxBNFBtYmZYaW52RnMyL051Qk9LNk9WSXdjbXhoenpub1QrZFBWV1pRQjkwYzB1Rkp5VzRIYkZRVDNBaklBVTg5NlVwVzBHbzNIek9ZNHowSnp3YXJ5U2Z1OHZqK2RWNXIxM2hLaFYrVTlSMXFzOHp0Q0ZJNUpyRnliTm94Uk1aOTVBSkFHY2RLVGFFWUViVzR5QmpyVUNRN25BWlhPMDlobXIwVVd6Qnh1UG9lMVRzVVFSMnFUTG1XTG5QU243SUl6dFJGWEg2Vk5JeklDT0FjZFJWQUlza2pNWkdYQTUzZC9wUzNGc1NTektHMjU2ODFSdWRseC9GaHg4dkZKY1krWjE2RDBQV3EzbTcxRElDU3B5d3pnMVZrRjJSUmFjVVpta1BtQWRzVnBXc2NLcjhueTFBcm1YNVZCSTljMEtoais2UUI3MU5ybDdJdnpNRlVGVDA3MUNYQlVrR3FzOGdFWkFreG5ucFZFMzJ4a1VrY25CeFZjakZ6R3FQM2lCRkp4bnJURTA1SlR1YkpJT2VSd0taRmZLWFZWeDA1OUswYk4zTVFPUnRJeUFLbHBvZHl2SHBhdmNneUZkdWNCUnhuNjFQSmJ3Vzl3VVNFWkgvUE1jVmJqaldYNW5iYWNmd25rZmhUaDVZVmR4Wm5BNUpwb2g3bEdlQWtzd2l4R0JsMkk2Vnp1cFhLTHhiS3BIdHpYUzM5MUpEYmtyS3dRc055OWpYTGFsNWNiNzJIN3VRNS9kOVJUdGNDcGIzWURiSkNBMjhjZ2MxcmVkNUVPZVR4bms5S3c0bXRtSWJQekJnM2Fyd3ZZMzRiN3JEQUdSV3FXaERacFIzallqZGxCVmhWbU83U1J6RzNBNmpGWTh1NGJJZlgzN1lxS0VYUU81bzJDampkbmlrMVpFM1IwRXNzYnFBbTdqcmswUE1vZ3gvRmppc1B6REdjK1psaDNKcGtsL3dDVXd5MlUvbFdQTUp6TmxiampHTnZmSnFLSzRJbkhHN2RtcU1kK2trTHRuSS9ocUo3MVltVnpnRmpuQU5WenNseU5lUytXSW50bnFPdFFOZEdXTlhqNklmbUk5S2dnMVcxazZoVmxKT1dJNE5SU3RMNVpnalVSaGp1SkorOFB3cWVaazh6UTJWM2xsQUs3U0d5R1VkUFNyQlV1aW1WaHVCeUQ2MUdzc0NMdFJ0MlYrWnljQWZTbzdqWXNCa2pZa25nRDA0NjBhc1RkMlRQZktPQU56NXlDQldiY1JhbFBKTWJhTUlISXlXRlg5SE1US1piZ3N5cU1kSzExbGhLZkw4eDdEb0JWN0E3SXk5SzB1NGhoYWFTU1FCbXdvUFEvL1hxNUxnUnE1WjFhTnVXUFRGWG9aVm5Wa0E0RGZLQzNVMVd2YmFWMTJ4a0ZsYk9EMzlxT1liamRYUTR2dmszc1F3eGpkU08wY2lObmRHY1pVcjFCcXZhUitValJ5L2VYME5XSW9vblJrbHk1WmVNZC9laFNZVTRkeWpJc3NjZXdjczJRWEo1cXZIQnZzSm5SZ1dKR2R5OU9lbFhwbzRpdnpGaEd2WWQ2b3lTNWlLcktWUlQwUGNWVjJ6U3lSTGJ6UkxHTGFaVmRoMEpIRlJ5V3VXSXRvWXp6bG1VVkFraUZIVGR1Wmh3eEgzYXMyTi9GRUZXVldZc1R1MmprYzB5R1ZMaHZzeWxKbEladXVSMHJQVmxpYWFKMEd4bXlwSFVWdWFrVXZnT1dUamhtNlpyQzFSRWlXTm9TU0FQbklPYzhkaFNJazlCWk5UOGxDa1pMWTkrMVpadlZ5VkpLc2ZTbjI4YVhNTW1BNWJQeWphUlZQN01yVG45N2dnY2lqZmN5dUpOY0hCMjdqNkhIZWt0bWJxNU9HR1JtcmtCVDVsd0NSMlBmNlZUdUx1SVhheHNTb0dkd3o3MVNTZWdteVZGa21WOXZESGhpT2NqTlF5WEVsdXVTeHdmbDZVMTc1clZmM2E4Ymh3dk9jMDJhOWFhMU1oSkJVOGowcHBDM0o0YmhmTVZuSndSemcxWXRyb3hYREVybHVxN3UxUlFmdmJXT1JVVm1HZDNHQ1B4cVdLQWs1QVp3ZWh4UVVpT01YSm5Zd29YSUp6Z2RLbHRyWUdZa3lFRGtuSGVydGpjdGFYS3lSZ0t3eUJ1SDRWUFpPbGplU1hFeEVpdUNDQ09BZmFxVFE3R25vY01VOFVzS2o5Nzk1ZHhJM2NkcXVTSkRGQ3dudDJqWmNZS0hPZnJWRFQ5UlNSWTQ1ZHhiT0l0Z3hnZld1Z3VOUERRaEgzTDVnSjNFL3dDY1ZYTjJLc1pVVVp1SXhORXlwZ25jb1A4QUtueTIrZHFQeGpwbmdFVlIwN2NtcG0yT0R0ZjV1YTZLZEc4aHlzVVJZSDVkeElvaks0SXhHdFloZ29OcTV5QWZXbEVDTytHSUI2NVljR3JjY0R5SVRMZ01Ud29QQS9Pb3A1WTRZOHN1MDlPRGtZOWVsSE9oMktxeHEwdVNEbEJnODlhcFRTbmNWWGR0T1FUNkdwb3pKSk16Um45MmVvSjVGS2lzck53RGs4NDlLd2xOeTNCQ1JTcUkwVUxrbkpKUGVvcHdrVW0vSHprWkdPb3FaclJ2T0JoWWJGWG92cjFOUTMxbmNvbm1Rcmh6Z0VaQjRQdlU3TVdwbXRxRXJONWU4OU9jZHEwN2FWR1dKQjgyRDFZMVdpMGJkbVNWdjNtM0JDMU1sdThjUURIYmp0U2RoN0VsNFQ5czJraGdUMnFac3FZODhFcnhpb0lZMWR0d09TT3hxMnpJRWpETVN3SUhBNjF2enJsc1F0eEU4MWx5b0M1QitVanZUbGt3VkRvTWdWQkpOc0IyY2pPYytsSkZPRElXazUrWGcxbnpYTlVXdklqbmo4d0FqYWU1NU5WaGJ2SVNjWk9jODBndnZKWEw1UFBBQTZVOUx4R0NsRGc5RFdia3d1VUpsa0U2dEt1QVIwOTZqdkxaZjNjZytiamtBYzVGYWQzUGJUUnNRcE1vd0ZIdjNxT3hRVHh0NWpCU1FkdnRUY2c2bURlVzNUM1hJNDVCcXRCRTMyWHltK1VFNDN0em11aGxnM0YxQjU2YnFna3N2TlFNSW1iYWVSam1yVXJvc29SUmVWR0ZsWmVBY2Q4K2xSUks3SExoZ3JISHBTM1U4U1hXMDVLNUIyOS9vYWxNUnVKZ3RxTnc0UGxrazdRYWtlN3NKZFdIbHg3d3pISjZBMFJ6RllmTE9NZE9SelYrKyswMmtjYTI4YXlEQUpPS3pEYlMzekJuVjR5T3VPOU5LK2crWFd4TWtidEw1ZzRVRG5pdHEwZTRaUWx1VlFaeVdVWXF2RmJTN0FJc2JRdU10M3E3cDlvOEV4Vjh5QW5BK2JIODZMQnlsNmRrRzAzSDd4K0J1eGpQMXFoZW1QZGlERzFEOHdCNlZhdlcyd0NDUmRwTEFBbHM4MW50YnNyc3A2NElMRHVhcmxaTEszbUpGTVdVZ2pHZnBWZHBsa25MZGljQVZBTGU0TTBpcHQ2NHlhc3dhUGVQYitlUnNramJCRGQvU3E1TEVrOGVETVFPYzhZUGFvWkU4MlhhL0NxZWxiRWVtS0RGUExMdDNEbGNkNnliN1Q1b1hhWXlkOEtBTzFSeTJGWWZMSndWUmVNOGU5RnNlR3pXWGNUR2F6TG9XM0x3UU81RkxhVFRYUElHQXE1UE5MbDBBNm8zR0dRd2pqM3FLYVZ3V0xERzc5S2xpR3hTcllJWTkrMUZ5bjdvNStmSTQ3WXJvYkxLMFprOGpDdG5lZUJpaUdZeGdzRHRJcVNDS1JDTnF0alBjVmNhMVY4aGdGejNOWlNzV2lLS1V5S0hZYmowQXFXSkpHWTRBempJQnA5dkY1YmRNajE2WXFZTnRreU5xanBVM3RzUGNoaWdSWkhreHViYjkzdFZlWGFvTHNEbm5nZDYwSGlBWWZObkk2ZzB2MlZHYmFXSkFHZlFVQWl0WlNqZW1CZ0VkS3R4TVRMdFkvS1RrazlxRFpCVkpoeU1LTWRLU0V5UnhnWEdPbUFmV2xldzl4enZzdWNPcFBvZldyRWVUT1NjZE1uSHJWYVZjekNYayttS3N4cVM0SlBiNXMwM3NORnBQblVkK09sUnlONWd3RklJYmJqSGFobitiQzV4MklxVlp0eDJ0MkhCTloyS1pWTWNzYXNFd28zWnhVYldoYzdpY3NSeDdWYm1mTGZkNHgrZE5EbnBWZEJHZmNhWWsremc4Y1lIclR2czdSU2VXM0dNWU9PdjQxZmkzQmlTY2lwRGlZNEpIeThnbnRVM0tzWjEyQ3UzQUhINTFISXpmWlJ5U1Y2REZYNVlGbTJzUUdJL2hQSFByVC9zeGFMYWlBdjdkalZKa3U2TU9TNFpYVlRuNXZRWnE3YVJYUWsyR0ludUNlMWJVT2xSbEIrN0NZNXo2R3RPRzFqaVVCUjI2MVNzOWlOVnVaMXJZYm93ekFaRmFVVUN4cnpnWUZTNVdKZW5XbXM0ZnR4VnhoM0ljbVArVUx4elVSWFBJNG9NZ3g4b3BGejFMQUQ2VmV4STRzQXZHQ2Fna2M3U1dQMUZOdUoxanhrWkI2VlJtdWQ3RUExbEtWOUVYR0lTWE8xaUZ5QVJWUTN5QnRnT1NPMVNvcXVTQ2M1NjBSYVl2Mmd1eC9Ha1hvUGczU2pub1JrVmNTUEpHMUJnZDZsU0pVd29DOGR6VTZnYmVNSDJGT01iN2t1VmhJbTI4RURGTUtmUHhrQTFJTUZzWXhqcm5tbEtsbE9BV0E2Y1Zxb3FPeG0yMlF5SXhVYlZIQjVPYWNNc0JuSlByaXJTTVZqQzdRb3hsaXhBQXFOcElnd3kvSG9LR3hJaG5Wa1E3Y2tqcVNLeHAvdEVqaFQ2OUFLdjNGMlJ1QTVYK2RRUjNDdG5LOXMxenlkMmJ4VmtWbzdXU05pc2hZbkhOV0gwMWxRU0Z3VTl1dFdJMWFZakEzY1o0OUtuR1dHU2ZtQjQ1eGdVRHVKSGJSV3UzQjh6SnlRVFdYcWw0dHZkYm94aFQxR2VCV2xQTEdZaU1FZjNpT2xjcnFVVWw0M0xNd1VIa0FqaWxhNDB5MnVwaVJBM3k0SnhnZHFTNTFOWTR5SVF1RDNJcm0xZDRvaHRiS0hrZW9GSkpkU1NiQkdCdDl4bjhLVDBKYk5GYjB0SjVmQUJQUEZQU0lXOGplZG5PNzVjSHJXTmIzTFJSa3lua25rVlpXNU1zeXVYNDl6UzFCTTFVRGVhSFdSbGovdWdZcUdacmhRZTNxY2Rhbjg0aU9NcGtvUHZIYm1vSkZGeEkwaXBOSnU2THdNZnJWeE5KTkdhOTYrNGxzanNwWTRxaE9aYnhRWThvM0IzVnJ6YVM3eVJFRTdtR09mbXgvaFZxUFQ0YkdERHVRMk1DUWNqOHExdWtaYXNwYVRvTjdKdWtNNVk4NHlhNkN5c3ZzeXBFOHpFcjFKYXF2OEFhSWhzL2xLaGw1T2VwOTZwL3dCcTc0UVM1YVRKeVdVSEE3VmxLVndVa2RVVXQ0NFZkNXZxT242MVQvdHEzOHlTSjJCS25nZzlxNWJVTlNaNDEyTVNGL2hQRlpBdUNIM0FOZ3R5TzlRTG5kOURyZFR1amRMNVVHVUI1K1k4QWQ2d1pZYnRZV1c2ajNScWZsZFRtckgyanpZVjhseUNnd2ZXcjBkd2pXNFYzR0QxNXJTTjBVOVRsanAxNVBQR0xkUEw3N240cXo5Z2ZleU93Qlh1cDcxcWFoZExBb0VmSTd1RHdLemhJemtsZ2NaNEhYTkVxajJNNU94Zlc0VkVDU2ZOdEdPZldvWnRVSzRoTEhEZE9lS2c0a3o1YmZ2QndjaW9CYjNEVEo4Z2tHY0hIRlkzWmxkaU90MWM3M2lCTWFFa3NlM0dhaGhmeld6SklDdVBtVmp5RFhWYVRhUnhXLzhBcExMSnlkeTRHUU9uVWRhbU9uNlVqeXZER0ZFbkRHUWR2YXFTSFk1dTBDN2hGakc0NUJIcFZwZFBhV2FUYTRiMFgwclJ0ZE1qdHpKOWoybGRtQzhoQkovd3FwWW9WbW1WM1VGdWdac1VtaDJLcTZhMXVQTWNxY0hoVzllOVBOOHF4dXBiNXlNS00weTV1eWwxOW1kSnBJd2Z2bGV4NXFwcU1PeTRRcXlrTU1nK2xWeWcwRVY2R0hsUHlEZzVYL0dyRHdUWnk4bnk0NHllZ3FuSEVTNVpOb1U0SngyUGV0U1prbGpiWklwTExuRGNZeFZXc1RzTnRIVUJsZkIzSFB2V21TaUtxcmphZURpdWN0SEszWVIxSkJHQ1BYNlZ1SVZ3VmNiUU1ZQkhTaEpzT2hjaXUxU1IxWHNBU01kUHBWcFprUDd4aHRPY2dnNUlyTCs0MlVJSjdlcDk2Y2s4MGlGVUtnZzhIcG1oeEhGdEYyNzNLU3dYcWNqSFhGVTRyZ2pwbjczSHJpblQzWVU0a1lncU80cWsxM3RCTHVBZW9CUFdpelJmTllsbXVKSDVDN1Z6akpyUHUyZDEyYmVTY0Uwalh6c3pEYnVVZEc5cWVUOG1jNGIxUGVwNXlXVUk0THNwSjlueDhwQzRQYXI4ZHJPSFJwcEVCNDNsZnBVVUY0SXJpUk1nczNmMXFaWk4wbnpmS3hIVDJwY3pJYkM1dUJBenhuYzhZNk1UVUlpU2FPTWtrSXJaY2oweGlsdWVIK1hhUm4xNlV4UE1DT1lFM2J1eDlLZHhFUVJvbWxTRlM2QUhESGo2VlJ4Rzl1WkpFd0dKNXgxTmJFWWxqUUtEeVNPTWRCVkxWWWlpS0ZWV2lWdWNmcFR1VFk1NCtZMXhLc1oyS281SnFvdHVGTWpUTVczZFdyckJwaXkyNWFGVkRNTVliMXJtMHRabnVUWkxHemxTMlc2QTROYVJrUzBSMjRMM0JXVDVvd3B3UU9udlVtb0ZWaldFTVF1NEJzRHRtdEJyTnJlZWNFaU5XVENnOEFZeFVWNWFUWEtxUnNWRUFZRUVINUIwL2xWM3V3U0xWdENxbVF3SEVTRGNvUFVpaTIxZEV1MFhDZ0h1S2JiQ1NXMU1lMHFHSjJ0NmUxRGFGZE5NalJ4RnlWNDI5Q1BYTlNPekxkM0puVUdNWkFRNEtuSFVIbW5UYnByZU5mdkJqa24weFc1RDRZbGVHTVhBTWJSTVY2L2ZCNlkvSCtkVUpMQ1JiazJ3SUpWdHlzcDVJOURTYk5FaXBwcEl2by9ueHRHVkh2WFdYYzkydHVseEsyOVZISUI3Vml4V0pEZWNxL2Q2Z0RrZlNyMHM3N1k4bmxSZ2oxcWVheFZpdGJzc2wzSGVEKzloK2Vwcm9STVh0emtxdnk5YXdOcDhqOTFqUEpHS3FKTGR2d2R5cXh3YzlqU1VpZG1hRTl6TEZKS2hrMmhHeG4wQnFNekNVTDVnOHhNY2lyRnc4VWlSQXg0MnFNN3h5Y2V0WXBtQWtjSXgycXhBcWVwUlloQ3dYVWdHVkhQRlZwcnA5ejg3VUI2ZWxLNWthTXlSZFIxSnFySk0za3JHNnNXemsxcEd6RWFObGVZWXZHRGtja1pyVkV2bUFPR0FiSHpaNzF6QnVmTCtWRkJWc2ZPaCs2ZlN0RzNiekF1WlFNS1JzSU9jOXFtVWJERk0wMi9LOGxpYzgwcnppT05ZMzUzZENhcnp5U0lTdTBvVk9DMktWMURuR1RnZ1lKN1ZtMFMxY2wzSkdRUWZyVWdseTI0dGhqMEhyVk1nK2NQa2ZESGFBT2Z4cHpNNmtuSDNSd2Zla0t4T2txYm1keU00NDljVTFER3hZamhmV29UTnZDN2RvMjhQeFZVaVZwMThybFdmYVZCL1duY2RoYnRIVExSazdUK2xRUVhEN0FpRVlQVmgxSDFxNDRkQnN1STJDRThrakdmZXM2NGlhMjh4NGQza2h1cElCTld0VUpsOXBoaFNXNmZ4VXlDOE1VMjFHQlhvZWFySWtyV3daMFhZUWRwejFxb1ZraXVESXNnMjkxTk93am9WdTFML0FDY2tqclN4YXdUZEZsYkNZeG5QUVZRV1ZZOXVRdnpkcWtVMjVuK1pSdFpjNEhyU1NIY3VSMmRyZnMvSDNobmNCejFxOVo2VEhiVExOYnBncXVHQlBPS3JXNy9abVhZbXlNcnozeWEzTjZ4MnliM3pJd0J3QnhnKythdEdzWkVWdkNyWEJqTUNrUGc1SnA5MVkyOWtYVm8wd1RuamluTElqNGZLNVVIOEJTbzhkdzI2WWdOMkQ4ODFUam9hS1dwV1h5RkFBNXlLbmRJNFJoNDJKNzROYVZydCtlT09DTlpOb3crLzlSNlZuM2x0QTEwWklKNUFuR1EzcjNGVnlwSzVMbGQyS2x6SGJ5cUdRWVpUeHgwTlFlVEkzTHZ0SHQ3VlplNFVxeUJNS2paK1ljZm5TK2ZFQU03Y2svTHptcnVUYXhGQkhISHVWZ1NXQkpPM3JWaHIxRVhZNHltTVk3aW9sa1JDV1lGbFlZR0IwckwxVmlKSXpDeEtrZk1SemcwV3Z1STFTdUdVeHljY2ZLZWVLbU5pbDVESXNyZk1lQjdWaHdlZmJFTy83eFY2c09tUFd0S1BVb3Baa0ViYmNqZys5SnE1UmpYMWo5aGpaRlREYjg1OWFndDdMWmE1UmM3bXllZTFXL0V5enNpend1V1hJQkdNMW4yTTBrVzZDVjJZRVpBL3UxbTRNVDNOd1NTVFhoSVFzcTlUN1ZhSHpBQmprSHBVVWY3cFNxZmVZLzN1RFRzc0Jrbm5HTVZUWlpKRzNsdGwyd2NuOHFuTTZ2dUlYazhxYWp0SVNXVU1jK3Fudm52VnRiYmZrQWc0KzdnZGF5WlNLelNIY3pSRWtqQXhpcElrS1J0SUZERE9lbFhIdGxHV0JBVUFENjBzZHNWWXFlRlljWXFibEZIZmxqdUJCNllGV1ZoYVZWQkdEakk3WnBsdkJJMHI3NGlHRGZLVDA0clJVTnRVdDk0ZTNGRngyTTZRVEZoenh2d01lbFRiQ2JsajFIUVo3Vk9VY3pBZzVYclVtT1h4dDZlbk5MY2V3K0tKQXgzZ2NEakZSVFI0R1JubjJwbm1sSlBuSngycUY3aGpnTno4MksxU00yVGdySEdDRGs5S2prbHdubUE4TDZWQktjeGtna25QVDFxQzJsTHJLcmpxT0JTWTBhSG5Pem9UZ2pvUU8xU1JNa21DbzNjZE05S2d0VktRN1pEejB6VWdWOGxZQmdkbTlUVWxGbnlzdnRUb3c1Rk1lMGNxeGlPMGtqbXJWdkhNK044ZTNBeGtHcjhjQTR5ZWxTQlF0N0tabHpKeUFPTUhtcjhOc3Y4QWNLNXE0SWlWOUtVNFJjQVpyUlF1WnVkaHFwZ2UxTGtDb21jNXhqSnFFbGd4M0hrOUJXc1kyV2htM2NuTEJxajNFOENveXNwd0EzSGNBZGFaTE02dVJFTWNkTWYxcHRwYmhxU0IyREZDYy9oVFpyaFlseHdUVFk1dDdiZWpFWnhtbzJpVjhsdXZ2V0VwWE5ZeHNVWjdqZEp0Ym9PZ0FxS0lPWmNxaHg3MXJMRWhHQ3ZIclQwaVZ1QXVCU1d1eFRzWjZ3dTduWWhCN1ZiaWdsVlJ1NC9ITlRzdUNNTGsrb3FaVVpWNUFOYnhqM01XOVNPTzMzS1BOSWFyT0FBTVkvQ2tDNytBcEE5YVhZcCtVdHROVVNMc3p5TnVPL3RTUXdzeU9NOERuT2FIaWhLSGx5VzZBRHJVYWpkbU1NMkZiUHpkUlRFSkpiTzBPNE1lZXA2NXFEN05JRnk3Rmw2Z1k0RmFDb2ZMMmtsbDlTYWlJM1NLTjI4RHNPMVl5aXk0eVJtUzIwa2pkQVFUbkdLbWh0UkZHd3g4NTYrMVdtbGpVZks2Z2o4alVmMmh5b0pLZ2MvZFBOVFpHbDNZWUpsVWhrY2RNZkxUSkxnUEpob0ZWZTdaeG4ycFZsSVRoZm1CeU1nRTFYYWN0eTJHT2M0QXhTdWdWeGtvVW5ZSDRZZmNVODFTdW9URmJzWkNzY1JCUFhKeFZtSzdXSmk3SU1BY2Jxb2FoZlJUcVdMS1FmNFV5QUtWeXJYT1d2c0dRaUZzcmpLWTlLejNrM0txbzRWZ0NUZzFQZGJpOGpSTDhtZUFCMnJEOHlXMm1JbXk1WmlvSUhhbWxka3ZRbWt2VEcwTzg4WjV6NjFmaW1CY0xFNi9uNjFsdXU2UmxDTkxrWlVGZWxXOU50RmhtU1YwYmMrRktFMWFocGNubTFOMjFtSlRnZ2xmZXJ6TTVLbkdHSUJ5dlROUTJsckVKUHZiQ1R5Q00veTYxcExGbkJmNTQrbnlqb2FoSTFkaUMwdVpHYmFJczdUMUhHS1RVN3lPR1Bzc2dPTWV0V2JxNk1FR1lvdzJPRGs0ejduTmN6cWhra0xOSVZqZnAwem1teU5oazkyc3diYy95anFBZTFNa2MrWGlGbEc0ZDZqdWJaN2FHM1k3UTB5N3NldzcxbVhKYTQ4djdPNVZtSEl4eHhXZkxkbWRqUU1wTnVGa2srWkQwcVJrbEVheTdlK0RnOUJVbW5hUmFtMDgyNnVKR2wzZEc0eCt0WEpsdHZzNFU1M05uY1A1VTNveFhzWlVjOGx1N3NjS29YSUphcjVkbWhBWTRERG5CNkdxOXZCSGNIRjBnWmM0d1JqNkdyVXN0dW1JendCd0RuTk56RG5mUWlsYVR6RWpaTjZNT25iRkliaEl6c1ljWTROTWx1dktZUngvTU9NWUhJcHIyZDFPcmVWREpIZ0g1Z242ODFHck1uZHNVM01ja2dUbzU1eU85YVdsU1EzVXJ3WEFaWkFEc09lbnJXZGI2VDU4Wk1jd1NkZUhWajBHT3RYZnM4ZHBBR0lKbFgrTU5qK1ZGckZtaEs2V3FrVzdZd3UzM05Wb3JqZW9WM0pJNk1UeFZHNWtuOGtGWE9EL0FIdVJWRlpKRWQ1SVhVTXZWQ01ocU54cG8yUHR4U1ZVejh2SUlGRUFOek5oRTNjNEI2QVZoMitwTXpNSmtBS241ZG5VZzExTVU4ZHJacThLZVdoQStjSExFbjJwcUpXaExQcDY0U09DZHQ3bmN2b3B4eUQ2MWg2dlpYRmxHWXBKdDZzNEFLODR6V2t1cWkxZDR3L25iczRYSEJwaG1OeEZ0dkUrWHFNZFI2VnJlMjRuWTQrQzZudDdob2k3U0tSeTIzcWEwN1JHdW9ISUc3Z2lOL2YzcVZyQllMeDVIL2VpUWtoempQMHEvQzBVVVpNQ2Jjbm9QcFNsTmRESnlJN2EyU0pWNmwwN0U1cDl3c2dDNExaT0dIdFVBdU12bG41SjlPYW4rMEtGeVdKVURCcUZKb0xrTCtZMGtiS2R6WTZaNjFwMmlPMFhtVHZzOUZ4eWFwYlUrU1NJN1F4em5uZzFNSndyRmR4Ym5QUGV0dVpOYUZETDRHU05qRG5PTU1wNXpXYmZSeVEyb2tiREpqT2M5UDhBT2EyTHpVQzhDUmhVSkhJMkxqbXFqeUY3UWxvY3IzOXdhejVoT1NNaTBsYjdPeERiZ3B5UUIycWRMc3lUckVtV2prWEtuMC8rdlQ0SVVFbTRIYXI1QkFIYXA3ZUNPSU94ZmNRRHR3TVk1cUhaRUp0aVFXYTI4NVl0KzliUHpIdlVoak1VcG1kc2pIS1l6bjNxdmVTeVJwKy9qTGJSMFUwMzdTV25TVmdkaWpKSHFLUVdKamlSV2NybE4yVkk0cVZVSzJva2hPQ001QjlLWmJ5bUtSaENDWTM1K240MVhNbmt0bFhMcnY1WE9hUUxVc3lCZ1ViSndRQ01VNUdENVNRQmg2SHZVYlhLdGxCd3VRUjdacDIwQ1FmUGdxUGx6MjlxQXNMSmRlVkR2QzhLY2MxQmxYY3pOR29kaDFVWTYxWW1qKzBXeFU0M0UvTVIzeFVzVnVDaUtxZ2xCemtlMU5NQ29iWmJpUDhBZkE1WlRqSS9Tbi8yYkdzVWJPb0tZd2ZZQ3JRWnR4TW1Cc0dQbDdVR1dNS1EyN2FPZU90SE5ZQ0NXSzNWNFU4b3FwT1VVQThHdW0wZUI3YXljT3FqTGc4ak9NMW5hZGN4UnVKVlVNNjhBdU04WTdVRzhrZC9MTzRMMU9EUzVtVWRKNXR2Y3FHYm9uRExuaDZwdmFRTGVLNmt4N2x4Z24rdFoxdGRPeWtSYlJ0NU83dldyQWdrdDFhL3VnMGFmZGpYb2ZyeFYzME5JdTQ2UFQ3YTFZdEtra3BKRzNqZ0QxcXRKNGZON2ZUVFNNWTRXUHlBOEVEMXE4MS9GRG02U1I0d0JrQ1RqdHdCaXFaMWdYV1hqTFRNcTdIQ2dIcjNQdFJ5bHNwSFNWZ1Z2Sm1RTEgwQk9TUjBOWjF4YjNQaythRk93SHI2ZTVyY3ZQSmM3Z1JseGdoc2xoN2p0V1BlQ1dLR2FkMEVNSkd5TlR6dVA0VXJHY3JsRzZsWm1WaWVHeCtlS3FUbFZrWlRnRTlDS0lwbWxISDNRY2duclJ2UzR5d1hMTDFxZFJhc0dMUnF6NUJCSFQweFZlVkZaRjh4Z0ZZY2pQSnEwQkd3SUx0ZzRySzFZTSszN1B1d2hPVFZMY1Y3YmxtMGhodDFJamJjMlQzNkdwaElpeWNmS3k0eU90WnRsSUlkb0JMR1FBa0hzY2MxZWhsaTg0dXd5ZWhGTjNGekU4NU1zNVk5R0E0b2RjcUZWeHVQVmM4aXBDNnNBVXlDQnlEM3FJZ0hCSXkrT1RVRldaTUFZZm0rOE52M1FjSFAxcUVIek9jbFRIeXk0cGdtODJaVmpCTFp3Yyt2cFdrdG82Uk5LeTRIUmw3L0FJMENNbDVVdUxmQ0JsTDUybnAwN1ZQWXdTZWFZeTIwZ0JzbmlsVzJnZHdBQUZ5VHRIWTBpSkpic1czWkFQR2NjaW4wQlNMeXd1T0xsdk9VRG9PbFkwMEtySklseGtCaGtlbGFKdUZMY0U4SGtWSGV3SmRRN3djWTVCb2pvQmt5RjFoV0ZDM2w5QnowelVxMkREbHNEY2NqNlVRZlBHMjg1QTcrbGFDM01iTmphUHJWTmt1NWx5MmNqU3A2cHhqUFduUkZvN2lQekZHQmtuSjRJclpraURxU09QUUFjMVdTTlpJSkE4YWhnTURQMTYwY3dJaGE2bVRPVzNLcHdDQjBxOVkzSjg3THY1aEE0OUt6SW95ekZZUUNCd1Q3L3dDRmFjTWNVTUtyenZ4MzdVN29FOVRYdDdyZ2JjWVk4Wlh0VjZWWlhtTEpqSUdRY2NWaXhUaUMzY3NqT3FINVZQSUdldE90OVRuRWlwRWpPTngrUW5BT0syVHVqWmFzM2J1MWdra1NhTW9wOHNMNVp6alAxckx1SlZzbFlHVHFRUW81cUI5VmRwRSswMmJDTEpCVUhrSDYxZHVMYUc1MDliaFdSMDh2K0FmTXZzYUhkNkZhSXAzbDdGS3Z5akJ3T0R4elZlQUs5eVdrWE9CZ0EvdzFZdGJDTzR3Wm5LN09oL3FhcTNFcmk2bGM4ak8zSUdNNDcxU0piSkhuQlFxNzdlY0VZNXpWTzZnbVMzV0pUa3NSeU93cDVuWjFKVlMyTUVqSE5TRm11RUN4Z2dBWko5YWIwUUlzV1NLOW1Wa3h6a1l6MXFoRXJpWXVvQlZUaklIU3RCSUpEc0svS2hCL2xTa1JoZkkyZ2M5QWV0UW1WWWprVU5hS0N4MmtZeUIwTlIydW1SUW5mSTRkWEhYR00xYWZhRUViN2w1NHgzN1ZLVWtGczZsd0U2Z01PS3JtRllTUWhiaEdSUXlrNEJQYXBiZUpqSVM0emdaeFZpS3ppOHBCMFA4QUZ4V2pIRWpBN2VnNHJudWFsYTJSMlZHQzhucWVtQlZ0cmRWWUZDUlVpTHRVTWVOM0dEVU1rakNVa2pJQnhVTmxwRmxJWXBZY1NmU25sQWlCQno3NHByYlRnZFBwVVU4cEFZS0RqR1ByVWpzU2h4NW0zcHpuNlU4bEI5MFZRV1l4dTNHU1FLbmlrWWtoeGpkME5NTEFXQ1NjWUFJcUlTQVRNY0RPZm0rbE9sakRPb2RTUU1qSTcrOVEzaDhueTJNWktFZ01RT2xBN0RyZ0F1Rkg4UHpEM0ZVYmh2TFVra2p1RFZ1OFlMSUZUZzdSazFUbW1MT1ZkZUFBQVNjMWNXUTBOUzZ5dVBUMXFXQ2FIZUVLSGNUamdjVXd3R1JsYU1EY0RnbkhXdGl6c3lTUE1DOGlyYlJHd3NkcjVpam9mVEJxOWJXWVJSa2c4MVlTRE9BQW9YMHhWcEl0bzVxZVZzZk1rUnh3N2Z1ODFZQ2dESkF6U1lDcnhVUkRIdndhMmpGSXljcmtqVERkdEJHYWdaMjgwWjZVOFJnTmtESnBXYkNra1k3QVZaSTBzaWprNHo3VXg5amVweDZpbk1WMnFUalBxZWxWbmt5ekF0MDlEU2ZrTmFraHVsUldYR01WU2x2RVpUdDljL1dtVFRxQ1EyVHgzcW5pQjhsQ1Q3bXNuRnZVMFRTSEpOSWJrOWpnN2UxV0ZNenk0Mm5HT3RMQW05a0N4TVIzTmEwVWFxbk9QcGlqbFlPU0lZSW0yZ0UxUHR4MHBTd1VjWUZITEx3YTBVYkVPVnh2cWNjMDlYeDk3RkJqd2hQZWlPRUVaQUxZOXFvZ0JJeFU3UDBwazRsQUJpd3plbENzcGJBK1ZDZW5OV1UycG5iMzRHQi9qVEFxeVNNWXdkK0dBN2V0UnMwam9venRmUEpKL2xVendKSjg3aEF4N2hjR25MYnJFTjR5V0hVWjVvQUdoSGw4c3pZSFBQV281cmhmSXhIRVVJNmpQV3BGYWVVOEJWK3B6VHZzZHFaUG1rSms3NHFKSzQwWlVEdWJyYzBlRVluQVBXcGx0bnViaHBkd1ErL1FWZUNReDV3amJHNk1SMHF0UFBFRlpWUHlrOWM5Nno1V2FLYUVNRVVjTGczbVdQWFlLcm9rVVZ0SWJkR1p2VnUxU3RJb2QxVERZN3FCelZjM3NzRUxSbHVUeWM4SEZRV3RUS3VJTVNzSk4zQnp6NlZsWDBhczRZTVZMY2hSMHJVMUtXTjJXUlpOaFlZd3pWejl6TElrcGtHMGhlRlRyazBteWhVaVZwU3BIQ2pOVFE2SmEzY0JsdUowVmdTUW82bmduLzYzNDFXanZFQ3NKK0R5U000NDlLYUQ1OHk3Wk00R2NIMDlxTDJGWnNtK3dLd1hDc3Jad1ZIcGppckVIaDJNUksrL2tFSGs4ajByUnU1SHVvb1pDeXN5SXE3RkhCSDUwdHE0TUJXUnNiandDZXRhdWVoSExka3NWb1l0enliU1Q5MHJTQzIzQlM1Wk8yM0lING1wWGVTV05Ja2I1Z2VtM2cxSmQya3p5SXhsOG9FNVlFQS81RlFtM3VXMVlwM2xzbTFVQ3MwYmNISXptc3k1MEl6U0FzaFpTM0M1N1Z1aTJrM1pFeE9CZ0VqZzFNOHBFWStZSXhYQklYT09hVGRocU56R2wwMjJ2TFZMVjBUQ0RBT2VWK2hySmpzTFRUMkRwdEpSeXFrOXZhcE5YbGVKSDhxTjJhTTdoSUR5MWMrTlZlNVpubjNLN25oY2NBanZSRzl0RE9iTk8vYnpiamFXMmJUMFhvYXhwTG1kWmxqS05JekhBWUNtcXR4ZHpNN3R0dzJQclc1YTZjOGtiR01NZS9KL1Qyck51MjVqWnZRcE5LMXRIODY5RGdpbUNhSmtCQzVCNUZXTDNUWll3U1BuSDl3a244cWJhV0crRGR0WnBQN3VkdlNoYWp0WTBMRXd2bDAybGdPaHEzUGZzdTBMbGsvdTR6aXN2Y3NjWmJhVlpjWkdlbjFwa2Q1RStjeWNnWjROUFVxMXk4c2dFa2p4OFB4a2VvOUtyWEV6bGdlUExZZXZTbnhTb3lMT1ZrMjd0dnk5R3Eyc01GNGhoaWFJS1Y1d2NFSDF4VHRjZ29OREwvWjZ6UnhsMFg3K0RuOGF6N21KNHJmZXlORXh3UXpEQU5kTXJMR3doREtGd1NTRkEzbXNmeEF6TmFveU8waTVPQS9KQUE2Zi9YcDh0Z1pobVpZV1NUeWtlUUx0SVByV3pCZjVSQXl2R3dCd3JjaXVlam5WTG9mYWcyNVNTcmpqSDFxNUxlbGxEUlpPN0hKSElyUW01WXVaRlc4RHhsb214ODJSeC84QVdxMUZjRVFMbHc1emtnR3NwZ2wzSEpEOHlrTnUzVTZUeWxRQ05zU0x5RGlwbHFKczFtWldCd2NMMXFySTZBankzSkJQSXoxcXVaamEzTHFHWWx1U0I3OU1VcU91MGtCUXVPZnJVV0p0Y3NwQ2dVakpVZHVlUlVEUnZHSlNUdUE1VVo0TlhvNTRQUEVlL2NzaTVUSTRIK2VsUjNNZXhkc2Z6TWZRY0NsZld3V0txVHptTDVUdzNDajBxM0JJNVRFNXl4N2p2VldDNDhwU0pWVWpPTnkxWTgyM3VNT1I5MEhBejFwdDlFTytsaVpicU9ObFhCSVBRNHpWNkthRjdmSk8zbkdEV0hIRWlqQUpPMDhEMHFMWmNUeU94bEtSNDI0VTlLamxCV0wweWJGWm8zeU4yZnBVRTdPMGlKYjdndjhBRm5xS3ArY205b2xPNDdjRURJeFVsc2hWejVya3FmbFZ4L0FjWnE3Q3NpNlp5eWJaMnlSMGJGTEdJVmpWM0c5K1Q3TlZXNzNKY0Q3T1EwYWo1am1rU1ZKSm5XUlNvd0FDUndLVm1WWmRDM2RZZ2phUlcvZHQvQU9vcGlTSHpKZjNRUXFkdTdxRFVWNU82V294OHhIQUI3R2lLU1dTTXFxS3JNTXNDY1pQZWdGYm9MYzNUUXd4THRDdWVNcU01cTNIdEw1YktzVkdENzFTdTRWQ3dyYzR5Q1F2L3dDdXB4R3BtUGx0a3VBY25wMG9GY3VCakk0TVhHRHlNOEdyRE41RzFkM1U0ejZpcU1QM2xrRHNOamZkejErdFdabDh4bFVFSkl2T004R2tTRFRidHlOamQyOTZlWlNiUXRHTXlZNEh0NlZDeXI5dUx1cCtaUmpuZ1ZhakNPcENxdVFLUXdRaGtCYmFjOGNjWU9La0pZS1NwK1lBQmdSMG8ySzJ3ZmQ1NUE5S2R0QmhmcnU3RWRSUUc1QVpmSm1CQktrbmdlNUZiTUYwazFwOW1mSUpCWmpuaGovU3NyeTFaQXhBYis4UGFwNFpiV0FFYlBsa0dHQlBmOEtwTWNYWXVYOXpiM2R0SjVWM2hvWWh1Vmg4ckhwdHpXVjVKdGJZVDVYelc2RHRnMDI4dll6S0doQ3F5WVpsSEF6NjFRaHZ6Szc4SGF6RVlCclMraGNxaU5XSytFMm5DTnlRNjlQYzRxR2ZVWkpiSm9aanZqMmtLbWUvcjlhekYzUjdnQmo1c2dacEpwd0ZZc3ZJSDVWSm56Q1dsbzJEdnhnSGdIM3F1eVMydHlZRWwzRmh1YmpwejBxMURJem9PY0RHUHlxM1lyRGNYWVdPUXh5aGNaSXpuMnBEVFpUV0ZyUWJicktibFZnQ2VjSG9mcFRXS3k1VTRLNHlNVjJWeTF0ZFd2OEFwVUtlWnRJVldqVmp4eFhLWEZ0YlI2b2tjQ21OSFU1SmJPM3NQeG9TNmxTV2htZlpoNTIvUE9lQUtaTHZpQmJCSGZkaXROck9lemJjNVJsaytZWU9SZy95TlVwNVV1QWJOd3dMSVNBQlQ2a0lTR09SNFZta2ZlU2VTT3dweTNaZnpWVWhYWGhGYzlSVjdUckNPSzFWV2JJVVpPUnpWYTkwcFdrL2R5S0NIeU41eHVIcGo4YWxOWExkeVNDQVRRN2l4R0d3Y2Z6cTgrbytUQ3FMdWtRbmFjL1NxMGR6SEJDa08xUU9oVWRLcmFoTks0WklRRUdNa2UxTUdoSnBmM2pQR2NESFQwck91NzE4cmdramQxelZKNzFtazhza3JLRGdEc2FRbVNWRDhoNjVPTzFYWW1KcTJ0d1hCVWcrWi9PcjBNNk14aVlZSjRJejByQ3RwSnQ1TVpHNWVPUlJCT1k1UzBtNG5keVQwTlRZbzZPTzBoamphSk9RYVQ3T09BaEdBTTFteFhtUG4zRlZQR2MwbjIwaVlMdTZqcjYxT3BKc2hYSEs5RjlEeFF5aEV3ZWQzWDJGVkJjTnRIb2VPRFVrSmVSY0hQVGlrd0pZeEVpbnl3RlBmM3BEbDJ3aHo3bWxhMGxReHNPZk1PMFlGUVRUU3hYQmpFZUNweFNIWXVSVHRDamRHNC9pcS9iWE1Za0huZ0FxS3pQM2lGVlpSazlmYXJEdjNVQWdjR3I1bXRqU043RnM3N3VWOHFtMVQ4clo0elMrZTdBcnY4czl3b3dEV1lxM0NTTVk0MktFQmtZSGo4YXZRLzZSYm56TXF4OVBXdEZKc05ia3NVU3hlYS9Mc1JnZTFaOTA3eHlMczRqY2ZNQnp6VitYY2hUNWNzY0g1VFVOd284b3RqcldxbFlwN0dVMTNIRmFsK3ZPeHNkdUt2UUR6TmpKd09qQUh0NjAyYTFTSzMzUm9HTHR6OWFraVNHTnh3M0dkeEorN1Z0cG9sWFJySkpFZ0NxKzRzQnpTeXdEY2g0YmNjSEhhcU1rYXhGVXlDVDBLbnRTckt5QlZRbHVjYzFOa1ZkbHVhMDNFQU1TS2I5bWFNRU1RVmJnRTlxa2ltUU9GWUhkZ1p3YXN1VWUzQnpqSHIzcEFOYVgxNEFGV3JKeVM1NktSZ0UxR2JYZTN5NEE0eWF1QmNSQUxnRmV1QlhJMmRBU2tFS0NTTWM1cHJxRnR6amx0MlRtbVRaZjdoeU9wNXF4RWQ5dXVjZGR4SjcwaWhTb081bTlLenJtNGZMN09uUVZlVWw1R0J5UmtpbUN6WGNWNFplVDlLQU1tT1dScjlvbUl4MkdhdXJPNFVDVUZkcHgwNjB3NmFiYTZlNTNBNVhwNlZMRE5JVkdWSEI3OWNVeFhMZThveTQ1eno3VkExeWp6R09YbzNZMDlKdk5rQTZnY1pxYUcxWVpDN01rOWNjNG9TQzVXbnRKWCtkZVNPZ0hVaW1wcHMwcFg5MFl6bk9ldWEyTFN4WmZ2dXpZNlZmRVpMNFFjZXRVcnZZbHRJenJmU3hGOHpFYzg0clFTSG41VkE5elV5eEJUaHVUVG1jS09LMWpUN21VcDlnQzQ1YW8vUFZuS29ja2RhUm5acVZJaDF4V3FSbmNhZUFjYzAwdWRvK1dweEdvSEovQ29pNnBuRVpQb0tMcEJxUmlaaUR0R2NldlNrV1RhTXVkeFBUMm9MZ3QrODR6MXFzNEpiS2NManBVdlVhZGd1SlNVNE9CNlZtelR5THdNWk5haGpVcjg0R1Q3OUtpRnJHV0djMU4wdEVXdk15V1dhUXJ1N0hyL1dyMW5aZktjODg5eFY1TFZSbmpqNlZPaUNQN2d3RCt0VW0yUzdDb3F4UjRWZjBvVTdoa2V0UEMrL1duZ0tBQU1rL2xpckp1UmdIbmdIMnhUMkJJRzFEK0ZSenVFWlFySEo2NDVxZk00akhsdXkrdlNtSXJ4U25kdDJ1MzRWTVJJRUkzZ2M4alBXbWVSY3RkK2RMSyt3OUlzNUdmV3BaSVZtbEIyNTljSC9JcENJVjgwc0FFeWZZZEJSY2w0dnZuYUQwQUZXQmdJVmpIbGpPTWRNMVF2cnVOUVFRQVJ3QlVTZGlvcTdMVU1rYlFkZVZPZW1hanVMdVA1WTl4VnNjbkhVVlF0NUpaWHhEakhYRkFnODR0dlk5ZWNuRlo4N3NhY2lMYWVXTG41WHlDTW5CcWFOZ21DcStZV09jWjVXcWNVTWFqamxoM0F6U3FtNlFiSDJsZjRzNEk5NnIyZ3VRMGxaMllxeEpWdjczUVZUa3M0WWxteTI4NStVaGVSU200ZzNLRnl4eDk0TndUM3FoZHpUYk42U3JrbmhSeVJRMndTUXZ5QUVBNDV5Y1ZqNnZkeHc0U00vTWZtM0VWTUVsa2QybWM3Y25HMDRJcksxUXl4VzRWVkRKbmh5T1Q3WnFPaHBZb1hONmtrY2FFbGlEa25OVjVHM08yeFdaVjV5TzFLeFZuTEtGR0JnTGpwVHJaVDViS0cvMWh6Z2Nack94UlF2R0wzc1loYktsY0gzRmFLV3dTMFJodXl4SUpIOE5TMjlqRENwTWlLU2V2UEFyU2doUzcyb01oTjJTZW1QcFZ0NkNTS2x2S2tlRWFVRVp5TWpvSzM0TGUwSlVzcXZnSEhOVjBzb0xlNFFtTnV2QndEUzNOeklKRDVDQTRPTUtPUHhwcnlGZTI1cXFzVzFTZ1hLbi9BRGlwN3FWTHJ5bWtHN2pERURpdWJOdnFzeFJoY0xBbVFTZ2ozVm9uTnZiczBrbVpzYnNub2Z3N1VXRmN1eFgwZk1BUlNBZU05aFVCVXpUdXcyQXFjRmZhdWNhOVlTbWFWc3BHZUVIR2MxbzJIaUtDNW11R2tDN25JQ2dERzBkaHhXZkxjdm1MRTFoSEo4a3Z6RThqaXE1OEt3R2Y5NmdBWUEvTU1ZclhqUXlBUEhpTmNkTWJzL1hOWDJ1RDVjYXlPY291RnlCd0tkbllUYXVjVnFQaGdST1JiTHNVWndTT28rbFZOTWtrZ1lSU3dPaFVuTFp6dTk2OUM4cTMreHRKTmFtVGpIbU1lZnc5SzV2VUliUzNVVFBLaXUvSVFnN2xIcFQ1THE0cnhUTW02dTRtMmtBSGIyelZBdWtwWmlTZzZEQnJOdkpBczdZd0lpU2FScnhEeEMvbUJCeUFNWS96NjBJaVVrMlhYUVhFTHEvREw5MzZkNnF3V01VUUlBSTNOd1BTb251NW96dlFGbHhrSjNQVE5TU0VMSmwyWnQvSVU5cVR1aE11d08xcGF2QzdBcWg0R09nT2F4NWI5VGN5aU5mTEtFNGYrOEswZHFTV1UwbWVjY2ZTczZhemlkTjJ6RE1uWEdhY2ZNaHBvVzMxVlpKSFVJeDdJYzlEU3ozZHpOSDVUUUU3UWR4cURUSWxZaGd1UjZlOVg3U0dWNXl6cVZZNUNnalA1MVVrQ2kyakRlMjg5a0lSMkxZNkQ3dUt1Q3pLaktMaC91a0RqSXJweHBobFJQS2oyU25rNTV6Vlc2MGU5KzBLUXYzQmduUFNrNU5hRXVtekUyRkpZeUNHQkhJenpVUmpYY1MrRXhucU9XcTlKYXlsbTh5RW9NRG5GUnpXbHhrUmtCd1JsU2V1UHJVM0o1R1U3Zlo1ckF2NWpMa3FPcG9JaXVwRldOWEJKK2RCMEk3bXJsanA2Y3lyRVRJV3o1ZzRJOVI3MWZ0YldHTzRZai9YS1NBU2NjSDJvYlNDMW1RdzJxTmFKSkNNb2d4anVQOEE2MVQvQUdXU2FCWFVCUzUrWW5zS3VDR1NPQWdyM0dDS2ppbWxMbUZsd09vck80SlhNZWVDTUw1Zm1FSG9NZXRTeEpIQkVxeUhkc080SHZXaGN3UXRJcDhrYmljanR6VldTQTVQeTRZOGpCL1NxVEphSzgweThTS3U1aU9NZDZqODZOcGtoSjJpVHQycVFJc2poSldLa0FFZXhxN3BOaXQxTDVzMGJlWDVaL2ViYzdjR3JWbVRaOURPRnU3dTVpNFZUbk8zcFZPV09lUzNsQ0RhZWVWSCtlMWRacUFnYU0rVEh0WGFGK1VZSkhxYXdaWUpMZFl1V1lGdm01NlVKamR5bmFPWTFEQWVZZG1EeDZWZlNDQ2VGY3lZOHc3bUNOelRMV09LQ1Y0M1VzZ0lZWjcxTWtjTVkrVVlJSlBKNlpwaVRhTSs4VXh5YkVjZ3N3MnVmcFVrTWVjeWJXV1VET0dQeW1sYTFNbzZjSXdIWG5QclY4UW9TT0FkbzJuMk5JRXl2Y1c2eXJHOHFzM2xrOEQrR3BiSmYzR0pNTTBaNEo3K2gvS3JFU3FIL2VqaGhpbW1Bd1NaWGxNQmdhUWg0aVZGYVQ3eXZnbkI2R3BKcllMSzhpdmxYVldYbmtVaXl0dGJiekdlcHg5MnBZSER3bGVQbDdmNFZEWnBZcnY4c1NnWWJyMTYweE1KMHpuUE5UUEdIQXh3UTNYdUtTVmVDT0F3SERad2FCTkFKSk1rUm5HTWRUMXEwSnhrTmdBdHp4VkpSdVpRVzJrZ2cxT2taTWZJeVFNWm9ZMFNCc01TT01uT2FoOHo1Zm1YNXM4WTcwc3NtMkVzdUNWR1N0VlZjU3FHa3l2UFBOTkE3QzNFYXJsZ2QyOGdIQTZmNXpVSGxDT1pkZzJLdzVHZWxXb1psOHZkamtIMXFPUnpMY295OEFja2RLcTVOaU5TbTdadXhMZ1lKNy9Tb3A1TGVPNENaM0YrT0RuRks4WisxaDl1N2JqdjBBcUJZRWprM1NrSWR4ZEFlNU5McVhFUkd6SnNVOFJIbXI5bUlsQ05sUSs0bk83QitsWnRwQThUenlPeUZTY3hsVGduNjFIZmVaNWlKR1NIYmtZK2xNRHB2dFdUbVFrTUc5YzFOTDlqRWZuRmQ4blFrY1pIdldLSmRzVVpjdHlPY25ucFR0TjFDUzVWdHFyNWFuSVluNXV2cFMxc1V0VFRpeERBUHRBUm9wQVNwSFZUV2VFaEYwWFlBa0tRckR0NjFwZVI1a085MlZBUndDMVpFN1BFR2JhUXZJSkE3VWt4dUQzTFRPQ0c4b2c4WTQ5S3o1aGNlZjV1emVoSUJiMHB0c2RrdStBdC9lMm1yRDNVYlJTU2JtUndNWXBrOGpLa2VMaG4zTHNPY0FuK2RMYVhHV0pjWlpSak5aYmFsNUJabFBJUGNkYW1qMVJtY041U2dzQWFweGRobCs2MHlKN2xicGxHN2JuYUIxTlFORklzbzJRNUJVa1ZhczlSVzU0T1E1Ym5ISXFhNW1TUEJjZ3Z1T01mU3B1eWRqT1NCbHpJM3lsVHlNVXdrVFc3eHhvRzU1T09nOWFtbG1lWkQ4d0NQeG1zK0tLNWkxREpCV01qYnowSXFrbXl0Q1JMTStVOFJZZ01SdEpwTGUxdVBQZEhRZnV6akpxNUdYZEFYQlZzNHEySmk1TVljRmgweU92dlM1aWJYSS9MRVVpN21CQjlEMHE1QmViWEFiN3A2Q3N1VTNOdXJTTEV4ejErWElJcGJLM3VybmJjcTJZODVVZWhxU3JXT2dqaUVpRGs3UWM5ZWhxUUtqc0NRUE5IZjFxdFp5eUY1UE54aGZ1KzlPRjFtVDVnb0hYRlNYWWl2UktKL1hqclVWc3dMbEdISTV5S3Z5TXNxTkkyTjJPQ2UxWkRYamJpakxzSUdjZ2ZwVklyWkd5aDRTTmVGenVCOUtuM0FoUmtaOSs5WmR2STd4SXk1SkhTcmNieDdRVytVQS9ObXFpOWJFbHVBdXQ0SkF3T0V6MHlEUThhdmNFbkFWdVFQU280N2xZN25nallZemc0NDYvL0FGNmUwcXV4Y2M4OEd0bTdERzJrZm1zNnNSdFRQM3UxU2l4TE51T0NDT3VlbFJBVEJtRnZKdE9jQWV1ZTN2Vm1PR1ZvVjh4d1FlR1VqQkZQWURPYUlyS04yUXlrcjBwWWd4eHowT2FpdmIwQ1psVnZ1OFpKNjRxcUx2ekNaRk9XSFVWZW9HbEh1VzRiZi9INitsWEVremlKc0VMMGIxckNpdjNrdU1UTHd6RWc0Nkg2MWNXOCt6VE51WU9tT29wMkE2NmRVWm1KeW9IVUNtSVY4a3FEMUhCNzFJVkx4bm42aXF6SG9Rb0lIZXVBNlIrMFF4WmRkeHhuOEtpanVTMGE3TVl6MHF3VVdXRkpUbHRxN2NkaUtoV05ZNUJ1alZnT21PdE1aUEhOSGpJUGZGRGJWa1pza0E5YVJvNG80eXpjNCtZRDBxR0tiT0hIS3NjYzlqVEJpM2x3RGhCZy9OMW9Fc01qQVpBYkdLckdHU1Y5c0EzSE9DMksxckxUUkV3YVFiajdWcFpLSm4xdVEyMm5oSmR3WWtaNjU3VnJXdHZIRnp6bHZXcEZRSTIwb0Jub01WWVJGVlNjYys5RVl1Uk1wV0ZTTTkrRnArUXB3dUFPL0ZNODM1ZlEwd3NUME5iUmlrWk50a2pTZ2dnVlhCTzdubWw4d0xuTlJtZFdIWEg0MVJKS1hDOWFmRmNLVXovTVZValozSkVaSEhlbFl6QWNqalBKelVTYjJSYXQxTEx5WkhwejBxUGZua0VjKzlRcVdPZHh5QlQ0VVFBRjJHZlQwckxsYmVwcHpKTFFaSkpuNWtWV0lQVEZRUFBNVitaZTNBSEZYaUl3MlJrbi9aRlZuQTh4bTJaWSt0YXFLMk0zSjNJb1F6SExKajZtclNxQU1rVXFxTnVTT2ZTbXZ1N0g4SzBTU0ZjZGtIb2NEdm1uZ0VFYlJ4Mk5SYlNWd1JtcGtka1ZTeTlQMXBra2lES2tidm05ZXRQUkEwTGJqejNOSXhYYmtBQ29WRGxpdzU1NExjL3pvRVNwYndKQ0pSd1ZidWVEVWdLYlFYUFlkZU0xQ1laSkRsMkJDOVFNVko1YkZlY1p4Z1pvQUZ1Zk1tSzdTRUE2ZzhWWkRDTElqWGFQNzNyVklsWUdBKysrTUFqaWtlN2FUY3FGZ29HUU1mZXFXTkUwamZLZHJMa2M4aXMrVzFTVzRMa3FTZnlxZE55VzY3c1pkaVNCbjlUVEVqZHJnYlZLWlhKSTU0cVhydVV0TmlGQkZhc3k1Y0U5Z3YzajlhaldPVUZoTElxZ2YzUmtacThVODJiL0FGakJtT01FNXdLcVNxUE1aQkl4UUhBWW1wc2lyc2ZZTTBSSXVFQko2YzR4VFpFbGVabkNMR091WFBGSkxLa00vd0FzbTQ5RDgyZW5lb0gxQjVRVmZjM1ByeCtWR2hXcGVoVmZMSkp5ZWl1TUVMVlZiTjVKblZmbUlPTWp2VU05ekk4SWlCMnhEb3FjVUpjTkVueWJsSjc1NVB2UkoyRkZNc3RiSkNqSzdDR1FkRlpldGN6ckVjcHROckZzQnNrRThaclphZG1CTE96Wk9jeWRLcVh0OEpJc1JEL1dLUmtyeFUzdVZhMjV4VnM3K2VRdkg0ZGF2Skk1Q3NCemp0MkZWallTaTRKUWxCNjU2Q25EY21JdHpEYjNQY1VXN0ZKazBzNUJ6dXdDdk5XN2U2SWhSbFlnTWNESFExakpONThnaktFbnVkdmJOYjFqR0paSVdFYkJZeDh1QnhVOHJLdXJHN2FNN1JoWlkvbUlxeUkyVEJSUm5QU21Rck84YnloZDNsRE8wOFpvaiswWFdXMnJISHV6d09jMDFGa09TSkpaTmk1SlVPVG5QYW9udC83U1l4TDhqWXlKSE8xYysxQXRubXVRd2w0SEdBY0NyNk1OM2x5dG1SUjh1MEFWYWsxb1EwbnFjOVBvRWtvVkh4dGo2N2Y0dWVUVTl0b0ZwYTVOdEQ4bWVDUWNtdHg0M0NxZkxLakJCZlBYM3FLWlpXakN4U0FJRGtETlRKOUJydVc5UEp0eW9saUFpeDh6QWNyVVYzTEU5eVRFWHczSkxBSE5aODExSkY4a2tnYzVISUpIWDFwWTVOeXR5Q0Y0Q2p0VUZYTHlYZ3RHeXhXWGNPTWpnVnpmaWU0RTZOSkhHZ0lHTUlPdFgyVStZR2pKVVl4Z0hqRlZMcFJNNWpJenZVZ21xV3hMV3B4dDFZek5BeHdQdVpISFUxVTBtRUo1clhSVkdVZ2JlNUZkTzFsSkhISkEzQ3NPQ2V1YW9TV0N4eU04YWNiZWg3bXBiMEl0cVZKREU3eXVXMmtJZG1mNTFXdDduN1ZJV2w1SWJhTWRqUjlpWWtUVExrc0NUeDJwRjA0dGNEZHlFNVVZNG91ckZhYkZwQzd6UEJJRkFaU0FCVS8ySm9iWUpFZDI1Y0RIWFA4QWhVQ1dzMFYxamF4WHVmWHZ4V29MY2xQS1JtaklJTzdyUzBUS2RyRmJTTEl4dk5pSmNNcHh4MVBGYVZvaG1MT2tRak1aeGswdm1TMjhhSVZ6dGJMTVVBNVBhcEJOc2dESnRWSE9EanZST2J2b1F0RFZZVzhkdUM3S3pjRmpqa21tcThjek1vWmRwKzhhTFV0ZFJDS1YwVUxnZ0JPU1ByVnFJd3dzY3hxdzlTdkpxMUpNb29mMlVsd1pOc2hNZlBIVWlzMDJFTnUzZVZjL043ZmpYUXp6L2FaZm5Hd0VZRElNZmlhWThNYlJNd2tPOVRuL0FIdndvNUVKbURjMjZSeXZESHRBUlMvMXpXYzhwYUVIeTFRS2NzY2M0OWE2ZlVzUHM4dmJnRFk0MmpJejZWa1hsckhCYXROYnVWM3BzWldiZ0hGUnlHYktHb1BjbTBSYktRU3N4WDVSNzFVc3JXVzUzbTVkb01ER1NlalZjMCsvbWgwbGpNTnV3RUp6L0tzUmIyZUNRSEtzakhCeWZXaG9tOWkra3BnWXBJd2tXTTRETjFKN1VndnZPVmdRTitlUGF1YTFLN2xTNmVMZVJoampiM3Flek1qTHNqSkVyTGtNTzlKeDZrczM0ZE9sdkpHWkU1VmR4NUZhSW1YVGh0amRuUUx0S3QyR0t6YkNTYTNpWkpUbVR1ZWxUSGFBVElkd1lBNW9RazBocTNCdVdMcmdKbnRTWElaNGNSWURaeG4ycXRLV3RuTFJnbEdQSXFTMHVVODdZKzdPTnhYMHBQUWU1Um5PeTVDamxzYmdQV2xhTW5jUzJXSFFqdG1yekdFU3FTQVI2azU0b0ppY2t3TGdFWVB0VlhNaXJhSUh0OHlmZTZaejM5YW1HWTVpQ00rNDZVbXdRWUNrWVBQSTZVK1lyaGpua0RJcFh1TzJvNldYcDBBSEoyK2xScGRHM2syVHRzNTVCOURUVkF6SEo1WURjWmJIRlNYRmlra3NrcGN2azdrNTRJcEZiRTlyZFJwTTMzV2pjWVlZL1dtUExERzVLSDVzNDNEb1JXZVZlR0Z0cW5kdSs2S2lqZ25ra1BrdnNBWE9HT1RtaTF5cm92elhra2Z6QmNnZmU0cUpwcHBnR1JDNHp4ejFGVTdLeHVqSXpYVE5nakFZTjFyU2o4dTJYQ2xldVNHSEJOT3lRWHVSZWM0a0VCR1ZZWkJ4eURrVlk4NHhrYlhETGpCeWVsUXlmTklNRURlTjN5bjd0QmlWbHl6Y3IrR2ZlZ0NVU0tZeHVQeWx1VDZWRks0UmkwV1NHT0NQU3FTc3l3a1N0bm5nNTVOU1dzcGtra0xaMmc4MDdFbHFFWWFSeXgyOU1WSWd3YzR5TVlxdEhLalhFbmxzRXljdG52VGxrK2RSSyswQnNBRG9ha29zdXY4QW8vbW9NNDRjWjVGVnJpS0c2dEF5TUJLT25QM2FsazNJeDJzeTdjaytocW5LL2tveW5DcXhBUS9YclFoNkpGVTVEckRPR1VOMGZzVFdsRkFqTnZkY25iZ01PNHFGYkZMdU1MTVdDajV4bHVvcVN4ampqM1pjbFNmbFZqbmltMkpFalJsNERnRExaRGY3T08xVWxUWk9GQUNSeC9NK0RWMUpvREFkdTdjckVNUDcxUU1zWTNISHl0enpTaTJPOWlLYTVNbDJTSEkyb0NJd08yT1B4cUU2akMwbmxaY2lRaFdPY2JUVWtzYXUwWGxIQk9QeTlLemRSc0VWZ2JVdHVVZ3MyZXZmODYxakZNYW4zTEwzSXRzeHUyMGhzQW52U0RMV2tzZ1l0dHlRVjVyUE1YbnlLSld5ZDJXQjdlOWJGcERGYnc3SXp2VU5uT2V1YWRra05QbTJPYThxZVdRN3lRcDViUFlWcDZYSDhwZlBtS3Aya2l0TFVyT0thQjJqd2pTWTNIMnJLc0lKYk12RWZuVWtFazk4VlRhYUl2YmMyWTdmeTJIM1ZMRElVZDZndWtQMk5qY1A1YnFjNTY5YW5qVXk3bmxSUWZMNDcwVFNyS2hqTzBuQUlKR1FLeVc1VFN0Y3lyVmpER1ZrUEdlQlU2M3Y3eFBPRzdCSEI5YXJTbnk0aEd5S0hWamx4NlVqcW0zSllIY09NZHFxeUlPcGpsdEx5RWJDRlBUSzlxZEZZK1hienlGQTU1Mmc5UmpvYTVPMmttZ1krUmtiVHlENlYxVnZJMDF1a3FPU0NuWDFyTng1VFNObU1ndUhkUk5NRDVUWkhsZ2VsU1F6UmZaL0xpR3dFa1lBNEZGdmNCbzJpbWp5QjBJclB0NVlwN2lTSkg4cU5Yd0NEMHgybzVibWwweTRXOGo1bWJJN1k5YXBTbkY0eW5KQkdVUHA3VllqU2NYTWlIbFFSZzQ2KzlXNUxTSWtzNjdXVWM4ZFJUalpDSFIvTmFvWlZ5VHdjZHFpRUN5N2dGNEdSazB0eE41ZW52MzVJTGV2VEg4NnF3WDRrVmZteHUrOVdqanBjTGxsSW5oTEhlQkVRTUQwTldrQ3lRbDJCeURrRUhyVkZFTFJrNXlwUE9hdU1yUldhb3JkU2VCVVJXb0MrYXBqS05qT0tUTG8yMVJsTTVCSnFuTHhJcW9XUGJkNzBseE1YaXdDY0hvU2VocWt0UU5PeHVvVWpra1lGeXYzUUQwUHJVa2QzTGNZbGl5Y25rZzlLb1c4eXFCdFpWYVFCUmxjNUhlbmVVVUxHT1VnRmNFRGlyMWJHVk5aaWkrMWwyYmEvd0RFbzZBK3RaZjJvUVc3bEJ1T2VTT2ExUDdNdFd1VGRYeXpTQmdCbFNRQ1FPcG9pMHhkeGEwUEQ4N1c1eFd5c1JxUTJSYWRRNjR4blByVjVjaGNuZ1o1RlF3V3Nsa0dXVHF6Y0VkalZ4TU1CTHQybFQ4eWRqNzBTR2pzd3c4d1pCSTZkT2xRektxUkRQQUpxUkNXamJKenhtcTl3b09RZW1hODg2aUtPN0JZSVB1NXhudFRKcnQ5d1JmbCtmYVRWYUpRSEM0NERuaXJkd2kvYWtPT2hOVllMa2IzSk12VWtBWXo2aXI5bFpHU0VCdXVjaXE5cEdqeXR1VUhCRmRFcUtrWUNnQVlwdlFSSEhERmJxU1JsaDZkelU4ZVNvWWZJT3RPalVZNmRCeFRGSitmbnZXMGFhTUpUNkVwd3JaQXpudlRIa0k3OCttYVFuQnF1R1AyajhLMk15UldidURUaVgyOGNHcXhrZjdRUnVPS2xSaVhHVFNrN0llNUhJZm4yemc4OUNLcHpvSXBOK1MwZmYxcTNkc2ZJYm5zYXhiaVIwczIybjd5alBlb1YyUGJRMEpya3dSRmxaZ0FBUmp2VThkeTVSWExxVjkvU3NpS1JwUGxjN2dRT0NLbmg0dFl5Q2NxcHh6UzVyRFN1YjhyeGJRM1U1SFNnaENwSTJnKzlVYmR6OW5qNXEwcWc5UlU4elpWckNyRzIvNzJGRk80RFlCR2ZlaHg4djQxQms3NjJpckl6YkxES3dHV0hCUFdtcjg3Y01LYXJFdUFUa2VsVEtpN2p3T3RVSVhCTEJTZTJjMUNaSlE0Q1liSDhxdENOQ09SMHF2S29Fb0E0SFRyUUEyNEYyK3o1Q3E0KzhvRkVVOFpqMkJqbnZ1RklpaHBTRzVHT2hPUlU4U0swNmJobmcwQVBTVUlqRTVJQjVwa3N1OVFVWmlxam5tcElnUHRMREF3TTlSVVV3QzVLakIzZHVLbHNkaXZKSXh3WTFaZ091YWxqdTlpbFhBNEh5NTR4VVFadnNUU2JqdjNkYzFqWGMwbm5iZDNHYXprMmFSaWpiKzJTVHF5Y0FaenZIb0t1V2Qwa0VqRlVWOXc1TEhHS3cweUl4Z25oZU9hYWpNelBray9MbnJXWHRIY3YyYVNMWTh5VzhsZVJsVEpPMEwwcWEyamdNaE03UGpvTURxYXpqODBaSnpuY0IxclVuUlZ0RlpWQU9RT09LdGU5cVM5TkNuTmJGYno5d0M2RWZLTVpxdEpFY0tTQ25KeUFhMUNvUzNoWVp5Vnpna2taK25Tc3k2a1l0eWV0VEx1VkVSc3VQM2VlbVBTazN2dFZWMnEyT2NqbWxCSWp5T3RVN3VSeEpIOHg1NjA0eTFCeDBMTDIyK05SSzVJQjlhWk5FSGhWRVhoUmhlS210bEJpTGtaYlBXcExQOEFleWxaQUNBeHh4VmMxMkxsc2pOL3MxdHZtQkFXYmpCNHFvMmxvSjkwdU56REFVQS96cnE3MUZqYUxZb0dWNTRxdEt6RWdFOEFjQ3I1VWpQbVpsUWFURkd3Mkx4M09LdDIxdUlmbWpkVk9lb0hTckVnL3dCSDNkNnBTL0tFSzhGaHpUc0s1czJyd3JHVk00TEU1K3RObWtTUE93ZzUvSTFuV29DeGZLT3A1TlJTTTBsbkl6c1NRT0RucFVOOUMxSHFhRVZ6R3M2amVIejFWUm1wU0Vqa2ttZ0lqYitMTmN0cE41Y1cxektZSkNoQlBJQXE2YnFlWnkwc2pPVzVPZS9JbzZBOURaVFZVVzNrbHVTV1h2dEZadHJxbSs0bUNNUU9xTWF5TCtSek01empPQ2NjQ29ReGliZkdkcmZNTWlzSlNldzc5U1hVYnZ6THQ4RGFEMUlQZWtnMUh5SThuT1dHTW4xclBtWW5rbms4bW9KZjlXRzcrdFo4ekZjMmpxSmFNQUhkeHppb2hlZzhBNXgwSVBYM3JQdFNTeWY3MlAwcVpQOEFYTU8yYTBUMEM3THR4S1Joajg2TVB2WjZHbm82SGlRREI5YW9kRXlQVWo5S1RKNEhiQU5ReFhaWWxTS2VQYmoyeUtTQ3lRSVdsS2xjZE85VVVrZFNTckVkL3dCYWxMc04rRDJwWEEwdHFKOCtWMk50WHJuL0FEMHA5MUVsdmRBS2R3WkFWSkdLekl6dXRDVHlkMVdkU21rZVliMkp3QUJudHhWWEFXZTVMdGgxSXdBQXBQUDFwbm1xeXNyZ29xbks4ZDZnVC9qNngyMjUvU25TTVNzcC93QnJGQk55VkwzeTVGYkxCQ01DdE9IVUlycFFHYkREclhOM0VyaU9NQnVNMW9hY2NXcWtjRXQxeHpWd2VvRzdISW9rQ2xTUVJucjBGUW1WZm5mUHpEb005cUE3Zkx6Nm1xSG1Pc1RZUFU4MTBKSVpMTGVPMEtsd0crWXRoZW81cXJMY0xlTElDNEtxTTdHNjVGUXU3QzlHRDN4K0dCU3l4ckpiRU9NZ3lZcXJJVE11ZTZtK3ltS2NLa1JKWHAzenhXSmRReWkxV09GVmxZbi9BRmltdWcxYU5YWHkyR1ZSaUZIcFdKanlUSDVmeWhrSkl6MXcxSnhWaUdaeldFODk0QklHWkhreVNPdnFSVzdhV2YyUzYyTGtEUDNUeWNmV3VoV05CbzhNdXhmTWs1WmlPU2Y2Vm1TS0dsYkk2WnJubExTeExSRlBjcEVTTUZ0dzVHS3piclUvTGpWSHpna0FZSFNyRjRCNWFudUtycERHNFIzVUZzOVQ5S2xiRWw2S1ZHakFaOGpxRDYxSzBQN3huR0J3QU1kNnFpMmlOc1hLRGNwT01kdVRUMGRtaEpKeVFPS0JlWlN2SXBMZVB6WXlTT3BHT0JTUVhFbjIyTlVWanVYTGVsWHdUSnVWeVNPdUNhcE83SmNZVTREY24zcDlCRmg1R2YxRGpnaW5HV01NeWNNeEh5Zzk2cVhITVljL2VMREpvbFJXdDJKSEtzTnA5S0I3bHpkSjVKRGdBSDd2TlEvYTViYWJ5dHdhTThnVUFZRzRkY2luU29wa0JJNUNrWnBCc1A4QXRZbVJwSWNiTWNuNmRxY2hqa1VQRDhyakFKNmpGTjJMOWhaZ29CSU9jRHJXVk03Um9XUmlwSTV3YVJSY3Y5Vml0UVVaZ0NDRG4ycUcxMUdLOWxNT011dzRZMWhhMHhNc09UMkdmZW9vcHBHdm1KWThjRDJyYjJhdGNvNm5kTEJicnNBZVJnVVVLY2pCcHJTckw4aHlyZ0x1VUhwVE5Ka2FUVDJMbmNRellKSFNzMjVBL3RUeStkbm1ZSUI2MUNqY1JmSmtqdlRDNFhERUZNNHhqMUZJSUdOeTBKbTJzV080TG1wdkpTYTMzeUx1WkdYYWM5S0gvZDNGd1U0TzNOREhZUkxXYTBqY3FDNVVITE4zNW9NWnVBb2hLaVRxYzlEVTZ1ek1BU2NPbnpZNHpXVHFnOG0yM1JaVTVBeURTU0I2R3c5OGx0YnRISzNtTXc0QzlGUHVhbytYTFBlUno4UEFxOExWaGJlSjdmTElDV1FaOTZ2YWFpaTA0QSs2VFJzSjZsWERXMFlPODR4eG1uckhMTkNsNFdDUUsyMG5QM2ppcldxd3BOWUJwRnljRG5PS2RCYlF4NkhzVkFGM2dZUE5TT3hVYU9Nd0FwdFJOeDNQbm5QdWF4cHRTMzNma282a2Nyd2MxMU9yV05zTEtZTENxaGp5RjQ5UFN1ZjFHeHRvYnFOb29WVW1CaVNQWEFxNGc0NkZVM1loWlVaeGx3QXU0L2ROWEkzVkl6SEtRM0JPY2YxckNraVF6cGtaK2IxclhTTkd1b2d3eUN5cVFmVFBTcmFKWFlaOW5odUZaa1Z0emRQY1ZIWnpHM2tuakp5NnJrTGpyVXM3R0dlYUtJbFV6akFxM0ZGR1lnU2dKd3h5UjdVcmxMM1hvWmR2ZlN2YzRsWEI2amRXc243ekFZZzVKeU1WVHVVVnIrVEk3WS9TcDlLTzlXTGNsV0dDZTFKNjdEM2VwWGt1L0p1SHQ0eGdJZm5MSGlteS9hSjdwVVQ1ZHFFKzNyVlMvSi90TzhQdldwcGlpYXhrTXZ6R0lBb1NmdTA1TGxHNGxDYjdydkluemhmdkwwWVZiMG0xdDdpTHpIY0VZSUl4bXBDb2ZZRzVIVEdhbjA1Rml1RldNYlZmTzREalBCcVhMUVVSczFpUVVralZYaVZmbXgzcXpwMHkvWnBRdWNaT1Z4ME5UUXhyRkxkSWd3b1VNQm5vY1UxU1Fzclo1M0E1UDBxVnJvWFlsc3hER3BMSEp6OHBJNisxV1JwZHFsdEtvakdXNkEvNDAyUlZGbEN3QURZem1yV1Q4bzdZelV1VFF6TTBtT2F5VmhOemw4ZnZEbml0RzRqTWdJVmNaR2ZyVWNvRFJZSXpVMEpKaVVucU9CVWMyb016Nyt5WjlNSVE0QnhrZlN1ZnRoNWFxU3JGU3hBd09vOWE2OTJJWEE2ZGNWbnpERTBlQmpodUIwclgyajJFUlFsVkN4TzIwTzJPblQwcWNQS1ZZOFpaeHR3YzFISW84MWVPOU5ZazJ6WlAzUng3Y2l0WXJRVEV1UUlwcEpEeXNpOEVkUWF6NTQvbFdTTml3eDh3ejA5NnZ6SXJSczVHV1VqQi9Lb05vTWlqQXdTTTQ3MGxKakpiZEVpV1BrdHU3SHRXbXFLOFkrYkM5TUVkNnBQRWlnTUZ3UVJqOHF2UUFHUG10TDJqY3BFY3R5SVN0dWR4QzlmZmcwUXpMRzZJVy9pNTR4aW1YQUFteGoycUM3UlEwWEg4WDlLelhrWDBOVVFyTTVBSVpTTTR4VmRudDVMaEdPY2dFRVpwdHRJeTI0WUhCQU9EVmFkUTNtc2VvY0VHcWszWVNSLy8yUT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvbG9kZ2VQYXJhZGlzZS5qcGdcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBa0FDUUFBRC80UkQ0UlhocFpnQUFUVTBBS2dBQUFBZ0FCQUU3QUFJQUFBQVBBQUFJU29kcEFBUUFBQUFCQUFBSVdweWRBQUVBQUFBZUFBQVEwdW9jQUFjQUFBZ01BQUFBUGdBQUFBQWM2Z0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHRjFkR2h2Y21sNlpXUjFjMlZ5QUFBQUJaQURBQUlBQUFBVUFBQVFxSkFFQUFJQUFBQVVBQUFRdkpLUkFBSUFBQUFETXpRQUFKS1NBQUlBQUFBRE16UUFBT29jQUFjQUFBZ01BQUFJbkFBQUFBQWM2Z0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFESXdNVGc2TURFNk1EY2dNVFE2TXpBNk1USUFNakF4T0Rvd01Ub3dOeUF4TkRvek1Eb3hNZ0FBQUdFQWRRQjBBR2dBYndCeUFHa0FlZ0JsQUdRQWRRQnpBR1VBY2dBQUFQL2hDeUZvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2QUR3L2VIQmhZMnRsZENCaVpXZHBiajBuNzd1L0p5QnBaRDBuVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtKejgrRFFvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWo0OGNtUm1PbEpFUmlCNGJXeHVjenB5WkdZOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2TURJdk1qSXRjbVJtTFhONWJuUmhlQzF1Y3lNaVBqeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSjFkV2xrT21aaFpqVmlaR1ExTFdKaE0yUXRNVEZrWVMxaFpETXhMV1F6TTJRM05URTRNbVl4WWlJZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWk4K1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUluVjFhV1E2Wm1GbU5XSmtaRFV0WW1FelpDMHhNV1JoTFdGa016RXRaRE16WkRjMU1UZ3laakZpSWlCNGJXeHVjenA0YlhBOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOGlQang0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREU0TFRBeExUQTNWREUwT2pNd09qRXlMak16Tmp3dmVHMXdPa055WldGMFpVUmhkR1UrUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SW5WMWFXUTZabUZtTldKa1pEVXRZbUV6WkMweE1XUmhMV0ZrTXpFdFpETXpaRGMxTVRneVpqRmlJaUI0Yld4dWN6cGtZejBpYUhSMGNEb3ZMM0IxY213dWIzSm5MMlJqTDJWc1pXMWxiblJ6THpFdU1TOGlQanhrWXpwamNtVmhkRzl5UGp4eVpHWTZVMlZ4SUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK1BISmtaanBzYVQ1aGRYUm9iM0pwZW1Wa2RYTmxjand2Y21SbU9teHBQand2Y21SbU9sTmxjVDROQ2drSkNUd3ZaR002WTNKbFlYUnZjajQ4TDNKa1pqcEVaWE5qY21sd2RHbHZiajQ4TDNKa1pqcFNSRVkrUEM5NE9uaHRjRzFsZEdFK0RRb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3L2VIQmhZMnRsZENCbGJtUTlKM2NuUHo3LzJ3QkRBQWNGQlFZRkJBY0dCUVlJQndjSUNoRUxDZ2tKQ2hVUEVBd1JHQlVhR1JnVkdCY2JIaWNoR3gwbEhSY1lJaTRpSlNncEt5d3JHaUF2TXk4cU1pY3FLeXIvMndCREFRY0lDQW9KQ2hRTEN4UXFIQmdjS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpci93QUFSQ0FKekE3d0RBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEWHBhUVU2dnVENWNLV2pGRkFCUzBVdEFDVVlveFJRQXRGRkZBQlJSaWlnQW9wYUtCaFJSUmlnUVVZcGFLQUVwYUtLQUNpaWxvQVNpbG94UUFsTGlqRkZBQmlpaWlnQW9vb29BS0tLS0FDaWlpZ0FveFJSUUFVVVVVQUdLTVVVVUFGRkZGQUJSaWlpZ0F4UmlpaWdBeFJpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb294UUFVVVVVQUZJYVdpZ0JLS1dqRkFDVVV1S01VQUpSUlJRQVVVVVVBRkZGRkFCU1V0RkFCU1V0RkFCU1lwYUtBQ2twYUtBRW9vcGFBRW9wYVNnQXBLWEZGQUJSUlJRSUtLS0tBQ2twYUtBQ2twYUtBRW94UlJRQVlvcGFTZ1lVVVlveFFBVVVZb29BS0tLS0FDa3hTMFVBSmlqRkxTVUFGRkZGQUNVVXVLS0FFeFJTMGxBQlNVdEZBQ1lwRFMwWW9BU2lscEtBQ2twYUtBQ2xGRktLQUZvb0ZMUUFVVVVVQUZHS0tXZ0JLS1dpZ1lVVVV0QUNVdEZGQWdvb29vQUtLV2lnQktLV2lnQkJTMFVVQUZGRkxRQWxGTFJRQWxGTFJRQWxMUlJRQVVsTFJRQWxGTFJRSVNpbG9vQVNpbG9vQVNpbG9vQUtURkxSUU1TaWxvb0FTbHhSUlFJS0tLS0FDaWlpZ0FwS1dpZ0FvcGNVWW9HSlJTNG94UUlTaWlseFFBbEZGRkF4S0tYRkZBQ1VVdUtTZ0Fvb29vQUtLS0tBRW9wYUtBRW9wYUtCQ1VVdEpRQVVVVVVBRkZGRkF3b29vb0FLS0tLQUNpaWlnQXBLV2lnQXBLV2lnUWxGTFNVRENpaWlnQW9vb29BS0tLS0FDaWlpZ0FwS1dpZ0JLS1drb0FLS0tLQUNpaWlnQW9vb29BU2lscEtBQ2lpaWdCS0tXaWdCS1Nsb29BU2lscEtBREZKUzBVQUtLV2twUlFBdEZGRkFBS0tLS0FDbG94UmcrdEFCUlMwVUFKUlMwVUFGRkxSUUFVVVVVQUZGS0tLQUVwYUtLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb3BhQkNVVXRGQXhLS1UwbEFCUlJSUUlLS0tLQUNpaWlnQW9vb29BS0tXakZBQ1VVdEZBQ1V0RkZBQlJSUzRvR0pSUzRveFFJU2lsb29HSlMwdEZBaHRGTFJRQWxGTGlqRkF4S0tNVVVDRW9wYVNnQW9vb29BU2lsb29BU2lpbG9BU2lpaWdBb29vb0FLS0tLQUNpaWlnWWxGTFJRSVNpbHBLQUNpaWlnWVVVVVVBRkZGRkFCUlJSUUlLS0tLQUNpaWlnWWxGTFJRQWxGTFJRQWxGTFJRQWxGRkZBQlJSUlFBbExSUlFBbEZMUlFBbEZMU1VBRkZGRkFDVVV0SlFBR2twY1VVQUpSUzBsQUNVVXBwS0FIQ2xwQlMwQUZGTFJRQVVVVVVBTFJTVXVLQUNseFJpaWdBb29vb0FLS1dpZ0Fvb29vQUtLS1dnQktLV2lnQktLV2lnQW9vb29BS0tLS0FDaWlpZ1FVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGTFFBbEZMUlFBVVVVdEFDVVV0RkFCUzFHOGlwd3g1UFRtcUxhNXA2WFgyZVM1akV2cG5GUktwQ09seTR3azFleG8wWXBFY09BUVFRZW1LZGlyUk93VVVVR2dRbEhYcFQ3VlZua2tMTUJIRU10ejFyaWZFdmpaOUwxZ3cya0t0Q3ArYmYzK2xjazhYU2hQa2U1MVJ3MDVSNWpzNkt4dkQzaU8yMSsxTXNJOHVSZUdUUFN0cXVtTWxKWFJ6eWk0dXpFcEtkUlZFaktLWEZGQUNVbExSUUFsRkxpa29BS0tLS0FDaWlpZ0FwS1dpZ0JLS1dpZ0JLS1drb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0JLS1dpZ0JLS1dpZ1lsRkxTZDZCQlJSUlFNS0tLS0JCUlJSUU1LS0tLQUNpaWlnQktLV2lnQktLS0tCQlJSUlFNS1NscEtBQ2lpaWdCS0tXaWdCS0tLS0FDa3BhS0FGb29wYUFDbHBLV2dBb3hSUzBBSlMwVVVBRkZGTFFBVVVVVUFGRkxpakZBQ1V0RkZBQlJSUlFBVVVVdEFDVVV0RkFDVWRLV2lnQktLV2pGQUNVVXRGQWhLS1dpZ0JLS1dpZ0JLS1hGR0tBRW9wYUtBRXBhS0tBQ2lpaWdZVVVVVUNDaWlpZ0FvcGFLQUNscEtXZ0JLS1hGR0tCbzVMeGxjejJBanVZR3dTY1k3VjVIZWF1OGwxSThuek9XKzkzRmU0ZU1ZVkdnSGZ0eTZzTUVjamdjL2thOERsdG1OdzQ2NVkxOHpXcmM5WjJQZnBVM0drcm85VStHMnZ5MzBFMWxPNWN4bktrbmtDdlFxOCsrRkZqRkhwTjNjTWc4NHk3QzNvb1hQOWE5Q0E5ZXRlN2htM1NUWjQxZjhBaU5CVFdHUTMwNHAxSTVDb1MzQ2daSjlxM2IwTWx1Y1hyR3A2aHBza2l3UzdWQkpPTy8xcnk3VnRYbnVycDk3ZVlTeEpPS3Q2NXJsN2RhbmRNa3pOREpJeFZTZWd6V1VzUG1NT0srV3Evd0FXVGZjK2docFRTTysrRnFzOXhjTjgrQmo2VjZoaXVYK0h1bnBaZUY0bkM0YVppekgxN1YxTmZSWWVOcVNQRnJ1OVJpVVV0SlhTYzRVbExpaWdCdEdLV2lnQnRGTFJRQWxHS0tLQUVvcGFTZ0FvcGFLQUVvb29vQUtLTVVVQUZGRkZBQlJSUlFBbUtLV2lnQk1VVXRGQUNVVVlveFFBVVVVdEF4S0tEUlFJS0tLS0FDa3BhS0JoU1V0RkFDVVV0RkFDVVV0SlFBVVVVVUFGRkZGQUJSUlJRSVNpbG9vR0pSUlJRQVVVVVVBSlJSUzBBSlNVdEZBQ1VVdEppZ0IxRkxSUUFVVVV0QUJSUlJpZ0FwYVNsb0FLS0tXZ0JLV2lpZ0Fvb3BhQUVvcGFLQUNpaWlnQXhSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVV0QUNVVXRKUUlLS0tXZ0JLS1drb0FLS0tLQUNpaWlnQW9vb29BS0tXaWdBb3BhS0FDaWlpZ0FvcGFLQUNwTGFMeloxWEdSeVRVZFN5R1dIU2JpYUg3Mk1BK2xjbU1xK3lveWwxT3JDVXZhVmxGbUY0enVZSnJkVkJVOEVNb1AzYzhmMEZlSXpSQ0s1WWVoT00xMm10VDNGMWMzR1cvY3hMbG56My96aXVLa0plVTVPVDYxOGZSazNxZlRWMGs3STlSK0Y4aXRvdDBuZFo4bjhWSC94SnJ1QUs4NStGc3dFMTdiay9mQ3NCOU1qK3RlamoxcjY3QnU5Rkh6R0tWcXJDc1h4WGY4QTluZUc3eWJveklVWDZzTWZ5elcyYTg2K0oycWpiQnBxSDd2N3lUSDZWdGlLbkpUYkZSaHpWRW1lY3NGYVFrMU5FcWdyeDNxdXcrZmcxYmhYY01kODE4cHpYbGRuMEZ0RDJid2t1UEMxbmorNlQrcHJackQ4R2xqNGJ0MWIrSElINTF2WXI2dkQ2MDBmTzF2NGpHMG1LZmlrSXJjeEcwaHAyS1FpZ0J0TFJpaWdCS1NuVWxBRGFLV2lnQktLV2tvQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUVvcGFLQUVvcGFLQUVvcGFTZ0Fvb29vQUtLS0tBRXhTMFVVQUZGRkZBeEtLV2lnQktLV2lnQktLS1dnQktLS0tBQ2lpaWdBcE1VdEZBaEtXaWlnWWxGTFNVQUZGRkZBQ1VVdEpRQVVVVVVBSlJTMFVBSlJSUlFBdExSUUtBRm9vb3hRQVV0RkZBQlJTMFlvQUtLS0tBQ2lpbHhRQVlvb29vQUtLS1hGQUNVVXVLTVVBSlJTNG94UUFsRkxSUUFsTGlqRkdLQUNpaWxvQVNpaWlnUVVZb29vQU1VVVVVRENpaWlnUVVVVVVBR0tLS1dnQktNVVVVQUZGTGlpZ0Fvb3BrczBjSCt2Y1I1NmJqak5US1VZN2xSaTViRDZLZ1M3dDM2VHhuL2dRcVJiaUJqZ1RSRSttOFZEcXdYVXIyY2lTaWx3U01yZ2oxQnpSajFxMUpTMkpjV3R3cXhjNFR3dGRNMlN6T0F1UHBWZkhOYUVpTEw0UnV3Ujh5dHgrVmVabW4rN05IZmwybUlUUER0Y3UzUzNsdDRnVjNFK1lvSDNzRUd1V0NNamZNRHg2aXVvS1BIcVU4dDRDUW03WXZxZjhpc2VhRy92cG1hTzNiYms5QndLK1pwV1doNzFYVjNMbmhYWFJvV3N4M01uTVorV1FmN0pyMnF6dkxlOXQxbXRabGxqWVpEQTlhK2ZMdlM3eUNQekpJeUI2NXBOTHVkV2hueHBrdHdqZWtiWXIyc05qRlNqWm5sVjhNNnJ1ajNuVzlhdE5EMDU3bTdkVklCMnJubGpYaUdyYXROcXVveTNjLzNwRzQ5aFZpWFQ5VHZWTStxM3VIVUVoWlhKSi9Dc2d0dGJaMXgzcWNUaXZiYUxZZEREK3kzM0c3anVGYWxncGZvS3pHQVp1T00xcjJDRkNwQjcxd0xkSFpmUTlrOEx4ZVg0ZXRTUVFTdWExOFZuZUhXMytIN00vd0RUTUN0STE5WlIwcG8rY3E2MUdOTkpTbWtOYW1ZaHBEUzBocGhaaVVocFRSaWdCS0tNVVVBSlNVcG9vQVNpbHBLQUVvcGFNVUFKUlM0b3hRQWxGTGlqRkFDVVVZb29BS0tLS0FERkZGRkFCUlJSUUFsRkxSUUFVbExSUUFVbExpakZBQ1VVdUtURkFCUlJpakZBQlJSaWpGQUJSUlJRQVVocGFNVUFKaWlseFNHZ1lVVVVVQ0NpakZGQXdvb29vQUtTbG9vQVNpakZHS0FDaWpGRkFDVVV0SlFBbEZMUlFBNmlpakZBQlMwWW94UUFVVXRGQUJpaWlsb0FTbHhSaWlnQW9vb29BS0tLV2dBb294UzBBRkZGRkFCUlJSUUFVVVVVQUZKUzBVQUZGRkZBQlJSUlFJU2xvb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb3hSUzBBQUhJNzF4L2lvTzJ0WEc0bmFNRlFPd3hYWDFqK0piRTNObXQzQ3VYaFVoeDZyNjE1dVlVNVNoZGREdndWU01aMmZVODl1SlN2SUJ3TzRQU3N1NXYwVnNOY0ZUN01hMjdxQlgrWWNLM2FzaTUwT0c3VXNmbFlkTVY4OTczYzluVHNRdytJN3V5Yi9SOVFrQUI2RnMxMmZoL3gxSk5JaWFoSUpJMjRMa2Npdkw3L1NaTE52bGJJcTVvM21iRHVPUFN0cVZhZE4zVE01MDR6Vm1qNkJpbFdhTlpJbURLd3lDTzlkRHBNU05vbDJaaDhqSEl6MDRGZUthRjRvdWRNVVFGdk5oSDhCN2ZTdlVuOFJKSDREamxpR0h1bU94VDFBNzEwNDNHUnE0Ymw2blBoY0xLbmlPWTg1MU94ZTd1bVZGQUxPUUd4MEZhVGFHTGF4VkltM3Rqc09QclY3UWRMbTFPNFRCK1RPV2IrZGRIZVdVVU1iaEQ4cURpdm5wU2FWa2U3eXBzODR2OU5pMHpSMm1iYkxPVDhwZmtZUFBINVZ3ZDVxdHdraFdKeWpEbklHTTEyM2lMVWQ5cmRlYUF4amtaVTlGNXdLODdsa2U1ZGpJY3NmYXVtamUycHoxclhzZ2U5bm5mTXBMTjJiTkR1anRrcUFmYW1LbmM4ZTFJNjl3YTZrMGN0aXdGQllZclcwOC9ManFSMnJCU1loZ0swYk81S01DYWEwWWJvOXY4S051OE1XZ0hPMVNQMU5iQjZmenJ6RHd2NDJnMFpmc2VvN3ZJazVSMUdkcHJiOFIrUDlQdDlLUDltVENXNGxVaGNER3l2bzZOZUNvcHRuaDFLTW5VdFlxK0pmaUVMQzZhMTA2TlpIakpEeU1lQWZTdVJ1ZkcrcjNjbVJjQlIvczF6VitETkdaQXgzRTVKejFyTGo4MlI5cUU1K3RlVld4VlNVM1oyUjZOT2hDTWRVZDFGNHAxUlYrVzhrejdHck1YaXJXRHg5dGtKK3RjbFkyVnh1RFNPZU8yYTJZWXdGR1RqbnJTak9xOWVZcHhwN1dPNzhLK0lyNjh2eGEza25tcXlrNU5kb09sY1Y0SjA0dGNTWHJENUZHMWE3YXZhd3ZNNmQ1SGxZamxVN1JFcEtXa3JxT1lLVEZMUlFBbEZHS0tBRW9vb29BTVVZb29vQU1VWW9vb0FLS0tLQUVvcGNVWW9BU2lsb29BU2lpaWdBb29veFFBVVVVVUFHS01VVVVBR0tNVVVVQUZGRkdLQUNpakZHS0FFb3BhS0FFb3BhU2dBb29vb0FNVVlvb29HR0tNVVVVQUpSUzBZb0FTaWxvb0FTaWlpZ0JNVVlwYUtBRW9veFJRQWxHS1dpZ0JjVXRGRklBcGFLS1lCUlJTMEFGRkZGQUJSUlMwQUpSUzB0QUNVdEZGQUJSUlJRQVVVVXRBQ1VVdEZBQ1VZcGFLQUV4UlMwVUFKaWlsb29FSmlqRkxSUUFsRkZMUUFtS01VdEZBQ1lveFMwVUFKUlJTMEFKUmlsb29BVEZMUlJRQVVVVVVBRkpnRUVNTWdqQlgxRk9wS1RpbXJNTHRXYU9KOFI2Ui9aOHJUUUROdEtjZzQvMVo3aXVTbWFTTm0yazRyMkdXR09lRm9wbERJd3dRYTRIeEI0ZWZUV2FXSWVaYk45MXU2L1d2bjhYaEpRbHpMWTl2RFltTTFaN25uMm9YRFNBakpCOTZnczdob2lvWVk1clQxQ3ozYm5YRlRlR2ZDbHo0ajF4SUVKU0dNYnBwUDdxWjUvR3ZPZWlPM1U2WHdqNFlPc0g3ZnFHNkd3VGd2bkJrUG92K05kWHF0amMzZ0VjUTJ3d0xoTUhDcUsxcnBMRFRvYmV6dGx4YlFwdFFIK0g2aXIxbmQyOTBpeE1vVmNaK3RlZlV1M2M2NmRsb044TUkrbTZXeXlBQTlCNjFCck4zSUU4dVA3N0FnWTdtdE8wSWFTZDJYaEd6eDZWejJvdXpzNElJWUZtNDdDc2I2blJHTmtlYitOSXlrc2tzRGZKSXZ6RFBRNEhhdUpSc2RldGRmNDJML2FBeUhhcFVncjZuZGl1T1hrMTNVL2hPS3I4UklDZHhOR3d5RDVhbWdVSHFNMVppaTZrRGdWb2pKbWQ5bFpXNXFlTmNOZzFaQ2x0MmV0SWtMQTVJK2xhclVsc2UwUWtoRzc3eWNpcUVwM2tEdUQwclRnYk00WDg4MDNYN1FXY2NkekV2MytEZ2Q2cm1hVmhhYm1mTklGaTIxU2dkbHVQa0hIclRYRXpxTjRxZTFpWWtiaFZSVGJJYjBOaUNWdU9jVnM2VHA4MnNhaEZhMnk1eWNzM1lDc3V6dFpMaVNPQzJVdEk1QUF4bXZYL0MvaDJMUXRQQVlicmlUbVJ2NkN2U3c5SG5ma2NWYXJ5THpOR3dzVXNMRkxlSDdxcmpPT3BxemluZldrTmV6R1BLckhsT1RiMUdta3B4NlVsVUliUmlsTkZBQ1VVWW9vQVNpbG9vQVNrcGFNVUFKUlMwVUFKUlMwVUFKUlMwVUFKUmlsb29BVEZGRkZBQmlpaWlnQW9vb29BS0tLS0FFb3BhS0FFb29ORkFCUlJSUUFZb29vb0FLS0tLQUNqRkZGQUJpaWlpZ0JLS1dpZ0JLS0tLQUNqRkZGQXd4UmlpaWdCRFJTMFVBSlNVdEZBQ1VVdEppZ0IxTFNVdEFCUlJTOUtBQ2lpaWdBcDFOcGFBQ2lpbG9BS0tLS0FDaWlsb0FTaWxvb0FLS0JSUUFVVXRGQUNVWXBhS0FFb29wYUFFb3BhS0FFb3BhU2dRbExSUUtBQ2lsb29BU2lnMFVBRkZGRkFCUlJTMEFKUmlpbG9BS0tLS0FDakZGTFFBbUthNkxJcFYxREJoZ2hobklwOUdLbHhUVm5zT01uRjNSeWVzK0NJTG9tVFRYRUxOMWpZWlUxZjhJYVJMb0dqNnV0NEVEektxbzRQYk5icEhGWW11YWhaMmFoTG56WExEN2tTa2xoWGw0ckF3Y09hQjZHSHhjK1pLUlQxOTJoMHhnajcySzVqWUduYUpxRFMyRUx6L0FDT3k0SnJ6L1UvRU02NmtiTGRMRkZ5Vlc0SEtlMWRycFNTM0dpeCtYR1ZrVVlLOWErYXFRY2RHZTVHYWs3bzdxenVJell5RlI4N2prNXJGMUtGdnNyU1JnYnlTcmNaNHgvOEFXcDVXV3owdUIzQkcvcm1wN2tNTkpiUDNzWjVyaWtyU082THZFOHY4WTJzY2xzc3NybGRpNVZSL2VKelhDSU1kYTZUeGhQSTk0d1oySVppVkhaUmppdWRoRzV1YTc2ZnduRFYrSWxpYkdjVlpXY1J3NFBVMVZYQWtJSHJUNUkzZHh0R1JXcU0yVEpKdFBGV2xiNVJrOXZ5cWtzYlJnczQ1RlVMeTdiRzBOajZWYWRpVFl0WTFtdXN4TnZDY24zcXhyczdTMnNVRWFNMlBtWWdaeFhQNlhOZVJ5SDdLQTNjZ211czBEVlpMUy9mN1ZhNUxqNWdjRUFVTGZVTjFvY3JIRTdzT0dZbjJycGRFOEk2cHFqcUliWXhwbm1TUVlBRmVvNkdtbFhhaDFzb0ZrUGNvTTEwcXFvWENBQWVnRmV2aDhQQ2F1MmVmaWEwb2FKSE9lSFBDTnBvVVlkdjMxeXcrYVVqcDdDdC9GU0VldE14WHJRaW9xeVBMbEp5ZDJOSXB1S2VhYWEwSUdtbTRweEZKUUEwMFU2a29BU2twYVNnQW9wYVNnQW9vb29BS1Nsb29BU2lsb29BU2lscEtBQ2lpaWdBcEtXaWdCS0tXaWdCS0tXaWdCS0tLS0FDaWlpZ0F4UlJSUUFsTFJSUUFVbExSUUFsRkxTVUFGRkZGQUJSUlJRTUtLS0tBQ2lpaWdRVWxMUlFBbEZMU1VEQ2lpaWdBcEtXaWdCS0tLS0FIVVVVVUFGTFJSUUF0RkZGQUJTMFVVQUZGRkxRQVVVVVVBRkZGTFFBbEZMUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFnb29vb0FLS0tLQUNpaWlnQktXaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQVVVVVVVQUZMUlJRQVV4b1luYmM2S1Q2bGMwK2xGSzF4K2g1NzQ5OEd0cUYwTlJzU29sY2hYUTlzRDcxZXBlQlBDME52b2RzTGtNY291U1QxRlp4aGprbVF6S0hSU0NSWG8xaEhFTFJHdDhDTmx5bzlPT2xmTlpsUmNaY3kyWjdtQ3FxUzVYdWM3cW1sUnlBMnFqQ0tBVnoycmxmRXlDUFQ3bVdHVVIvd3JrWndPL3dES3U4dnkwa1RzT3VBQzM0MTVaNHZ2ZmxraUp4REd1Q2Y3eE5mUHYzcEhzdzBpZVplSjlWVzQwNjN0NDRWQlVrZWRqbHYvQUsxYzViTGlUbnBVbW8zSDJpN1lya3FwT0FmMXFPRlR1cnZnclJzY3RSODBpMDhLaWVQSDhRelY2MXQxbWZrNEZGcmIrZGJFbjd5OURVa0xiUUQwNXJaR0xKcE5KUjFJTHRYT2FucFVrRGs0TFI1NEk3VjI4QUR4amRVNjIwTWpmdlUzTFIxR2NIWVF0YndTeUFuUEdLMXJ2YzhVVnhGOTRMODMwcUxWMlg3WXdqWEVhc1Z3S2x1blNPekFEY0hHS1RDSnJhRDQzdXJGMWpjSnNIR1F2TmVuNk40aWoxT0FNT3A3VjRLWE1NcElVRUh2WFYrR05ZbWhuUkIwSjlhNnNOV2xDVms5Q0sxR05TT3U1N1IxcEtvYVpkTlBiZ3Z3U0swRFgwVk9mT3JuZ1ZJT0VtbU5OTU5QTk5JclV5R2tVMm5Ha0lwZ05wS2RTVUFOTkZPcEtBRW9vb29BS1Nsb29BU2lscEtBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQXBLV2lnQktLV2lnQktLV2tvQUtLS0tBQ2twYUtBRW9wYUtBRW9wYUtBRW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtTbG9vR0pSUlJRSUtLV2lnQk1VVVVVQUJwS1drb0dGSlMwVUFMUzBVVWdDbEZGRkFCUzBVVXdDaWdVdEFCUUtLS0FDaWlsb0FLS0tLQUNpaWxvQVNpbG9vQVNpbG9vQVNpbG9vQVNseFJSUUFsRkxSUUlTaWxvb0FTaWxvb0FTaWxvb0FTaWxvb0FTaWxvb0FTaWxvb0FTaWxvb0FLS0tLQUNpaWxvQUtLS0JRQXRLS1Nsb0FYdjlhN1R3MU9KdEhLTWZtak9COURYRjRycFBDY2loN21Oajk1UWNWNXVZdzVxTDhqdXdVdVdxdk1UeEhmaXp0QkdyYlc2c1ByL0FQcXJ4Zng3TTBGdnZkbS9lWllZUGZ0WG8zaU81dDVkVXVUSk1DeUhvRzdkcThxOGFDVjRVZVZoSkhrN0dCNlY4aENQdkgwcmw3cHdDTmtFdDFKelM3ei9BQThjMDEyRzdIcFNxVTNEQnpYY2tjZHpvZEdmZEZoOGNWTkxFTjVBNktlTVZVMGgxVjhkY2ptdE1RTVFjOVNldnZWQVdMYU5wbDIvZElxTFVMMmF6TFJ4cndzWkpOWDRtanRreTMzdWdyTDFpYk44WXlBQUV5Y2QrbE9Ra1lleGpiQnBHNWRpVG5xVFdmcXNqcUlseWNCUldpekNTNVlOd0Y0RlptcUh6SXhJQjkzSXFHVjBHeFMrYmI0Qk84Vk5CZXpXN0JnYzRQZmlxbW1ZKzBoVzZFVk84WGx6RU53T3h4UXIzdWhwbm92aGJ4Z0VLeFRKSjA0S3RrVjZWWjMwZDNFckorT2E4QzAveWZPUWwrYzl4aXZVZkMwN2VXcWdySXYreEprL2xYcllTdE4raHhZbWxHU3VkcVJTRVVJZHlaNS9HbE5lM0U4U1NzeGxOSXA1Rk5OVUlZYUtjYWJRQWxKUzBVQUpSUlJRQWxGTFNVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUNVVXRGQUNVVXRGQUNVVVVZb0FLS0tLQUNpaWlnQktLV2lnQktLV2lnQktLV2tvQUtLV2lnQktLS0tBRW9wYUtBRW9wYVNnWVVVVVVBRkZGRkFCUlJSUUFVVVVVQUpSUzBVQU5vcGFTZ0IxTFNVdElBb3BhS0FDbHBLV21BbExSUlFBVVV0RkFCUlJSaWdBcGFLS0FDaWlpZ0Fvb3BhQUVvcGFLQUVvcGFLQUVvcGFRMENDaWxwTVVBRkZGRkFCUlJTMEFKUlJSUUFVVVVVQUZGRkxRQWxGTFNVQUZGQUZGQUJSUlMwQUZGRkZBQlMwbExRQVV0SlMwQUtLY0w5ckNHUjBsTVpaU3VlOU5yUDFlZElJQkpNUUkxeTc1OUJYSGpmNE1qcXd2OFZITDZza3krYmR2TTJNRWd0M05jUTJweDNzYnc2aEt3SWNzRVhwVzlINGtQamI3Um9VR3kza1p5MXVUL0V1Ung5ZXRjUnI5alA0ZTFtUzF1RHVrUUE1OWErU3AyMmU1OUZPKzZJWGdXNnVKbUI4dEVHNEtCMXF1a2V4aGtFRDNxWnRVa1REckdzYTdlZU90VjQ3NDNSWVBnZjNmYXVoR0xScTZkT0k3dUlzZmxCNXgzcnFVbVZrYVVMd0JraXVLc1dKbkdPZUs2dXlsSTB1UTlUdHg5S0JsVDdXODE0TW52eFVrMHllWktaVG1WK21mU29MTWI3OVZQYmswU3dmYk5TQml5VVVBTVQwR0toaks5emJDRFlSL0VTYXhydzdiRWc5elhYYW9rZjJMS2tFcU1BMXkxeEh1amJJNkRpaGdVZE9VK2R1N0FWcVNtT1pURHV4SUJrWXFqWnA1VzdQZmlvcDVkdDV2UTlEUUJJazd3dmtjTUs2WHc3NG1TMW5WYnRWWWRtUEJINGl1ZXVZeElpelI5SC9RMVV3ZDNGYVU2a29QUUdrMVpuMGJvMS9GZTJxdkJJSEIvd0JyTmF3cjU3OE4rSWJqU0x4RzN1RXp5QWNDdmE5QzEyMjFXMFI0NUJ1STVHZWE5N0M0bFZGWjduajRyRE9QdkxZMXpUVFQ4NTVwQ0s5RTg4aklwQ0tjUlNFVXdHbWtweEZKaWdCS1NsTkZBQ1VVVVVBRkZGRkFDR2lsb29BU2lnMFVBRkZMU1lvQUtLV2s3MEFGRkJvb0FLS0tLQUNpaWlnQXBLV2lnQktLV2tvQUtLS0tBQ2lpaWdBb29vb0FLU2xwS0FDaWlpZ0FvcGFTZ1lVR2lpZ0JLS1dpZ0JLS1dnMEFKUlJSUUFVVVVVQUlhS0RSUUE2aWlscEFGRkZMVEFLS01VdElCTVV0RkZNQW9vb0ZBQlMwVVVBRkZGRkFCUzBVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFnb29vb0FLS0tLQUVwYUtLQURGR0tLS0FERkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZMUUFvb29vb0FNMXlmakh6YnF4bmdpTFlTTWtoVHlhNnFSdHFFKzFjcnE3U1F1SmU3NTdkc1Y1R2FWMVRnbzl6MU12b3VjbkxzZVYrSE5PdUlQSEdtcmhsemNLY2pqNVFjbW5mRU83aXZmRzE3TEMrK0lQZ01QclhyZmh2VHJLN2tpdXpBclN3bytDQnhtdlAvQUJ2cGx2SHFSOGxVVlIyVVY4ekdyRjFMSHR1bkxrdWNMcUc1dkpTUG9VcGtNV3c0UFU5ZmF0SzZpVlFqTGo1Rk9hcG9Delp6OTdqQXJyT2NzV2hDekllMjdtdXFndXJjS1lsSTJ0NzF6Y2Rvd1FZN2RhMHROc3ZPbVFzMjBaeXhQUlFPOUpqUnNRUlF4WGNqc2VNREh0VUYzZHhSUitYYmZLR1BMVmlYV3NHUzRlQzBVbFNjQW52U1N1MGx4QkMzSkh6TjdDcHVPeG9YazNsV1cwblBHYTVrM3hZbFc2RTFwNnZkRDdOd2VXT0s1N3JUQTBSSis3M0Nxak51T2ZXcFlzbTFQdFVHZUtCR2paUDV0ckpFZW81RlFTRERFcU1jVXVuT0Z1UUQwWVlwOGk0ZDBQVlR4UU1iRE0wVWlzUUhBN0h2WG9uZzdXdE5WMVdZdGJTOGY3cHJ6YjdwSE5iZWkzTVFuUlhrVlRuZ1NENVQrTmRPSG00eU02a2VhTmo2RHQ1NDU0Z3lPR0hxTzlTWXJtUERNNE1LS0kyUSt6NVUvU3Vvem12cGFVK1pYUG42c09XVmhwcHBwNXBwcll5RzBocHhwcG9BU2twMktTZ0JLS01VVUFJYUtXaWdCS0tEUlFBVVVVVUFGRkZGQUJSUlJRQWhvcGFLQUVvcGFLQUVvcGFLQUVvb05GQUJpaWlpZ0Fvb29vQUtTbG9vQUtTaWxvQVNpbHBLQUNpaWlnQW9vb29BU2lsb3hRTVNpbG9vRUpSUlJRTUtEUlJRQWxGTFFhQUVvb29vQVhGS0tLS1FDMFlvcGFZQ1V0RkZBQlJpakZHS0FGb29vb0FLTVVVdUtBQ2lpaWdBb29vb0FLS0tLQUNqRkZGQUJpakZMUmlnQktLV2lnUWxGRkdLQURGRkxpakZBQ1VVVXRBQ1VVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFLS0tLS0FGb29GQjYwQVMyMEludW9vMnh0WngxcWw0MDBieW9aSHhqampGV2NsU0N2WHFDSzE1cFk5YTB2eUpHQW5VWXdlOWZPWnpRbkpLcEhaSHVaWFdqRnVEM09HMEtUN0JvQmtqUCtzREErMWVZZUpyMzdUcTBvQnlvSng3YzE2WjRqZ2swM1RIaGlYeXd1YzRyeUM3Wm11MkpPY2s1SkZmTzBJTnpjbWUxV2t1VGxSU25VdEV4RlM2Zlo3OEVqTldZcmNNT2FzUnRIYmZLT1Q2Q3ZRNkhGYlc1T1lQTFQxT09CV0pOY1hzek5CR1dTUE9NQVl6WHF2Z0x3NnQvRExkWHhSWGNZaFdRY054MHJtUEUxbkhwR3BUSzBheERkd0FPdFMyMDdGSlhWekEwM1NsUWVZd3kvZXBkUmlqczdhU1VmNnhoZ0gycDF0cUt5eUNOVnc1KzZ2cFZieEU1Mnhvdk9QdkgxTk5FczUrZVpwRlhjY2p0VUFxOU5hN0xWSEdTVzRwSUxGOTY3MXd2V3FFT2hURnAwNjFSUERHdDVvQUl3RkhGWk05dXl5a3FPS0JoYUhiY0lldURWaStMUjNtNzE1cUd6VE00TGR1dExmeTc1dm9LTndGbFVaM0RvYVpHeFYrZVFhZGJ1SFF4bnJUSEdHb3ZaZ2VnK0N0WU52TXNmbnNxLzNUeUs5ZHRKaFBBcERCcytsZk9HbGFqOWh1a2tZRmxCNlp4WHRuaEx4RFo2amFLc2I3WC91bml2ZHdWYUxWbTlUeWNaVGxlNTFKcHBGUDdjVTBpdlZSNVkwMDJubW1tcUFTbW5yVGpTWW9BU2t4VGlLU2dZbUtLV2tOQUJSUlJRQVlwTVV0RkFCaWpGRkZBQmlreFMwbUtBREZHS01VWW9BS0tLS0FDaWlpZ0Fvb29vQVEwWXBhS0FFeFJpbHBNVUFHS01VWXBhQUV4UmlqRkZBQlJSUlFBVVVVVUFKUlMwVUFKaWpGRkdLQURGR0tNVVlvR0dLTVVVVUFGSlMwVUNFeFJTbWtvR0JwS1dnMEFMUlJTMGdDbHBLV21BVVVVdEFCUlJSUUFVdEZGQUJSUlJRQVVVdEZBQmlpaWlnQXhSaWlpZ0Fvb29vQU1VVVVVQ0NqRkZGQXd4UlJSUUlLS0tLQURGR0tLS0FDaWlpZ0Fvb3hSUUFVVVVVQUdLS0tLQUNpaWlnQW9vb29BTVVZb29vQUtLS1dnQW83MFVVQUZJQ1VjTWgya0hPUlRxTVZNb3FhYWEwWTR5bEdYTWlQVjBUV05QZUtkUG43c09wNC93RDFWNUpySGhLNnRycG1qaVprNmpBcjEvRk5lRlpSOHd6OVJYalN5cUY3d2VoNmtjeG5hMGtlS1FhRnFVeDJRMjdqNml1cTBMd0FWbFdmVWZtT2M3YTlBUzJqVWNJQjlCVTZxQlc5TEw2Y0h6UFV4cVkyYzFaYUQ5THRvN2VXQ0tJTEdnWVl5T0FLNVg0eWVINEJiTGRSU2hKR2JPMGpyOURYVnFjR3RQeFhwMm5hMTRaaXVMN2J0Z1hMTjdBVndablJVV3FpUjE0Q3E1WGd6NWVzTFY0WjhxRHUvdkdybW8yNG5XSzNISkIzTVJWbnhKcm1uUlhaajBpQWhWNFp5ZXA5YXAyMTJwdFRJRG1SdW50WG1JOUJrWmpWNUJHQndEU3p1a2FsbXdGRlFQYytSYnZMbms4TFdKUGRQTU1NeHhucFZDTmlPNlNjRUwxN1ZHKzBIRFl6NlZRMDQvNlFmYWwxQWxaOGdubWdDNlZWWTl5REhyV1hjajk0U2FmRGRNbUZibGFzeVJDYUVrRG50UUJucTJHQkhGV24rZVBlUHhxc3lGU1FlMVQyemo1a2JvUlRZRE9uSXJwL0MvaUNiUzdsY29KSXM4anZYTk91R05TUVNsSEdEaXRhVTNGcG96cVJVbzJaOUdhTHJLYWxiSXlSTXZIZXRYdHhYbWZnUFYyV05ZWFk0emdaNmZuWHBpSGVvSTdpdnBhTlRuamMrZnJRNUpXRzBocDVGTklyb01SdE5weEZKVEFiUWFXa05BQ1VVVVVEQ2tOTFJpZ0JLS1drTkFCUlJSeFFBVVVVVUFGRkZGQUJpa3hTMFVBRkdLS0tBREZJYVdpZ0JLS0RSeFFBVVVjVVVBRkZGRkFCU0dsb29BUVV0RkZBQ0dpbHBEUUFVVUNnMEFGRkZGQUJSUlJRQWxGTFNVRENpbHBNVUFGRkdLS0FFb3BhS0FDbG9wYVFCUlJSVEFXaWlqRkFCUzBVVUFGRkZGQUJTMGxMUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQWdvb29wQUZGRkZBQlJSUlFBVVVVVXdDaWlpZ0Fvb29vQUtLS0tRQlJSUlFBVVVVVUFGRkZGQUJSUlMwQUpTMGxMVEFLS0tLQUZGTFNDaWdCMUtEVGFVVUFPcFJTQ2xwQU9CcTlER3VvYU5lNmJJTjNtUmxrSHFSVkFWUGF6dGIzS1NKd1ZiOU85Y2VKcGUwcHRIUmg2bkpVVFBucnhmYlc5cmV0YjJ0c1VkT1dJRlltbWlUN1FRT21PYzE3UDhTOUZ0dFB2M3ZCR29pblhjT09TRFhqdHFrcHZKV1VmSUI4eEhTdmxWcGRIMGN0ZFNIVkcyb2thOXVUV1YwTmFHb3NTMk92dlZDdEVRUzJyRlp3UlUrb25NZ05RVzQvZkw5YXQ2Z3Z5QTQ3MGhtZU90YWxyZzI2Z2RheXd1V3g2MXN3eGVWQ3VmU2hpQXdJL1VDcTF4YWVWODhmSW9rdnZMZjVSa2Q2ZkJmTEsyMXhqTkFGY25kajZVeitMcHpWdTV0ZkxqOHlQb0RuRlZjN200cG9EZThPYXpOcGwycHo4cDZnaml2YnRBMW1HL3NrSWRDMk9nTmZQa0pkV1hZU0RuMHpYb2ZoRFVyaUtSREpDanIweXJDdll3ZFMyalBPeGRKU1YwZXNHa1BTbzdhWHpvUTJNY1ZLYTlnOGNZYVNuR2s3VlFDVWhwYVE5YVlEVFJTMGhvQVEwVXBwS0JoUlJSUUFVVVVVQUZJYURTMEFKUlM1b29BU2lsb29BU2lscERRQVVVVVVBRkZGRkFCUlJSUUFVaHBhS0FFb3BhS0FFb29ORkFCUlJSUUFVaHBhS0FFRkxSUlFBaG9GTFJRQWhvcGFLQmlVVVVVQ0Nrb3BhQmlVVXRGQUMwVVVVaEMwVVVDZ1l0RkZGTUFvb29vQUtLV2lnQW9vb29BS1dpaWdBelJtaWlrQVVVVVVBRkZGRkFCUm1paWdBb29vb0VGRkZGQUJtaWlpZ0Fvb29vQUtLS0tBQTBsTFJRQVVab29vQVNpbG9vQVNpbG9vQUtNMFVVQUdhTTBVVUFGRkZGQUJSUlM0b0VGTFNVdEF3cFJSUlRBV2xGTnB3cENIQ2x6MXhUYVVWTFE5aXpyZWlXM2lidzFHdDM5NkJ0dVIzQTV4WGwydGVHRkttMTB5QVJKR1NYZnUzZXZYdEd1WTBTZUdiRzFsM0RQdFhJZUk5VXNyV3pubHRaa0pKT0FleEZmSFkyTHBZaVNXelBxc0hKVmFLZlk4SjFhd01FOGtCNVpUMXJKYXlrM0JRTTU2MTArcE9MaTZlVmpsbUlKK3RVUE1SRGxqM3FWZXdtVm9kUEVDaDJPVFJjUStiQ3g3NHFTNHZZMllBTU1WSUNza1IyOVA1MHdLRnJaN2xFamRNMUxmWEFpVGFQdlZieUlZdllET0t3cDVQTW1Zbm1taERDZDNOSUR0SXh3UlNVdlVpbUJzMlUzbjIrMStjQ3FMRFpLdzdacTdZS0ZnQkhmclZTN0hsM1JCNVU5RFNBZEV4VnVLNmJ3N2ZlWGNBTnllMkR6WExISXdSeFZ1eXZtaGtHOVJJTTkrby9yWFZRcWNyMU1xc2VhSjcxb04yWllGQkRqMmF0MDE1eDRVMWVHYmFzZHkwWjdxNURmcjJyMFNCdDBZSU9janJYMFZLWE5HNTROV0ZtT05OcDlOUFd0akVhYVNuRVUzRlVBaHBNVTZrb0FiUlRqU1VERW94UlJRQWxGTFNHZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUROSWFXaWdCS0tXaWdCS0tEUlFBVVVVVUFGRkZGQUJTR2xvb0FTaWcwRHBRQVVVdElhQUNpaWlnQW9vb29BS0tLS0FFeFJTMGhvQUtLS0tBRkZMU1V0SUFvb3BhQmhSUlJRQVV0RkZBQlJSUlFBdEZBb29BS0tLS0FDaWlpZ0FvcGFLQUVvb29vQUtLS1dnQktLS1dnUWxGTFJRQWxGTFJRQWxGTFJRQWxGTGlqRkFDVVV0RkFDVVV0RkFDVVV0RkFDVVV0RkFDVVV0RkFDVVV0RkFDVVV0RkFCUlJSUUlLS0tLQmkwdEpSUUlkUUtTbG9BZFNpbWlscEFPeWVkcHdhOHc4WFdrZ0U4U0g1bWZldk5lblZ6WGluU0RkUTNGMUdnL3dCSHQya1krb3lLOGZNcUtuQlRQVnkrcTR0d1BMZFAweDc2eHVwbmJpSTVKNm5OY3ZxbUZsS3hrbE04RTE2TjRUampWNzZ6a2JJbFFuUHFLOCsxMk1SYWxMQW44TDhlOWVGRjYyUFhhME1yY2M1UFd0cTBtVm9VQ2pIcldNRUliYWV2ZXR1MWpXSzNHN2cxYklKSi9uWEhZaXNLU01xekhCd0RXNEgzQWtjMGtrQ1BEakhYclFtTXdhWHZXaE5weHhtS3F2MmVVTVJ0UHZ4VHVJMDlQVWkzQlBUdFZlK3hLTXI5NUR5S3RnaUt5R09tS3h2T0lsTEU4SHJTQW1pZmVtMDhudFJrZ1p4elVHZGttVjZWT1R2VGNQeHA3RE5uUTliYlQ3bFRLcXVnUFE4ZnJYdC9oZldJZFMwOVdoNDQ1REd2bmJmdDZWMkhnbldtc3RTVlBOWlZZZ1l6eFhwWVRFdU11Vm5EaWFDbEhtUjd2VFRUTFdYenJkWHlHeU8xU2tWN3NYYzhTMXRDTTBsUE5OeFZpRzBVcHBLQUVOSlNta3BnSWFLV2lrTVNpbHBLQUNpaWlnQkRSUzBVd0VvcGFRMGdDaWlpbUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFJYUtXaWdCS0tXa05BQlJSUlFBVVVVVUFGRkZGQUJSUlJRQWhvcGFLQUVvb05GQUJSUlJRQVVocGFLQmkwVVV0SVFVVVVVQUZMUUtLQmhTMFVVQUdLQlJSUUFVVVV0QUNVdEdLS0FFcGFLS0JCUlJSUUFVVVVVQUZHS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0FwYVNpZ0JhS0tLQkMwdEpSUU1kUzBnNlV0QWhhZzFBc2RKdVlsR1JLbXh2OTJwNlVqY3BCOU1WaFdoendjVGFqUGttcEhqOEZrMm1lSVBNaUJhRmlVOHZ1Qm1zSy8wZGpyZHhMTkcyd2ZkR0s5Tm4wbC8rRWhRR1BlaEo3ZEJWVHhIRkZCTXBrQVZ6d1Z4NmRLK05tL1oxT1UrcGl1ZUhNZVFDeTh1NWRuSGZwVWQ1TWRnalE4OThWdmE3SkQ1elBEd29IT081ckYwdUFYVFRzNmx0b3lQclduUXpGMC9tRGs0NXBidVI0cEZJUHludFZpR0F4cnloQzU0TlZ0UWY1QXVLWWlTSzlpTGJUd2F0THNmb1JYT3NTclo1cDhkeEpHd0lQSHBUc0kycDB6R1FQU3NCaHRZajBOYmRyT0xoZXZQY1ZRdnJVeHk3d1BsYWhBVXdwYkpBemlwWW5JNFBTcHJLSmhQdUk0eGc1cWVhd3l6TkgxNjRwZ1ZzRGR6eFY3VDBIMmdGV0l4MElxazZFZ1o0STYwc01oaGtWa0pVNXprZjRWZE9TakxVVWxkYUh1dmd1NGxObWl5emJ4am9lMWRnUm12SHZCdmlSeklzTXFSdGc4RldLbjhqa1Y2M2F5K2RBcmtiZU9oTmZTWWVhbEhROEhFVTNHYmJKU0taVHpTR3VvNUJocENLZGltbnJUR0pSUzBob0FRMGxMaWt4UUFZb3hSUlFNU2lsb29BU2lscERRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQ0dpbE5BNlVBSlJTNHBLQUNpaWlnQW9vb29BS1EwdEZBQUtRMHRGTUJLS1dpZ0JLS01VWW9BS0tLS0FDa05MUlFBbEZCb29HTFMwVVVoQlMwbExRQVV0SlMwRENpaWlnQW9vb29BS1dpaWdBb29vb0FLS1dpZ0JLS1dpZ1FVVVVVQUZGRkZBQlNVdExRQWxKU21pZ0JLS1dpZ0JLS1dpZ0JLV2lpZ0FwS1dpZ0JLV2lpZ0Fvb29vQUtLS0tBQ2twYU1VQUZGRkZBQ1VVdEZBQlJSUlFBVVVVVUFGRkZMUUFVdEpSUUlXbEZKU2lnQndwYVFVdFN4bDNUTEJMcTY4MDdkMFlKSTlSWG5IeEhYN0ZQSk8zek44d1FZcjBmU3JqN1BmS1NlR0JVMTV2OEFGUjBudm81WWp1Q25heSs5ZktabFJjTVNwclpuMDJYMUZPaHk5anlHN21hOG44c0hCZms1TmFuaHkwQ3BkSkw5NGRCV1JlNWh2MmxRc09lTTExR2piWlo0NWh5WkV6Z0RyNlZ6eStFMFh4QzMyMkcxTnFzWStRNTNqMXJscjlqZ1k2WnJ1ZFJzdk1oZHVVeDZjZmpYRzMwV2R5OVNEVXdlaFVscVpERElwdEs0SWFtcldobVN3U3RES0dVOVRXMWdTcUNjSGowckdpaU1zZ0MrdGJjS2JGQTdBVUFJa1NnMUlTRjl1S0E2bHNkNnBhbnZWUXlFaWtNUzdqSDMxNzlSVkVrNTdVeGJodzNMWkh2VWprT01xYWV3RnV6bDhwd3pMbkI0MnRnaXZXdkJIaVZIaVczbnVITERvSk91SzhhV1ZvMjNJM05kWjRiMXQ0YmhCZFFwSXVSODJPYTlIQ1Z1V1ZqanhGUG1qYzk1Vmd5Z2pvYVVpcy9TTDJLOHMwTWVCeDByUU5lL0YzUjRjbzIwRzAzRlB4VFQxcXlSdUtURk9OSlFBbEZGRkFDR2twY1VVQUpSUlJRTUtLS0tBQ2tOTFJRQWxGTFJRQWxGTFJRQWxGQm9vQUtLS0tBQ2lpaWdBb29vb0FURkZMUlFBbEZMUmlnQktLWEZHS0FFb29vb0FLS0tLQUNpaWlnQXBEUzBVQUpSUWFLWUJTR2xvb0FXaWlscEFGTGlrb29BWEZGRkZBd3BSU1V0QUJpaWlpZ0Fvb3BhQURGRkFvb0FLS0tLQUNpaWxvRUpTMFVVZ0VwYUtLQUVwYU1VWW9BU2xvb3hUQUtLS0tBQ2lpakZJQktNVXRGQUNVVXRGTUJLS1dpa0FVVVVVd0VwYUtNVWdDa3BjVVVBSlJTMFVBSlJTMFVBRkZKUzB3RXBhS0tRQlJSUlRBS1dreFMwQ0NscEtXZ0JhV2tGTFNBVWNZSXJqUEc5aTNuZWNxaGxrVU45ZWVhN09xZXQ2Yi9hT2p1NjQ4eTJPOGU0NmY4QTE2OHZNS2FuUzV1eDZXQXFPTlhsN256ejRnc21TWm1YT00vcldqNEp1L04xTzNzMnp1WTdVejdtclBpT3paNU1wOHUxc043MW0rQ2xNWGpqVHVlazQ3Vjg4OVlYUGErMmVuZU1MTmROc1ZnVmdzaXIwSUh6WnJ6Q2RkMGh6emsxN2o0L3RvcDlIYVVERGJRYzE0akxLcnlIN29PZTFaVVhkR2xYUm1YZld3Q2xrSFBlczdHR3JvbVVPaHoweFZDV3hCWkRHT0FlYTZMbUpKcDF1Rmp6MXpWdTRieW9tSTV3S2t0NDlnR09QYXMvVlpTdUVIUTlhUUZQN1kvMmtPRHQ3R3RTVlZ1TGNqcUNNMWdIcnh4V2hwMTJWa0VUOHFlS0FLRWkrVzVVOWpRajRPUFdyZXBXNVNiZXYzVFZIcFZib1JPM3RWaTF1cExlUU91ZU93NzFDb0RSMCtJRGR5Y0QzcW9OcVdnTkpyVTlOOEgrTDRWa1dLNlh5MlBIdFhxVnRjcGRRaDRqdVVpdkZmREZzek9oVllwQVR4a2NnMTY1b3p1TGNMSW0zRmZSWWFUY2RUeE1URkozUnFFVTBpbkdrTmRod2pPMUpUalRlMVVBbElhWEZGQXh0RkxSUUlURkpTMFlvR0FvTkZCb0FTaWlpZ0Fvb29vQUtNVVVVQUZGRkZBQ0dpbG94UUFsRkxpakZBQ1VVdUtNVUFKUlJpaWdBb29vb0FLS0tLQUNrTkxSUUFDa3hTMFlvQVNpbG9vQVNpZzBVQUZJYVdrTk1Bb29vcEFMUzBVVUFGS0tNVVVBRkxTVXVLQmhSUlMwQUZKUzBsQUMwdEpSUUF0RkpTMGhCUlJSUUFVVVlwYUFFeFJTMFVBRkppbG9vQVRGR0tXaWdCTVVZcGFLQUNpaWlnQktLV2t4UUFVVVlwYUFFb29wYUFFb3BhS0FFb29wYUFFb294UmlnQW9veFJRQVVVdEppZ0Fvb3hSaWdBb294UmlnQW9veFJpZ0Fvb3hTMEFGSlMwVUNDbHBLV21Bb3BhU2xwQUtCVTlzeXE3Sytka2lHTnNlL0gvMTZnRk9GWlZZS2NIRm1sS2JoTlNSNVZyK21TMm1venhTS1dDc1JqSE9heE5EMGlUVGZFTnZlWEtsRTgzNWQvSDFyMkhWOUFmVk5YZ21NZVlaRURTRUFkdUs1YnhaWW0yUUZma1ZjL05qR0srS3FTY1p1QjlkR0tsQlROenhkTUQ0WmVTUEJPM2pKcjU4dW81WXBKSFpzQU5Yc09wYW9sejRQaGFNN3o5MThuT0s4cTFoeXpNaEE0NUI5ZWFWRmFDcWxXMHZ5NTh1VGozcSttR3pnMXo0RDU0NHJTMDJSMlZ3M2F1Z3dOSXVFVWtubitWWWwvTUpaamc1QXE3cUFiN1A4djQxa0dtQTBtbFVrTmtkcUtiVEVia1pGNVpqUFhHS3lKb1RESVVmdFZqVHB6SE1GejhwclVrZ1NVNVlBNTRwYkFZa0xZeUQrRlNjQS9OMHE3TFlnRGN2YXFKT0dJTkY5YmpOalJieVcybUJpZkhQUld3YTloOE1hbzA4YUNWbnpqb1Vyd21Gc09Nb1d4enh4WGUrRWZFY051NnhTWE1rUE9Ocjhpdld3bGEyalBQeFZLNnVqMmhUbFFhRFZhd3VvN20zUjQ1RmZqczJhc212WlRQR2VnMm1uclQ2RFZpSTZURk9OSWFZeE8xSmlsTkZBaEtTbG9vR0pSUlJRQVVVVVVBQnBLWEZGQUNVVXRGQUNVVXRGQUNVWXBhRFFBbEdLS0tBREZHS0tLQURGRkZGQUNVVXRGQUNVVUdpZ0FvcFJTR2dBb3hSUlFBVVlvb29BU2lsN1VsQUJSUlJRQW1LS1dpZ0JhS0JTMEFGRkZMUU1LS0tLUUMwVVVVQ0NqRkxSUUFVVVV0QXhLTVV0RkFoS1dpaWdBb29vb0FLS0tLQUNpbHBLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpbG9FSlMwVVVBTFMwbExRQW9wYVFVdmVrd05yUjVROXZNajR5cS9MbnRYblh4QnVyWlZlQm4zYmx3UUJYWTI5dzlzNWVQcUZQR2V2RmVSK0oybnViaWRwVGxuSklCUFRuL3dDdlh5T1pVT1RFODYyWjlQbDlYbncvSzkwWnRpTjFoTENya0lUMFBRMXpldVFIelFDUDA2RFBXdEhTN2t3WEhsWjZuR005VFUrcFdaa0xrcnU5L1NzWXBSTlhKeU9ia3R3dHFEakg5VFVXbWhkejVPRDZWdXphZExkUTdFR0NWNFVEcldYQnBrOXRQdWNFRGtjMDB4TldKSjFEUk12dHhXQ3cya2p1SzZTVEhsblBBeFhPekFlYTIzcG5pcVJKRnpSaWx4U1V3TE5qR0pKdVQ5M210b0hhcDVyTTB1SWx5L2FyZW9TQ0tBZ2NacEFXU1ZNWkk2VmpYS21PZksvZE5OaHZHamY1bUpHS1JwdzdFRWZLVHg3VURMVnRNOFREWSt6UFgzL090blQzamx1Rlc1bVIxSE9DQm45Qi9XdWU1Mi9TcFlKY01BWldRWjZpdWlsVmNYWm1VNDh5MFBjL0N0M2JpTUxDNFZSeGpILzE2NjlUdUdSeUs4VDhNNmdZWm84WHl1bjkxM1pmL3JWNjVwVjRzOEM0Sy9nMmE5K2hVNWtlTGlLVGl6UnByVTQwaHJxUnlqRFRhZjJwTVV4RGNjVWxQTk5wZ05vcGNVVURFb3BhU2dBcEtYRkZBQ1VVdEZBQ1lveFMwVUFKUlJSUUFVR2lpZ0JLS1dpZ0JLS1drUDFvQUtLVVVVQUpSU21rb0FNVVlvb29BS1EwdEZBQ1VVdUtTZ0Fvb29vQUtLS0tBRU5GTFJRQWxGQm9vQWNLS0tVVWdBVVVVVUFGTFJTMERFcGFLS0JCUlJpbG9BS0tLS0FDaWlpZ0FvcGFLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29wQUZGRkZNQW9vb29BU2pyUzBVQUppaWxvb0FLU2xvb0FURkZMUlFBbEZMUlFBVWxMUlFBbEZMUlFBbEZMUlFBbEZMU1lvQUtLTVV0QUNVVXRGQUNVdEZGQUJSUlJRQXRGRkZBaHc2VXROcHc2VWhpL3B4WG4zaTZ4TnJkU0l3Ym5rREhVZHE5Qi9XdWQ4WFczbUxCUHNKeWhRbkg2ZmxYajVuRmV6VWoxY3VtK2R4UEhYaFpiMFNOMUJ6akdLNzdSL0RKMVBUa3ZUSXFwdXd5c09vcm5ydlRKSmJqQ2pldjByMUR3NVpyYjZERGJzNVpsWEpHTzlmTzFLbW1oN2tLZXVwazNtaVEyOWdnZ2dUelVPQVJ4MXJodFhlQ0NhUzNaOHRra2tIb2ZTdlQvQUJCdk5rWTR2OVlWQkJCN1Y1anFHazdJcm1hN2Y5K3ZWUWZtNTZWTktYY2RSSE1Tdythclo0RlkxemFHS2JZbVNPdGJVTWdrM1p5QURqNjBoaURTNUl6NlYxSEt6bXlwQjlLbmpzNUpJdDZqZ1ZyTmFLVmI1QjgzV3BvSVZoVUFkTWRLWUVWZ21JQjh1MDk2bzZ1U1dVRDYxdDdWQ2ZMV0ZxaXQ1dWVxWTRwRE02akhjVVVVeEU4TW00YmM4MUlFeTNQNW5pcXluREExWmNaVUdqcUJjc3BKSVpnWW1VNFBkOC96cjF2d2ZxdDFKQWl6Um9UMktiUi9VWnJ4UU9WYlBXdDdSUEV0enBzeUJYd2dQT1ZyME1OWFVIWm5OWG91YXVqNk1qWXZHQzNlbkVWelBoZnhSYjZyYXFONm1UMEFycHUxZTlHU2tybzhPY0hGNmphVEZPSXBLc3pHRWMwbUtrTk1OTUJLUTBwb3BqRW9vTkZJQktLS1dnQk1VVXRKUUFVVXRKUUFVbExSUUFsRkxSVEFTaWxvb0FTaWxvb0FTaWlpZ0FvTkZGQUNVb29OQW9BRFNVdEZBQ1VVdEJvQVNpaWlnQkRSUzBob0FLS0tLQUNrTkxSUUF0S0tCUlNBS1hGRkZBQlMwVVVBRkdLV2lnQW9vb29BTVVVVXRBd29vb29FRkZGRklBb29vb0FLS0tLQUNpbG9vQVNpbG9vQVNpbG9vQVNpaWxvQVNpaWlnQW9vb29BS0tLS0FDaWlsb0FTaWxwS0FDaWpGRkFCUlJTMEFKUlMwbEFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGTFJSUUFVdEpTMHdDbG9GTDNwQUtPUlRyMnovdER3N2N3THpKR1E2RDlLWjNyUjBlVkV2MVdYN2tpbFQvbjhLNGNiVGRTaEpJNjhIVVZPdW4zT1pqOE54NmRHc3BCTGRSdTY4MWIwa0VXYktDQVZiSHYxL3dEclYwV3V3aGJZaGZ1a1o0TmVjeGVKTExUOVdGck5MdzRKM2RoMnI0ZU41YUgxODdibC9YTmZ0dExnWnB5WkpTQ0ZBWHA2ZnJYaStzYW5jM043UGRQTXc4dzlBZWc5SzdyWEhXKzgyU0tUZmtuYVR6eFhubDZuTW1CZ0x5TTExVW8yMU1hclhLckZXeHVHRndVSUcwODhucldsdTdnWTlhd0pma1pXQk9hMTdObmtpVm5ycE9RdHFBL1VZb08wSEdSbWtJMnhrZzg5cXhacnlUekhHN3J4VEEyV2tDc0EzT2FiSmJKSWh6M3JBYTRsZkJaaWR2U3JzR3JGVlVTRE9PQ2FBS3QzWU5DNTI4cjErbFU4VjA2RkxtTElJSWFxVnpwZ1B6Sjh0RndNbUdJeVBnVlluVXhnSHRWMnl0c0tkNDU5YVcraVh5dHZmdFFCbGtucU92dUt2V1Z5SUgrZU9LVmVwVWdqL1A2MW5vU2VEMXFSV0NObkJxNmN1V1Ftcm85WjhGYWpDWkVDV1FSdjczVVY2aEV3ZU1FWS9DdkFQRG10UzIxekdrWlhyMHlSWHMrZzZrOTNicnYyajJCelgwT0duekk4WEUwN00yVFNZcDlJYTdUZ0dFVTJubW0weGlZNHBwcHhwRFRBU2lnaWlnQkRSUzBVQUpSUWFLQUNpaWlnQW9vb29BS1Nsb29BU2lsb29BU2lpaWdBb29vb0FLU2xvb0FTaWxvcGdKUlJSUUFVVVVVQUJwS1dpZ0JLS1UwbEFCU0dsb29BU2lscERRQTRVVVVvcEFGTFJSUUFVdEZGQXdvb3BhQUVvcGFLQUNpaWlrQVVVVXRBQ1VVdEZBaEtXaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNrcGFLQUNpaWlnQXBhS0tCQlRoU1Vvb0dLS2NyRlhETDFCem1taWlvYVRUVEdtMDAwWmZpblhidFhhTU1GR001eDk0VjVMcWFodFQ4OEFsaWNuMnIwN3hYRHVpaWt6emdqaXZPTlJpZHBUNVJ3YzdRTTlUMXI0NnRSOW5Xa2ZXVWFudEtTTEt4K1phWUErZ3pYSmFrcGd1M1dZYmVSMTc4VjFsaE9oV1hJWStXQm5qclhPNjdwcE1nZVl0OHpIYVBhb2pib09TZlU1aTdQNzVsUDRWcDZXNGEzMjQ1elZKN0xNNVJTU3ZaaldocDl1WUkyQjZrOFlyUXlKTHVieW9UbnVNVmdzY2s1NXJvTHVMemJZcjBPTTF6N2RUbm1tQXlrcFRTR2dDM1pYaHRuN2xlNHJldFowdW9RUitWY3VEaXJkaGUvWlhKYkpVL3BRQnZKRXNic0FPRHpXUHFzK0psVWRxMjQ1Uk5iK1l1RHh4WE1YN0g3Uy9PZWFRRVVvQWtEcnlyVThBRVo2VWtHSkZhTnV2VVVvWDVTUFNuc0Jkc0xwWUpWUG1zaEI2RkF5MTZ4NE4xdUp3cStiYS9WVjJWNHlHMmtjQ3Q3UUwzeWJwY000SGZhQWE3OExXY1pXT1hFVWxLTjBmUjBVZ2xqREtRZmNkS2RYTytHTlFTZTJSUVpXTzBmZlhGZEppdmZqSzZQQ25IbFpHYVRGU0dta1ZhSkdZcEtkamlrTlVBMDBVdmFrb0FRMFV0SWFBQ2lpaWdBb29vb0FRMFV0SWFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQktLV2lnQktLV2tvQUtLS0tBQ2twYUtBRW9wYVNnQU5KUzBZcGdKUlMwR2dCS1EwdEZBeGFXa3BhUWhhV2twYUFDaWlpZ1lDbG9vb0FLS0tXa0FsTFJSUUFVVVVVQUZGRkZBQlJSUzBBSlJTMGxBZ29wYUtBQ2lpaWdCS0tXaWdCS0tXaWdBcEtXaWdCS0tXaWdCS0tXaWdCS0tXaWdCS0tXaWdBcEtXaWdCS0tXaWdBcEtXaWdCS0tYRkZBQ1VVdEZBQ1VVdEZBQ1VVdUtLQUVvcGFLQUNrcGFLQUNpaWlnQlJTMGdwYUFGcGZyU1V0SjdBWnV1MnhuMHR5cllLR3ZNdFdSdHhYcTNaY2R2V3ZZUEtXNGpraFA4YWtENjE1bnJscjVjemIvbGJKQU5mTjVndVN0ZnVmUTRCODlHM1l4NEVFdWx5Rk9aWStjRHVPdE1tdHY3V2tSWERZMjVZanNlMWFuaHF4YSsxT1dKZmxHMzV2YkZkRlBveHNOUG5YNVJJNURLUitncnlicU1uWTlMV1VkVHpUV05OanNMa1JoQm5HYyt0VTBUMUhHSzJmRWlsTDRid3l0dDZFMWt4OEhqN3ZyVzBkam5sdVZyeFcreXNGR1NlMVlEWkhYclhVa0Rub1RXVmZhY0FDOFFPNnFKTWRxU3BHUWpyVWRVQVpwUlNVWnhTRWRGcGt5dlpCUjFYcldIZnBzdkhCOWF1NlJLUE1aR09BUlNheEFBUklPL0ZDR1phT1k1QXdxMkNHWGVCMXFqVTBEa050endhYkVoNzVVNUg4cXMya3NhU0FTUmdqUFhvYXJzTU5nMDVBTnczTmdmV3FoSnhlZ05KbzlWOEU2eFpKS3NhK1lINlpMZi9YcjFXSnQ4WVBxSytlUERzMFVWMGppK0VKenp1ei9oWHQyZ2FsRmMycXFibFpTQjFGZlFZV3B6UlBGeFVOYm0yUlRjY1U2a05kcHdqU0tiaW5Ha05NQkRUYWRpZzFRRE1VVXRJYUFDa05MUlFBbEZCb29BS0tRMENnQmFLS0tBQ2tOTFJRQWxGTFJRQWxGTFNHZ0Fvb3hSUUFVVVVVQUZGRkZBQ1VVdEZBQ1VVdElhQUVvb29vQUtEUlJRQWxGTFFhQUNuQ2tGS0tBQ2xvcGFRQ1V0RkZBd3BhS0tBQ2lpaWdBb3BhS0FFcGFLS0FDaWlpZ0Fvb3hSUUFVVVVVQ0NpaWlnQW9vb29BS0tXa29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29wQUZGRkZNQW9IV2lpa0FVVVVVd0NpaWxvQUJTMGxMUUlXbHBCUzBtQTZOdGtpdDZFR3VTOGE2YUlkYWRWQldPVUIxK2hycXgxejNwMnRhZW1yYWJaenF1Wkxkd2tuMHJ3czNqYUNxTG9lM2xVL2ZjSDFPSDhNNlpOWjZpMDdxd1hiejdpdXoxS0VmWWZOZkIzQTU5c0NsdTRVczFMbklYYnp4aW5YY29sMHdEc0Y1SHRYek43dTU3MmxySGgzaVpHdDdxU1NSdHlra2dtdVhsMVRhMzdzY2V0ZFY0eHZyZDVMaUpWTElmdVk3SDFyejlqODNwWGZEWTQ1N25RMkU1dVk5emNuT0RWd0x2QkRjbXNYU0pYV1prQitVak5helRGVy93RHIxWkJTMVMwQmczb01GZXVLd2lLNnk0Qm5zMkM5eDFybDNVcXhCNmcwQVJZcERUelRhQUpMYVF4VHE0T01IODYyOVFqV2V4M0p5Y1pyQXJlMDZUenJQYTNiaWdEblc2MFpJNlZhdjdjd1RuSFFuTlZzYzB4RmdEekVWaDE3MHBYQXFkRUgyVlNPdFFPVHUyNXBESkxlU0pXL2VLU1BVVjZMNE8xYlQ0WkVDYi9NSjR3RFhtUjRxelpYOGxwSUdqWVYxVUsvczNxWTFhWHRJNkgxRFp6ck5BckNweUs4eDhEZUwxbDJ3WEQ4OUJoVFhweU1KRUREb1Jtdm9LVlJWSTNSNE5XbjdOMkVJcHVLZlRUV3lNaHBwTWNVNGltMVFoTVVsS2FLQUVwRFNtaWdZbEZCb29BUTBVdEZBQ1VVdElhQUNpaWpGQUJSUlJRQVVVVVV3Q2tOTFJRQWdvTkxTR2dBb29vb0FLS0tLQUNrcGFLQUV4UlMwbEFCUlJSUUFtS0tLS0FGcFJVTTg0Z1FNeXN3NzdSbkZQaW1TYU1QRTI1VDNxYnE5aXJPMXlRVXRGS0tZaE1VdEZHS0FDakZMaWlnQk1VdUtLS0FDaWxveFFBbExpakZGQUJpakZGRkFCaWpGRkZBZ3hSaWlpZ0F4UmlpaWdBeFJSUlNBTVVZb29vQU1VWW9vb0FURkxpaWlnQXhSaWlpZ1FZb3hSaWpGQXd4U1lwYUtBRXhSaWx4UmlnQk1VWXBjVVlvQU1VWW94UmlnQXhSaWpGR0tBRXhSUzRveFFBbEdLV2lnQk1VWXBjVVlvQVRGR0tXakZBQ1lvcGNVbElBb29wYVlCUlJSUUFVdEpTMHhDaWlnVVl6U0FjSzFOSFlQNXNESEFZYmhtc3NVK0tkcmE1Z2xVWi9lQUg2SGl2UHg5UG53OGtkbUNueTEweGRmSVcyZEZPUW9PYTVHNDExUnBmbFFsWkhkQ3JldzZWc2VONzZTelZvNGlBOGd5M05lWjZWY3Y1OGtVckhlQ2YxcjQ2bkM1OWJKMk9hOFFMSVpDbXpBSFUrOWNwT2hXVDV1dld1NjE1OXhsNHh4MXJpYnZoeUN4TmRzTmpqbnVUYVk0VzVIUFhpdEMrbTJEak9lMVkxdXhXWkNPb05iazhJa1ZUanRWa0M2Yk0wc1B6ZGFqdmROOHd0Skg5NzBxMVp4ZVVQU3BubmpXUVJ1MkNhQU9Xa1FxeEJHQ08xTXhYUVhOZ2s2c3lINWozckdraFpHdzY3YVFGZmJXbHBQbXJJUXVTaDYxSlkyQXViZDk0SXh5RFd2WjJxeHhEYU1IdlFCbmFwYUdXTGNPU3ZJckNLRlRoaHpYYVNSS3hQdDJySnY5TUVpczZENWdLQUtzWURXWUsvU3N1ZHNTbm10ZXpqSzJqaGhqQnJHbC8xamZXbUE0TUN1S21oalo1TUlNL1dxZ09DS24zSEFJelQwVDFEZEhZK0hMTzRqdUk1RWt3MmY0Zi9BTmRlMDZGTy93QmxWWjJKYkg4UnI1dnRMMHdPQ0pIVWpwZzE2QjRXOGF3V3hWYnVWaWZWc212WXd0ZUM5M1k4M0ZVWlNWMGUwZlNta1ZVMHZVNGRUdEZsZzVYSFhHS3VtdlZUUElhdG9SbWtwNUZKamlyRU5OSmluRVUybUFHbTA3RkpRTVNnMEdpZ0JBS01VdEdLQUVvb05GQUJTWXBhS0FFeFMwVVVBSmlpbG9vQVNpbHhSaWdCS0tEUlFBVVVVVUFJYU1VdEppZ0F4UlJpaW1BVVVVVUFKaWlpakZBQlNVdEZBREpYYUtRN1kxbUF4akJwWTRsVml5OXh6VGdPTVU0Vm5HS1R1OXkzSnZRVUNscEtjS3NrTVVVVWMrbElCY1VVZ1lNTWpCK2xMUUFVWXBhS1lDVXRJVGdaUFRPS1dsY0JLV2lscGlHMHVLV2tvQU1VWW9vcEFHS01VVVVBR0tLS01VQUZGRkZJQXhTVXRGQUJSUmlpZ0JLV2lqRkFoS0tXaWdCS0tXa29BS0tXaWdZbEZGRk1Bb3BjVWxBQzBsTFNVZ0NpaWlnUVVVVXRNWWxGRkZJQW9vb29FRkZGRkFCUmlpaWdZWW9vb29BS0tLS1lDMFVVVUNGcFJTVW9vQUtYcGcvM1NHL0tnVXZ0V05SYzBIRTBweXROUHpPUytJeU9OVFdRRnNGUVR6WG45dTIyNzNFNVluSDYxNm40OWg4NWJXUWM3bzhFMTVhNml6djJPTWNEUDFyNHVDNVcwejYrZXNVeVBYNG1NTzVWNGJBNXJqNzYzVkxjTW81ejE5SzcrNnQydTdiZEprSEhHSzVPN3NKcGJqeW9FTElUNlZyR1NJbEZtRGIyN1N0bFIwTmRER2hFYWc4NHFPM3RCYlp3T2MxYVg3dGFHSUVoVTU0ckIxT1kvYU9PM1E1clh1bk1jWlljZ1Z6OTBYbFl2dHd0QUY3VDlVOG9iSmZ3clllMml2WU1rYzlqWE5XTVBuWEFCNkN1dHRVMlJqSHBRQTJ5dC9JdC9MUE9Lc0FiWWpRV09PVFRDZmx5TVVnS0YzTThGd3NqSDkxMEk5Nm1NNm5HVDFGWk9vWDJmTWlZZE9sWnB2cFNxL045MmdEb1pGVWdoZTljNWYyN1JYREhIRmFsaE8wOGJHVDBvTFIzS3NPRGppbUJ6OVN4Tm5LbXJGelpiVGxLWkRiZDJvQkRTcEZXN0s0bHRwZzBYQnoxcUdSUmppbzFZcWVLY1cwN2haTldQWS9BMnYzY20yTzRPVkhmTmVtUnVKVUREdlh6ZG9kODhOeXJianNCNUcvRmU0K0Z0WFM4c2xVc09Cd0ZGZlFZV3J6UnNlSmk2WExLNk9pSXBDS2RRUlhjbWNKSFNFVThpbTRxaERhUWluVVV3R1VZcHhwcG9HSlJTMG1LQUNpaWlnQXhTR2xvb0FTaWxwRFFBVVVVVUFGRkZGQUJSUlJRQVlwRFMwVUFKUlFhS0FDa3hTMFVBSlJRYUtBQ2lpaWdCS1NuVVV4Z0tkakdQY1pybnY4QWhJYmJ5M2l2cENySzJOMElMRDh4MHBZZFhuS2xJbVlKMGp1SkVPMHI3ZjhBMTY1WlZtblpLNXJHa21yczZFVTRWbTZmT0lyVUxkWGFTeTV5ejlQMHEydDNDMkNqYndlNjgxdkYzVjJadFdaUFRKRzJxZWNjR2x6dUFJUEZCQVpqdTdEcWFHT0sxdVIyaUZJUUdPYW5QQXllbE5pQkNjNDlpS1NVYmtaVC9FTWNVYkltMTJPREFqNVRuNlV1S3J3UWZaa0NJQ09lUzNKcWZPVk5KTzZ1UGxzUXNHZTVBK1lJdlBCNEpxeFRVUXF2SnlhZmlpS3NEZHhLS1drcWhCUlMwVUNFb3hTMFVBSmlqRkxSUUFtS01VdEZJQk1VWXBhU2dBcEtXbG9BU2lpaWdBb294UlFBVWxMUlFBbEZMUlFJU2lsb29HSlJTMFVDRW9wYUtBRW9wYVNnQW94UlJRQVlvb29vQUtLS01VRENqRkZGQWdvb29vQUtLS0tBRXBhS0tCaFJSUlFJS1drcFJRQVVvb29GQUNpblUwVTZrOWhwMmR6UDhWVy9uZUg0WkJrN0hJUEZlVTZyQmlZYmhsaWNrK2xlejZpaGw4TFhTbkJDc0NCWGx1cGFmTE1yaUxMTjE0SFExOFppYlU2MGtmWDRhOVNoRmxyVDlPYS9XTll4a2hNazA3VjlOaXRJMm1nVlF5cm5KcnN2QnVsZVJwTVFsUUNRakRFMWdlTTl0cmJTSGpiZzhqc2E1Vko4MWplU1hJZVgzcmo3UXhVY1ZUbHVraEJEbkRZNlZGck9xQjdyL1IxQUFBNTlUV0pKTVpYM09jMTJuR2RDa2kzTUh5anJWVzh0ZjNZMmo2MUJwVjJJMjh0K0IyclZjYnhuT2M5S1lqRnRRc0YzdGJnTWNWMFVDOURuTlppMnF5WENsOGNITmE4S0NOYzlxQUpXQXh6V2JlWHkyallCM1pwTlExTVFIWWg3VnowMHpTc1NUeFNBUzRmekpXYjFOVjZrSnlLaVBXbUJ0YVFoTUxHczZabXRydGdDUnptcmVqeUVTbE4yTTlxajFtUGJNR0F4dXBBTlcrUi92ajg2bStRcGxPVFdSVWtNNWliSjVGTUI4NVlTYzBxSFBOVFNSaTRYY3BxR09ObGJEZmRwQVc0TDJTSWhWZmFvN1YzL0FJTThUaTNrQ1hNanNDZUJrWXJ6Vmx3YXNXMXcwTXU1ZW9ycm9ZaHdlcGxWcEtwRStuYkRVSXJ5SUdOMUp4MEJxN2pOZVJlQ3ZFRFFzZ2VXRUE5UzcxNnZhM1NYVUllSmd3eDJyMzZkUlZGZEhnMXFUaEltTk1OUHhUU0syTUJ0SmluWXBNVlFDVTAwNGlreFRBU2tOTFJRTVNqRkxTR2dCS0tXaWdCS0tEUlFBVVVVVUFGSlMwVUFKUlMwaG9BS0tLS0FDaWlpZ0JEUlMwaG9BS0tLS0JpR2lnMFVDQ2twYUtCbGVHMGhVUGlOZHJuT050V1JFb2pDaFYyK21LYkdNalBic0tsRlRIWXB0bGE0c29MbUYwa2lVN2x4MHA5bENrTm5IR3FoUXFnREE2Vk5rQWpOSUNGWEM4ME5LOXc2V0k1STlwekcyMGs5T3hwWVdMQmxrQVZ4MTl4NjBTeEY0eVN4eU9SejBxSXY1a0t5Z2ZPbzQ5NmlUU0xqSG1MTUgzQjZEak5LSll4SVUzRGVCbkZVTEhVeElHVmxZYld3YzhZcU84a1dIVTQ1dHB3eTdkMmVLemxXU2h6SXBVM3pXWmVhWjN1aDVwNXhrSDJvYWVORmtrSitSTVovR3FON05JMGtSaVFrTDZIclRZVkQrYWpOZ3ZrZ09ldnRXYnEyMGlhS25mVm10RzNtS0dIR2VhZFZXMm4vQUhLcUUzTUJ5TThDbGtsSTZ1TjM5eGY4YTZJdTZPZVVYY25EZGNtb1laSkd1SFJsSVFmZGIxcU5ZSmZNQmR6ODNVQTFZSWFKYzdpM3NUVGVvV1JKUzAxSDNEcGcraHBUSUZVbGpnRHJWR2FWeGFLYWtpU2ZjWUg2SE9LZFNUdUd3VVVkNktZQ1VZcDJLTVVBSlNZcGNVVUFKaWpGTGlpZ0JNVVlwYVEwQUZGQU5MUUFsRkdLV2dCS0tLS0JCUlJpakZBQlJSaWlnQXBNMHRKUU1LS1dpZ0JLTVV0RkFoS0tLV2dCS0tXaWdZbEZMU1VBRkpTMFVBSlJTMGxBZ29vcGNVQUpTMFVVQUZGRkxRQVVVQ2xvQVVkS1drcGFUQTFOS2dXN3Q3aUNRQWhnRHpXU2RJaGdaenNVYnZsSnJSMGk2RnZlRGNmbGY1VFZuVm9zUnVpamxzOGl2ajgxanlWNzl6Nm5MSjNvMk1Ld2tFZDQwS01QTEE2NTZWNW44U2RVODZOb1V5Z1ZpR3dldGJ1c2F6OWt2VEJCS2NuNzdacmdQR2R3WnBObzVKQVAxcmdoSDNybmRKKzZjRksyWkRqcG1vODByZmZPZldrRmQ1eEQwSkRWMHRnelNXYTdoemlzS3h0VGNQZy9kcm9yZVB5WVZWYUFGampIbTVwMTdOOW5zMktrNVBGUFZsRGM4WnBMaVA3VkNVVTRCNzBET1dsWXV4TGMxRWF1WDlxMXZLUUFTT3hxaVJRSVEwd2ptbm5OSlRFV0xCdGw1R1Q2NHEvcmE1aFU0NzlheklUdG1VK2h6V3RxQ0dlMEJYMHpTR1lGSWFVZ2c4akJwTVV4RTlxNUVtQWVQU3JycW9HZWxaMFEvZUN0SjQ5NmMwaGxVeUs3RmFRSWQzVVZETXZsUzhWSWtnZmdpbUJvNlhMRkJjSzAwcFZRZjRhOWM4SytMclV4cGJRNXhuQmR6WGk0bDh2N29XcjJtbSt1Smo5bmZ5d3ZWaWNBZmpYWmg2N2c3SkhOV29xb3RUNlp0cjJDNjRoZFhQY0ExUFhrdmhMV2swMGJHbmFhVmpnRFBldlJyTFZWbENxeEJrUFhIYjJyM0tkUlNXcDQxU2k0U05QRklSVGhTRVZ2Y3dHVWxQeFNFVXhEYVFpblVsTUJ0R0tVaWpGQXh0RkxSaWdCS01VVVVBR0tTbG9vQVNpbHhSaWdCS0tLS1lCU0dsb29BU2lscEtBQ2lpaWdBcERTMGhvR0ZGRkZBQ0dpbHBEUUFSdGtaQXdNY2U5RTBvaFVNM0hPUHJXYmI2a1pBcDgxRGtad09PYW5rdW9wNDJMaHRxOEFlL3JYUEdxbkUyNUducVdZNVJLL1lBZEI2MU03Q09JdmpPQm5GWTdYWjhvZVV1NEUvTWY3dFNYY3A4cEk0cEQ4eEFPR3FIV1d4YW91NVgvdDJPV2FTUGxlTWNldnZWbGRRU0NXQlJHSFJrd3h6d0RXYk5wU2J5UE4ydEllcWpwVk5uYUpwTFVmNjFUamNlaEhYTmNNNVZJcDh6dWRjWXgzaWI4N1J3UytlKzBJL3dCNERrajBOUnozbHRjTEg4bS9kL0Nwd1I3a1ZIcDkxYnZDVW1VR1RHM0xkRFdmUEFtOTFra01NMGFrQTU2NHJTcFVmSXVXMnBOT0tkMjBXdFJobVNOWHQ1OWdBTzBFVld0SHVJb3cxNy9wRW0zSzdmNGZRWnFtdHplVG9rYW9adU1CK2d4U3gzQnR5c2N4QWNmd25QSkh2WE82aXZ6dFdOdlp0cmxMc04vY1NsdHcrenFBZHgvcFd6cGJ4WEVHNkVLZWNiczlhNXlhL04xZEtGMmpKeXc2S0szTENhUGdRTkdGWHFGSEdhMXcxWG1uYTl6Q3ZUNVk3R3V3VkkrVGpITkNmdk1OanJVY2NKbkllUW5IWVZhQ2hWR08xZW5lNXdhTFFqTFlmRGQrbFY1eVZrQ3N1WTVEMTlQYXJNd0dBVHdNMUFYTW9hSXB2SHJuQXBzYUpZb2tqWDVGQzBTUHM1N0RyVVVFaFRja3g1VDlSVEdQbnlBTmtMMXhuclM1a2hLTGJ1eVZKQzVKQTQ3YzFLcEo2akZRRE1VMmNZVG9BRFU0Ymp1S29UUXBIV2tYb0tONDcwMVdYY1JtZ213K2pGSnZIYm1uVUFKUlNrVVV3RXBwNEg0VS9GSVJrZmhRSWFuS1U3Rk1oKzdVbUtCc2JpakZMaWpGQWhLS1hGRkFDVVV0RkF4S0tXaWdRM0ZHS1hGR0tBRW9wY1VVZ0VvcGFLQUVvcGFURkFCU1V1S01VQUZGR0tLQmhSUlJRQWxGTFNZcGlERkxSUlNBS0tTaW1BdEZGRkFBS1drcGFBRnBhUVV0SUVLbkRybis4S3Q2N2RpMmhaaTJQbERjOXhWUWRmMXFwNDNSNTlDdFpvdnZGZHJIMHI1N09LZDBwSHZaUlBXVUdlVWVJYnpHcHRKaktNU1NSMkZjdHFOejlvVm5kOXpLT0I3VnArSlpQc3FtTGNXbDIvaGlzT3h0M3VMYVZuVGR0WGtpdkloYTF6MXAvRll3WndCTDh2U24yOEpsa0E3RThtcEo0U1p5QU9lbGFWbmErV296MXJvV3h6TXNXdHNzSTJxS3VqamxxWW93dlBGVU5UdlRFQUltNTYwQ05QSVpoakdhY293d0hhdWZzZFFsbHZrRE5nRTlLNlBBOWNVRElieTJXNGdLbnIycm5KcktXRm0zS1NCM3JxUU1INVRTeVc2elJNckRxT3RBSEZFWUZNcld2dEpraEphUDVsck1aQ094cGlHZzRJcm9yZFJMYUErMWM2cW5keFhSYWFEOWxDbWtCejExRTBjN0J1OVJLcFpnQU90ZEZmV0FsVmlCOHg2R3FOdnA3SklDM1A4QVNtQkZiMlBSbTRxd3lnL0tEajhhc3pqeW92UTRyRWVZK2FXelFCTGNXdUFXeWMxUkdWUEZiRWNpVFFqY1FEVVUxcXBHUUtRRlNOZ1I4M1dyWXVaUkdJWXlWVW5KclBPVWJGVExKdUdEeDcxU2swSFRVM2ROMUEyZHdCYmt0SWVySHNLN1hRUEZQbFhDUmh3ems4ay93aXZORWRrQldMZ25xYTBkR3Q1N3k3V0cxR0NXK2R5Y0FEM05kZEd0Sk94aFVwUmxxejZOMHE5VzlnM0ljci9lOWF2NHJqL0NWL0R0Rm5iU2Vhc2ZEeWpvVDdWMk9QU3ZlaExtUjROV1BMTFFiU0duVWhGYUl5R1VocDJLVEZVQTJrTk94UVJUR043VWxMamlqRkFDVVV1S1NrQVVocGFLQUVvb05GTUFwRFMwVUFKUlMwbUtBQ2lpaWdCRFJTMGhvR0ZGR0tLWUNHaWxwRFFBVVVVVUFjaEJQQmJFaTd4c1kvSTYvd0FQMXJYdnBoSHBjS1dleDVXR0JnNUJVamtuM3pYSmFmY1EyOXJMRmZ5TVZMNFhiemtldGFxYWJiNDgyeXUyaU8wWWRUeG4zN1Y4ekdvNXlVVTdJOTV3VVUyMXFOczVaYmFCeVhMTnlHaXp6bXF0dmZmWjlRVkpHazh6R2ZwbnJtczdVZFB2STVrYWE1ZDMzQmk2Y1lXclVKamtWcnBabFF4amJsaGt5ZmhWVkpMbTVRakY4cmZjNlpua00wTWtrZ2VNWUl3TzNyV1pySlNYVkhaWlNQTEF3L29LamgxbWUwdDJaN1BidkdJK2MvampyNzBYU3U5cXpRaFhsbWJrc2VnOWNVVnEwZVZSUXFWS1Q5NWl4U05KR2theEZJdDJTNDdpbVNNbDVmM0gyVkdtOHBRV0JiR0IvV3F5UGRXc1lqTElaWElSVDJVVXQ1Y3BwNUpUQ0NTTUtTcHp1TlM2a2VUektqQ1NrMmkzYVgwejMwZHRzV0tJRGdEbjlmV285VGxBMWdKQXBkc1o1NkxUZEsxQjJ0bVdiRUtzQ29rQUJJK2crbE5odGJkdFFhVXl2TG5ydWJKck9mUE5MWFFJKzdleGF1SllwTk5XMjhobW1sNVV4akpQdFdwWU5PTGFLMlZJbzl3K2ZITENxcTNBUzNXT3hVWmpQeWp1ZWZXdFN4R3k3THNnMzdjNS9wWFJoWU9FMUxvekt1NHlocnVhMXZBYmRmbWtaaWY3eHFaNWxqKzkvS3FNMm94NENrNUo1STdpb1d1VGNZTDdoRjBCSFd2WjVsc2p6T1I3eUx4ZFpYRE9XMjlnYUZsT1dNYUU4OStLcVhHcTJ0bkhHbTVtN2JzWnhuM3E2SjRSYnF3a0JEZENPOU5TVjdFdU5pbEdKYmpVc01vMmhlM1hyVXkyY0xYWG5CbTNwd1FEZ2ZsVU52TC9BTVRHY29NTGdBTVBXdFJFQVgzcEpLOXlwU2FHT0FmbDc5UlNCaHR5YWJjSGJnNXdCem1xcTNDdEl1MlRLN3VsYVhTTStWdFhML1VWSElpaGd4RlNNeXIzcUdlVGF1Q09DZURUSlNKQ3dWY25wVGg5Mm9pNGRRQjgzTlREcFFBZ3dlUlJUVSs4eTArZ2tpWXN2SUdSNlVxTUdIRlNWQk1qS1E4WFVkUjYwRDBDSGhuWDNxYkZWWVowZVZ5T3VPUjNGV0EyZWdvdURRNmt4UzBtOVFjWjVvRUZGQklIZWhUbW1BZEtia2x2YWlUc1BVMDZnQXBNVUU0K3RBSGVnQXhSUVRqcWFRSFBRY1VDRm9vb3hRQW1LS1dpZ0JLS1dpZ0JLS01VVUFGRkZGQXhLS1dpZ1FsR0tXaWdCS0tXaWdZbEZMUlFJVEZGTFJRQVV0SlMwQUFwYUJSM29BQlQ5UnRYdnZEY3lnY3d0dUZJSzA5SVVUK2ZiU2Zja1htdk56R0hOaDM1SG9aZlBseEM4endmVjlIUjVwR2Y1bUlPU1QzcXRwVnJERkk4S0puY2NWNjFyM2hXMiswU3NGd3JWeVZwcEpzTGpnS1NTY2tqUGZpdmtvejkyeDlWS0s1cm5FYTlvU1dsMTVpSUJ4MDlUV2Q1WGxuNWhpdlVkVTBPSzZSWkpjTUZHODQ5SzgxMU5raXU1RC9CdUlVbXVxbks2T1dwSFVvWHR5SUlENm5wV0M1TG5rNXExcUYxNXJiUmdnZWxWQWExTWg5a3VMMVByWFdnQXIxN1Z5dHZKNWM2UDZHdW5WdzhJUFlpa0JRdXRSTnJQc3hrY1VzV3VvV0lmZ2RxeXRTWnhkRU9jK2hxam1tQjE4VjVEZHJzUWc1SElwa21tUU4wWEhIU3VXaW5lRnN4dHRQdFc5cDJyZWFvaWxiNXZVOTZCRFYwY1J6aDg1WE5hS1FpTmNqcFUrNGJUanBWZTVtVlUrZHNERkFER2RTU00wdzdkbVIxTmM3UGRTZWM1VnpqUEhOWE5Odmk4Z1NVOXV0QUVlcVRPdnlkQWU5WldhMmRVaURSbGdLeHZyVEFjckZlbFg0YjFXVGJKeFdkUzBBYVp0b3BnV0dDYXFTV2pSdmdET2FmWnV3a3dEeFdpK0ZHVDFwQVVCR3lJQWV0WEk3MTQ3ZjdQYmZ1a2I3N0RxYWdsdVlSd09hZ053bTdpcWpKeFlwSlBjOUM4SitJN1BRNFY4NW1aaWVGSGYzcjFYU05iR293TElWMmh1Z3p6WHpiQk9ZMzNwZ24xUGF1MDBIeGJjV3Z5UGRMR21PWFljajZWNjJIeFMya2VmaU1QZldKN3JrSHBSWEI2UDQ1dExxUVJKS3pFZFdidlhiMjl3bHpDSFJzNUdhOU9NMUxZOHVkT1VkeVFpa3AxQkZhR1l3MGhGT3h4U1k0cWdHMG1LZFNFVUFKU1V0RkFDVUdscERRQWxJYVdpZ0JLS1drTk1Bb29vb0FRMFV0RkFDVVVHaWdZVWhwYUtBRW9vTkZBQ0dpbHBEUUI1TE5IOWwrVXlxd1k1em5PMGVsYmlRSFR0T2N5WE1jME1vWGFFYmtFODlQYXNHM2tzNVZhUzRVWUpLcU00ejcxdFdkdmEyN1c5M2NRNzAzL3dDcUo0UHBYeFVxampMbWlmVmNpYXN4RFBQYUtBN3gzQzNVWlh5eWVWRlZiVUlzTWFHSlN1U1hBUE9hdFFYRWI2cks1aVFKS3pSaU1kVTl4Vlc1MDE3YVJybTBlU1J4S0Z3dkl4NkVVUm0rYTdHNHExalYwb3E5ODRmTWtrYS9leDkwVlZteTEweXdPV2thUUhPZUFNODVyTGgxQzVoMU40bmNSTVNkK09NZ2RxdWFWcUEvdEdTTzFnRHlUdHREUDBIdlc3bEdiczlqTGxsRlhSbzNubVJLa0FzTjhzakg1bGJJL3dEckNrL3NWYmV4TjJidUdlYUU1ZFdmZ0ErZzlxTHkwZFdaWU5ReGR2OEFMTXVNQmZvZlNzK2JTaXFvcVNCb3lENWo0SnlCM3JLZFNQT3JPeGNZTnh0YTVZTnhheHhNVWlhU2NnN2dweUI3MHVtT3NhQ2RZbWtjdDh3UGNWRGJyRkhjQklpRlFyalBmMnJSU0ZaYldXTzJtQ3lJd0tJb3dXR09hNnBWWTJWekdOTjNzaWVPN3RJTG1hVkdLamphZ0gzVDNGYTJsT2JtNVdVRWhTU0dIOHE0RnJtV0pwbGUza1dWaVNIemtESFd0VFI5WSt5eFp2SjVJQnRCVU4wWTF0U3F4akt6MFJoVnBTbEhRN1RWSWxpdklGVGNTM1VEMHF6RzBlMEp3b1grSTk2NVpkZFdlUkhFbnpBOHV6WkI3VmRoMVNEWXV3bVdUSHpFbm9hN0k0bVBOZHM1NVVaY3FzaDJvMjh0emNNbHNvMnFNaHVtVG1pMWVTM3VERmRCZ3ljZ2tjZlNyNDFHSzJzVDlxMmhNWjNBWnlheDdpL2FSby9MbmpsREhPem8yS1ZXVUw4NmVvNEtWdVZvM2JHNEVzaWtwam5KUHJXcTF6R3VNa2p2eUs1Nnh1bGdVRU9wUFlMMnE1TkxOY3VGVThnOUYveHJwbzFHNCtaejFhYTVpM2VYa0pVSVNDT3ByTWpsaDhtVUtCbEh5QUJ6VjVyS09WVWU0SEs5ZHY4QVdxTjFJbGxOSWNxSW1YQVU5NmRTVGhGeWtWQ0tkb3hOUkoyMmdoTUxqcTNla3VaQjVNZkJCWTFrckxlelNCV2xWWTQxQnlvNml0RzJaTDFjK2FXQ2NEdHpUcDFYVVY5ak9kTlFaWmpYeWdDTS93QzBLbFZoS1RnNUE3MVZ1TGt3TWtaUHo0eG1wNDk4a0FFZVkxUEphdHVhNjBNZVh1TWR0akhCeXk5UU80cXhHU3k1OWFwY1d0eGxqdldUZ1pxYUdmREdNcWM5UjJ6VjNJY1dUR1VLK0QxcGR3SHZXUGV6QmJodm5NVE1Qa3ljODFjdFdjVzhhellNaDZrVmxHb3BOcEdrcUxpa3hFVS9iWm1pSFBjZXRXNFhEZytvNmowck4zR0crbVVTRUFya042VkphVHU4ak1jbjBJSFdyVGQ3Q2xIUzVlWmlqYzlEM3FLNktDSWtubnRqclNGWG5ZZ2xrQkhOVkhzWlVtVlk1aTJlY3Z6VkVSU0wwUlR5Z1dQYnZUL05Uc2Z5Rlpwa2UzdVVqdkVCUm0rVngwRmFEbFZDbFRqK1ZKUzdoS05ub01hWk4rNG5oYWExNEJqQ0hIWW5qTlZIdVVXK0pDaG0yOVIwcVNSVElBeWZ2R0hQc0tWNzdGY3ZjaWZVaTF3a1FRZ25wbnBWMk1UT011UXVQU29QTWdaY2s1Y2RQWTBrVjRBQUoyd0FhaUVuczl5NXhWcm91cW85ZDMxcVNtSzZNUGxZSDZHbjFzam1lNGxGQk9LVVV3RW9wYUtBRzBVdEZBQ1VVdEpRQVVsTFJRQWxGTFJRQWxHS1dpZ1lsRkdLS0FDaWlpZ0Fvb3BhQUNpaWlnUUNuQ2twUlFBdmVybW15ZVhlcVNjQTVGVXU5U0lTc2daVHlEbXNLc2VlRFhkRzFLZkpPTWl6cTk1RGRXOGl3Z2Jvd2QzdFhHWEV3VjMyamJ1Ymc0OWF0YXZlSFNkYWtESE1NdzNZOVFSWEo2bHJyQlE4ZUZFVDhEKzhLK0Y1WENUaXo3T0w1b3BuWUdQTnMyUmxQS0k1cncveG5PdjlwTkhHQUZCNUFIU3ZacmEvUzY4S0c1aUkzTW1Sam5CcnhIeGJHeWFnN3lITFNIYzJPMWEwWFoyTXFpMHVjNHh6MW9CeFNFMG1hN0RsSlViNWdhNmkwWU5hSVNlY1Z5YW5tdDdScGk4WmpKenQ2VURLdXN3aEpsSzlEV1ZYUmF4RURhYjhaSU5jOFJRSU8xV2JKUzExR0I2K2xWc1ZwNkxHV3VkdzdVQWRJb0N4OGpQRmMzcTEwWkppaW5BRmRGZGt4MnJNTWJnTTF4c3psNUdZOGttZ0NKalN4UHNrRERzYWFldEozcGdiOFVpM2NKejZWazN0cDVMYmwrN1Q3QzU4bWNBbjVUVzJZRW5qeXlnaWdEbUIwNXBldGFGN3Ava0tYWHBucFZBcmlnQjhCS3pLUm5pdGVYQnQ5eDRyTnN2OWZnalBGYU4xOHR1Y2p0U0F4Sk9IT0RrWnB1YVUvZU5KdEpQSE5VSWtoazJOejNxK1YzcmtWV3RyVm5mTERpcjBqTEJEK1BhZ1pMWTM4bGhLSGpIUHJYYjZCOFE3bUNWWW5YZVR4azlCWG5QMnBaRDZWSkRJVWNNQ1I2NHJlblhuQm1WU2pDYVBwSFJ0ZWgxS0VOdkc3b2EySzhKOEo2OTVGMnBrZGhGSDBCUFUxN0hwbXRRM3NBSllaSzljOUs5eWhXVlJIaTE2THBzMHpUY2NVNEhJQm9JcnFPVVppa3AxSVJWQU5OSlRzVW1LQUV4UlMwbEFDR2twMUpRQWxGS2FTZ0FwRFMwVUFKUlFhS0FDa05MUmlnWWxGRkZBQlNHbG9OTUJLS0RSUUI0bnFKTjlkYnJCQkdtQWRwN1lxN1lzUlpvMTNjRUtyTXFucUd4Lyt2RlZkSzAyNHVoUElzc0tLaEgrc2ZiK09POVhYYmJKYTJNbmx0NWJiQXlEZzVPYy9yWHc5MDFzZlVvazFSN2NKYnlXb2tCRGZ2Q0QxNXJRbjhYWEdqV3FwWVdNTnQwTzUxM00zSHZVTUZpOXpDK21Lak15M2JQdlBHMlBKSDQxTmJhZmEyK3F1K3NTaVNIeWo1UjY3UjJCOTZIb2l1Wk16TkduazFPN211cnJhSnBtTEY4WnhtdG15MDJYVHBaTG1WQXdSRElTUmpqdC9PcUZwZlcxbERldkNmbTNBUjdFSFE1elUrcmFoYm15amVScHBYOGlQZXB5dWZsUEgwNkdrM0p0TkN1WjhkeUpwbUxsZ3NqZkt6ZnhIdlc5STZXNzI5dEhPNVZRVEprZktCWEhXbHpjU1JvbkxCWDNLQ3ZDMXRtVWxGRTAyMUpFSWtaUjZkcWNvV2FLVW5xUXJkS2wxTmNGRzh0UHVNdk9PZTlhMXFZYmZWTFRVUW9rdDVRQUVEZk1DZldzUFpBWkJhV0JkVmx4dXo4MmNjMWNoV2FXUjdTd1hhQW9ZbkhjZWxhOHlVV21SeXU5MHk3YzZoTkxxRWx2TjVVVVRURUtTTW5CUFFWamEvUE1idzIwYWlPR051dWNrR25GeHA1WnJseXNrYmhnb0dkeHoxck4xTFVoZkIwU04wVm4zTTdkelVOT1NUdmNkdVhRdDNldzI2TDUrSENqSlFjR3RUU0w2TzArYWFNczVYalBUOGFyV3JvTE9HMm5SWkdkdmtPMytkWGt1clpaSGhsdENISTJiOGRENlZ0Qk5yUXprK2pPbnRkV0g5bmkxbnR4SXNoM0FnWnpqMHJsbXU3ZVRXSm1oamVJcmtiV0dRRFZhTTZoY1RPYk50NlJnNFVqR01VeTJNMGtaaGVWRWR6aHlCZ2l0dWRTanlwMlpDaTA3dll0MjkrV3ZDQzVDQWpLcjMrbGR2cDJxMll0dHNUNVVyeG5nakhyWG55Mjk1YnNra1RiaEczQnh5MVhmTnZMOVRic05rakhQeWpCcnB3MVZVMCtablBYb3ViVGlkK0xwUEpXUldWaEoxd2VCV0Uxdjl1dkdhT1ZmTGh5eDNOeHgyckJXL21odEhTY01FUWJTMjdCQitsVTRyMTFzL3MwTGJwSm40R01FMDhUaUhKSklNUFJjVzIyZFN0N004aE52S2czTHRJSFlWS3R6Y1c4a1Vkck5BNVpzWUo1eldURGEzV25JUHRVZTJabHo5QlNJaVc3ZWVrKzhNZVc2N1RXU3FWSmFSZXhvNmNFcnlXckxsOWRYZHRlTjU4aU80ZmxtYmdWdTJYaUJOa2R2TUZhWXJ3VU9RYXdHdmJkbzFGekFYU1JDUE1QUW1xT2t4V3NWNFdqZGdyY0x2Nmo2VjFVNmxTTnRkem1xUXB6djVIWFhOekhNdmt5dnNrQnlGQitZVkswKzZKWXl4TXdHRU9QbXJGdUxSYlc0am10Z3NzNUhJWTlSNjFHTlZpZ3VWWmkwa3E5ZWYwcnM1Mm8rOGMzTHI3cFBlMjExRGMvdm4zeVl5TWlwN2ZVNWJaRlc5Umt5UDhBVzQ3VlRhNm11cmhwQ3dWc2NLM1VBMXBMTGJ3d0JaRzh5ZVViZm01d0t4cGU2M1kycXU5a3hsdmVKYytkTWpFd2djSEhMVnAybHpHeUhiempuYjZWaTNVNngyclc5aXE3ajhyTmpnVkpvNlNXaXM4aWx5M0RmNDF2R1h2V1JoS0Y0blFDU1prSmhRWi8ycVpFWGx1RHZZZktPMUpCZVJ0Q3o1d29HQm1peEhsd21Sam5jU2Mxc25kblBiUWxtaVZ3RWtHVlBTc205dDUwdTRVa21JdDg0R1A1R3RkM1dhUElQQTZZcWhxZ1dhS0pYYkcwNUk5VFRsYTEyT0hOZXd5NHRXU2MvWk5xb0I4MmV0VjdTNmlJZU1QSVNwd2M4Q29FdmpieCtYZFNEWTNJY2Z5cTNZMjhOeEo1cUFGVk9ldFpKM2VocnBHUHZGZVZHdGJlV1NZTW9jNUdCVmpUV2t1WTJlU0VyR28rWGVQdlZwWFUxdjhBWnlKR1hCSFNzeXh1SlZ5cVprUUg1UWZTbmF6MVljM05HNW9QQWlJanhSNEg4V0RTTk5CRkdDWFk1NkFHa1ZacEpEdmJZamRBdFIyMXBCRGV6QUhQSFJqbXRFbEZhR0x2SjNaS2swanJrUm5iNzFhVjg0cWk4NVNReEpsa0orOVU4SU83YXhPNzBGVkd3cEx1VEsyV0lwNXBxRERFVWtqWXdCeVQrbFVaMkF0ZzQ2MDZrVk52WGswNm1BbEZMUmlnUWxGR0tLQURGSlMwWW9HSlJTNG94UUFsRkxpa3hTQUtLTVVVQUZGRkFwZ0ZMMG9vb0VGTFNVb3BBS0tYdlNVNFVtQmkrS3RORjVwc1U0TzE0MjI1OVJYbk9vYVRtUE1zcmJldUIzcjFyVWtFbWhYSS9pVERBVjVIck4wNVpWRzRFTVF3SHBYeU9PcDh1SVo5ZGdhdk5oMGROb1JpdGZDZDFieHR0QkFPV3J6UHhWc25sWTRBS25JSHJYZFdzZ2wwTmtRZ1lYQkZlZjZ4RVJKSThvRy9jVnlPaTF4MDAxTFU2YWpYTG9jczR3ZmVtWnF4T3dhUTRHS2d4WFljUW9PSzA5R2xDM1F6M0dLekJWaTBKUzRRajFvR2ROY29KWWlHNllybUprMlNzdm9hNm5xZzNkY1ZTZlRZM2tMdjNOQUhQNDlLNlRSNDBTM1ZsSFBlb2hwTWF5S3c2Vm93UWlLUGFPZzZVQ0tHdTNiQlJHaHdHNjF6YmRUVzdyclphTUJlT3Vhd3pUQVpTVTZqYm1nQkIxRmJGaHFCSldOdnBXWEZBOHJCWTFMSDZWc1dHa01yaDV4akhTa010M2NKbWd3TzQ0ckltMDZRU0txYzU2bjByb21DZ0FaemlvcFdqUmR4d0tCR0ZiMjBrTjBBeTVIcUt0MzZ1WVFxTDlhdGk0Z0xZUWdtbnNtN2srbEFHSkRwanNNdndLc1IyS1E4azUrdExjYWo1WUtLbklQV3FVbW95dUQ3MHdMTTl3a1NrTDFyT2x1R2tQSnBqdVdZa21tMHhCbjBxYUdVamhqVU5Bb0ExSUxreEFGVDBPUml1Z3NmRk41RHNpU1ZrVE9TUlhJeFNiT3ZTcmFISy9MV2tLa29iTW1VSXpXcVBvWHdwNGxqMVN5UkhQempnWjcxMGc1RmVEZUVOV2tzN2dzemJZbzF5M05ldCtGOWZqMXUxY3EzeklmMHIzY1BXVTQ2N25pNGlnNE82Mk40MGxPb0lyclRPTVpTR25HbTlxc0JEU1U2a05BQ1VVVVVBSlJpbHBLQUVvcGFEUUFsSWFXakZBQ1VVVVVERHRTVXRHS0FFb29vb0FLUTB0SmlnRHdtZXd1WTdHMEx5SVRNcFlFQTUyQTlmMHJvbHM3VzVtc2IyNHVuVnhJRVdKRXdRaWpsaitsWVF2V2t2cGJoRkd4RTJ3eGs0d3ZwVldUV2JyZkpKZlpTWlQ4dU9Qa1BYSHRYeGIyc2o2cFdSMXVyYUZlT1lKN0hVR3VmUEJ3eUhqOGNWa1hTM0FtaU43dmpUeWdURXJZTGhlQzM2RTFZOEdhbXMxNSs4dTJoamorWlJ1Nm1ybW9DUysxQTNSS21CSWpIOC9zVHgrTlljM0sybVhaTXk3VytSWTU3UzNYeWxsVXNIZnZqb3RQTDNWeFl2ZjMwb1pnUW5sdDA2WS9sL0txMTVMY3ZPWjFpQ2lOdzIxVitWVFVGd0VObmNYUzNBVU0zRVJQclZxWE1oV3NkZG9PanBjMnRwTW5rRUkyNlRjK0RJdWVnQnFoZlgwdDVKZFFEeTB0NFpHY29xNGJHY1lybDlMdkpDdzh5UmlJeDhnM1l4V3JlVFNDM1NUeWkwa28zU1NrZmU5NlVuSzVLVjlRdWpCYVgwUzJrNVlNQVZZZFZOYVpsdUxKWTc4TzN5THRiM3owcmx2Sm11SjBhR0ppRmNGNUFPQUQ2MTFkL3B5UWFld2d2bXVGMkJpQ1B1bkhTbTBtMGk0dmU1V251VzFPMGVhY1Jwc0lLNTZzYXhyeVlYTHhqN2hEY2dEa0QzcDlzMFFWaVpHWkV3ektUNzFidm9QTmlackNSSGlVQm1BWHQzNXFvcmxZdWE4UjFyREpxTjZSOXJXRmJkTndKSDN1MkswOUdzNURheVRYRWdaNVd3by94ckFzdzl0SUxoUDN1T0FnNmMxMFM2cloyR2tzc2tSTnl3TzQ1eHRKcldYTW8zWFV6VnIyWWtpUHBpeUVURlg3Z2REbnRXZGNXazl5ejNMNVhid1FSZzFETkxjcFpwSk1ma0pHWFBZZXRTM0xUclppN2tuenU1QUIrK0t3MVROM3JveXhwbXJKcGwzR0hiekVLRmNnWkFwdDVjM1VGNko3WU9SbktzQjBxbk5QYXhXNjNFYjdHYkcxTWQrOWFMYWtidXliekpndUZHMGxjZmhWeHUzb1E3TGN5cjYrdVo1eEpLdVUzYmlxbmpOYkVoc2hIRnFKbUJkQndCeHRJbzB6VFgxS056REpDc1NBQlQ3OTgxbFhObkxiM0RXMHhWbExaK1UvcldrNUp1eWV4TVkyVjdHN2VlSlRxZHBERkk1M3FPcDYwc2s5bkRaS0NHRzduY096VmpqeVpXTVlZaVZNQmNEazB5K3ZDTFR5SjJLaGp4Z1pPUlhSUms0WGZRd25IbVpydkpMSkhIYlFzWDIvTklvR2RnOWFqVzR2bXZvRnRTdXoxSzR4NjFrNmJxRnpBSjVMV2Nsd3Z6Z2p0N0dyVmhwV28zOW1kVXUzSzJxSGNtNXNaTmErMlZyYkdmczNyWTZSTDM3TGVvME1odTl3TzRIZ3I3Vk5aNkJlMzhqWHQxQUVSbS9kam5nMVRhT0NiVHZ0Zm0rVEtwQUVlT0QrTmEvOEFiOHNGcmJzSjFQOEEweFZ1QWNkY1ZzcDg4ZFhzWk9QSzlGdVorc0cvMG1aVW1WSGlVZjZ4UWZscTVwRnpFc25tVE9HWXIrN3owckxqMXFYV3J1WXpzTXEyR1FqNVNQOEFHcThscGN6NmxEQzh2a3h2SmdrRG9QV3BuaU5icGFEVks2MTBadFhsOHR0YVhKakFNcFlGUmpnVkxiNnM4RnVrczBUTjVpakFUa1o5Nmh1Ykd4MHU2Tmhkejc1UHZCczhPS3BXNlBjTkxIYXUyeUZzYmdjL1N0YWRWMUxOR2RTQ2dyTTZFM2h0ZEl4UEd6c2VUdEhDNXJSKzBJdGloV1RKWUQ1Y1lJcms5VkdwMnNjVWpTckk2L013QTdWcmFmTStvYWNsemNaODAvZEo0RmRFWk9FbmRtTW9Yc2tkQkF5SlorWXhHRlhKeFhNRzduMVRVR050dU1LdGdrZGo5YWZmYTBrTU1kbWpyNWpuREVkNnRTUVEyR2xxWXBQTGxaZ3hJN21uemUyZW15SjVmWnEwdHlwTkdycTQxQk5xbkcwMGxqWnZhMi83bTVkbzNiZHRCN1V6eEZmQ095V0c1Y2JqZ0t5MWEwL3kxMDFJMGtHTnVRVDFhcWkxejhvU1Y0cHN2Rmxpakhub29IUVpITlBTYUtBcXFOblBmMXFwZnp5eTI2RVJaQ2tCeVRnQ3FUQkdiNUhadHhQQ2ZkV3RKU2Q5RE5SVnRkenBUZlFFYlhaVVlEUExWbkpjaHhKT21ESmtna0dtM0ZsSEhZTE91eDVGR2NrL2VxcGFYRGNvUis4WnNOR2VBbzlhSlNiOTFnb3BLNlp0d1JFMitXQXl3emsxTllnK1JuT1RuQk5FckNPMUlZZ0ZWNE5aVTEvTGF4Uk5ibEhCSHpwbmtuMXJUbWpIUXk1WEpYTlc1a01aVXA5NXVNVXFSRmVYY2xqV1ZwOTlKZVRPYmo1RzdaNlZwdmVSTGIvS1EwaDRvOXBhUE5ZU3B0dmxKd29Yb2MvV2xCQnFxTDJFOUczRURIQXBndWxUNzJWQjlSV2taS1N1aUpRY1hZdkU0b3FGQ1ppRDBYdDcxS1pCR3ltUVpYcFEzWlhaUEsyN0M5YVNqSUdjOER0U2JzOU9sVWhDMFV0SmlnQW9vcEdiYVBlZ05kaENjR25ZcGlnOVQxTk96aWdCY1VZb05HYUFERkZGRkFCUlJTMEFBb29wYUJCU2pyUUtYRkpnUGpWWk44YmdFU0lWcng3eFZHMXJkeURHQ3JFRVY3QWh3d05lZmZFTFRWL3RFT293c2k3aDcxOC9ta0xOVkQ2REs1M2k2WmdhRk9zMExnRTRIV3VaOFJKSTExTnRYOXk1M0thNkh3N3RWMnQzR0F3d1RVdmlmUjJnc2xjRGpsVHgrVmVLcC92RDJKUTkwOHJsWEVtTTVxTWoycTNKYlA1alpHRG1wSWJKcGxKQTVyc3VjVmpQQzgxb2FkYW1TVU1lZ3F4RHBmelpmbkJyVXQ0VmlYNVZ4UUE4ZmNIclRnUDUwWkFIUEI5YXF5WDhjU3VDZm1YdFFCZlZmZW5oUjFKeFdGSHJYemZNdkZhRmxlclBIbG1HU2FBRTFLMFdhMVlqN3c2Vnl6cVFUbnJYYmxROFo2Wkl4WFB5NlE1dUdBNmRjMEFZb0dUVjdUOU9lNW1HUVF2Y210V3owZFluVjVmbWIwclVSSTRCOHFnQW5rVUNJcmF4aXRWK1ZjVVhkd0l1cEFGUlh0OElJeWV3cm03MitlNWM4L0xTM0dYYnpWam5iRjY5YXpKTHFXUlR1YzlhaHBSelRFU3dGdk1YYm5PYTZTRWt4RGR4eFdaWWFmdTJTbGg5SzFabThxUEpGQXpIMVNMTGJvMCt0Wlpyb2pORk5IeGcrdFZKN09OMXlvK2Iyb0VZMUdLdHlXVWtmVVpGTWUyWmNFamltQld4VDQwTE5oUmsxWSt5U2NFcndhdHcyZ2p3dzVhZ0NwOWtiZ21wclpDakVQMnE5dFhpcTF5cEgrcjYwQVRpNlpJSklvempmMVB0WFUrQVBFRDZkclVjVHZ0aVlZT1RYQmlSbE9HTldyZTVNY2drVTRLOTYycDFYQ1NablVncHhjVDZpdGJtSzZnV1NKZ3ltcHE4djhDK0toSHBvanVIUHlaSnlhOUl0THBMeTNXYU5nUXdIU3ZvcVZSVkZkSGdWS2JwdXhNYURRZXRCcmN4RzBocGUxSlFBVW5OTFNVQUZGRkZBQlNHaWlnQktLV2twZ0dLU2xwRFFBVVVVVURFb3BhU2dBcFJTVVVBZk4xMUtZN3ZmQ1Ezem5nSGcxcVg5Mit0d1dVMStyQUlIUStXbk8wRE9LV2JSMGgxellWWUlWTWl1ZWdCR2Y2MHlmVXlqeTJ0aklrVUtyenh5M3QvT3ZpSlBYWStxVzF5bnBsMzVjengya0lZc2NCei9EWFRlWkpKRmE2VXJHVjNjU1N1VGhVWTVHTSttTUg2MXp1bTJWeGNYQkZ0aU5PcGYyNzExTnRiaTR1dkxkY3hsbGJjRGdIMHordFoxV282c0ZxV3RSdkxYUklaclQ3VkhMTkltNWlCbkI5cTRtNHVFdTMyd1pmSk9Bb3JZMS9UWEdydXdZU1FvZnZkalU5bW1tUngrWGJ3YnAyWXNKQjBWUU00cDA3Y3Vnem5saXVMSUY5Mnh6a0JXUElHT2F2MnQ1UEphcERlTXhHQXFaN0QxcVdPMVRVUEpudlM2UnUyQ3hIUE5SYXVSQkRHRmJjSWpnWUhidFd2TW5vSExaR3pIRGNOYi9ackJ2S1RINzZUT0ZQNDFaZ3ZNMnZsV3orYkdtUktlN25IV3NHeHZyN1U1MWhNcVJRRlMyQjkwWUhXcTZ5RzB2bnhJU1I5MWs3MFdWOUJYTjIrMHk0MC9UVW44dEFrNDNESjV4OUtaYzNEeDZiRkhESG5jQjVqb09BUFNxTXQzTmZ0aHBNczJPUDd1SzEybUZqcHNsbk9xeTNFeTVaOTMzYVVuWmxJb3czUzJrUWVBL3UyYkhQdFNYTjZsM0tVaGtNclA4NUxER09LZ3R0UG5NTVpoalo0bWJKTGV2ZXJrTmo5bmFaNVNxQmx3SEk1K2dxN3A3a3E1Vm0xVmZzb3Rib01ZODV4MXpXbEZHSDhNaGtnSkxFaEdZNUFIb0JXTmVHemp0d3NLRXpsZ0MyN29POVhuYVcyRU1mekt1QnRYT2MwSmN3cjJaU3NMUzZ1SVdGd2dFTUxaMy8zYXZXZDNiM0Z3WWlqUEFvSUJQR1Q2MXJQcUZ2TnBaaGpSRWtVZk1Sd1RYTzMxNlVVUVJoVlZWNUtqQlAxcUZlVjFzVTdMVTJiRFd6cDIrMVNPTjdkK3A3cjlEVGJxU0xVWkdhMEVpU2c0K2JwaXEyblBadG82SVJzRVIzU2NjdGsxMitvdG8ycWFEREpvbHZpYUNQTXFnWXhqMTlhaTlwYkZuTytIOUlOMUUvblMrUzJlckRHU085WldyV0Z6TmVEeVVEQUU3aU8yS3RXMnNYa00waXJHSkk1ZmxDdjFXbTJSdmJtNnVJVHVSUWR4d0t0eWt0YmtwSnExaWNXQ1J4UXRheWdpVk5yb09TRDNyY3M5WHRsMFo5SW5pL2R4anJ0emcxU3ZiaFYwLzhBczYzZ0N5TnlKdWh4V1hiM0M2ZkUwS1NCcFpDTXNlUXRITXByVkJ5dUQwTFRrNmpPTEpIOHFHTTd0K1B2ZlNwWXAwdGJoTFlJc2pFaFRJM1VWSnBYMmY3ZmlkMW1DSnVaZ2NjKzFQaGpqbDFHN2xtUmRrUTNCZjhBNjlhZTI2RWV6TmsyTnRiNmVMZ1JSaU1INzZIRFo5NnlZUmRRWFp1cnRTTE4vbFdSdTFJdXBKTkZKWUdNMjBNZ0Q4ODdxemJzM1RCWUxTNWVTQitOaDZDdFZYdTdkaUpVN3JVMDVMeUhWWTJlS0V1YmYrSnZTc3ZRZGJmVDc2NWE3aWNRcytWcUR6aHA5ajluTCtYTHUrYkhlcGRLSDJ6Y3Fodk42bGoweFNwMVhHZk1FNmFsSGxaMUV2aU93dnJvUnhmT1crOUlSd0tXeG5XYThsU3hrWjFnR1dEREFQdGlzTXdDR1FUWEVLb0U2REhVMU5KZDNkdHR1YkpseFA4QUswS2prQ3RhMkljeUtWRGxMOE1ZZlhCTEw1WkNuY0ZiZ211aHZyOUxtTVJ4d2xqSGc0SFEvalhLUTZ0YndJc29ScGJvL0tVZm5iV3RwZCtyV0VyMzZLSExFQUoxcnV3MVNNSXBYM09LdkNUbnpXS1d2b3Q3RDVzaEVUSUFWakE1UDQxME9tTmFXdW53VDNlMGZ1dmw5cTVjWE1idmNyZHlzcXFDSTkzOHFodExzZVRDM3ozR3puYWVuNFZjYXFWUjJRcDAzS0N1enA5WldXNXRUY3hxeVd2VXIzWVZjMHQ3S1BTSTVZaWZMa1hKVWpKTlU0TmREMjBuMnVOdHJEYUV4MDRySzhPWFROcnMxdEx1U0dOdDBhSDBycTlwZHBycWN6ZzdhOURvSWtSWTJrbUdZZWdYUDNQd3JOUzFWYmg3Mkc0M0tyN1FPMWFIaUsrVzNzM1dKVTh4aDBKeGtWeTJnNnBQQmNOOWxSSmQ3a3RHL0tnKzFjbUxxT0tVWTduVmg0eGZ2TmFIVVg5MExxMzJCaUNnM0hIZXNwcmVOSTBDWExobVhKeWNZcTVaN3BwMnk0RXB5R1JlV3FKSk5QbHM1TGFGUzAyTUY4YzVxRkNUMWs5VFJ5Z3RFdEI0RU1NTVV5UXl5YkJnbm5CcTIxNFlyVm5qaWpWbEh5alBKL0NzNkRVREtrbHBLV2lTTWJSZ2N1ZlNtNlZkVzl3a2lzalJzbytjRTUrbGRDcWFKWDZITnlXYjlUUzBPVzR1UE1NaUtIemtybnBWK1k1UTc4Rjg4Q3FXa3NpSzdRRUVEcko3VkxKY1FOdVR6QnlSZzU2MXRUbHl4Um5PUHZ0bWpBWDhzTUNBRzZnZHFaZXhTdkcyR0JSUms0NjBzUkZ1dVpqaEQwelZKdGJTVzRsdG9WTDdPR0s5eFd0U2NWWmR6S25CdHVScFFnUEdwem5pcGpoUjZDc21DLzhBSmxraFdOcFZqSXd3SEgwcVJyMjRkY2ZaWDJub1NhMDVqSnhiWmZWOThoeDkwVThHcytLZTZLRUNGZjhBdnFwTjk1dTI3WXdUMnpWWEo1UzI1d00valVLUzc1TVk1eG5OUVRQZUNOdmxqeGoxcHR1bDhzUXo1V1QwcVhxeTBra1h2TVFkVGdEMXBpT0N4a1lnTDJxaFBiM0RNVGRPTnFqSUM5cXNRd0ZsVTdzOGNaSGFsejYyRGs5MjVQNTZuSVFGajlLQVpPdTM5YWtDNEFIOHFYRldaRFFXN2luVXVLS0FERkZGTFRBU2xvcGFBQVV0RktLUWdGWlBpalNUcXVqc3cvMWx2eXBIcFd1S25odzhjMEpIRXFGYTRNYlQ5cFFhTzdBMVBaMTArNTVyNGI4TUdUVTBTUnVHUFBGZGhydWd3R3pFTW8zRUVFZmhXaHBHbE5hekdSL2wybmo2VXp4UGRlVmFTckh5d1RodSthK0xUOTQreG5xanh6eEhvbGpieVN5cGhYRGNMNml1YmpSVTZEaXRYVzJuYThsZTYzSnU1VVZoaThqWGd0WG93MlBPbnVYQW9wU01DcWpYOFVhakxaelZtS1FTUmdyeXRhR1pVMUtVd3c1QjcxejhrcGtrTE4zclgxZVZmcyswL2U3VmdrMEFQelU5dE9ZNVZPZUJWWE5PVTgwQWRwYlRCNFFRZW9wN2JBZVR6V1BvcGJ5eXpFbm5nVlBxOHpSd2JsYkJvQXVTVHBHRHVaYzFqM3VyN1pBc1hRZGF5NUxwNWY4QVdOazFBZWV0QUUxeGR2T2NzZVBTcTRveFNnVXdFeFVrRUxUU0JWQlBQTkNMOHc3aXVpMDJ6Vkl2TUFIUE5KakpMYTNXM3QvWEFyTzFHK0JpS2drTjZWcFhWeXNTSDBybTd5V09WeVVIT2V0SkFSTEt5SEttcmtGOFJ4SjA5YXpqUm1xRWJRdUkzeGsxTGhYWHB4V1Bic2dmTW5TdGFNYjF3dkF4UUEvZW9BWEZRVDNDb3ZYa1ZTdUdlS1VnTjBxckpJV09UUUJhYStMTGpvYzFhRndKTGN0L0VCV1Jtck5vNExiRzZHZ1JFN1pZbW5JNVhwU1RKdGxJSHJTeEl6TmdDZ1pxV2QvSmIvNnRqZ25rVjZUOFBQR0diMXJPOGZDc01wazk2OHlXRFlCNjRxUzB1WkxTNVdTSWxXQnJwbzEzVGw1R0Zha3B4czl6NmVpbFNhUGRHUXdQUTA2dlAvQTNpdEwyUmJLWnp1eDh2TmQvWDBGS29xa2JvOEtyVGRPVm1CcEtXa05iR1FocEtVMGhvQUtLS0tBQ2twYVNnQW9vb29BRFNVcHBLQUNrcGFRMHhoUlJSUUFkcVNsN1VsQUhtL2orQ09QNGQ2WFBHZ1NYYUUzcU1FakhRK3RlVzZTaXphaEg1bzNmdkY2MFVWOFpMK0dqNmw3STdiVFZBdHIwZ2ZkallEMjVGTWNtTTNjYUVoUE82VVVWeTEvZ0o2RGIzNXJhM1VrNGJPUm5yUnBjTWEzdXhWRzAyN01SNzRQTkZGVlIrRkdpMktndXBudTdLSm56R0pQdTRHT3RidHhERmQ2MXFNVnhHanhyRVdDN1FBRHg2VVVWczl4TGM1aU1lU0pQSytYSTdWVjA4bDlSWGZ6eDMrdEZGTG9IVTM5RmhqZWE1RElEaFRpcWtxS2wxRUZIM2p6M3p6UlJSSGNKR3hrMmt3K3prb0ZBd0FlQnhWZTZZelRyNWgzWnlUUlJVTDRtYVMySUxHQ0o0TG5mR3B3NElKSHZXaUZETTI0WjJxZHVlMUZGVWc2blBhZW9NMXlUazQ1SE5XV2lRV2NyN1J1OWFLSzE3RVBjbDA2TlRweXFWR0drNTQ2MTJlajI4VWVuVEJFQUd3bWlpc3BmRVZFNW0yZGhxOHNlZmx5T0t1eHlQYjNrendzVmJPTS9qUlJTbnNOYmo3NmVUN1d4M2NralBGWmN5aFo1R1VBRWprNG9vb3BiQTl6b3RFczdkL0M1bWFJR1FzZm1QV3FHb1R5UmFYY1BHMjFpTUVnZHFLS2hmRU9Yd2s4RWpUUm9KVHVBdDF4a2RLYkpLOE4xNWNSMnFWQndBS0tLMWpzUXluZlJvOGpzNmdsb3lTU090UjJTZ1djRGpoaStDUnh4UlJVdjRSOVRXMXo5M2JSYk9POVVQRE16elhjN1N0dktnNHoyb29xbjhCSjBHbVc4TFc4ak5HcFptNU9PYW82ei9vdXBJbHY4aWxod0tLSzZmK1hrVEYvQXloSTdIVm9sSnlwQkpIcldqcHFnUTVIWG1paXV5UHhITkxZMDVva1dTQjFHR1laWTU2MVd1R01Xc1cwMGZ5eU9RR1lkeG1paXV1WHdJeGh1ek04WFhNMGw4NnZJU0FPS2g4TWdSYU96eDhQazg5YUtLOCtYOFJIVEgrR3pxZEgvQUhLcmNSL0xNNCtaK3BQRlZkS2tZU1RzRDh5azRORkZkOGpqNkdmYlNPOTVsbUpMTXhQUGVvOUxrWnIrVldZa0VFa2V0RkZabzBsMU5wcEh0N1dPS0E3STNjRmxIZXJGdkdzbTFuVUVxeHdmU2lpdXFPeHlkeTlxTXJuU1lpV3lXZkJySVUvWmxkNFBrWWc1SStsRkZaVmY0a1RlaC9EWnE2WXg4bTNYUERmTTN1ZUt0TTdOZE1yTVNvQndLS0s2dXh6OXgybU1XOHpKemh1S3RTSE1oYnVBY0dpaXRuOEpnL2lHeXNUYnNUM0lxeEYvcTFvb3B4SmtNdXY5UWY4QVBlcDI2SjlLS0tYVWEyQ2lpaXJNZ29vb29HRktLS0tZQlNpaWlnQlJTMFVVZ0hDcElUaVpjVVVWbFUrRm1sUDRrYU42eEVYQngwcm4vRVEvME1OMzQ1b29yNE9wL0VaOXBUL2hvOEc4VzNjNzNESzBoSUJPQlhHYmpucWFLSzdxZXh5MU54d0pKNU5kRllmOGVTMFVWcVpHWHJQM2hXVFJSUUFVOWVvb29vQTZqVFJpMVhIcFZUWFA5V3RGRk1EbjZLS0tZQjNwNjhzS0tLUUc1cDF0Q3lndEdDYTFnQWtmeWpIMG9vcE1vNS9VNUhKd1c0cktORkZDRVJtaWlpbUljbjlhM0xYbTNGRkZBR1plL3dDdWFxWm9vb0FLbGcvMWkvV2lpZ1Jka1JTMlNLa2hVSzNBeFJSUXhpU3lObnJVYUVuclJSU0JuVGVDSkhUeFZaYld4Kzh4K2xmUVErNlBwUlJYdlpmL0FBenljdzNRdmFrb29yMGp6QkRSUlJRQVVVVVVBRklhS0tCaVVVVVVBQnBLS0tBQ2tvb29BS0tLS0FDbEZGRk1ELy9aXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvc2FmYXJpLmpwZ1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFmcmljYU1hcCgpIHtcclxuICByZXR1cm4gPHN2ZyBjbGFzc05hbWU9XCJhZnJpY2EtbWFwXCIgd2lkdGg9XCI3MDhcIiBoZWlnaHQ9XCI0MDBcIj5cclxuICAgIDxkZWZzLz5cclxuICAgIDxnIHRyYW5zZm9ybT1cInNjYWxlKDAuMzc5MzQ2MjQzNDU0NDkxNCkgdHJhbnNsYXRlKDQ4My4xODQ0MDg5ODgyNzAxNSwgMClcIj5cclxuICAgICAgPHBhdGggZD1cIk0yNjQuMSwzMzYuNzNsLTAuMzgsMC42bDAuNjQsMS40bC0wLjI0LDAuNmwwLjQ1LDQuNTZsLTAuMzUsMC43OGwwLjk2LDIuOTVsLTAuNTIsMC4zOGwtMS4xMywtMS4xMmwtMS4xNCwtMS45MmwtMy4wNSwtMi41MmwtNi42NywtMC4yNWwtNS42NSwyLjA4bC0wLjgxLDEuMTFsLTEuMywtMC4zM2wtMC44MSwtMC41OGwtMS4wNiwwLjExbC0wLjk3LC0wLjQ0bC0yLjc3LC0xLjk1bC0wLjMxLC0xLjM3bC0xLjM1LC0yLjQybC0yLjAxLC0wLjk4bC0xLjQzLDAuMDRsLTEuMzEsLTEuMDNsMC43MywtMy45M2wtMC4zNSwtMy4xbDEuNTgsLTEuMDFsMS4yLC0zLjA3bDAuMjMsLTEuOTFsLTAuNzEsLTEuODlsMC4wMSwtMS40NGwxLjksLTEuNDdsMy41NywtMC43NmwxLjI4LC0wLjU3bDEuMzcsLTAuOThsMS44OSwtMi4yMWwwLjE4LC0zLjE4bC0wLjU1LC0wLjg5bDIuODQsLTEuNjJsLTAuMCwtMS4xN2wtMS4xNSwtMi42MmwxLjkyLC0yLjA0bDEuMDcsLTAuODNsMS4wMywtMC4ybDQuODUsMi42bDIuODksLTEuMTlsMC42NSwtMS42OWwwLjE2LC0yLjg3bDIuNiwwLjMzbDAuODQsLTAuMjRsMC41MiwtMC42N2wtMC4wOSwtMS4yNGwwLjU2LC0xLjgxbDEuMDQsLTEuMzhsMi4xOSwtMS43OGwxLjI4LC0wLjQ4bDQuMjIsMS4yMWwwLjg3LC0wLjU1bDAuOTIsLTIuOTNsMy4xMiwtMC41OWwyLjM4LC0xLjQybDUuMTYsLTIuM2wzLjQyLC0yLjc0bDIuNDIsLTAuMzNsMS42OCwwLjc3bDEuODcsLTAuNTNsNC44NCwxLjYxbC0wLjU0LDQuNjZsMi41MywzLjEzbC0wLjI4LDEuMzJsMC45MywyLjExbDIuMjIsMy4yMWwzLjQ1LDEuMjVsMC43NywwLjU3bDAuNjIsMS4xMmwxLjQ5LDAuODNsLTEuNTQsLTAuMzRsLTAuNDksMC4yOGwtMC4yLDIuNDJsMC4zMSwxLjg1bDEuMzYsMC41NGw1LjYyLDQuMzlsMi44MSwwLjI1bDIuNTgsLTEuMjFsMC43NiwwLjExbDAuNTYsMC42NmwwLjY4LDIuMDZsLTEuNTUsMC40bC0wLjM3LDAuNzRsMC40NSwxLjA3bDMuMzQsNC4zOGwtMS4wNiwyLjE0bC0zLjM4LDMuMDRsLTEuNCwtMC4yNmwtMi43OSwwLjQ3bC0wLjU4LC0wLjU0bC0xLjg1LDAuMDlsLTEuMzUsMS44NGwtMS44NCwwLjQzbC0xLjAxLDIuMjRsLTEuMSwwLjAxbC0wLjUyLDAuOGwtNC41NSwwLjQ1bC0wLjM2LC0wLjQzbC05LjIsLTIuMDhsLTAuOCwwLjkzbC0xLjE3LDAuMTJsLTAuNjQsMC45bC0xLjQ0LDAuODNsLTAuNzMsLTAuNjlsLTMuOTksLTAuMjVsLTIxLjAsMC4xNGwtMC40OCwwLjVsLTAuODIsMy4wMWwtMC4xLDEuNjlsMC41MSwxLjI3bDAuOTUsMC45MVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJCRlwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTgwMC4yMSwzMTAuODZsMi40OSwtMC44OWwyLjA2LDIuNmwxLjIyLDMuMDRsLTAuMjksMS4wbC0xLjE1LDEuM2wtMi41NiwxLjYzbC0yLjg4LDEuMDVsLTEuODksMi4wOWwtMS4xOCwtMC4xMmwtMC40MywwLjVsMC4yMSwwLjgxbDAuODQsMC4zOGwzLjk2LC0xLjA2bDIuNzIsMC4yMmwwLjYzLDAuNWwtMy40OCw1LjQ2bC0xLjI1LC0wLjFsLTEuNTIsLTAuODFsLTEuMjksLTAuMDZsLTcuMDcsMS42NWwtMS40NywtMC4zNWwtMC4zNSwtNi44OGwwLjUsLTEuNDFsMi4xLC0yLjIzbDQuNzgsLTYuODdsMC40MSwtMC4xOGwyLjE4LDEuNTlsMC42NywwLjAzbDEuMDgsLTAuNzZsMC45NywtMi4xMVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJESlwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTY0NS40Miw1MTEuMTdsLTMuNCwtNi44bC0wLjM1LC01LjMxbC0wLjUsLTAuNjlsLTAuOTEsLTAuMjNsMC4xNSwtMy4wNGwtMi40NSwtMy4xNGwwLjEyLC0xLjI3bDAuMjksLTAuNTJsMS4xNywwLjIybDEuMCwwLjUzbDAuNTYsMS4yNmwwLjY4LDAuNDFsMy44OSwtMC4xNWwyLjIzLC0xLjEzbDAuNzMsLTQuMjFsMS44NywwLjkybDEuNDMsLTAuODFsMS44NCwtMC4zNmwxLjE2LDAuODJsLTEuMjEsMi4zOWwwLjQ0LDAuOTRsLTAuNDksMS4yOWwwLjEsMC43OWwxLjIsMC44bDMuMDEsMC44bDAuMDQsMi43MWwtMS44MywwLjg0bC0wLjI3LDAuMzFsMC4xMSwwLjdsLTIuMjUsMS44N2wtMC42NCwxLjhsLTEuMjcsMS4zN2wtMS40MiwyLjc0bC0yLjI2LDIuNTJsLTIuODEsMS42NVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJCSVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTMwOC4xMiwzMzAuMjFsMC44NiwtMC45bDAuNjQsMC4xNGwwLjYsLTAuM2wwLjg2LC0yLjFsMS44MiwtMC40NmwxLjIzLC0xLjc2bDEuMjIsLTAuMDNsMC43MywwLjU5bDIuOTUsLTAuNWwxLjcxLDAuMTlsMy42NCwtMy4yOGwwLjk1LC0xLjg2bDAuNjEsLTEuOTlsLTAuNTYsLTIuNDZsMy4xMSwtMC44MWwxLjY5LC0wLjk4bDAuNjMsMC4xNGwzLjA5LDIuODlsMS43OSwyLjNsMS44MiwwLjk0bDEuNDIsMS41bC0xLjExLDIuMTZsLTAuMDcsMS4zOWwyLjcsMy44OWwwLjQ2LDMuNjJsMC45LDEuODJsLTAuNTcsMS45MmwtMC43NiwtMC4xNWwtMC42NywwLjI3bC0wLjk3LDEuNTdsMC4wMSwwLjY2bDAuNzIsMS4xM2wtMC45MywyLjY3bC0yLjM3LDEuMTNsLTAuNDQsMC42OGwwLjA0LDEuMTRsLTIuMiwyLjQ5bDAuMDcsMS43M2wtMS4wNSwyLjQ3bC0yLjk3LDAuMzlsLTAuMzUsMC4zNGwtMC40OSwzLjE0bC0wLjU1LDEwLjc2bDAuNDIsMy4yM2wwLjc0LDEuNThsLTAuNCwwLjg3bDAuMDcsMy44NGwtMC40MSwxLjA5bDAuNTksMy4xMmwtMC43NiwzLjY4bC0xMC4xOSwxLjI3bC0wLjM5LC0xLjhsLTEuNjgsLTIuMTlsLTAuMTcsLTAuNjJsMC4yNSwtMC43N2wtMC42MiwtMi40OWwwLjksLTAuNDNsLTAuMjksLTI0LjIzbC0wLjUxLC0xLjNsLTIuMDEsLTIuNDlsLTAuNDUsLTIuMzlsLTAuMjIsLTUuMTZsLTYuNjEsLTQuNThsMC4yNiwtMy41OWwxLjI2LC0zLjEyWlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkJKXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNzQwLjk3LDEwNTMuODdsLTAuMywwLjE2bC0yLjA4LC0wLjM0bDAuNzcsLTAuODhsMC45NSwwLjE1bDAuODMsMC42bC0wLjE3LDAuM1pNNTEzLjM4LDg3Ny4zNmwtMC43LC0yLjQzbDAuMjEsLTEuNTJsMS4zMywtMC45N2wtMC4zOSwtMi4zMWwtMi4wNCwtMy45NWwtMS4yOCwtMC45M2wtMC45MSwtMS44OWwtMC45OCwtMC43OWwtMC40NCwtMS40MWwtMC44NywtMS4wM2wtMC4yOCwtMS41MmwwLjg2LC0xLjFsMS4wMiwwLjczbDEuMTcsLTAuNDJsMS41OCwtMS40MWwwLjg3LC0xLjkybC0wLjE0LC01LjJsLTEuMTgsLTQuOTlsLTYuMywtOS40OGwtMy44NiwtNy4zN2wtMS44NCwtNC40bC0yLjgyLC04Ljk3bC0yLjQ5LC01LjA4bC0zLjE5LC00Ljg0bDEuNzEsLTEuMjNsMS41OCwtMC41bDEuNTEsLTQuMjNsMC41NSwtMC42bDEuMTcsLTAuNGwwLjg2LDAuNTFsMC42NywxLjQ5bDEuNzEsMC44MWwwLjI3LDAuODlsLTAuNSwxLjI1bDAuMDYsMC42M2wxLjQ2LDIuODVsMi45MywwLjg5bDMuMjMsMC41NGwxLjYsMC43OWw4LjU4LC0wLjA0bDIuMTUsMC43M2wxLjg5LDAuMTJsMS4xNSwtMC42MmwwLjY2LC0yLjBsMS4xNCwtMC4yOGwwLjg5LC0wLjY3bDAuNzIsLTEuMTNsMS40MSwtMC44MmwyLjMxLC0wLjY2bDEuMTQsMC4wMmwwLjQxLC0wLjRsMC4wLC00NS41MWwzLjU5LDIuNjhsMC45NSwxLjM5bDQuMiw5LjUxbDAuMjcsMi45bC0yLjIyLDMuNjJsMC4xNywzLjgybDAuNTUsMS4xNGwxLjEyLDAuNTNsMS40NSwtMC40N2wyLjM0LDAuNTNsNC40NSwtMC4yNGwyLjM5LDAuMjVsMS4yMiwtMC42OGwxLjAzLC0xLjU1bDIuMDMsLTAuNTJsMS4wNywtMC43NmwxLjU0LC0yLjQ1bDQuNDQsLTMuMjFsMC41OSwtMC45MWwyLjc3LC03LjYzbDAuNzgsLTEuMGwxLjA5LC0wLjY0bDIuMzIsLTAuNTRsMS4zMywwLjI4bDMuMTksMS43M2wyLjcxLDIuMTRsMC45OSwwLjM0bDIuNTEsMC4wOWwxLjcxLDEuMzdsNC44NywwLjkzbDEuNjcsLTAuMDhsMS40NCwtMC43MWwyLjQ3LDAuMDNsMi44OSwtMC42bDEuNzcsLTEuNTJsMy43NCwtMTAuNTZsNS42NCwtMS42NWwwLjc3LC0wLjVsMS44OCwtMi4yNWwyLjUzLC0xLjkxbDEuOSwtNi43OWwxLjA5LC0xLjQ4bDIuNjEsLTEuODRsMi4xNywtMC43bDAuNzYsLTAuNTRsMC44NCwtMS4yNGwxLjQyLC0wLjMybDAuMjksLTAuNzRsMS44MywtMS4zNWwwLjE0LC0wLjdsMy4wOSwtMy40NmwxLjksLTEuMTdsMy42NCwtMC43MWwxLjc0LC0wLjY5bDEuMzUsLTEuMTJsMC44MywtMS40NWwxLjE5LC0wLjdsNi4xMywtMC44MWwyLjcsMC40NWwzLjQzLDEuMzNsMy4yNywwLjQ3bDUuMjgsLTAuNDdsMS43OCwwLjJsMi4yMiwxLjBsMi44NCwxMC42NWwwLjE4LDIuNTdsMy4wMSw1LjE3bDIuMTQsNi45MWwtMC4wMiwxNC41MWwtMC43NSwxLjg4bDAuMjUsMi4wNWwtMC4zOCwwLjFsLTUuMzUsLTIuOTJsLTEuMDksMC4xMmwtMS43LDEuMjNsLTEuNCwxLjcybC0wLjY4LDEuNTNsLTIuNzMsNC4wNGwtMC4wNyw0LjczbDAuNDYsMC40N2wwLjY2LDAuMDdsMi4wNSwzLjg2bDIuNiwxLjcybDIuNDksMC43OGwzLjIsMC4xOGwyLjU2LC0wLjA1bDAuMzksLTAuNDNsLTAuMTQsLTEuNjNsMC41MiwtNC4xNmwzLjg3LDAuNjJsNS43NywtMC4xNWwtMC4zNiwyLjRsLTIuMjUsNi42NmwtMS40Myw3LjQ5bC0xLjg0LDMuNzJsLTEuMDEsMS41MWwtMi45NywyLjczbC0xLjQ4LDAuODZsLTEuNDksMC40M2wtNS4yMyw1LjY3bC0xLjk0LDIuNzJsLTEuNzQsNC4wbC0xLjcxLDIuMmwtNC43NCw4LjI2bC0yLjE0LDMuMjhsLTMuNjgsNC41bC0yLjc1LDEuOTFsLTIuOTYsMi42NWwtNy4zOCw4LjA4bC00LjczLDQuMjdsLTIuNzgsMS45MWwtNC4xLDMuNjlsLTUuODMsNC4wM2wtMy4zMiwyLjA5bC03LjQ1LDMuMDhsLTUuMDcsLTAuNjJsLTIuMjcsMC4zNGwtMS45OSwxLjU3bC0wLjI5LDIuMTZsLTAuNDQsMC4xOWwtNC41OCwtMC45N2wtMi4wOSwwLjE2bC0xLjM5LDEuMjVsLTAuODYsMS4zM2wtMi40NCwwLjA3bC00LjgzLC0xLjQ4bC01LjcyLC0wLjkxbC0xLjUsLTAuMDdsLTMuNiwxLjI0bC0zLjkyLC0wLjIzbC0yLjMsLTAuN2wtMi4xMywtMC4wbC0zLjg2LDAuODZsLTUuMjUsMy45M2wtMi42MywwLjBsLTIuNDIsMC40NmwtNC4yLC0wLjU0bC0xLjMyLDAuMjZsLTEuMzEsMC43MWwtMi45NCwwLjM0bC01Ljg5LDQuMjFsLTQuMjksLTAuNDFsLTIuNzYsLTEuODlsLTAuNjUsLTAuMDJsMC4wMiwtMS40bC0xLjA3LC0xLjEybC0xLjE3LC0wLjA0bC0wLjc4LC0wLjg3bC0yLjc4LDAuMTZsLTAuMjQsLTMuMDRsLTAuOTUsLTAuNjVsLTIuOTEsMC4xMWwtMC45NCwxLjJsLTAuMDYsMS4zOVpNNjIzLjU1LDgwNy41OGwtMS4zMywwLjU2bC01LjA4LDcuMjlsLTIuMzQsMS4wNGwtMC40NSwwLjM0bC0wLjIyLDAuNzZsMC45NywyLjUxbDIuNTgsNC4wMWwtMC4wMywxLjE3bDAuNDgsMC45NGwxLjMsMC43M2wzLjA4LDMuMDRsMy40NywwLjZsMS4xMSwtMC44OGwwLjU3LC0xLjgxbDIuNzcsLTMuNjhsMy45NywtMC41OGwyLjAxLC0wLjg1bDIuMzUsLTEuNTZsMC42NCwtMi45MmwxLjc3LC0xLjc2bDEuMTcsLTMuOTJsLTEuMDgsLTIuNDlsLTQuMTcsLTIuNzlsLTMuOSwtMy44NmwtMi4xNywwLjRsLTIuODEsMS4wOWwtMy4yNSwyLjIxbC0xLjQ0LDAuNDNaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiWkFcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk01OTIuOTQsNjcwLjVsLTAuMjMsMS4yNmwwLjcxLDEuNTlsMS4yMywxLjI4bDIuMDQsMy42MmwyLjM1LDIuNDhsMC42NSwxLjg1bDEuNDUsMS42N2wwLjExLDEuNjlsMi41Niw1LjU3bDYuMTEsNC40N2w1Ljg1LDIuNTRsMC43OCwxLjM4bDAuMjcsMi45NGwwLjQxLDAuMzhsNC40MSwwLjIzbDAuMTUsMi44N2wtMC4zNiwzLjg0bDIuMDksMi40OWwyLjAsMy41OWwwLjYzLDAuMzhsNS42NywwLjk1bDUuNTksMS43MWwtMC4yMiwxLjUybDAuNDIsMS4xN2wwLjg1LDAuNjZsMS41MywwLjJsMC42OCwwLjcxbC0xLjc4LDAuMTVsLTEuNTMsMC44NmwtMC45MSwxLjUzbC0xLjE0LDAuOTdsLTEuNjEsMC42NGwtMy43NywwLjc1bC0yLjAxLDEuMjRsLTIuMjQsMi4zMmwtMS4wOSwxLjRsLTAuMTIsMC42NWwtMS44LDEuMzFsLTAuMiwwLjYybC0xLjIyLDAuMTlsLTEuNjIsMS44MWwtMi4yLDAuNzFsLTIuNzcsMS45N2wtMS4yNywxLjc2bC0xLjc1LDYuNTNsLTIuNDksMS44OGwtMi40NSwyLjYxbC0zLjEsMC43MmwtMi43NywxLjFsLTMuODYsMTAuNzJsLTEuNDksMS4yM2wtMi41NCwwLjQ5bC0yLjUxLC0wLjAzbC0xLjYxLDAuNzVsLTEuMjksMC4wNGwtNC43NiwtMC45MmwtMS43OSwtMS4zOWwtMy4zLC0wLjM1bC0yLjYsLTIuMDdsLTMuMzYsLTEuODFsLTEuNTIsLTAuMzNsLTEuNTcsMC4yOGwtMS42MSwwLjVsLTEuNzcsMS43NmwtMy4yOSw4LjQ1bC00LjM4LDMuMTVsLTEuNTUsMi40NmwtMC44MiwwLjYxbC0xLjk5LDAuNTFsLTAuNjgsMC40N2wtMS4wNSwxLjYxbC03LjA4LDAuMDlsLTIuMzMsLTAuNTNsLTEuNTcsMC40N2wtMC44LC0xLjAzbC0wLjE3LC0zLjUxbDIuMjEsLTMuNTdsLTAuMjgsLTMuMzVsLTQuMjksLTkuNjlsLTEuMDksLTEuNTZsLTQuMTIsLTMuMDVsLTAuMDQsLTMzLjc3bDExLjI1LDAuMGwwLjM5LC0wLjMybDAuMDUsLTQ0LjY2bDExLjgyLC0xLjQ0bDE0LjA4LC0yLjRsMC43MSwwLjI2bDEuODIsMi4zN2wxLjM2LDIuNThsMC43LDAuMzZsMS4yNywtMC40NmwyLjQyLC0yLjQzbDMuOTQsLTIuNDJsMS4yMiwtMC41bDIuMjIsMC44MWwzLjAyLC0yLjI0bDEuMjcsLTAuNDlsMy40NSwtMC4zOVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJCV1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTIyMS4zMyw5OS4zNWw1LjU1LC0wLjE2bDYuNTYsLTEuNjJsMS45NCwtMS4zNmwxLjM5LC0xLjQzbDIuNDgsLTMuODJsMi4xLC0xLjA2bDUuMzMsLTEuODhsMy45NiwtMi43NmwzLjgsLTAuN2wwLjY2LC0wLjhsLTAuMDgsLTEuMTNsLTIuMzIsLTEuNTFsMC41LC0yLjA4bC0wLjY4LC0zLjIybDAuNjUsLTAuNjFsMy43NywtMC4xOGw1LjA0LC0xLjdsMC42LC0wLjc5bDAuNjIsLTIuMDRsMC41NCwtMC4yOWw0Ljc5LC0wLjcxbDEzLjc0LDAuNTNsMC43NCwtMC4yN2wwLjI1LC0wLjM3bC0wLjQxLC0yLjE0bDAuMTksLTAuNjRsMS45NSwtMS42MmwwLjExLC0wLjQ5bC0wLjY0LC0xLjIzbC0zLjkxLC0yLjk4bC0wLjY0LC0xLjFsLTAuNTIsLTIuNjNsLTEuNDQsLTMuMDRsMC41NCwtMy4xNmwtMC45NywtMi45M2wwLjI1LC0yLjc0bC0wLjE3LC0yLjQ1bC0wLjk1LC0yLjQ4bDAuNjQsLTEuNDFsLTEuMzIsLTEuODNsMC42LC0xLjkxbC00LjA3LC0zLjE2bC0wLjcyLC0xLjAxbDMuMDUsMC4wN2wyLjkzLC0xLjIxbDQuMTEsLTIuNTJsMi44NCwtMi43OWw3LjYyLC0zLjcxbDIuNzMsMC41N2wxLjg2LC0wLjI3bDEuMjMsLTEuMDJsMS4xNywtMi4xbDEuNzksLTEuMjZsNy42OCwtMy43NWwzLjI3LC0wLjk5bDEyLjY4LC0xLjIxbDIuOSwwLjEzbDQuNTUsLTIuNDdsNi4zNSwtMC4xNGwzLjExLC0xLjM2bDExLjMzLC0wLjBsMi42MywxLjEzbDIuNDQsMS44MWwxLjM5LDAuMzlsMS41OSwtMC4zOWwzLjQ5LC0xLjY1bDQuMDIsLTAuODlsMi4xNiwtMS4wbDEuMDEsLTEuNDdsMS40OCwtMC40M2wxLjA3LDEuMDVsNC4xMiwxLjEzbDMuODcsLTAuNjZsMC4yNywtMC40OGwtMC4yNiwtMS4wOGwyLjA0LDAuMzRsMS45NywwLjc3bDIuMTEsMS41OGwxLjU0LDAuMzlsMi43LC0wLjcybDQuOTIsLTAuMzRsMC4xNSwwLjc1bC0xLjYsMC44NWwtMS4wMSwxLjgybC0xLjU1LDEuMTJsLTAuNDQsMC43bDAuMjQsMC42NmwxLjAxLDAuNDlsMC4zOSwwLjg3bC0xLjE4LDcuNThsMC44NCwyLjA3bC0wLjAzLDMuMjJsMC44OCwyLjYzbC0wLjg3LDEuNDNsLTAuNDYsMS40OWwtMC4zNywzLjI1bC0xLjMzLDIuMDhsLTMuMjYsMS45N2wtMS4xNiwyLjE0bC0yLjc1LDIuMzFsLTAuMjUsMy41M2wyLjgsNy42NWwwLjQ4LDAuNTZsNC4wLDIuMjRsMS4xMSwxLjYxbDEuNTYsNS4xNGw4LjIsNS45OGw1LjQ4LDIzLjQ3bC0yLjIsMS4zM2wtMC4xMywwLjU1bDMuODUsNi4xMWwxLjkxLDUuOGwwLjQyLDIuNmwtMC4zMSw1LjJsMC41LDYuNTdsMC42NiwzLjIxbC0xLjk2LDUuOGwwLjU4LDMuNzFsMC40OSwxLjYzbDAuNjUsMC44N2wtMC4xMiwyLjU0bC0wLjIzLDAuODFsLTQuMzIsMi43OWwtMC42OCwxLjI1bC0wLjE3LDEuNDFsMC4zNiwxLjEybDYuNDQsOS4xNWwwLjMxLDMuNDdsMS4wNywzLjI1bDEuNzEsMi42NWwxLjg2LDEuNDJsMC42NywwLjA1bDIuNzgsLTAuODVsOS40NCwyLjg5bDUuMDcsOS4zOWwtNTIuMzEsMzIuMzhsLTE5LjMyLDE3LjAzbC0wLjk0LDAuNWwtMjguMjIsNS40MWwtMi4yMSwtMS41M2wxLjU3LC0yLjQ0bDAuMTYsLTAuNzZsLTAuNjQsLTEuODlsMC4wMiwtMi43M2wtMS4wLC0xLjA1bC0zLjI0LC0xLjM3bC01LjI2LC0xLjI2bC0xLjQxLC0xLjcxbC0wLjgyLC0wLjU0bC0zLjU1LC0wLjM2bC0xLjkzLC0wLjY3bC0wLjY4LC0wLjQ5bC0wLjg4LC0yLjE1bC0zLjg3LC0yLjAzbC0xLjI3LC0xLjA3bDAuMDgsLTEuOTNsLTAuNDksLTEuNzRsLTY2LjQyLC00NS43NmwtMTEuNzQsLTcuNzRsLTM2Ljk1LC0yMy4yOWwwLjE2LC0xNy42NmwxMS4zNSwtOC4wMWwyLjM0LC0wLjU1bDMuNzgsLTIuOGw1LjkzLDAuNmwwLjc1LC0wLjIybDAuOTcsLTEuMWwwLjI1LC0xLjg4WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkRaXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIiBjdXJzb3I9XCJwb2ludGVyXCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTcyNS45NCwyOTEuMzFsMS41OSwtMC41OGwxLjQzLC0wLjA4bDIuNywwLjQ4bDAuNjEsLTAuMzJsMC44MiwtMS4zOWwxLjAxLC0wLjQxbDAuOTYsMC44M2wxLjc3LDIuNTRsMS4xNiwwLjI1bDMuNzUsLTguMmwxLjAzLDEuMTJsMi40OCwwLjk5bDEuNzksMi4xbDAuOTIsMC42NGw0LjU2LC0wLjY1bDIuODYsLTEuNzRsMS41NCwxLjc4bDAuOTksMC4xbDIuOTgsLTAuNzdsMi41NSwwLjQzbDEuNzYsMC43bDIuNzcsLTAuMThsMC44NCwwLjI2bDMuNTEsMi40M2wyLjkyLDEuMGwxLjg1LDEuODJsMi4xOCwyLjk4bDIuODIsMi44Mmw0LjY4LDMuNzRsMi4xNywzLjU2bDIuMjEsMS40MmwyLjYzLDMuMzVsLTQuMzEsNi4zM2wtMi40NSwyLjgzbC0wLjM0LDMuMzRsMC40LDUuMTdsMC4yNywwLjM1bDIuMTEsMC40N2w3LjAsLTEuNjRsMC45OSwwLjAzbDEuNTEsMC44MWwxLjA2LDAuMTRsLTEuNTYsMS45bC0xLjIxLDEuOTZsLTAuMDcsMC42MWwxLjQ5LDIuNzNsMC42OSwyLjBsMi42OSwzLjMybDEuMzQsMC42NGwxLjM5LDMuMDlsMi4xNiwyLjc5bDEuNzUsMC42Mmw0Ljc2LDQuMTVsMzQuNjEsMTEuNjZsMTAuOTIsMC4wNGwtMTcuNTQsMTcuMGwtMTcuMzQsMTguNmwtMTAuOTMsLTAuNTJsLTQuODcsMS4xNGwtNS40OCwyLjUzbC0xLjM3LDEuMDRsLTEuNzgsMi43MWwtNy4yNSwxLjM5bC0yLjQsMC43NWwtMS43NSwxLjg2bC02LjQxLDAuNDFsLTEuOTQsLTAuMjFsLTMuMDQsLTIuNjFsLTEuNjUsLTEuMDNsLTEwLjg3LDQuOTdsLTIuMjcsMy4yOWwtMS42NiwxLjI5bC02LjA4LC0wLjc1bC00LjI3LC0wLjk0bC01Ljk3LC0wLjU1bC0xMy45LC04Ljk3bC0xMC4yOCwtMC42NGwtMi44NCwtMy43OGwtMC4wNywtMS41MWwwLjUxLC0yLjU0bC0wLjE3LC0xLjU3bC0wLjc3LC0wLjkybC0zLjI0LC0wLjg4bC0xLjc2LDAuNTlsLTAuMzQsLTAuMjZsLTAuMDUsLTEuMDZsLTIuMTYsLTIuMDlsLTEuMSwtMi4wOGwtMC4zMiwtMi4yNWwtMy4wLC03LjM2bC0xLjcsLTEuMzhsLTEuMDMsLTEuNDhsLTIuMzUsLTEuMmwtMi40MywtMi41M2wtMC41MSwtMS42NmwtMS40OSwtMS43OGwtMi44OCwtMS45NmwtNS4xNSwtMS4wNmwtMi4zNiwtMS4zbDMuMDUsLTUuOTJsNy43NSwtMC4wNmwxLjk3LC0xLjg0bC0wLjEyLC0xMS4xN2wwLjkxLC0zLjkzbDEuNzksLTQuMDJsLTAuMzksLTQuMDRsMS43MSwtMi44N2wxLjM3LC0wLjkybDIuNDQsMS41MmwwLjY2LC0wLjIybDEuNCwtMS4zbDAuNTMsLTMuNzFsLTAuMDgsLTEuNGwxLjcxLC02LjI0bDEuNjUsLTEuNjlsNC44MiwtNy44NGwxLjU4LC0wLjY0bDMuNjMsLTAuNjlsMC4zNywtMS4wNmwwLjI5LC0zLjQzbDAuNTksLTIuMDZsMi4xLC00LjI4bDAuNjYsLTIuNThsLTAuMDIsLTEuOGwwLjg1LC0yLjlaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiRVRcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02MzYuMjIsNDg4LjI2bDEuMjYsLTAuOTFsMS4xMSwtMC4zMWwzLjEyLC0zLjQ1bDAuMjMsLTAuODNsLTEuNDksLTMuNjhsMS4yOCwtMS42NGwyLjUzLC0xLjQ5bDIuNzIsLTAuNThsMC43MiwxLjQxbDEuNDUsLTAuMTdsMS40NCwtMS4wMWwyLjYsLTMuMDNsMC44LC0wLjQ0bDAuMywwLjAybDAuNDQsMS40NmwxLjUsMS45NGwxLjAsMC40NGwwLjUsMC42MWwwLjU0LDEuMTJsMC4wNyw0LjY3bDAuNTQsMC45OWwwLjEyLDEuMDJsLTAuNywyLjIybC0yLjY2LDAuNGwtMS44MiwtMS4wMWwtMi4xNiwwLjQ0bC0xLjE0LDAuNzZsLTEuNDksLTAuODdsLTAuNzQsLTAuMDNsLTAuMzgsMC4zN2wtMC42NCw0LjE3bC0xLjc0LDAuOGwtMy40NywwLjE3bC0wLjk5LC0xLjU0bC0yLjM3LC0wLjk0bC0wLjkxLDAuMjdsLTAuNSwxLjAzbC0wLjc0LC0wLjU3bC0wLjMyLC0xLjgyWlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIlJXXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNjQ0Ljk3LDUxNi41OGwwLjM0LC00LjYxbDAuNzMsLTAuMDdsMi43NSwtMS44bDIuMzQsLTIuNjFsMS40NCwtMi43N2wxLjMyLC0xLjQ1bDAuNTQsLTEuNjVsMi4zMiwtMS45MWwwLjAxLC0wLjg5bDEuNzMsLTAuNzRsMC41MSwtMS4xNGwtMC40LC0yLjgzbC0zLjM1LC0wLjk4bC0wLjcxLC0wLjMzbC0wLjA3LC0wLjM1bDAuNTQsLTEuNGwtMC40NywtMC43N2wxLjE1LC0yLjMxbDIuODUsLTAuNTdsMC41MSwtMC4zNmwwLjcxLC0yLjU0bC0wLjE0LC0xLjI4bC0wLjU0LC0wLjk4bC0wLjExLC00Ljc5bC0xLjI1LC0yLjAzbC0wLjk5LC0wLjQybC0xLjM2LC0xLjc1bC0wLjM0LC0wLjk5bDIuMDMsLTAuMjVsMS40OSwtMC42NGwxMS45NSwwLjI0bC0wLjQsMy41NWwtMC43MywxLjU1bC0xLjE3LDUuMjVsMC4xMyw0LjA1bDEuMjYsMi4wMWwtMC41NCwxLjAzbDAuMTgsMC42MmwwLjYyLDAuNTVsLTAuMjcsMC42OWwwLjI2LDEuMjlsMC40MiwwLjNsMC41MywtMC4yNWwwLjI3LC0wLjg1bDAuNDEsLTAuMTdsMC4zOSwwLjU3bDAuNjYsMC4yM2wwLjQ0LC0wLjUxbC0wLjI0LC0yLjFsMS43OSwtMC4xNmwwLjE4LC0wLjQ0bC0wLjUxLC0xLjI5bDEuNTcsLTEuMDZsMC43MiwxLjIybDEuMDYsMC42NWwwLjg5LDAuMTJsMC4yNiwwLjUzbDAuNTMsMC4wNWwwLjg5LC0wLjY1bDAuNDcsMC41OWwxLjIyLDAuMjFsLTAuMDcsMS4zMWwwLjUsMS4xNWwtMC45NywwLjk3bC0wLjE5LDEuNjJsMC42MiwwLjRsMS41MiwtMS40bDAuNzEsLTAuMTNsMC4yOCwtMC41N2wtMC44NywtMi4wNmwwLjA5LC0xLjk1bDAuNDIsLTAuNDlsMS4xMSwtMC4wOWwxLjcyLDAuOTNsMi42NSwwLjQ3bDAuNDksLTAuMzhsMC4wMiwtMC41OGw0LjI1LC0zLjEybC0wLjEsLTEuMjRsLTAuNzQsLTAuMzZsLTIuMTMsMC42NGwtMy41OSwtMC41OGwxLjc4LC0wLjYxbDEuMTYsLTAuMDFsMC4zOSwtMC40OGwtMC43NywtMS4wOWwtMS41NiwtMC4xNGwwLjU4LC0wLjQ1bDEuMDksMC4wOGwxLjMzLC0wLjc4bDAuMjIsLTAuOTFsMC44OCwtMC45M2wtMC4yOSwtMC43NWwwLjIyLC0wLjU1bDIuNTUsMC4zM2wwLjMzLC0wLjczbC0xLjA4LC0wLjkxbDAuMDgsLTAuMzhsMS4yOCwtMC4yNGwwLjA0LC0wLjY5bC0wLjQ0LC0wLjUxbDEuNDcsLTEuOTZsNDEuNzEsMjMuM2wwLjQsMi4wN2wtMC45MSwyLjM4bDAuMDksMC44M2wxLjIzLDAuNTRsMS4wNCwxLjU5bDE2LjQ4LDExLjg2bC0yLjc2LDkuMzNsLTAuNzksMS4yOWwtMS4wOCwyLjk2bC0wLjE5LDIuMzdsMC45MSwzLjM3bDEuMjYsMS40NmwxLjY5LDEuMTlsMS4xNiwxLjQ2bDAuNjcsMS40OGwyLjI1LDAuOTFsMC43MiwxLjQzbC0wLjI1LDAuOTNsLTAuOTksMC45OGwtMC45NCwxLjU4bC0wLjgxLDIuMjhsLTAuMDIsMy4xOGwwLjY4LDAuMjlsMC4yOCwtMC4yNmwwLjcyLDAuNDlsMC4xMywyLjA1bC0xLjE2LDIuNjlsLTAuNDIsMi41OGwwLjg2LDMuMjdsMS4yNiwxLjY3bC0wLjMzLDEuMWwyLjE0LDIuODNsLTAuMTQsMi42bDEuNzMsNS4wMWwwLjA4LDAuNzFsLTAuNiwwLjlsMC4yNywwLjYybDEuNTEsMC4yNGwxLjIzLDEuNDVsMS4zOCwwLjE3bDMuNDUsMi4yM2wwLjY0LDAuOWwtNS4yOCw0LjAxbC0xLjk2LDEuMDZsLTIuOTgsMC43OWwtMi44NSwxLjcxbC0xLjY0LDAuNDlsLTIuMjIsMC4wMmwtMi4yNiwwLjczbC0zLjQ0LDIuMWwtMS44NiwtMS4wOWwtMS43NCwtMC40M2wtMy4zMSwwLjI0bC0wLjU1LDAuNDNsLTAuNjYsMS45M2wtMS4xLDEuMDVsLTIuMDUsMS4wN2wtMS44NSwwLjM5bC0xLjcsLTAuMjdsLTIuOTMsLTEuNDNsLTEuMzgsMC4wOGwtMi4zNiwxLjM0bC0xLjY4LDAuMzVsLTIuNCwtMC4xMWwtMS4wOCwtMC4zNGwtMC4yNywtMC43M2wtMS4wOSwtMC44NmwtMi4yNSwtMS4wN2wtMS43NiwwLjFsLTAuOTIsMC45MmwtMS40NiwwLjc1bC02LjcsLTAuM2wtMC44LC0yLjAxbC0wLjcyLC0wLjY3bC0wLjc4LC0wLjE0bC0xLjc4LC0yLjg1bDAuNzEsLTMuMTlsLTAuMDYsLTEuMDdsLTAuOSwtMi4yM2wtMC4xOCwtMy4zNmwtMC41OSwtMi42NWwtMi40NywtMy42NGwtMi43MiwtMi4yOWwtMS4xOCwtMC41NmwtMC40NiwwLjA5bC0wLjYyLDAuOTZsMC4wNiwwLjk5bC0yLjU3LC0wLjg2bC0zLjEyLDAuMTVsLTEuMTksLTEuMDhsLTIuMjksLTAuMjhsLTEuNzQsLTEuMTNsLTAuODUsMC4wNGwtNC44NCwtMi4xOWwtMC44LC0wLjczbC0yLjQ0LC0wLjM2bC0xLjE3LC0wLjYzbC0xLjk3LC0wLjJsLTAuMzEsLTEuMjlsLTEuMjgsLTAuNTJsLTEuNjQsMC4wOWwtMS4xOCwtMS4wNWwtMC4zOSwtMS4yMmwtMS4wLC0wLjdsLTEuMzksLTAuNjNsLTEuNjcsMC4wM2wtMC40MiwtMS42OWwtMi4wNywtMi40OWwtMC4wNiwtMS4zMWwtMi43NSwtNS4wMmwtMS40LC0xLjg1bC0wLjA1LC0xLjlsLTAuOTYsLTIuNzRsMC40OCwtMC42NmwwLjA2LC0xLjAxbC0wLjQ2LC0xLjAybC0wLjkxLC0wLjg4bC0xLjgxLC0yLjhsLTEuNjcsLTEuNjdsLTEuMTMsLTAuMzVsLTEuMzksMC40MmwtMi41MSwtMi42NmwwLjI3LC0yLjE5bDEuODQsLTAuOTZsMC41OCwtMS4yMWwtMS4wNSwtMi45M2wtMS4yMiwtMS45MWwwLjY5LC0zLjU3bC0wLjMsLTEuMzlsLTAuNjYsLTAuODhsLTEuNDMsLTAuODhaTTc2Mi43OCw1NTIuNjlsLTAuNDUsLTAuMDNsMi4xOCwtMS45NWwtMC40NiwxLjA4bC0wLjc3LDAuMjRsLTAuNTEsMC42NlpNNzY0LjQ3LDUxNy40N2wtMC4xOCwzLjQxbC0wLjk0LDEuODRsLTAuNjYsLTAuNTFsMC42LC0yLjgzbC0wLjI0LC0xLjc5bDEuNDIsLTAuMTNaTTc2MC4xNSw1MzIuMDFsMC44MywyLjMxbC0wLjQzLDAuMzRsLTAuNTIsLTAuOTVsLTAuNzQsLTAuMTZsLTAuOTIsLTAuOTNsLTAuNiwtMC4wNGwtMC41MiwtMC44OGwwLjI1LC0xLjAzbC0wLjE1LC0xLjYxbDEuMDUsLTEuNThsMC4yMywxLjgybDAuNzYsMS45M2wwLjc3LDAuNzdaTTY4My41OCw0ODIuNTVsMC4zOCwwLjI4bDEuMjQsLTAuMDZsMC43OSwxLjQzbC0zLjA1LC0xLjBsLTAuMTQsLTEuMDNsMC42LC0wLjE3bDAuMTgsMC41NVpNNjcwLjUsNDg1LjY4bDAuNjQsMC43bDEuNzEsLTAuM2wtMC4wMywwLjM2bC0xLjI3LDAuMjdsLTAuNDEsMC42MmwtMC43LC0wLjk4bDAuMDYsLTAuNjhaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiVFpcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk00MTAuMDcsNDQ2LjY0bC0xLjA3LC0wLjc3bC0xLjE4LC0wLjIybDEuMTEsLTMuMGwxLjY2LC0xLjYzbDAuOTksLTIuNTVsMS4wMiwtMS42bC0wLjExLC0zLjQ5bDEuOCwwLjg1bDE1LjQyLDAuMGwwLjA3LDEyLjlsLTE0LjkyLC0wLjA1bC0xLjM2LDAuNWwtMS4wMiwtMC4zOWwtMC43MywtMC45NGwtMS4xLDAuMDFsLTAuNTksMC4zNlpNMzk5Ljc0LDQxNS41OWwxLjgxLC0wLjAxbDAuMjYsMC4zNGwtMC4wNCwwLjY2bC0xLjc0LDIuNThsLTAuMzcsMS4xN2wtMC41NiwwLjc2bC0wLjM2LDAuMDVsLTEuOTEsLTAuNTFsLTAuMjcsLTAuNDVsMC4yMiwtMS4wMmwxLjQxLC0wLjU2bDAuNzMsLTIuMjJsMC44MSwtMC43OFpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJHUVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTQ2Ni43NCw3MzMuMDdsMC4zOCwwLjE0bDAuNTMsLTAuM2wwLjI5LC0xLjQ5bDAuMDYsLTEuMzhsLTAuNzgsLTMuMjJsLTEuNjksLTMuMjZsLTQuMDYsLTUuMTdsLTEuNTgsLTMuNjJsLTQuNTQsLTYuNzlsLTMuMjksLTguODlsLTEuNTIsLTIuMGwtNi44MywtMTMuMzhsLTEuNiwtMi4yNGwtMy4zLC0zLjMxbC0xLjA2LC0yLjQ0bC0yLjAxLC0zLjE5bC0wLjQ4LC0yLjkzbDAuMDgsLTUuNjdsMS41NiwtMC4yM2wxLjM2LC0wLjdsMC45OSwtMC4wNGwxLjIzLDAuNTRsMy45MywwLjAzbDYuNTYsLTIuOTVsNC4wOSwwLjc5bDEuMDIsMS4yMmwxLjU2LDEuMTFsMi45NywxLjkzbDAuOTksMC4yNmw0LjczLC0wLjI1bDQ2LjY1LDAuMTRsMC44MiwwLjQybDIuNzksMy4ybDIuODcsMS4yNWw1LjAxLDAuMjhsMy4xMSwwLjUzbDYuNTIsLTAuMDZsMi4yMSwwLjI3bDIuNzEsMS4zMWwxLjU5LDAuM2w0LjMyLC0wLjc3bDEuOTEsMC4wOGwxLjY4LDAuNDVsMzMuNDcsLTYuMjhsNy41OSwwLjc0bDEuNzEsMS4wMWwxLjIyLDEuMmwtMy4xNSwwLjM2bC0xLjQ3LDAuNTVsLTIuOTgsMi4xOWwtMS44OCwtMC44M2wtMS41OCwwLjU3bC0yLjkyLDEuNjNsLTMuNTQsMy4yN2wtMC44NiwwLjMzbC0xLjM5LC0yLjU2bC0xLjkxLC0yLjVsLTEuMjgsLTAuNDlsLTE0LjIsMi40MWwtOS4xMSwxLjMxbC0zLjAxLDAuMTRsLTAuMzgsMC40bDAuMDQsNDQuNTVsLTExLjMzLDAuMGwtMC40LDAuNGwwLjA0LDgwLjI0bC0zLjMzLDAuNjlsLTEuNjQsMC45NGwtMC43NywxLjE4bC0wLjc2LDAuNTdsLTEuMjQsMC4zNWwtMC40OSwwLjU3bDAuMDIsMS4wN2wtMC4yOSwwLjQ2bC0wLjc4LDAuMzhsLTEuNDMsLTAuMTJsLTIuMjUsLTAuNzVsLTIuOCwtMC4xOGwtMy40MywwLjM5bC0yLjMyLC0wLjE4bC0xLjQ5LC0wLjc2bC02LjAsLTEuMzlsLTEuMDksLTIuMzJsMC40NiwtMS43bC0wLjMzLC0xLjIxbC0wLjY2LC0wLjY5bC0xLjE3LC0wLjMxbC0wLjY4LC0xLjQ5bC0xLjIxLC0wLjc2bC0xLjc4LDAuNDVsLTAuODUsMC44NWwtMS40Miw0LjEzbC0xLjQzLDAuMzhsLTEuOTQsMS40M2wtNi4xOSwtNS42NWwtMS45NiwtMi4zMWwtNS4wMSwtOC42NGwtMS44LC02LjExbC0wLjA5LC0xLjMzbDAuNDUsLTEuMDRsLTAuMjgsLTEuMTZsLTAuNjIsLTEuMjRsLTEuMzksLTEuMjVsLTAuNDEsLTQuMzZsLTEuMCwtMi45M2wwLjIxLC0yLjMybC0wLjUzLC0zLjYybDAuMiwtMi43N2wtMC44MSwtMy4wNmwtMS42NiwtMy4wNWwtMS40NiwtNC4yM2wtMC4zMiwtMTEuMzNsLTAuODEsLTMuODRsMC4xNSwtMC4zOVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJOQVwiIGZpbGw9XCIjMDMzOTZjXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTMyMS44MSwzMTMuNjZsMS41MywtMC40bDAuNCwtMC44OWwtMC4yMiwtMS4xbC0xLjQ1LC0yLjEybC0xLjk1LC0wLjFsLTEuOTQsMS4xMWwtMi40NSwtMC4yNGwtNS4zOSwtNC4yOWwtMS4xNSwtMC4zOGwtMC4wOSwtMy4xNmwxLjgyLDAuMzNsMC42OCwtMC40NGwtMC4wNCwtMC42MWwtMi4wOCwtMS4yOWwtMC41LC0xLjBsLTEuMCwtMC43NWwtMy4yNSwtMS4xMWwtMi4xMiwtMy4wN2wtMC44LC0xLjhsMC4yNCwtMS40OWwtMi40OCwtMi45MWwwLjY4LC01LjE1bDUuNDUsMC4xOWwyLjc4LC0wLjM1bDQuMTUsLTMuNDZsMTkuODEsLTAuODJsMC42NiwtMS4wM2w1LjE2LDAuODRsMC40NiwtMC4zNWwwLjE3LC0xLjM3bDIuMDQsLTEuNzVsMS42NiwtMC44MWwxLjMxLC0zLjA5bDAuNzksLTIuOTRsMS4yNiwtMi4wNGwwLjczLC0yLjc5bDAuMjMsLTQuNDRsMC4zOCwtMC41N2wtMC4wOCwtMjUuNjdsMTcuNTEsLTMuNDhsMS4xNCwtMC41OWwxOS4zNSwtMTcuMDVsNTIuNDUsLTMyLjQ3bDE3LjU0LDQuMTNsMS4yOSwwLjdsNy4zNSw2LjIzbDAuNDgsLTAuMDJsOC4yOSwtNC40MWwyLjE2LDEyLjY3bDAuMTcsNS4wN2wxLjM2LDEuNDVsMy40OCw1LjNsLTAuNjcsMS4xMmwwLjU1LDEuNzNsNC4zNiw0LjY2bC0yLjY0LDUuMzFsLTMuMDUsMzYuMmwtMTIuOTIsMTMuODlsLTYuNTgsOS40MWwtMS45NSw0LjA0bC0yLjI0LDIuOTRsMS42Niw3Ljk1bC0yLjkzLDAuNDFsLTEuNTksMS4xOWwtMy43NywxLjQ5bC0yLjY0LDEuNTNsLTEuNywxLjU4bC0wLjU1LDEuMTNsLTMuNjIsMC4wMmwtMS41MiwtMS4ybC0zLjUzLC0xLjI4bC0zLjMzLC0wLjY3bC01LjQxLC0wLjIybC01LjY3LDAuNDlsLTMuNDgsMC43M2wtMS43NSwwLjgxbC0xLjQ0LDAuOTFsLTMuNTUsMy43NGwtNC42NiwtMC4xMmwtNS4xOCwtMS4wMWwtMy40LC0xLjc4bC00LjIyLC0yLjc1bC0zLjI2LC0wLjY1bC0wLjc0LDAuMDhsLTQuOTUsMi43bC0yLjE4LDAuMjdsLTEuMzksMS4wMmwtMS4xNCwtMC4wOWwtMS4zOCwtMS4wNmwtMi41NCwtMy42MmwtMy40NywtMy4wNGwtMS41NCwtMC4xM2wtOC4yMiwtMi40OGwtMS42MSwwLjQ1bC0xLjM5LDAuOTNsLTQuODQsLTAuMDRsLTMuMTQsMC43bC0xLjc2LDAuNzJsLTIuMDUsMS43MWwtMS4xMSwwLjUybC0wLjksNS4wNGwtMC41NCwxLjM3bC0xLjAyLDEuODJsLTMuNjIsMy4xN2wtMC4wOCw2LjZsLTAuMzMsMS4xbDAuNTksMS40NmwtMC4yNywwLjIzbC0xLjU3LC0xLjYybC0xLjcsLTAuODRsLTEuNzgsLTIuMjhsLTMuMzksLTMuMDlsLTEuMDksLTAuMTdsLTEuNzksMS4wMWwtMy4zNiwwLjkybC0wLjI4LDAuNzRsMC40OCwyLjY3bC0zLjIyLC00LjZaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTkVcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0zMzguODksMzgzLjZsMi41NCwtMS4zbC0wLjAzLC0wLjczbC0wLjY4LC0wLjE4bC0zLjI4LDAuODRsLTEuMjgsMS41MWwtNi43NiwwLjI4bDAuNzYsLTMuNDRsLTAuNTgsLTMuMjFsMC40LC0xLjA3bC0wLjA3LC0zLjgzbDAuNDEsLTEuMDVsLTAuNzcsLTEuNzRsLTAuMzgsLTMuMDNsMC41NCwtMTAuNjNsMC40NCwtMi44MWwzLjE2LC0wLjU3bDAuODEsLTEuMzRsMC40NCwtMS41N2wtMC4xMSwtMS41NmwyLjEzLC0yLjM2bDAuMDgsLTEuNDdsMi41NCwtMS4zNGwwLjY2LC0xLjMxbDAuNTQsLTEuOWwtMC43OSwtMS41bDAuMjcsLTAuNjdsMC42MSwtMC42OWwwLjk5LDAuMTNsMC41NCwtMC41NGwwLjYxLC0yLjE5bC0wLjkyLC0yLjAxbC0wLjQ2LC0zLjYxbC0yLjY3LC0zLjhsMC4wMywtMS4wMmwwLjcsLTEuNDhsMS4zMiwtMS42MWwtMC41OSwtMS42MWwwLjMzLC0xLjA0bDAuMDcsLTYuNDNsMy40LC0yLjgybDEuMTUsLTIuMDFsMC42MiwtMS41OGwwLjY4LC00LjYxbDEuMCwtMC40NmwyLjA1LC0xLjcxbDQuNTIsLTEuMjlsNC45NCwwLjAybDEuNTUsLTEuMGwxLjMxLC0wLjM3bDguMDMsMi40N2wxLjMsMC4wNGwzLjI3LDIuODhsMi41MywzLjYybDEuNzcsMS4yOWwxLjUxLDAuMWwxLjUyLC0xLjA2bDIuMTcsLTAuMjZsNS4zNCwtMi43NGwyLjk2LDAuNTdsNC4xOCwyLjcybDMuNTgsMS44Nmw1LjMzLDEuMDRsNC45MSwwLjEzbDMuOTQsLTMuOTZsMS4yOSwtMC44MWwxLjU4LC0wLjc0bDMuMzQsLTAuN2w1LjYyLC0wLjQ5bDUuMjcsMC4yMWwzLjIzLDAuNjVsMy4zOSwxLjIzbDEuNjcsMS4yNWwyLjM2LDAuMmwxLjc4LC0wLjI0bDAuODMsLTEuMzZsMS42LC0xLjQ5bDIuNTEsLTEuNDRsMy44MywtMS41MWwxLjQ3LC0xLjEybDIuOTIsLTAuMzZsNS4yLDcuMjNsMS41NSw4LjE5bDEuMTQsMC42MmwxLjcxLDAuMTZsMS4wNiwwLjQ4bDEuMDUsMS41NmwtMC4yNywzLjU5bC0wLjQyLDEuMzVsMC4wNCwyLjVsLTQuMDQsMi41NWwtMi42NywwLjcybC0xLjEyLDAuOTNsLTIuMjcsMy4xOWwtMS45OCwzLjI5bC0xLjM4LDUuMDJsLTEuNzMsMS43MmwtMC44MSw1LjQ5bC0xLjk3LDAuNzdsLTEuMTksMC45bC0wLjY2LDEuNTVsLTAuODEsNC44OWwtMC44LDEuNWwtMS41OCwxLjMxbC0yLjMxLDAuNTNsLTEuOTksMy42OWwtMC45Myw0LjA1bC0xLjU2LDIuNjVsLTAuMTEsMS41MmwtMi44NiwzLjdsMC45NywxLjkxbC0zLjE4LDIuNjNsLTAuNTcsMi43bC0yLjI1LDEuODhsLTEuNzcsMC41bC0wLjU0LC0wLjUzbC0wLjg2LC0yLjhsLTMuMjUsLTMuMDJsLTEuNjIsLTAuOTRsLTAuOCwwLjEybC0wLjc3LDEuNThsLTAuOTMsMC40M2wtMi4yLC0wLjE0bC0wLjU5LC0xLjA4bC0wLjU3LC0wLjExbC00LjIzLDIuNzZsLTEuNTEsMi43NmwtMy4zLDIuNDZsLTMuNzYsMy43NGwtMS41MywyLjgybC0xLjU2LDYuODFsLTIuOCw1LjBsLTAuMzIsMC4yNWwtMC41NywtMC4xNWwtMC4zNiwtMC42NGwtMC43NCwtMC4zbC0wLjk2LC0xLjA3bC0wLjc4LDAuMTZsLTAuMTEsMC40NGwxLjA1LDIuODJsLTAuMjcsMC43NmwtNy4yNCwwLjM4bC0wLjY5LC0wLjMybC0wLjM1LC0wLjk1bC0wLjYxLC0wLjE4bC0wLjc0LDEuMWwtMS43NywwLjA4bC0xLjQ4LC0xLjQ2bC0wLjkyLC0wLjQ4bC0wLjU1LDAuNDlsMC45OSwxLjIxbC0wLjA4LDAuODNsLTEuNDMsMS4xOWwtMC43NiwwLjA2bC0wLjQ1LC0wLjQxbC0wLjkyLC0zLjI3bC0wLjYsLTAuMjNsLTAuMzksMC41bDAuMjksMi45MWwwLjU0LDAuODlsLTEuNzYsMC4yMWwtMC42LC0xLjQ4bC0wLjY3LDAuMjFsLTAuMjUsMS4zMWwtMi42OCwwLjM4bDAuMSwtMS4xM2wtMC42NSwtMC4yOGwtMC44LDAuODJsLTAuMDgsMC44N2wtMS4wMywtMC4xbC0zLjEzLC0xLjg3bC0yLjM4LC0yLjE2bC0xLjA5LC0yLjJsLTEuMSwtMi44N2wwLjgzLC0wLjRsLTAuMjEsLTAuNjVsLTAuOTQsLTAuMjZsLTAuMDIsLTEuMjRsMS41MSwtMC41NGwwLjYxLC0xLjJsLTAuNTQsLTAuNTFsLTEuNzQsMC43N2wtMS43NSwtMS4xNWwyLjAzLC0wLjFsMC43NCwtMC40NGwtMC4wOCwtMC43MmwtMS4yMSwtMC4xNmwtMC4wMywtMC41N2wtMC42MSwtMC4zNmwtMC42NywwLjhsLTAuODksMC4zM2wtMC4zNywtMC4yNGwtMC4yMywtMS4zOGwtMi43OSwtMy4xN2wtNS4xNCwtMy44OGwtMy44LC0wLjhsLTYuNzQsMC4wM1pNMzgyLjU2LDQwNy4xbC0wLjg3LDAuMjhsLTAuMDIsLTAuMGwwLjQ1LC0wLjY4bDAuNDQsMC40MVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJOR1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTM5My45NSwxMS4xNmwxLjY5LC0xLjI4bDAuOTQsLTEuNzVsMS43NCwtMC45NGwwLjAzLC0xLjQ3bDIuNjMsLTAuNzdsMy42NSwtMi42MWw2LjI4LC0xLjkzbDEuMjIsMC4yN2wtMC40NywxLjI1bDAuNTQsMS4wM2wwLjYsMC4xMmwwLjc4LC0wLjYzbC0wLjA2LC0wLjkxbDEuOTUsMC4wNWwwLjk3LDAuNDdsLTAuMDgsMi4wNmwxLjY1LDIuMzRsLTAuMzksMC45MmwwLjIsMC41MmwxLjQsMC42N2wxLjYzLC0wLjgzbDAuNjgsLTEuMTlsMi4yNiwtMC43MWwyLjA5LC0xLjY3bDAuNzIsLTAuMTFsMC42NSwyLjA1bC0xLjY2LDEuNjlsLTEuOTYsMy4zMWwtMS43MywwLjkzbC0xLjQ1LDEuMzVsLTAuNywyLjIzbDAuMzgsMi4xNGwxLjA3LDIuMDRsMS4xNSwxLjE3bDEuMjEsMC40NWwyLjM2LDEuNjlsMC40NywzLjgybDAuODEsMS4yM2wtNC44NCw3LjE5bC0xLjc4LDEuNzJsLTQuOSwzLjUybC0xLjA1LDIuMThsMC4xNCwxLjI0bDEuMjksMi43MmwxLjgsMS43MmwyLjA3LDAuOTdsMi41NCwtMC4yOWwwLjE3LDEuOTFsMC40MSwwLjMzbDIuMTMsLTAuMjZsMC43NiwtMS4wNmwxLjAsMC41NmwwLjcyLDIuMzlsMS4xMywwLjgzbC0wLjM5LDAuMzJsMC4wNywwLjY2bDMuMzIsMC43OGwtMC41MSwzLjQ0bC0wLjA2LDMuMzdsMC45NiwyLjEzbC0wLjI2LDAuNTdsLTcuODUsNC4yOGwtMC43MSwwLjgxbC0xLjg3LDEuMTdsLTEuNTQsMi40OGwtMS44NiwwLjM4bC0wLjYxLDAuNDJsLTEuMzgsMS44NmwtMC41NiwxLjM0bDEuNSw1LjU3bDAuMTQsMS45OWwtMC40MiwwLjk0bC0zLjY3LDQuOThsLTMuODgsMS43N2wtNS41MSwtMjMuNDhsLTguMywtNi4xNGwtMC4zMywtMS45MWwtMS4wOSwtMy4wMWwtMS4yLC0xLjc3bC00LjQzLC0yLjc0bC0yLjY4LC03LjNsMC4xNCwtMy4wNGwyLjYxLC0yLjE1bDEuMTIsLTIuMDlsMy4yOCwtMi4wbDAuOTMsLTEuMjJsMC42NywtMS4zMmwwLjc1LC00LjUybDAuOTQsLTEuNTRsLTAuODUsLTIuOTJsMC4wMSwtMy4zNWwtMC44MywtMS45OWwxLjE4LC03LjYxbC0wLjYsLTEuMzFsLTEuMCwtMC41M1pNNDI5LjA4LDM0LjQxbDAuMDUsLTAuMDRsLTAuMCwwLjAybC0wLjA1LDAuMDJaTTQyNS41OSw0Ny44OWwtMC45NCwwLjQybC0xLjIzLC0wLjQ3bDAuMTUsLTEuMzhsMS42NCwtMC4wNWwxLjA1LDAuOWwtMC42NiwwLjU4WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIlROXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNMTgyLjQ0LDM1OS40NmwwLjIzLDAuNThsMC40NywwLjI0bDAuNDgsLTAuMjdsMS41NiwxLjMybDAuODYsNS4wOWwwLjksMi4zOGwtMC4xNiwxLjM4bC0wLjksMS41OWwwLjE0LDAuNzJsMi4zNSwwLjQ2bDEuOTgsMS45NWwxLjg4LC0wLjYybDAuNzEsMC4wN2wyLjA2LC0yLjg2bDAuNDEsLTEuOTRsMC44NiwtMC4xOGwwLjIzLDAuNmwxLjQxLDEuMmwxLjYsNS4wNmwtMC40LDMuMDFsLTMuMDcsMy4zMmwtMC4wMiwwLjU1bDAuODgsMC41NmwxLjA4LDAuMTNsMS45MiwxLjY0bDEuMDksMC4zNWwyLjUsMC4wNGwwLjksMC41bDEuMTQsMy4wOGwwLjk5LDAuNzVsMi45NCwwLjg3bDAuNTcsMy4wNWwtMC4zMywwLjg3bC0wLjAxLDEuNjlsLTAuNTksMC45NGwtMC4xNiwxLjI0bC0wLjg5LDAuOGwtMC4yNiwzLjAybDAuMjMsNS4wNWwtNy41MSwtMi42OGwtMTAuMTgsLTUuNDNsLTIuOCwtMi4xNmwtMTAuNTcsLTkuODRsLTEuNzIsLTEuMWwtMi4xOSwtMC41NmwtMi4wMiwtMS4wNWwtMC44NiwtMS45bC01LjE2LC0yLjYybC0yLjE4LC0yLjIxbDIuNTEsLTMuNTlsMi4xMiwtMS45NGwyLjQ2LC0xLjY3bDIuNiwtMi41M2wxLjA3LC0zLjgzbDIuNCwtMS4zMWwwLjk4LC0zLjQybDEuNTMsLTAuMjhsMC4yOCwwLjY4bDAuNTEsMC4yNWwzLjEyLC0xLjFaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTFJcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02MzQuMTYsODIyLjg1bC00LjE5LDAuNjhsLTIuOTksMy45MWwtMC4yLDEuMTFsLTAuNjksMS4xNGwtMy4xNiwtMC40M2wtMi45MSwtMi45MWwtMS4yNSwtMC42OGwtMC4zMywtMC42NWwtMC4wMiwtMS4zMWwtMi42LC00LjAzbC0wLjg1LC0yLjM2bDIuNzEsLTEuMzFsNS4xNCwtNy4zNGwyLjQ4LC0wLjhsMy4yNiwtMi4yMWw0LjM4LC0xLjQ1bDMuNjcsMy43bDQuMDIsMi42N2wwLjk0LDIuMDJsLTEuMDgsMy41NWwtMS44MiwxLjg1bC0wLjQ5LDIuNjVsLTIuMTIsMS40bC0xLjg4LDAuOFpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJMU1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTYxOS41Miw2NjcuMzJsMS41MiwtMS4xM2wxLjQyLC0yLjgzbDEuNiwtMC43NWwxLjE4LC0xLjEzbDAuODUsMC4yNWwwLjc5LC0wLjM5bDAuMzYsLTAuNzdsLTAuMTksLTAuNjFsMC41MywtMC45N2wyLjEsLTAuNTdsMS4zMywwLjkybDAuODQsLTEuMzVsMS41LC0wLjYybDAuMjEsMC43N2wwLjQ4LDAuMzdsMC43NiwwLjA4bDAuNzYsLTAuNDRsMC41NSwtMS4wM2wwLjg0LC0wLjE3bDAuNTIsLTAuNzZsLTAuMDIsLTAuNjVsLTAuNDgsLTAuMzhsLTEuODEsLTAuNDFsMC42NSwtMS4wNGwwLjI5LC0zLjQ0bDAuNTQsLTEuNmw0LjI5LC0yLjQ4bDIuMjksLTAuOTRsMi43NywtMC42MWw3LjM4LC0wLjAybDAuMTUsMy42NWwwLjUyLDAuNTJsOS40NCwwLjRsMi45NSwxLjg1bDIuMywwLjQybDIuODgsMi41MWwzLjc0LDAuMzNsNC40NywxLjY1bDEuMzQsMS4xbDIuMDgsMC4zNmwtMC43OSwxLjc2bDAuMTIsMS45OGwwLjk3LDIuNTJsLTAuMTcsOS45N2wwLjQ0LDMuMjdsLTEuMjMsNC4zNmwtMS45MSwxLjIzbC0wLjMxLDEuNTZsMC40MywxLjFsMS4zMywwLjk4bC0wLjgzLDMuNDhsMC42NSwyLjEzbDIuMDIsMy43NGwtMC4xNCwxLjE1bC0zLjY3LDYuMzRsLTEuNjIsMS4xNGwtMC41OSwwLjhsLTAuMiwzLjUzbC0xLjM4LDIuMmwwLjc0LDIuMDdsLTExLjUxLDEyLjEzbC0xLjQxLDEuMDhsLTIuMzgsLTEuMDVsLTEuOTIsLTAuMjNsLTUuMzksMC40N2wtMy4wNiwtMC40NWwtMy4zNCwtMS4zbC0yLjg5LC0wLjQ5bC0zLjQ1LDAuNTdsLTEuMzIsLTEuMjdsLTEuNywtMC4yOGwtMC41NSwtMC40M2wtMC4yNCwtMC43NGwwLjI0LC0xLjUybC0wLjM2LC0wLjZsLTUuODUsLTEuODFsLTUuNjcsLTAuOTZsLTAuNjIsLTAuNjRsLTEuNTQsLTMuMDFsLTEuOTgsLTIuMjlsMC40LC0zLjZsLTAuMDUsLTIuODJsLTAuMzEsLTAuNmwtMC45NCwtMC40MWwtMy42OCwtMC4wN2wtMC4yOSwtMi43NWwtMS4wLC0xLjczbC01Ljk2LC0yLjYybC01Ljg5LC00LjI4bC0yLjQ0LC01LjMybC0wLjE3LC0xLjgybC0xLjUyLC0xLjc4bC0wLjY1LC0xLjg2bC0yLjM2LC0yLjVsLTIuMCwtMy41N2wtMS4yMiwtMS4yNmwtMC42LC0xLjMybDAuMjQsLTAuOTdsMi4wLDAuNTRsMi4yMiwtMC4yM2wxLjAxLDAuMzVsMS41NywxLjE4bDEuNzYsMC4xOWwxLjU5LC0wLjY3bDIuMTIsMC4ybDIuODEsMS4xMWwyLjY1LDAuMjNsMy42NiwtMS4xNWwyLjQyLC0zLjM4bDAuNzUsLTAuODNsMS4yMiwtMC40N2wtMC4wMSwtMC4zOFpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJaV1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTI5Ny41OCwzMjkuMDJsNS4wMiwxLjE2bDAuNDEsMC41bDQuMjcsLTAuNDNsLTEuMjEsMi45MWwtMC4yMyw0LjA3bDYuNzQsNC44OWwwLjA1LDQuNjFsMC41LDIuNjFsMC41MiwxLjBsMS42MSwxLjY5bDAuMzQsMC44OWwwLjI5LDIzLjc3bC0wLjcyLDAuMDRsLTAuMzUsMC41NmwwLjU3LDEuM2wwLjIsMy4xNWwxLjcxLDIuMjNsMC4yOSwxLjFsLTEuNTcsMC40MWwtMC4yNiwwLjQ5bC00LjIzLDEuMThsLTAuMzIsLTAuNDNsLTEuMDcsLTAuM2wtMS4zMiwtMS43N2wtMC43NiwtMC4wOWwtMS44NywtMS4zM2wtMC4zNiwtMS40MWwtMi4wMiwtMy4wOGwwLjA1LC0xLjJsMC43MSwtMC44OWwwLjQ5LC0zLjc0bC0xLjQ5LC0xLjE3bC0wLjA5LC0xLjA0bDEuMjQsLTIuMjdsLTAuMjUsLTQuODdsMC4xNCwtMC41OGwwLjk5LC0xLjA4bDAuMDcsLTAuODZsLTAuODcsLTEuNjVsLTEuNjQsLTEuMjNsLTEuMTIsLTEuNTZsMS4zMSwtMS4zNmwtMC4yNywtMy4xbDAuNzQsLTIuOTdsLTAuMTUsLTAuNzJsLTEuMSwtMS4wOGwtMS4wNywtMC4wN2wtMC45NiwwLjZsMC4xNiwtMC44N2wwLjg0LC0wLjQ4bC0wLjIxLC0wLjY1bC0wLjMyLC0wLjA4bDAuNDEsLTAuNDhsMC42NywtNy4xNWwtNS40OSwtNC42OWwwLjg1LC0yLjM4bDAuMTIsLTIuMDlaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiVEdcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk01NzguMDMsMjczLjE4bC0zLjkzLC0wLjQ5bC0xLjc4LDAuMzlsLTQuMDYsMC4xM2wtMS40LDEuMDFsLTAuOTQsMS4xN2wwLjMzLDIuOTJsLTAuMzgsMS41NmwtMi4wLDIuMDFsLTAuOTUsMS43bC0wLjE1LDEuNThsLTIuMTgsMC45MWwtMS4xMywxLjA4bDAuNjksMy41M2wxLjAxLDEuM2wtNC4xLDIuNzlsLTAuOSwxLjQ4bDAuMDEsMS4xNGwxLjMxLDMuMDJsMC4wOCwxLjUybC0wLjcsMS4xNWwtMi4wMiwxLjI5bC0xLjgxLDMuMTFsLTAuMTgsMS4xMWwwLjg0LDEuMzJsMS41NiwwLjM2bDIuNzEsLTAuNDRsMS4xNiwwLjQ5bDAuNTgsMS4wOWwtMC4yNCwxLjA2bDAuOTUsNC41N2wwLjI4LDAuNTNsMC45OCwwLjQ3bC0wLjI4LDMuNzJsMC40MywxLjI0bDIuMzQsMi4xNWwwLjksMC4xOWwwLjY3LDAuNTRsMC4xMywxLjUybC0wLjc5LDIuODRsLTQuMTYsLTAuODNsLTMuMDUsMS4yMmwtMC44OSwwLjc3bC0xLjI3LDAuMDVsLTEuMDksMS4wOGwtMi4zLDEuMTRsLTAuOSwxLjExbDAuMjMsMi4zNmwtMC40MywwLjc3bC0wLjQ4LDAuNWwtMS4yOSwwLjQzbC0xLjU3LDIuNDVsLTEuNTMsMC4zMWwtMi45OCwzLjA5bC0wLjM2LDAuOTlsLTIuMzcsMi42MWwtNC45MywzLjIxbC0zLjAzLC0wLjA3bC0xLjU0LDAuNzFsLTMuMjMsMC42MmwtNi4xOSwwLjA3bC0xLjI3LDAuM2wtMS4xLDAuNjhsLTAuOTEsMC43bC0wLjA4LDAuNzhsMi41LDIuMThsLTIuMTcsMi43MWwtMy4xNywyLjc3bC0wLjY3LDEuMzRsLTEwLjc3LDAuNzZsLTQuNzIsMi4wMWwtMS41NiwxLjMzbC0yLjU1LDAuNzZsLTEuMDIsMC45M2wtMi4wNywtMi4wNWwtMC40NiwtMS4yOWwtMC40OSwtMC4zMmwtMS44MSwxLjE4bC0wLjM3LDEuMDRsLTMuODgsMS4yNWwtMC45MywwLjc4bC0xLjE2LDAuMzNsLTMuNTQsLTAuNTFsMC41NSwtMS4yOWwtMC4wNCwtMS41NWwtMS4zMSwtMC45MmwtMi4yLC01LjQ3bC0xLjYyLC0yLjgzbC0zLjA4LC0yLjk2bC0xLjUyLC0wLjgxbC00LjYzLC0zLjk0bC0zLjc5LC00LjVsLTAuMjQsLTAuOTFsMS43NiwtMi4zMWwxLjA2LC0wLjgxbDYuNzksMC40NmwzLjU1LC0wLjQ5bDIuMTYsMC4zNGwyLjU5LC0wLjA3bDEuNDgsLTAuNTlsMC4wNywtMC43bC0xLjQxLC0wLjkzbC0yLjkzLC0zLjExbC0xLjY0LC0zLjM1bC0wLjczLC0yLjM2bC0wLjQ0LC0zLjA1bDAuMjksLTIuOWwwLjc3LC0yLjAybC0wLjQ4LC0xLjQxbDAuMDMsLTIuMzdsLTIuMzcsLTUuMTVsLTAuNDMsLTIuODRsLTEuMDEsLTEuODNsLTEuNzEsLTEuMDFsLTAuOCwtMC45NGwtMC4zMiwtMS43OWwtMC43OSwtMC43NWwtMi42OSwtMC43NGwtMi4wMiwtMC4wM2wtNS4yLC03LjI0bC0xLjc5LC03LjgxbDIuMTcsLTIuODdsMS45NSwtNC4wNWw2LjU0LC05LjM2bDEzLjA2LC0xNC4xN2wzLjA1LC0zNi4yOGwyLjY2LC01LjM3bC0wLjQ4LC0xLjA1bC0zLjk2LC00LjA1bC0wLjQ1LC0xLjQxbDAuNjcsLTEuMjhsLTMuNjgsLTUuNjFsLTEuMjUsLTEuMjdsLTAuMTEsLTQuODVsLTIuMjEsLTEyLjk1bDExLjMzLC01LjM0bDkzLjQsNDguMjhsLTAuMDgsNDUuMjFaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiVERcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk03MjUuOTgsMjkwLjQ1bC0xLjA4LC05Ljg3bDEuMDcsLTEuMzlsMS44NCwtNS43bDEuNTcsLTMuMjJsMS4xOSwtMy42N2wtMC4yNywtNC4wMmwxLjAxLC0yLjBsMC4yOSwtMi45MmwxLjY3LDAuMjJsMy4wNiwtMC4zOGwxLjUyLC0zLjA5bDIuNzIsLTEuNmwyLjY5LC0wLjkxbDEuMDEsMC4wOWwxLjg2LC0wLjczbDEuNTIsLTEuN2wwLjU5LC0xLjNsMS43MywtMS44bDMuMzEsNi41M2wxLjQzLDQuMDlsMS4yNiw0LjI2bDAuOTMsNi40MmwwLjkxLDMuMzNsMS40OCwxLjcxbDAuOTYsMi45OGwxLjAxLDAuMzdsMC40OCwwLjY2bDEuMDMsMi44MWwwLjgxLDEuMTZsMC42OSwtMC4wN2wwLjQsLTAuOTJsLTAuMjksLTEuNTlsMC41MSwtMS4yN2wxLjYzLDEuMjlsMC41MSwyLjE0bDEuNjMsMS44OGw0LjAxLDAuOTdsMy4wLDIuMjlsNC4zMSwxLjQzbDUuNjYsNy42MWw2LjgsNC42N2wxLjEyLDIuMTRsMC42MSwyLjE3bDAuNDEsMC4yOWwxLjI3LC0wLjA5bDIuMjksMi4yM2wwLjk0LDEuOTlsMi4wMywwLjY3bDAuNTEsLTAuMjZsMC4xNiwtMC40OWwwLjQ0LDAuNGwwLjI3LDAuOTNsLTIuNzgsMS4wMWwtMS4xNiwyLjM2bC0wLjU2LDAuMzhsLTIuMzksLTEuNTlsLTAuNjcsLTAuMDRsLTAuNTgsMC40MWwtMi41OSwtMy4zbC0yLjE1LC0xLjM2bC0yLjIxLC0zLjZsLTQuNzMsLTMuNzhsLTIuNzgsLTIuNzhsLTMuNTUsLTQuNWwtMy41OSwtMS40NWwtMy41LC0yLjQzbC0xLjA2LC0wLjM2bC0yLjk0LDAuMTZsLTEuNTMsLTAuNjZsLTIuNjgsLTAuNDdsLTMuNzksMC43bC0wLjcyLC0xLjE3bC0wLjcyLC0wLjU2bC0wLjg0LC0wLjA4bC0yLjYzLDEuNzdsLTQuMTcsMC42M2wtMi4zOSwtMi41OWwtMi41MywtMS4wM2wtMS40MiwtMS4zOWwtMC42LDAuMTdsLTMuNTksOC4yMmwtMi4wMSwtMi42MmwtMS40NCwtMS4wN2wtMC44NSwwLjA5bC0wLjgyLDAuNTZsLTEuMDksMS41MWwtMi40NSwtMC41MWwtMS41NiwwLjA5bC0xLjQ0LDAuNTFaTTc2Ni4yMiwyNzIuNzhsMC40OCwtMC40MWwwLjAzLC0wLjQ3bDAuNTMsMC4zNmwwLjkxLDIuMjNsLTEuMDUsLTAuMDNsMC40NSwtMC4zM2wtMC4wNCwtMC40OWwtMC42NCwtMC42OGwtMC42NywtMC4xOVpNNzY5LjE3LDI3NC41NWwwLjM4LC0wLjQxbDEuMTUsMC41NWwtMC42OCwwLjAybC0wLjg0LC0wLjE2Wk03NjcuMDIsMjY5LjQ2bDAuMDIsMC4wNmwtMC4wNywtMC4wM2wwLjA0LC0wLjA0WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkVSXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNDMyLjUxLDU1Ljk2bDEuMzgsMC42MmwxLjc3LDAuMzJsNS41MiwzLjA5bDUuNiwwLjc2bDYuMiwtMS40N2wyLjkyLDEuMTZsMy41NCwwLjQzbDMuNjksMS4wNWw0LjI0LDIuNjFsNy42NiwxLjU0bDAuOTMsMC45MWwxLjAxLDEuODRsMC4wNywyLjQ3bDEuNTcsNC4xMWwyLjYzLDMuMThsNC45NSwyLjEzbDcuOCwwLjY3bDYuNiwxLjcxbDUuNTgsMS45NmwxLjQ1LDEuMGwyLjc2LDAuOTRsNS42NCw0LjY2bDMuMTMsMS42MWwyLjMyLDAuMzVsMi4xOSwtMC4zMmw1LjAsLTIuNjFsMy42LC00LjFsMS4yLC0yLjE4bDAuNDksLTEuNTZsLTAuMSwtMS42NmwtMi4xMiwtNC43M2wtMC4zOSwtMy4yOGwwLjUzLC0yLjI1bDEuNjYsLTIuNzNsMi44NywtMi43MmwyLjg5LC0xLjkybDUuMDcsLTIuNWw0LjI0LC0wLjMybDIuNTMsLTEuODFsMi4yNiwwLjM4bDQuMDIsLTAuMTJsMTAuMjksMy44bDAuMzksMS45MmwtMC4xLDEuODdsMi4zLDEuNjFsNS45NSwwLjcxbDMuOTcsMS45NWw0LjExLDAuMTdsMi40LC0wLjI1bDIuMTgsMC4zOWwxLjUxLDEuMTZsMS4yOSwyLjY0bC0zLjM4LDQuMjdsMC4yOSwzLjU3bDEuMTIsMy42NmwtMC4xMywxLjE2bC0wLjk1LDIuNzRsLTIuMDksMy41M2wzLjI1LDEzLjA1bC0wLjAxLDExNC4wOWwtMTEuMzIsLTAuMDFsLTAuNCwwLjRsMC4wLDUuNDNsLTkzLjIsLTQ4LjE4bC0xMi4xNiw1LjU2bC04LjY5LDQuNjFsLTcuMDUsLTYuMDhsLTEuNDUsLTAuOGwtMTcuNjcsLTQuMThsLTQuOTgsLTkuNDRsLTAuNTcsLTAuNDhsLTkuNjQsLTIuOTVsLTMuMzcsMC44MmwtMS40NSwtMS4xNmwtMS41OCwtMi40NGwtMS4wMywtMy4xM2wtMC4zOSwtMy42N2wtNi40NCwtOS4xNmwtMC4yNiwtMC44NmwwLjcsLTIuMDJsNC4yNSwtMi43MWwwLjQ0LC0xLjIxbDAuMTUsLTIuODJsLTAuNzEsLTEuMDZsLTAuNDYsLTEuNTRsLTAuNTUsLTMuNDZsMS45NiwtNS44OWwtMC42NywtMy4yNGwtMC41LC02LjUybDAuMzEsLTUuMTZsLTAuNDUsLTIuNzlsLTEuOTYsLTUuOTVsLTMuNjksLTUuODZsNi42MSwtMy4zNmwzLjg0LC01LjIxbDAuNDcsLTEuMDVsMC4wNCwtMS4ybC0xLjY0LC02LjY3bDEuNzQsLTIuNjNsMi4zNywtMC42OGwwLjg1LC0wLjk0bDAuNzYsLTEuNmwxLjc2LC0xLjA5bDAuNzEsLTAuODFsOC4wNiwtNC40OGwwLjM4LC0xLjY0bC0wLjk0LC0xLjYzbDAuMDYsLTMuMTlsMC40NywtMy4xNlpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJMWVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTEwMi43NSwzMTQuMDRsMi4wMSwtMC4xNWwzLjE0LC0xLjA2bDMuNTMsMC4yM2wzLjIxLC0wLjYzbDQuNDYsLTIuMjVsMTYuNjksMC4wN2wwLjAyLDAuNzVsMC42NCwxLjI2bC0wLjU0LDEuOThsLTEuMjcsMC4xNGwtMS4zOSwwLjkybDAuMTQsMC43OGwyLjM1LDEuOTNsMC4wNCwyLjcxbC0yLjI4LDAuNzVsLTMuNzYsMC4wOWwtMi4xOCwxLjIybC0yLjc4LDAuNjFsLTEuMjYsMS4zN2wtMi43MSw1LjA1bC0wLjE4LC0wLjI2bDAuNCwtMS4zN2wtMC40LC0wLjUxbC0wLjc5LDAuMTdsLTAuNzMsMC45M2wwLjA0LC0wLjg1bC0wLjM2LC0wLjQybC0xLjEsMC4wMmwtMC42MywtMC41NWwtMC4wLC0xLjBsMC40MywtMC40MWwwLjAzLC0wLjYzbC0xLjI2LC0wLjI2bDAuMjksLTAuNTJsMS44OSwtMC44MWwyLjA5LC0wLjI5bDAuMjQsLTAuNjRsLTAuODEsLTAuOWwtMS4yNywtMC4zbC0xLjE5LDAuMjFsLTAuODgsMC42bC0wLjgxLC0xLjBsMC4zMSwtMC45OWwwLjQxLC0wLjIzbDIuMywwLjAxbDEuNTgsLTAuNjVsMC4zNiwtMS4wM2wtMC43NiwtMC4zMWwtMS4wMSwwLjVsLTIuOTMsLTAuMTdsLTEuMDMsMC4zN2wtMS41NiwxLjE0bC0xLjgyLDAuNmwtMC45LC0wLjE3bDAuMzQsLTEuMTZsLTAuODQsLTAuOTNsLTIuMjcsMC40M2wtMS4zNywtMC42MmwtMC40OCwtMC42N2wwLjA4LC0wLjhsMC44NywtMS4xN2wtMC4zNSwtMC41MmwtMC45NSwtMC4wNWwtMS4zLDAuNDFsLTEuNzQsLTAuOTdaTTExMi45LDMyNi42OWwwLjEyLC0wLjExbDAuMDIsMC4wbC0wLjA1LDAuMDZsLTAuMDksMC4wNFpNMTEwLjMsMzI0LjAybC0wLjU5LC0wLjA4bDAuNDQsLTAuODZsMC4wNCwwLjAxbDAuMSwwLjkzWk0xMDguMzEsMzE5LjY5bDAuODQsLTAuMDZsLTAuMjcsMC42NGwtMC41NywtMC41N1pNMTA3LjM0LDMyOC42MWwwLjQ3LC0wLjE1bDAuNjUsLTAuNThsLTAuMDMsMC41OGwtMS4wOSwwLjE1WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkdXXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNTc4LjgzLDU4Ny43OWwwLjU3LDAuMDlsMC45LDEuNjNsMS45NCwwLjQ5bDAuNDEsMC41MmwwLjMxLDEuM2wtMC42LDEuNjZsMC42NiwwLjY1bDEuMDQsMC4zNmwwLjgxLC0wLjA5bDEuODQsLTEuMDRsNi45OCwtMS42NGwtMC4zMiwxLjk5bDAuOTIsMi44MWwxLjg3LDEuNTFsMS41LDAuMDJsNC43NSwxLjcybDYuNzEsMC45OGwyLjg1LC0wLjFsMS42NCwtMC45bDEuMTUsLTMuMzNsMC45MywtMC4zbDAuNzUsMi4zbDIuMTEsMS44NmwxLjI0LDIuODlsMC42LDAuNTRsMS4wMywwLjU2bDIuNDYsMC4yMmw2LjMxLDIuNjdsMS41NCwzLjY2bDEuNiwwLjUybDAuNTYsMC42NGwyLjE4LDMuMzVsMC4zNSwxLjI1bDAuODQsMC43NGwyLjQ1LDAuNDVsNC4xNSwtMS43N2wwLjUzLDAuMzZsMC40MiwxLjU1bDEuMTUsMC41MWwwLjg3LC0wLjQxbDAuMjcsLTAuNjhsLTAuMCwtMTQuNzdsLTAuNDgsLTAuMzlsLTMuNDcsMC45bC0wLjM4LDAuNjZsMC4xMiwxLjQ3bC0wLjQ4LDAuMjNsLTQuMDgsLTAuOTRsLTIuNDUsLTIuNjVsLTQuMjMsLTMuNThsLTEuMzksLTMuNjlsMi4xNSwtNy45M2wxLjEzLC0xLjcybDAuMDgsLTEuNDFsLTAuNDQsLTEuODZsMC4yNiwtNi42OGwtMC4zMSwtMS44OGwtMi4zOCwtNS4wOWwzLjE2LC0yLjRsMi4yNywtMi43N2wwLjY0LC0xLjE4bDAuMiwtMS4zbC0wLjMxLC0xLjAzbDE4LjcsLTIuOTNsLTEuMDIsMC45bC0wLjQxLDEuMjVsMC40OCwxLjA0bDAuODYsMC4xbC0wLjMxLDAuNjFsMC4zNiwwLjI2bDEuNTYsLTAuODFsMS4yOSwwLjU4bDIuMDUsMi4xbDEuMDMsMC42M2wxLjI4LC0wLjdsMC42NywtMC4wMWwwLjMyLC0xLjQzbDEuMzEsLTAuMDJsMS44OSwxLjA5bDAuMzIsMS4xM2wxLjQyLDEuMjZsMS44OCwwLjBsMC44NCwwLjNsMC4wOCwwLjg5bDAuNTMsMC42bDIuMTMsMC4yM2wxLjE1LDAuNjJsMi4zMywwLjMzbDAuNjYsMC42Nmw0Ljg4LDIuMjFsMC42OCwxLjIxbDAuMiwxLjE3bDEuMjUsMC40N2wwLjU5LC0wLjQybDAuNTYsMC4xNmwwLjYxLDEuNDdsMS4xMiwxLjE1bC0wLjMzLDIuMjVsMi40NSwyLjIxbDAuMzEsMS44NWwxLjIzLDEuODZsLTIuMTEsMi4yOWwtMS40NCwwLjM5bC0xLjA2LDEuMDNsMS4yNywzLjQybC0xLjE2LDIuNTdsLTAuNTMsMC40NmwtMC4wMywxLjYxbDAuNzEsMC45MmwwLjE1LDAuNzhsLTAuMDMsMi4yNWwtMC41NCwyLjg4bDEuMTYsMi40OWwwLjU4LDAuMzNsMS4xMiwwLjAxbC0xLjAxLDEuMTVsLTQuNTMsMS44bC0wLjk0LDIuMThsMC42MSwxLjM3bC0wLjM0LDMuNThsLTEuMzIsMi43M2wtMi4xOSwxLjg0bDAuMjUsMC41N2wxLjI3LDAuNzVsLTAuMzQsMC40N2wwLjExLDAuNTVsMS4xNywwLjY2bDEuNTksMi40OGwtMTcuMDgsNS45MmwtMTAuMTMsMi45bC01LjE5LDIuMDZsLTAuMzMsMC40NGwwLjAxLDAuOTRsMC4zNSwxLjQ4bDEuMTQsMS45OGwwLjQ2LDIuOTZsLTcuMzcsMC4wMmwtMi45MywwLjY0bC0yLjQ0LDEuMGwtNC40MiwyLjU2bC0wLjYyLDAuODVsLTAuNDksNC41OGwtMC42NCwwLjk4bC0xLjUzLC0wLjM3bC0yLjYsMS4wMWwtMS4xMSwtMC40M2wtMC41MSwwLjgzbC0xLjA2LDAuNTJsLTAuMzEsMC43OGwtMS4zMywxLjE5bC0xLjU2LC0wLjYxbC0xLjI3LDAuNjFsLTAuMzQsMC41bDAuMzcsMC42OWwtMS4yNCwwLjM2bC0wLjM0LDEuNDZsLTAuODQsMC4ybC0yLjA5LDIuNzRsLTEuMDcsMi4wM2wwLjI4LDAuNTZsLTIuMjUsMi4xbC0xLjg3LDMuMjNsLTIuNDUsMC44N2wtMi4yMywtMC4yMmwtMi45MiwtMS4xM2wtMi4yNywtMC4yMWwtMS43OCwwLjY5bC0xLjM0LC0wLjE5bC0xLjM0LC0xLjA3bC0xLjMxLC0wLjQ4bC0yLjI3LDAuMjNsLTIuMTIsLTAuNThsLTMuMDgsLTIuNzRsLTMuMjQsLTAuNjRsLTUuNSwtMC40NGwtMTAuMywxLjg5bC00LjgzLC00LjE2bC01LjgzLC01LjY5bC0zLjU0LC0yLjU3bC0xLjI1LC0zLjg4bC0wLjcsLTMuNjRsLTAuMDEsLTM0Ljk0bDIxLjQ3LDAuMGwxLjQ3LC0wLjE1bDAuMzQsLTAuMzNsMC4wMiwtMC42M2wtMC45NSwtMS43OGwwLjI5LC0xLjc0bDAuOTcsLTIuNjNsLTAuMzgsLTMuNjhsMC4xNSwtNS42N2wwLjg3LC0yLjg0bC0wLjg1LC01Ljc3Wk02ODUuMzMsNjI0LjczbDAuNTcsLTAuNDFsMC4xMiwwLjE3bC0wLjY5LDAuMjRaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiWk1cIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0xOTYuOTMsMzgyLjhsMi44OSwtMy4xOWwwLjQzLC0yLjMybDAuMDUsLTEuMjVsLTEuOTUsLTUuNTlsMi42NSwwLjI2bDEuNCwtMi40NmwtMC4wNywtMS40bDEuMzIsLTIuMzdsLTAuMiwtMS4yNmwtMi42NCwtMS4xNGwwLjE5LC0yLjAzbDEuOCwtMC4yNWwyLjQ4LDAuMzNsMS4xOSwxLjA5bDAuNSwtMC4wbDAuNTQsLTAuNjVsLTAuMDgsLTEuOThsLTAuNDMsLTEuMThsLTAuOTIsLTEuMDNsLTEuNzIsLTAuNjlsMC4xNCwtMS44MmwxLjY5LC0xLjAzbDAuMTUsLTAuNTdsLTEuNTQsLTEuMjlsMC4yMiwtMi40NGwtMC40NywtMC40MWwtMS40MiwwLjJsLTAuOTQsLTAuODlsLTAuMiwtNS40NmwxLjc1LC0xLjlsMS4xMywtMC4yOGwwLjk0LC0wLjY2bDEuNzEsLTIuMTdsMS41NywtMC4xNGwxLjIsMS4xNWwwLjQ5LDAuOTZsMi45LDAuNjNsMC43LDAuNjNsMC43LDAuMDlsMC44LC0wLjY4bC0wLjI0LC0xLjAybDAuMjgsLTAuNjRsMy4xNCwtMC4yOGwwLjMyLC0wLjc3bC0wLjEyLC0yLjQ4bDAuODQsMC42M2wxLjc1LDAuMzRsMC41OSwtMC42OGwtMC4yNSwtMC44bDEuMzgsLTAuNGwwLjA4LDEuNTlsMC41NiwxLjgybC0wLjU1LDEuNjVsMS42NywxLjAybDEuMzksLTAuMGwyLjEzLC0yLjIzbDMuMTMsLTAuNTZsMS45MiwxLjQzbDEuNTYsLTAuMDFsMS42NCwwLjc5bDEuMTgsMi4ybDAuNDMsMS41NWw0LjEsMi42bDEuMTgsLTAuMDdsMS40LDAuODVsMS4wMSwwLjA2bDEuMDUsLTEuMjRsNS4zOCwtMS45OGw2LjUsMC4yOWwxLjM5LDEuNjFsMS4xNiwwLjdsMi4wLDMuMDZsMC45LDAuMTdsMC40OCwtMC4yM2wtMC4xMSwxLjMybDAuMjcsMC4zN2wtMC43NSwxLjY5bC0wLjA1LDAuOTVsMS4xNywxLjE5bDAuNTYsMS44M2wxLjA3LDYuNzRsLTEuMiwwLjcybDAuMDQsMS4wMWwtMi4xNCwxLjU2bC0xLjI1LDIuOWwtMC43NCwyLjcybC0wLjMyLDIuOTNsLTIuOSw0LjYzbC0wLjE0LDIuMDZsMC41MiwzLjYybDIuMzgsNy41MmwwLjc0LDEuMDhsMS42OSwwLjM1bDAuNCwxLjc2bC0wLjUzLDIuODdsLTEuNCwwLjM3bC0yLjA4LC0wLjgybDAuMTcsLTEuNDFsLTAuMzUsLTAuNDRsLTAuNTcsLTAuMDdsLTAuODYsMC40NmwtMS4wNCwyLjE0bC01Ljg3LC0xLjAxbC0xLjQzLC0wLjg3bC0xLjY2LC0wLjJsLTUuMSwwLjM1bC0wLjg2LDAuNmwtMC4xMywwLjQ2bDAuMjQsMC4xNmwtMy4yOCwwLjQ1bC0wLjYzLC0wLjA4bC0wLjgxLC0wLjY4bC0zLjE3LC0wLjA2bC0wLjgxLDAuMzVsLTAuMzgsMC40OGwwLjIxLDAuMzhsLTIuMjksMC4xOWwtNC4xNSwwLjk0bC0xMC45NCw0LjBsLTIuNTIsMS41bC0yLjA1LDAuN2wtMi4yMywxLjI2bC0xLjA5LDAuMjNsLTAuMzEsLTUuMDhsMC4yNiwtMi43OWwwLjg0LC0wLjc3bDAuMTQsLTEuMThsMC42NiwtMS4xN2wwLjAxLC0xLjcxbDAuMzIsLTAuODRsLTAuNjMsLTMuNmwtMC4zMiwtMC4zOWwtMC43LDAuMDNsLTEuMzIsLTAuNzFsLTEuMTMsLTAuMTZsLTAuNTYsLTAuNDdsLTEuMjcsLTMuMjFsLTEuMjMsLTAuNjVsLTIuNTksLTAuMDZsLTAuODksLTAuM2wtMS43OSwtMS42MWwtMS40NywtMC4yOVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJDSVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTk4LjA4LDIwNS4wN2wwLjA4LC0wLjUzbDQuNjEsLTAuNjhsNy43MiwtMC4yNGw1LjQxLDAuNjFsNS43NCwwLjEybDEuNTYsLTAuMTJsMS4zNCwtMC43N2wxLjAsLTEuMzNsMC43LC0xLjgzbC0wLjE3LC0xLjM5bDMuNiwtMy45MWwxLjE2LC0xLjY4bDAuNTksLTUuNTRsMC44MiwtNC4ybDAuOTMsLTMuOGwxLjQ4LC0zLjM3bDEuMjUsLTEuMWw1LjQsLTIuMzdsMy4wNywtNS4zM2wwLjc1LC0wLjc5bDQuMTksLTIuNTlsMi40NywtMi4wMWwxLjQ0LC0zLjU3bDEuNjUsLTYuNjJsMS4wMywtMi44NGwtMC4wNywyOS41M2wtMy44MiwxLjcxbC0zLjAyLDAuNjRsLTQuODIsMy4zNWwtMS41NiwyLjM4bC0wLjE5LDEuMDdsMC44NCwzLjE2bDAuODksMTMuODRsLTQ2LjA2LDAuMlpNMTU3LjQsMTQ3LjA1bDIuNTcsLTAuNjFsMS4xLC0yLjU0bDEuNDcsLTIuMTlsMi4wOCwtMi4xM2wwLjI3LC0xLjU1bC0wLjc3LC0xLjQ1bDUuMDYsLTEuNDlsMS44NiwtMC4xMmwyLjMzLDAuMzZsMy42MiwxLjY1bDIuNSwtMC42MmwxLjQzLDAuNzFsMS4yMSwwLjA0bDEuMTcsLTAuMjNsMy42NSwtMi43OWw0LjY5LC0wLjAxbDIuNSwtMC4zOWwwLjgxLC0wLjc4bC0wLjUxLC0yLjA4bDAuMjcsLTEuODlsLTAuNDcsLTIuMDNsMC43NCwwLjBsMC4wMSwyMC4xM2wtMzcuNiwwLjBaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiRUhcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiIGN1cnNvcj1cInBvaW50ZXJcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNMzk4LjAzLDQwMy40MmwyLjgyLC01LjA3bDEuNTYsLTYuODJsMC43LC0xLjU0bDQuMzMsLTQuNjNsMy4zMywtMi40OGwxLjQ4LC0yLjczbDMuODUsLTIuNWwwLjc3LDEuMDZsMy4zOSwwLjBsMC42NSwtMC41OGwwLjY2LC0xLjQxbDEuMzcsMC43OGwzLjEyLDIuODlsMS4xLDMuMjNsMC43NCwwLjQxbDEuMiwtMC4xMmwxLjE4LC0wLjQ2bDEuODgsLTEuNGwwLjkyLC0xLjI1bDAuMywtMi4xOWwzLjIzLC0yLjYzbDAuMDUsLTAuNjhsLTAuOTUsLTEuNDdsMi43NiwtMy40OGwwLjE5LC0xLjc2bDEuNTMsLTIuNTZsMC45MiwtNC4wbDEuODYsLTMuNDVsMi4wNiwtMC4zNmwwLjg3LC0wLjU3bDEuNTgsLTEuODNsMS4xNiwtNS44NmwwLjU2LC0xLjNsMC45MSwtMC42NGwxLjc4LC0wLjU5bDAuNTMsLTAuNTZsMC44MSwtNS40OWwxLjcyLC0xLjdsMS40MSwtNS4xbDEuODksLTMuMTJsMi4yMSwtMy4xMWwwLjk2LC0wLjc4bDIuNiwtMC42OGw0LjM1LC0yLjg1bDAuMjgsLTEuMjhsLTAuMjIsLTEuNjRsMC42NSwtMy4wNWwwLjAyLC0yLjA4bC0xLjQxLC0yLjA1bC0xLjIxLC0wLjU1bC0yLjM3LC0wLjQxbC0xLjQzLC03LjU4bDEuNTgsMC4wMWwyLjQyLDAuNjNsMC40NSwwLjM2bDAuNCwxLjk0bDEuMDMsMS4xN2wxLjUyLDAuODNsMC45MiwxLjY2bDAuNDMsMi44M2wyLjMxLDQuOTNsLTAuMDQsMi4yOWwwLjQ4LDEuMjZsLTAuNzQsMS45N2wtMC4zMSwzLjA4bDAuNDYsMy4xOWwwLjc3LDIuNWwxLjc2LDMuNTZsMy45LDMuOGwtMy4wNSwwLjMxbC0yLjIzLC0wLjM0bC0zLjUsMC40OWwtNi45NiwtMC40NWwtMS41MiwxLjA5bC0xLjg5LDIuNDZsMC4zNSwxLjc2bDMuODUsNC41N2w0LjcxLDQuMGwxLjU1LDAuODRsMi44OCwyLjc0bDEuNTYsMi43MWwyLjIzLDUuNTNsMS4zMiwxLjIxbC0wLjI2LDEuMzhsLTEuNzMsMi44bC0xLjUsMS4wN2wtMC41NiwwLjc4bC0yLjAyLDQuOTRsLTIuMDMsMi43M2wtMS4xNywyLjg2bC0wLjU5LDAuNjFsLTIuMjcsMS4xbC0wLjg3LDAuOTJsLTAuMTcsMS4wbDAuODgsMS41bDAuOTksMC4xOWwwLjI3LDAuMzRsMC4wLDQuMDhsLTAuNjMsMi42MmwwLjkzLDEuMzhsMC44LDYuMGwwLjgsMS40bDIuOTQsMi4zNGwwLjQxLDAuNzVsMC44NCwyLjQ5bC0wLjg3LDAuMTRsLTAuMjksMC41NGwwLjM0LDAuODZsMC44MywxLjQ5bDcuNTksOC4yM2wxLjY0LDAuNDdsMS42NiwyLjBsLTAuMDcsMS41bDAuNDcsMS42MWwwLjA5LDEuOTJsMC44OCwyLjM2bC0wLjA1LDAuNDVsLTEuMSwxLjE5bC0wLjE3LDEuMTVsMC43NywzLjMybC0wLjQyLDAuM2wtMy43MSwtMi43MWwtMS43NCwtMC40M2wtMi45OSwwLjA1bC0yLjA5LC0xLjA0bC0wLjkyLDAuMzhsLTEuODcsLTAuMTNsLTAuNDUsLTAuNzNsLTEuMzMsLTAuMDFsLTIuNTIsLTEuNDFsLTEuMDMsMC40OGwtMTMuNiwtMC4wOGwtMC4zNCwtMC42N2wtMC43OSwtMC40NGwtNC4xNSwwLjExbC01LjksLTAuNThsLTkuNDUsLTAuMDdsLTIuNDcsMC4wM2wtMC4zOSwwLjQ1bC0wLjE3LDEuMWwtMTUuNCwtMC4wbC0xLjE1LC0wLjQ4bC0wLjYsLTEuMDFsMC45NiwtNi44MWwwLjcyLC0xLjg2bC0wLjM3LC0yLjExbC0yLjY4LC0zLjM5bDAuOSwtMS4ybC0wLjQsLTAuMjNsLTEuMTIsMC4xMWwtMC43MiwtMS41N2wwLjQ3LC0wLjU5bDEuMDUsMC4xNmwwLjQ2LC0wLjQ1bC0wLjE3LC0wLjU3bC0wLjk1LC0wLjg1bDAuNDIsLTEuMmwtMC43NSwtMC4yOWwtMS4wMSwwLjVsLTAuODYsLTAuNDRsLTAuNDYsMC40OWwwLjE2LDAuNTlsLTAuNTUsMC41OWwtMC45NSwtMC4xNGwtMC44NCwtMC43bC0yLjc1LC0xLjAybC0wLjI0LC0xLjQybC0wLjc1LC0xLjUxbC0wLjEyLC0yLjU2bC0xLjg0LC0wLjM1bC0xLjIxLC0xLjA1bC0wLjU4LDAuNDVsMC4yOSwxLjJsLTAuNjksMC4wM2wtMC4yOSwtMC41NWwwLjMxLC0xLjgxWlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkNNXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNjU1LjUzLDc4LjA3bC0wLjIxLDAuMzVsMC4zNiwwLjM1bDEuNjEsMC4xN2wzLjY0LC0wLjc3bDAuOTQsLTEuOGwxLjE0LDAuMThsMy45NywxLjY5bDEuMSwwLjAxbDMuMTQsLTEuMDVsLTEuNjUsMi41NGwwLjE1LDAuNjFsMi43MiwwLjkzbDAuOTcsMS40OGwwLjQ2LDAuMTlsMS40MywtMC40N2wwLjg4LC0xLjA2bC0wLjE0LC0wLjdsMi41MywyLjA1bDEuMTEsMC41bDUuOTYsLTEuMjJsMS4wNSwxLjBsMi4xLC0wLjU5bDMuNDIsLTAuMGwyLjg1LC0wLjY4bDMuMTIsLTEuNTVsMy42OSwxMC44NGwxLjUsMy4yNmwyLjc5LDguODlsLTEuODksMi42OGwtMS4zOSw2LjUxbC0xLjk5LDUuMDdsLTAuNTUsNC4zMmwtMS44OCwyLjg2bC0xLjcxLC0wLjY4bC0zLjI2LC0yLjdsLTEuOTIsLTIuNmwtMi4xMywtMS43NmwtMS45LC0yLjE4bC0xLjM4LC01LjIybC0wLjY5LC0xLjI5bC0yLjM3LC0yLjY4bC0xLjcxLC0yLjk0bC0wLjg2LC0zLjQ5bC0wLjk4LC0yLjMxbC0wLjU3LC0wLjE5bC0xLjA5LDAuNjJsLTAuMDQsMS4ybC0wLjksMS4yNmwtMC41OCwxLjhsMC41NCwxLjRsMS45MiwxLjg0bDAuMzUsMC43MmwwLjQzLDEuNjlsLTAuMDQsMi41MmwwLjM4LDAuOTNsMS40NCwxLjc2bDEuMzMsMi44bDMuNjMsNC42MmwyLjAsMi4wbDEuNDMsMC45N2wwLjUxLDAuODFsMC4wOCwzLjc1bDEuNzEsMy4zMmwxLjI4LDEuMDRsMC41LDAuOTRsMS4yNiw2LjY2bDEuMTIsMS40bDMuMjgsNi42MWwyLjc1LDQuMTVsNy4zNywxNS4xN2wzLjM1LDQuMDNsMi43MSwxLjk3bC0xLjgsMC4zNWwtMC42NywyLjE0bDAuMjIsNC4yNGwwLjUxLDIuMThsMS41Nyw0LjAybDIuNjcsMi43M2wzLjY5LDEuMzhsMi4xOCwyLjg4bDQuNzksMy41OWwwLjI4LDAuNThsLTYyLjY4LDAuMDFsMC40MSwtMS42NGwtMC41NSwtMC43NmwtMC43NSwtMC4xM2wtMC45MiwwLjM4bC0xLjA1LDIuMTFsLTAuMzcsMC4wNmwtNzIuNjMsLTAuMDFsMC4wLC04OS42MmwtMy4yNCwtMTMuMGwyLjAxLC0zLjIxbDEuMDEsLTIuOTVsMC4xNCwtMS40MWwtMS4xMiwtMy42NmwtMC4yOCwtMy4zMmwyLjk3LC0zLjY3bDAuOTQsMS4zNmwxLjg0LDAuMjdsNi4wNiwtMS4zOWwxNS43MywzLjEybDMuNDcsMi4xNWwxLjA2LDAuMjlsMi4zMiwtMC4wNGwxLjcxLDEuMjZsNi4zNiwwLjZsNi42NSwyLjg1bDIuNTIsLTAuNDlsMS44NCwtMC44Mmw1Ljg3LC0zLjg3bDEuMjYsLTAuNDRsMi4wLDAuMDhsMi4yMSwtMi42bDEuNTgsLTAuMTVaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiRUdcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0xNjUuNzMsMzQyLjY2bDEuNjMsMS43NWw0LjE3LDUuNjRsLTAuNzQsMi4zMWwwLjQxLDAuNDVsMS4xNiwwLjI3bDAuMTMsMi4xMWwxLjE4LDIuMDVsLTEuNDYsMS42MmwtMC45OSwyLjMxbDAuMTksMC40OGwyLjI0LDAuMmwxLjkyLC0xLjk0bDAuNjMsLTAuMDRsLTAuODEsMi45NWwtMS43OCwwLjY4bC0wLjc0LDAuODJsLTAuODYsMy41MWwtMi42MSwyLjU2bC0yLjQyLDEuNjRsLTIuMTUsMS45NmwtMi41NCwzLjYxbC0yLjQzLC0xLjkybC0yLjM2LC0xLjE2bC02LjI4LC0yLjMxbDAuNTMsLTEuOGwtMC44MSwtMS4yNmwwLjI5LC0wLjg1bC0wLjM4LC0wLjUzbC0xLjE5LDAuNmwtMS4xOSwtMC4xNGwtMS43MiwtMS4xNmwtMS4yMywtMy44MmwtMC45NywtMC43NWwtMS4yNywtMC4xNGwtMS4zLC0yLjI3bDIuMDcsMC40MmwxLjk0LC0xLjc5bDAuMzcsLTEuMDRsLTAuMTIsLTAuMzFsLTAuNjMsLTAuMTdsLTAuNDUsMC4zOGwtMS40MiwtMC4xMWwtMC44OCwwLjUybC0wLjQsLTEuMDJsMC4xNywtMS4zbDEuMzEsLTAuMTNsMC40NiwtMC41MmwtMC4yOSwtMC41NmwtMS4wMSwtMC4xOGwtMS4yOSwtMS4xN2wxLjU2LDAuMTRsMC42OSwtMC4zbDEuMDMsLTEuMDJsMC40NSwtMS4yOGwxLjMsLTAuNGwxLjA0LC0wLjk0bDIuNDIsLTQuMDZsMC42MiwtMS43M2wwLjY2LC0wLjMzbDEuNTksLTAuMzRsMS43MSwwLjYybDIuNTgsLTAuNTZsMC4zOSwtMC44Mmw3LjA4LC0wLjA0bDAuNTcsMC4xNmwwLjIxLDAuNDVaTTE1MC4wLDM3MS41MWwtMC41MywtMC40NWwtMy4wOCwtMC44N2wyLjgxLC0wLjI2bDAuOTIsMC40N2wtMC4xMiwxLjExWlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIlNMXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNDMzLjQyLDQ4Ny4yMWwxLjQ2LDAuNTVsMi40LC0wLjU2bDEuNTQsMC43N2w0LjQ4LC0wLjk3bDAuMzEsLTAuMzZsMC4zOCwtMi41N2wtMC41NCwtMS45OGwxLjU1LC0wLjk4bDEuOTcsMS4wOWwyLjUxLDQuNTlsNC4zNCwxLjA5bDEuMzcsLTAuMTFsMi4wMSwtMS40NWwxLjI3LC0xLjQ0bDEuMTcsMS45bC0wLjE5LDAuODNsMC4zMywwLjgybDEuNjgsMC40NWwxLjMsLTAuNGwxLjI5LC0xLjI5bDAuMTQsLTAuOTJsLTAuNDQsLTAuODFsMC40MywtMC40N2wwLjU5LC0yLjA3bDEuNTcsLTEuMzhsMC40NiwtMi4wOWwtMC4yMywtMS4zNWwwLjUyLC0wLjg5bDAuMSwtMS4zMWwtMC41MiwtNS4xOWwwLjc0LC00Ljc1bC0xLjQ0LC0xLjQ4bC0xLjg4LC0wLjUzbC0xLjYxLC0xLjgybC0yLjI1LC0wLjU5bDAuMjcsLTQuNDNsMC42OSwtMS43M2wxLjQ3LC0yLjBsMS43MywtMC4yM2wxLjEzLC0wLjg5bDEuNDIsLTIuNDVsLTAuMDYsLTEuMTdsLTEuNTMsLTIuNzJsLTAuNzEsLTIuMjdsLTAuOTgsLTAuODNsLTQuMDYsLTAuNTZsLTYuOTYsMi4wM2wwLjM3LC0xLjE0bC0wLjk4LC0zLjIybDAuMSwtMS41NWwxLjQsLTQuMDRsMTMuNTgsMC4wOGwxLjA4LC0wLjQ2bDIuMjIsMS4zOWwxLjE1LC0wLjA1bDAuNDgsMC43OWwyLjMyLDAuMTJsMC43NSwtMC4zNmwyLjEsMS4wM2wyLjk1LC0wLjA2bDEuNTQsMC4zOWw0LjA3LDIuNzlsMS4xMywtMC45M2wtMC43OCwtMy40OWwwLjExLC0wLjg2bDEuMTQsLTEuMjRsMC4wNywtMC42OWwzLjMxLC02LjUybDAuMTQsLTQuMDJsMS4wNSwtMy4zN2wwLjM2LC0wLjM3bDcuMDQsLTEuMDNsMi41MywtMS4wMWw0Ljk0LDEuNTFsMi42NiwwLjAzbDAuODYsMC42M2wxLjkyLC0wLjk3bDEuNjksLTAuMzhsMC41OSwxLjAzbDAuNjMsMC40MmwwLjEyLDEuNzVsLTEuNSw0LjM1bC0zLjI5LDYuMDFsLTEuNjQsNC43MWwtMC4xOCw1LjY1bC0xLjgzLDQuOTZsLTAuMTksMy4xNGwwLjQ2LDMuN2wtMC40MywzLjQ2bC0xLjMyLDMuMzFsLTAuNTksMi43bDAuMzEsMy4xM2wtMi4zMiwyLjVsLTMuMDMsMi41N2wtMy41NiwxLjY1bC0xLjE4LDEuMDZsLTQuMDQsNy4yN2wtMy44LDMuOTRsLTAuMzcsMS40N2wwLjMsOC43N2wtMC44MSw0Ljk5bC0zLjEsNS4zM2wtMy4wNCwxLjA3bC0xLjAsMC43NGwtMC42LDEuMDVsLTIuNDcsMS41NmwtNS42OSw2LjI5bC0wLjcsMC4zNWwtMi45OCwtMC4zOWwtMC40OSwtMi42NmwwLjk0LC0xLjcybC0xLjEzLC0xLjg5bC0wLjM4LC0wLjE4bC0zLjgyLDEuNDVsLTEuMTQsMC43M2wtMS42NiwtMC41N2wtMS4wNCwwLjI3bC0wLjU1LDIuOTNsLTIuODYsMS41bC0xLjk2LC0xLjQybC0wLjk2LC0xLjE4bC0xLjE3LDAuMDZsLTEuOTMsLTIuMDFsLTEuMzMsLTAuMTdsLTEuODYsMS4xOWwtMi45MiwxLjBsLTAuOTksMS43M2wtMS4zNiwwLjMybC0xLjc5LDIuMjhsLTIuMDIsLTIuNTNsLTAuNDMsLTAuODhsLTAuMTMsLTEuNDJsLTcuNDMsLTcuNDlsMS4wNiwtMi4yOGwyLjkzLC0xLjg0bDEuOTUsMS44N2wxLjk4LDAuMThsMC44LC0wLjcxbC0wLjA2LC0wLjgxbC0wLjQ4LC0wLjczbDEuMTcsLTIuNTNsLTAuMTYsLTAuMzhsLTIuNDksLTEuNmwtMC4xOSwtMC4zNmwwLjcyLC0xLjAybDAuMDksLTAuNjdsLTEuNTYsLTEuNzZsLTAuOTQsLTAuMjNsMC42NiwtMi40N2wtMC4zMSwtMi41N1pcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJDR1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTQ3NC4xNCw0MTIuNDZsMC42LC0wLjA3bDAuNDMsLTAuNDdsLTAuOSwtMy4xMmwtMC41NiwtMC45N2wtMi45NiwtMi4zNGwtMC42LC0xLjA1bC0wLjgsLTYuMDJsLTAuOSwtMS4xN2wwLjYzLC0yLjQ4bDAuMCwtNC4zNWwtMC41MywtMC44MmwtMC45OSwtMC4xN2wtMC42NCwtMS4xbDAuNzgsLTEuMDhsMi43NSwtMS40OGwxLjQ2LC0zLjI5bDIuMDQsLTIuNzNsMi4wMiwtNC45NWwyLjAsLTEuNzZsMS4wNiwtMS43NGw0LjAzLDAuNTVsMS40NywtMC4zOWwwLjk1LC0wLjc5bDQuMCwtMS4yOWwwLjUzLC0xLjJsMS4wMSwtMC43NmwxLjQzLDIuMjJsMS43NCwxLjMybDAuNjEsLTAuMTlsMC43NywtMC44MmwyLjYyLC0wLjhsMS41NiwtMS4zM2w0LjU3LC0xLjk0bDMuMzYsLTAuMDNsNy40OCwtMC43NmwwLjUsLTAuMzhsMC40NiwtMS4xOGwxLjI4LC0wLjg1bDEuODYsLTEuOWwyLjQsLTMuMGwtMC41MiwtMS4xOGwtMi4wMywtMS41OGwxLjY3LC0xLjExbDEuMDMsLTAuMjJsNi4xNiwtMC4wNmwzLjM3LC0wLjY1bDEuNCwtMC42N2wzLjI5LDAuMGw1LjEyLC0zLjM1bDIuNDksLTIuNzVsMC4zNCwtMC45NmwyLjc5LC0yLjlsMC44NSwwLjA1bDAuNzgsLTAuNDZsMS41MSwtMi40bDEuMTUsLTAuMzVsMC43NCwtMC43MWwwLjYyLC0xLjE4bC0wLjA1LC0yLjZsMi42MywtMS40M2wwLjk3LC0xLjAxbDEuMzMsLTAuMDhsMC45NCwtMC44bDIuODQsLTEuMTRsNC4wLDAuODZsMS4xNiwxLjg3bDQuMDgsNC4zMWwyLjcsNC4ybDEuMTUsMi4zN2wtMC4yOCw1LjUybC0wLjI3LDAuODFsLTEuNTQsMS45MWwtMC4wMywwLjk5bDAuOTksMS4ybC0wLjA1LDEuNjVsMC43LDAuN2wxLjEzLDAuMzlsNS45MiwwLjlsLTAuMjksMi4wNGwwLjQ0LDEuMjZsMC45NywwLjkybDIuMTEsMC43MWwzLjI2LDAuNTZsMS4yNCwwLjU4bDEuOCwyLjAybDIuMjEsMS44bDAuNDUsMC44bC0wLjc1LDEuOThsMC4yLDAuNjNsMS4wNCwxLjA4bDEuMjgsMS4xOGw1Ljk1LDMuMTZsMS42NCwxLjIzbDEuNTYsMi4wNGwyLjEsMS42bC0wLjU1LDEuODdsMC4xOSwwLjkxbDEuMTUsMS41NGwxLjExLDIuNDFsMS4wNiwwLjc0bDEuNjIsMC4yN2w0Ljc2LDMuMTNsMC44OSwxLjY3bDAuMzMsMy4yMWwwLjg2LDEuMjVsLTIuNzUsLTAuNjRsLTIuODMsMS41OWwtMTUuMzYsLTIuODlsLTEuNjQsMC44MmwtMS42NSwyLjU4bC0xLjk2LDAuNjFsLTEuMDksLTAuMTZsLTIuNCwwLjZsLTMuNzYsLTAuOTJsLTEuNTIsMC4xOGwtMTAuNiwzLjg5bC0xLjA3LC0wLjBsLTIuMzcsLTAuODZsLTMuMDMsMC4xNmwtMi4wNCwxLjdsLTIuNDQsNC41NGwtMC43MywwLjY1bC04LjQ4LC0xLjY5bC0xLjc4LDAuNDFsLTIuMTYsLTAuNzZsLTEuNTIsMC4wN2wtMS4wMywtMC4zbC0yLjA1LC0wLjk3bC00LjUyLC0wLjU0bC0xLjg5LC0yLjU4bC0xLjk2LC0xLjY5bC0yLjY5LC0xLjRsLTIuMjEsLTEuNjNsLTEuNjksLTAuNWwtMi4zMSwtMC4wNWwtMi4xOSwwLjcybC0yLjk5LDIuMTFsLTIuODYsNC40MWwtMS40NSwxLjU2bC0xLjQsMC42NmwtMC4zLDEuM2wwLjYsMS42MWwwLjE1LDEuODFsLTAuNDMsMy4xOWwwLjEsMS41OWwtMC42LC0wLjk4bC0wLjY0LC0wLjI5bC0xLjksMC41MmwtMS41MywwLjg4bC0wLjYzLC0wLjU2bC0yLjc1LC0wLjA2bC00LjYzLC0xLjU1bC0zLjIsMS4wNWwtNi4zOSwwLjczbC0xLjAyLDAuNDdsLTAuNTcsMC42NmwtMS4wOCwzLjQ1bC0wLjE0LDQuMDFsLTIuOTMsNS43N2wtMC41LC0xLjU3bC0wLjU5LC01LjI5bC0xLjYzLC0yLjAybC0xLjg0LC0wLjY1bC0zLjY0LC0zLjc5bC0zLjgzLC00LjMxbC0wLjg3LC0xLjY4WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkNGXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNDQxLjgyLDUzMS4ybDUuNTEsLTEuMDJsMy4zMywtMS42NGwxLjE5LC0wLjA5bDEuMzMsMC4yOWw4LjAsLTAuMjhsNC45NSwwLjQybDIyLjQyLC0wLjMybDEuMjYsMC4zN2wxLjE0LDAuNzFsMS43OSwyLjI1bDAuMSwzLjQybDAuNCwxLjc5bDIuMSwzLjgxbDAuNDksMS4zN2wtMC4xMywxLjJsMC40NCwxLjNsMS45OCwyLjM5bDQuNDcsNy4yNGwwLjksMC40NWwzLjc4LC0wLjM2bDEuMjcsMC40NmwyLjIsLTEuMGw0LjMsLTEuMDJsNC4zNywwLjc3bDIuMzUsMC4wbDIuMzksLTAuNDJsMC4zMywtMC4zNWwwLjM2LC0zLjYybDEuMjcsLTIuMjJsMC4wNSwtMi4yNWwwLjQ2LC0xLjQxbDEuMzksLTEuMTNsMi40LC0wLjU3bDcuOTMsLTAuNzlsLTAuNjUsMi43MWwwLjI5LDAuODdsMC43MywwLjU5bDEzLjk2LDAuNTRsMC4zNCwwLjg4bC0wLjA5LDIuMDJsLTAuNjMsMy4xOWwwLjI0LDIuOTFsMS4xMiwyLjc2bDAuMTEsNC4wNWwtMC44OCw1LjU4bC0wLjIsMy41OWwwLjU4LDEuNzNsMi43NCwzLjJsMS4yMywyLjAzbDAuODgsMi41MmwwLjM2LDUuMGwtMC4yNCwwLjg2bC0wLjc3LDAuNDZsLTAuNDcsMC45NGwwLjYxLDMuMTFsMC42MiwwLjg2bDAuNywwLjIybDMuMDEsLTEuNjlsNi4wNCwwLjM3bDQuNDksLTEuNGw0LjMyLDAuNTJsMC45NywtMC40bDAuMzMsLTAuODNsMC4xMiwwLjc1bDAuNjYsNC42NmwtMC44NywyLjg2bC0wLjE1LDUuNjZsMC40NCwyLjhsLTEuMzMsNS4yOWwwLjk3LDEuOTRsLTIyLjg5LDAuMWwtMC40LDAuNGwwLjAxLDM1LjM4bDAuNzMsMy44MmwxLjQ0LDQuMjNsMy41OCwyLjU5bDMuMDksMy4xNGw3LjExLDYuM2wtMjIuMTgsNC4xOWwtMS40NywtMC40NmwtMi4wNSwtMC4wOWwtNC4zMSwwLjc3bC0yLjY0LC0wLjc3bC0xLjQ3LC0wLjgybC0yLjQsLTAuMjlsLTYuNDQsMC4wNmwtMy4wOCwtMC41MmwtNC45LC0wLjI2bC0yLjYxLC0xLjEzbC0yLjc0LC0zLjE2bC0xLjI5LC0wLjZsLTQ2LjcxLC0wLjE0bC00LjY0LDAuMjVsLTAuNzUsLTAuMmwtMi44NCwtMS44NmwtMS41LC0xLjA3bC0xLjExLC0xLjI5bC0wLjk2LC0wLjQybC0zLjU5LC0wLjQ5bC02LjU5LDIuOTVsLTMuNzQsLTAuMDNsLTEuMDksLTAuNTFsLTEuMzYsMC4wMWwtMS40MiwwLjcxbC0xLjMsMC4xOWwwLjg0LC02LjExbC0wLjI2LC04LjY2bC0wLjQ5LC0xLjY2bDEuNjIsLTEuMjlsMC44NSwtMS4xM2wwLjU3LC0xLjQ1bDAuNjgsLTMuMjNsMi40MiwtNy4zbDEuMTYsLTcuMThsMS40NywtMy40NWwwLjUzLC0zLjY4bDQuMCwtNC44MWwxLjAzLC0zLjAxbDQuOTQsLTIuOTRsMi4yOSwtMi45NmwxLjA2LC0yLjBsMS4xNywtMy43bDAuMDEsLTMuOTVsMC43NCwtNS4xMmwtMC4xNiwtMS41OGwtMS4xMiwtMi4xM2wtMC4yNywtMS41N2wtMi4xLC0yLjVsLTAuNTQsLTEuOTRsLTEuODgsLTMuMDFsLTAuNTEsLTEuOThsLTAuOTEsLTEuNDlsLTAuNjMsLTMuNjhsLTEuODMsLTQuMDJsMC4wLC0wLjI4bDAuNTQsMC4xNWwzLjY3LC0zLjk0bDAuMjEsLTQuMDRsLTMuMzcsLTYuOTVsLTIuNjYsLTYuNDFsLTAuNTQsLTMuNDFsLTMuNTIsLTQuMjZsLTIuNjIsLTUuMjdaTTQ0MC45Miw1MjYuMzZsLTAuMjMsMC4wNmwtMC40NiwtMS4wNGwwLjU3LC0xLjk4bC0wLjM0LC0xLjY5bC0xLjcyLC0zLjYzbDEuODksLTIuMzRsMS4yNywtMC4yNWwwLjkzLC0xLjY3bDIuODQsLTAuOTlsMC45OCwtMC43NWwxLjIxLC0wLjQybDIuMDEsMS45OWwtMi40MywwLjk1bC0yLjcxLDIuODFsLTEuNjYsMS4wN2wtMC4xNSwwLjU5bDAuODEsMC44MWwtMC4yMSw2LjEybC0yLjU4LDAuMzVaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiQU9cIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk00NDEuMDgsNTI3LjE0bDIuNjIsLTAuMzJsMC41LC0wLjQxbDAuMzEsLTYuNjhsLTAuNjcsLTAuODFsMS40MSwtMC45bDIuNjksLTIuNzlsMi41OSwtMC45OGwwLjYsLTAuNTNsMi43MywyLjU2bDAuOSwwLjE0bDMuMCwtMS40N2wwLjM4LC0wLjU1bDAuMzYsLTIuNThsMi4yNSwwLjVsNC42OSwtMi4xNWwwLjg1LDEuMjZsLTAuOTMsMS44MmwwLjY2LDMuMDZsMC42NSwwLjQzbDMuMjYsMC4ybDAuOTUsLTAuNTFsNS42NiwtNi4yN2wxLjUyLC0wLjc2bDIuMzQsLTIuNDZsMy4xNywtMS4xM2wxLjU1LC0yLjExbDEuOTEsLTMuNzFsMC44MywtNS4wOWwtMC4yOSwtOC44NWwwLjI0LC0xLjA0bDMuOCwtMy45NWwzLjk0LC03LjE0bDIuNTQsLTEuNzlsMi4xLC0wLjgybDMuMSwtMi42M2wyLjUsLTIuNjhsLTAuMjMsLTMuNDNsMC41NSwtMi41NWwxLjM2LC0zLjQzbDAuNDQsLTMuNTZsLTAuNDYsLTMuODFsMC4xOSwtMi45N2wxLjgzLC00Ljk0bDAuMTcsLTUuNThsMS42LC00LjYybDMuMjYsLTUuOTVsMS41NywtNC41MmwtMC4yOCwtNC41MmwwLjQzLC0zLjI4bC0wLjE2LC0xLjkxbC0wLjU5LC0xLjY0bDAuMjIsLTAuNzJsMS4yMSwtMC40N2wxLjU1LC0xLjY1bDIuNzgsLTQuMzJsMi44OCwtMi4wM2wxLjk2LC0wLjYzbDMuMzIsMC40bDIuMywxLjY4bDIuNjEsMS4zNWwxLjg4LDEuNjJsMi4xMiwyLjc0bDQuNjUsMC41OGwyLjAxLDAuOTVsMS4yMiwwLjM1bDEuNDMsLTAuMWwyLjE2LDAuNzdsMS45MSwtMC40bDIuNSwwLjMxbDYuMDEsMS4zOWwxLjM2LC0wLjk3bDIuNDUsLTQuNTVsMS42MiwtMS40MWwyLjcyLC0wLjE0bDIuMjMsMC44M2wxLjM4LDAuMDRsMTAuNywtMy45bDEuMjUsLTAuMTdsMy43OCwwLjkybDIuNjEsLTAuNmwxLjEyLDAuMTZsMi4zNCwtMC43OWwxLjc1LC0yLjY3bDEuMjQsLTAuNTZsMTUuMDksMi45MmwwLjg3LC0wLjIzbDEuNzEsLTEuMjRsMC44NiwtMC4xMmwzLjE3LDAuOThsMC45OCwxLjU3bDIuMDgsMS40OWwxLjQ3LDIuMzdsMi4yNSwxLjMzbDEuMTUsMS4yNWwxLjU5LDAuOThsMi44MSwwLjNsMy41NywtMi4xMWwyLjMxLDAuMmwyLjM2LDEuMTFsMS4wOSwwLjAybDIuMDgsLTEuMzJsMS4wMSwtMS4zMmwwLjcxLC0wLjIxbDEuMjYsMC41bDEuMTEsMS4xNWwxLjExLDEuODZsMy43OCw0LjAzbDMuNjksMS43NWwwLjQ5LDEuODhsMC40MywwLjU4bDIuMDUsMC4wNmwwLjg0LDEuNDFsMC42NywwLjQxbC0xLjM4LDMuMWwtMC4zMiwxLjVsMS4xMiwxLjg2bC0wLjkzLDIuMzlsLTAuNDksMi43MWwxLjQsMS4wbDEuNiwwLjAybDEuMzEsMS4yN2wxLjAzLDAuMThsMC44LDEuMGwtNC4zNiwzLjIzbC00LjA0LDMuOWwtMS42OCwyLjc5bDAuMTksMC44OWwtMC45MiwwLjM2bC0wLjk1LDAuOTdsLTAuNzEsMS41NWwtMi44NiwxLjlsLTAuMTQsMy44MWwtMS43NiwzLjc0bC0wLjcxLDAuODRsLTAuMzksMi4zOGwtMi4yMywwLjkzbC0yLjAsNC4xMmwwLjEsMC45bDAuODEsMC45NGwxLjg2LC0wLjQxbDAuODEsLTAuNjRsLTAuODUsNC42MmwwLjIsNC41NmwtMi41OCwxLjUybC0xLjE5LDEuNWwtMS42OCwtMC42bC0wLjg2LDAuNjFsLTAuNjEsMi4zN2wtMC45LDEuOTZsMC4wMywwLjk2bC0wLjUsMS4zNGwwLjQ4LDEuMDdsLTAuNTksMC44M2wtMC4xNSwxLjFsMC44OSwyLjk5bDEuMDMsMC41MWwwLjE0LDAuOTRsMi4zMywyLjg0bC0wLjE1LDIuODdsLTAuODEsMS4xNGwwLjA2LDIuNDZsLTAuNTEsMS45NGwtMC4yMSwzLjYxbDAuMTQsMS4zOGwtMC40NywxLjAxbDAuMzIsMC42N2wwLjgyLDAuMzFsMC41MSwtMC4xNWwwLjIzLC0wLjQ0bC0wLjIsMS43NGwtMC41NCwwLjM4bC0wLjM3LDAuOTFsLTAuMjYsNS42MmwwLjY4LDIuMjRsMi4zNiw0LjJsLTAuMzIsMC41MWwtMC4wLDEuNDlsLTEuNjksMS41NWwwLjA3LDEuNjZsMS40MiwxLjlsMS4zMiwzLjUxbDAuNjMsMC40NmwtMC4wMiwxLjEybDAuNzIsMS41M2wyLjU5LDIuOTFsMy4wOCwxLjc4bDEuNDUsMS42N2wwLjY4LDEuOTZsLTAuMDQsMS4zM2wwLjkyLDMuMjRsMy4wMSwyLjU4bDAuNDYsMS4yM2wtMTkuNDMsMy4xbC0wLjI3LDAuNTJsMC4zOSwxLjE1bC0wLjE3LDEuMTNsLTAuNTIsMC45MmwtMi4xNSwyLjYzbC0zLjQxLDIuNzdsMC4wNSwwLjhsMS42MywyLjc1bDAuNzIsMS45M2wwLjI5LDEuNzNsLTAuMjYsNi42M2wwLjQ0LDEuOWwtMC4wNywxLjI0bC0xLjExLDEuNjRsLTIuMTgsOC4wMmwwLjMsMS4yNWwxLjI0LDMuMDZsNC4zMywzLjY5bDIuNzMsMi44M2w0LjIxLDAuOTdsMC44OSwtMC4xNGwwLjU0LC0wLjc5bC0wLjA1LC0xLjU4bDEuODYsLTAuMjVsMC44LC0wLjQybC0wLjEzLDE0LjQ3bC0wLjc4LC0wLjJsLTAuMzMsLTEuNGwtMS4wOSwtMC43MmwtNC4zMywxLjc3bC0xLjkxLC0wLjMxbC0wLjY4LC0wLjU5bC0wLjI3LC0xLjExbC0yLjI4LC0zLjQ5bC0wLjY3LC0wLjc2bC0xLjQ0LC0wLjM3bC0wLjgzLC0yLjM4bC0wLjg2LC0xLjQxbC02LjU5LC0yLjgxbC0yLjUyLC0wLjIzbC0wLjczLC0wLjQybC0xLjYyLC0zLjJsLTIuMTgsLTEuOTZsLTAuNDYsLTIuMGwtMC42LC0wLjU0bC0xLjA3LDAuMTFsLTAuODYsMC41bC0xLjExLDMuM2wtMS4yMSwwLjYxbC0yLjU1LDAuMDdsLTYuNjIsLTAuOTZsLTQuNzYsLTEuNzNsLTEuMjIsMC4wOGwtMS43MywtMS4zOGwtMC43MSwtMi4zN2wwLjQxLC0xLjg1bC0wLjc0LC0wLjgxbC03LjM4LDEuNjhsLTEuOCwxLjAybC0xLjI4LC0wLjIybC0wLjIsLTAuMjJsMC41OCwtMS40NmwtMC40MywtMS42NGwtMC43MywtMC44M2wtMS45NywtMC41NGwtMC45MiwtMS42MWwtMS4zLC0wLjIzbC0wLjcxLDAuMjdsLTAuNSwxLjE3bC0wLjUxLDAuMjNsLTQuMzEsLTAuNTJsLTQuNTMsMS40bC02LjAsLTAuMzhsLTMuMSwxLjY3bC0wLjQ1LC0wLjYzbC0wLjUzLC0yLjU3bDEuMTYsLTEuMTlsMC4zMSwtMS4xbC0wLjI4LC0yLjg2bDAuMjQsLTAuODJsLTAuMzMsLTEuNjNsLTAuOTUsLTIuNzJsLTEuMjcsLTIuMTFsLTIuNzEsLTMuMTVsLTAuNDcsLTEuMzZsMC4xOSwtMy40NWwwLjg5LC01LjY3bC0wLjExLC00LjE2bC0xLjEyLC0yLjc5bC0wLjIzLC0yLjc5bDAuNzIsLTUuMjVsLTAuNDQsLTEuMjVsLTAuNDYsLTAuMzdsLTEzLjg0LC0wLjQ5bC0wLjU3LC0wLjc5bDAuNzIsLTIuNzNsLTAuNDcsLTAuN2wtOC40OSwwLjc5bC0yLjUyLDAuNmwtMS44NCwxLjUzbC0wLjUxLDEuNTlsLTAuMDUsMi4yNWwtMS4yOCwyLjI5bC0wLjMzLDMuMzVsLTQuMjcsMC4zNWwtNC40OSwtMC43N2wtNC40MiwxLjA0bC0yLjAzLDAuOTdsLTEuMTgsLTAuNDZsLTMuODMsMC4zNmwtNC43NCwtNy4zNmwtMS45NSwtMi4zNGwtMC4zMywtMS4wM2wwLjEzLC0xLjIybC0wLjU0LC0xLjUxbC0yLjA3LC0zLjcxbC0wLjM4LC0xLjY2bDAuMSwtMi41OWwtMC4yNSwtMS4wN2wtMS45NSwtMi40OGwtMS40NCwtMC45bC0xLjQ4LC0wLjQybC0yMi40NywwLjMybC03LjQ1LC0wLjQ0bC01LjQ2LDAuM2wtMy41MiwtMC41MmwtMi41NiwwLjUxbC0xLjM1LDAuOTlsLTEuODEsMC40N2wtMC45NSwtMC4xNmwtMS45NCwtMi4wOFpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJDRFwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTQwMC40Nyw0NjcuODZsMS43NiwtMC4xbDAuNjgsLTAuNjJsMS4xMSwtMC4yNGwyLjU4LC0zLjI2bDAuNTcsLTMuN2wtMC4zMywtMy45OWwwLjQyLDEuMThsMC43OSwwLjYxbDEuMzgsMC4xOWwyLjQ4LDEuMTZsMC42MiwtMC4yNWwwLjE0LC0wLjczbDIuMCwtMC43NGwwLjI2LC0wLjM2bC0wLjkxLC0wLjY3bC0yLjA3LDAuMjdsLTIuNTQsLTEuMTRsLTIuNCwtMi44M2wxLjYyLC0wLjc1bDEuMCwxLjA3bDAuOCwtMC4zOWwwLjEsLTIuNDNsLTAuNTEsLTIuNjRsMS40NCwtMC40NGwwLjY3LDAuOWwxLjM2LDAuNDZsMS4zOCwtMC41MWwxNS4zLDAuMDVsMC40LC0wLjRsLTAuMDgsLTEzLjY3bDAuMjgsLTEuMTlsMTEuNDIsMC4wNWw1LjkyLDAuNThsNC4wMywtMC4xMmwwLjU4LDAuNzhsLTAuMDUsMC42NmwtMS4zNiwzLjU1bC0wLjEzLDEuNzNsMC45OCwzLjMybC0wLjQ4LDAuN2wtMC4wOCwwLjU5bDAuMzEsMC4zNmwxLjA5LDAuMjFsNi43LC0yLjA3bDMuNjUsMC41M2wwLjUyLDAuNDJsMC43MSwyLjI1bDEuNDgsMi41N2wwLjA2LDAuNzhsLTEuMjUsMi4xM2wtMC44OSwwLjdsLTEuNTgsMC4xNmwtMC41LDAuMzdsLTAuNTIsMS4wN2wtMC45MSwwLjkybC0wLjgsMi4xMWwtMC4xOCw0Ljg4bDAuNjcsMC41OGwxLjkyLDAuMzFsMS40NiwxLjczbDEuOTUsMC41OGwxLjE1LDEuMzhsLTAuODEsNC4wOGwwLjUyLDUuMjZsLTAuMDksMS4xOGwtMC41MywwLjkzbDAuMjIsMS40bC0wLjQyLDEuODlsLTEuNSwxLjI1bC0wLjYxLDIuMTFsLTAuNTEsMC42N2wwLjQzLDEuNDJsLTEuMTQsMS4xNGwtMC44OCwwLjIybC0xLjAxLC0wLjI0bC0wLjAyLC0xLjQ4bC0xLjA2LC0xLjg4bC0wLjc4LC0wLjQ4bC0wLjUzLDAuMTZsLTEuMjcsMS41NGwtMS42OCwxLjI4bC0xLjA5LDAuMWwtNC4wMywtMS4wbC0yLjM1LC00LjQ2bC0xLjAxLC0wLjc4bC0xLjU5LC0wLjU0bC0xLjcxLDAuOTRsLTAuNTgsMC42NWwwLjE0LDEuNDdsMC40LDAuNzVsLTAuMzUsMi4xNmwtNC4wNiwwLjg4bC0xLjQzLC0wLjc3bC0yLjUzLDAuNTZsLTEuNjksLTAuNTJsLTAuNSwwLjUybDAuMywyLjc4bC0wLjc1LDIuNzJsMC4zMSwwLjVsMS4wOCwwLjJsMS4yMSwxLjMxbC0wLjgzLDEuMzlsMC4zNCwwLjg5bDIuNDksMS42NmwtMS4xNSwyLjM3bDAuNTgsMS4ybC0wLjE1LDAuMjdsLTEuNTYsLTAuMTFsLTEuNjcsLTEuNzZsLTAuODcsLTAuMTNsLTMuMjQsMi4wNmwtMS4xMSwyLjI1bC0wLjY3LC0wLjYxbC0xLjAzLC0xLjk2bC0zLjU2LC0zLjA4bC0wLjY3LC0xLjQybC0yLjc5LC0zLjExbC02LjIyLC01LjE3bDIuMDEsMC44M2wwLjgzLC0wLjUzbC0wLjA3LC0wLjY0bC0yLjM5LC0xLjI3bC0yLjE4LC0wLjM2bC0wLjQzLC0wLjRsLTEuMDYsLTIuMzZsLTEuODgsLTIuMThsMC43OCwwLjM4bDAuNTQsLTAuMTlsMC4wMiwtMS4wOGwtMS44NywtMS4wMWwtMC43OSwtMC4wN2wtMC4wMSwtMC45NmwtMC44NywtMS43MmwxLjE3LDEuMTlsMS4xMSwwLjAzbDEuNDcsLTAuNDRsMC4yNCwtMC41N2wtMC4yNiwtMC41MWwtMC43MSwtMC42NmwtMS43NSwwLjA5bDAuNjYsLTEuNzlsLTAuNDcsLTAuNTRsLTEuNDksMC42NGwtMS40MiwtMC44NmwtMy4zOCwtNi4zNlpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJHQVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTE0MS43MSwzNTIuMjlsMC4yNCwtMS4wNmwtMS40NywtMS43MWwtMC41NiwtMS4zNGwtMS41NSwtMS40NmwtMS4xNSwtMC4wNWwwLjIyLC0yLjQybC0wLjQ4LC0wLjk2bDAuMTEsLTAuNzdsLTAuNDgsLTAuNDVsLTAuODIsMC42MmwtMC40NywtMC4xMmwtMS40NywtMC45bC0wLjY3LC0wLjhsLTAuMzEsLTEuMTRsLTEuNzMsLTAuMDVsLTIuODIsLTEuMzNsLTIuMDMsLTMuMzlsMC4xOSwtMi41MmwtMC42NywtMC4yMmwtMC41MSwwLjQ4bC0xLjE3LC0yLjVsLTEuNjksLTAuNDJsLTAuNjEsMC40OGwtMC40OSwxLjRsLTAuMiwtMC4xNGwwLjA3LC0wLjkxbDEuMTMsLTEuNTVsMS45MiwtMy45MmwwLjkyLC0xLjA0bDIuNjgsLTAuNThsMi4xNiwtMS4yMWwzLjYxLC0wLjA2bDIuNjgsLTAuODdsMC4yNywtMC4zNmwtMC4wNywtMy4zM2wtMi40NiwtMi4xNGwwLjg0LC0wLjQybDEuMTgsLTAuMDVsMC43OCwtMC44MmwwLjQyLC0yLjA1bC0wLjY3LC0xLjk1bDcuMDQsMC40NWwtMC4xNywwLjkybDAuNDksMC43OWwwLjg3LDAuMTFsMC44MiwtMC41N2wxLjQyLDAuOTFsMy4wOCwwLjkxbDAuODgsLTAuMDJsMC43NSwwLjQ1bDEuNDQsMC4xMmwyLjgzLC0wLjgxbDIuNzcsMC4xMmwyLjcsLTAuNDZsMS4zOSwwLjEybC0wLjkyLDIuMGwwLjA4LDAuNjlsMi4zMywyLjBsMC42OCwwLjIxbDAuODUsLTAuMjZsMS44LC0xLjhsMS4xMiwtMC4zMmwyLjE3LDMuMjhsMC42MywwLjM3bDEuMjcsLTAuNTdsMS44MywtMi4zNmwxLjk5LC0wLjc4bDUuMTgsMS45N2wxLjUxLDAuMDFsMC44MywtMS4yOWwzLjU2LC0xLjQxbDAuMzcsLTEuMTFsLTAuNjcsLTEuMzhsMS41NiwtMC4wNGwxLjg0LDAuODdsMC40NCwwLjU3bDIuMDcsNC45M2wwLjE1LDMuMjFsMS4xNywwLjU1bDAuNjUsMS4zMWwyLjk1LDEuNTFsLTEuMzQsMS4yM2wtMS43LDIuNGwwLjAzLDAuODNsMS4wNywwLjM3bDEuNTEsLTAuNjlsMS4yNiwwLjU1bDAuMjUsMC44MWwtMC4yLDEuODNsMC43NCwzLjI5bDAuNTUsMC42OWwyLjUxLDEuMzJsMC4xNywwLjM2bC0wLjA1LDEuMDhsLTEuNTgsMS41bC0wLjM1LDAuNzVsMC4xOSw1LjgxbDAuNjQsMC45OWwwLjgsMC41bDEuMzYsLTAuMDhsLTAuMjMsMi4xNWwxLjQ3LDEuMThsLTEuNTksMS4wN2wtMC4yNiwyLjU3bDIuMTEsMS4xbDAuNjUsMC43OGwwLjQsMi40OGwtMS4yNywtMS4wMWwtMi42NiwtMC4zM2wtMi4xNiwwLjI2bC0wLjQzLDAuNTVsLTAuMDksMi43NGwxLjQ0LDAuOTFsMS4xNCwwLjJsMC4xNiwwLjZsLTEuMzMsMi4zOWwwLjA5LDEuMzNsLTEuMCwxLjg5bC0yLjIzLC0wLjMybC0wLjcyLDAuNGwtMC45NCwtMS4yN2wtMS4zLC0wLjFsLTAuNzMsMC41NGwtMC4zOCwxLjg4bC0xLjYsMi41MmwtMC45LC0wLjBsLTEuMzIsMC41M2wtMS44MSwtMS44NWwtMS4wOCwtMC4zN2wtMC45NSwwLjFsMC44NywtMS41NmwwLjE3LC0xLjc1bC0wLjg5LC0yLjM0bC0wLjA3LC0xLjM5bC0wLjcsLTEuOTZsLTAuMDgsLTEuNzdsLTEuOTEsLTEuODhsLTAuODUsLTAuMDRsLTAuNjMsLTAuNzZsLTMuMTUsMS4xNWwtMC4yOSwtMC41N2wtMC44MywtMC4zNmwtMS4yLDAuMzZsLTEuNTYsLTAuMDVsLTIuMjgsMi4wOGwtMS4xLC0wLjE1bDAuNzQsLTEuNzZsMS40MSwtMS40OGwwLjE0LC0wLjU2bC0xLjIzLC0yLjI2bC0wLjEyLC0yLjIybC0wLjMyLC0wLjM0bC0xLjI0LC0wLjI2bDAuNzEsLTEuNjdsLTAuMDUsLTAuODJsLTYuMzIsLTguMTJsLTAuOTEsLTAuMjRsLTcuNDgsMC4wNGwtMC40OSwwLjlsLTIuMTksMC40OGwtMS43MSwtMC42MmwtMS44NiwwLjQxbC0xLjA3LDAuNjdsLTAuNjIsMS43NmwtMi4yOSwzLjg4bC0wLjc4LDAuNzVsLTEuNDEsMC40M2wtMC43MSwxLjU4bC0wLjc2LDAuNzRsLTEuOTUsMC4wM1pcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJHTlwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTEwMC45NSwzMDQuMzFsLTAuNjIsLTIuMzJsMS4zNiwtMS4yMWwxLjAzLDEuODFsMi4wNiwwLjU1bDIuNTYsLTAuMTVsMC40NSwtMC40MmwwLjE4LC0wLjgybDYuMTEsLTAuODdsMS43NywwLjAxbDAuNTEsLTAuMTJsMC4yNCwtMC42MmwtMC40LC0wLjM0bC0xLjY1LC0wLjJsLTYuNiwwLjYxbC0yLjU5LDEuMjRsLTAuNzcsLTAuMDlsLTAuODksLTEuMDZsLTAuMjQsLTAuOThsMTEuODQsMC4wM2wxLjI1LC0xLjc2bDEuNjcsLTAuNjdsMS44LC0wLjI2bDEuODQsMC4yOWwxLjkzLDEuMzRsMi4zMiwwLjY2bDIuMDcsMS4zOGwxLjA5LDAuMThsMi4xLC0wLjU2bDEuODIsLTAuMDhsMS4yMywwLjY1bDAuMjEsMC41OGwtMC4xNSwwLjUybC00LjM4LDEuMTFsLTIuMTMsLTAuMzdsLTYuODQsLTIuOWwtMS44MSwtMC40OWwtMC42NiwwLjQ2bC0wLjksMS40M2wtNi4xMiwwLjg0bC0wLjMxLDAuMzVsLTAuMTksMS42NmwtOS4yLDAuMDNsLTEuMCwwLjU5WlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIkdNXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNODcwLjg0LDMyNy4xMmwtMC4wMSwyMC44NmwtMTEuMDcsMTYuOTFsLTExLjQyLDAuMGwtMzQuNTksLTExLjY1bC00LjYyLC00LjA4bC0xLjY1LC0wLjU0bC0wLjk2LC0xLjFsLTEuMDQsLTEuNDlsLTEuMzksLTMuMTJsLTEuNDMsLTAuNzRsLTIuNjEsLTMuMmwtMC42NSwtMS45bC0xLjQ0LC0yLjYxbDYuNiwtMTAuMDRsMS44OSwxLjVsMi4xOSwzLjYzbDIuNywzLjA5bDUuMDMsMy43MmwxLjQ4LDAuNTZsNi43MSwtMC4xM2w0LjYxLC0yLjUybDUuNDUsLTIuMTZsNy40NSwxLjE5bDEuMzYsLTAuMTNsNC45MSwtMi4xNmwzLjA0LC0yLjA4bDEuOTQsLTAuODNsMy41NiwwLjc0bDMuNiwtMC4zMmw2LjUsLTIuMTVsMS4wOSwtMC4wMmwyLjc1LDAuOFpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJYU1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTI4Ljg0LDI2Ny42OGwxLjM5LDAuMDhsMC40NywwLjQ0bC0wLjE1LDEuMDNsLTEuMDYsMC41NmwtMS4wNiwtMC40NGwwLjQxLC0xLjY3Wk0yOC4xOSwyNjAuNGwwLjAxLDAuODJsMC4wNywwLjM2bC0wLjI2LC0xLjA3bDAuMTksLTAuMTFaTTI1LjIyLDI4MC4wMWwtMC4yOCwtMC4yNGwwLjA2LC0wLjc3bDAuMjMsLTAuNDNsMC4zNCwwLjAzbDAuMTQsMS4xOGwtMC40OCwwLjIyWk0xOS4wMSwyNzkuMTFsMS45LDEuNTdsMC44NiwxLjI3bC0wLjQ0LDAuNjhsLTEuMjMsLTAuMDdsLTAuNjQsLTAuMzZsLTAuODEsLTEuMmwwLjM1LC0xLjg5Wk0xMS40OSwyNjIuMzVsMC45MSwwLjI5bC0wLjQ5LDAuNmwtMC40MywtMC43NGwwLjAyLC0wLjE1Wk0xMS43NiwyODMuNWwtMS4wLDAuMTZsLTAuNDcsLTAuMzZsLTAuMDYsLTAuNzRsMC45NiwtMC41NGwwLjM4LDAuMTJsMC4yLDEuMzdaTTMuNDgsMjU5Ljg0bDEuMDYsLTAuNDdsMC4zMSwwLjU0bC0wLjUzLDAuMTZsLTAuODQsLTAuMjNaTTAuNDIsMjU3LjE1bDIuMywtMS4wOWwwLjYzLDAuMTRsMC40LDAuNjFsLTEuOSwxLjQ0bC0wLjk3LDAuMjFsLTAuNDYsLTEuMzFaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiQ1ZcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0yNjIuMDIsMzk5LjQ5bDAuODMsMC4wNWwxLjcsLTAuNTNsMC43NywtMy41OWwtMC42MiwtMi4yMWwtMS45LC0wLjUzbC0wLjM3LC0wLjYzbC0yLjYyLC04LjQ5bC0wLjEyLC00LjE2bDIuODYsLTQuNTVsMC4zNiwtMy4wN2wwLjcyLC0yLjY2bDEuMjMsLTIuODJsMS44NywtMS4yMmwwLjM2LC0wLjY1bC0wLjE3LC0wLjYybDAuODMsLTAuMzFsMC40NywtMC43N2wtMS4xLC02Ljk2bC0wLjYzLC0yLjAxbC0wLjQ4LC0wLjgxbC0wLjYxLC0wLjMybDAuODQsLTIuNDRsLTAuMzMsLTAuNTRsMC4xOSwtMS4zOWwtMC4yNCwtMS4yMWwtMC44NSwtMi4zNWwwLjM0LC0wLjY5bC0wLjQ1LC00LjZsMC4yNCwtMC43MmwtMC42MywtMS4wOWwwLjM1LC0xLjE3bC0xLjA3LC0xLjA0bC0wLjM3LC0wLjg3bDAuMDgsLTEuNDdsMC43OCwtMi44N2wyMC42OSwtMC4xNGwzLjgxLDAuMjNsMC41MSwwLjYxbDAuNTcsMC4xM2wxLjc0LC0wLjk5bDAuNzUsLTAuOTNsMS4wOCwtMC4xbDAuNTUsLTAuNzVsMi4yMywwLjVsMC43LDAuOGwtMS4xMywzLjQ1bDAuMDksMC44NmwzLjYsMy40MmwxLjc0LDEuMTVsLTAuNTgsNi42N2wtMC42NSwwLjM3bDAuMjMsMC45M2wtMC42NCwxLjcxbDAuNzYsMC43bDEuMzgsLTAuNzJsMC41MywwLjA0bDAuNzYsMS4wNmwtMC43MywyLjg5bC0wLjA3LDEuNjdsMC4zNSwxLjI5bC0xLjIsMC45M2wtMC4xLDAuODNsMS4zMiwxLjkzbDEuNTUsMS4xNGwwLjczLDEuMzFsLTEuMiwyLjI2bDAuMjQsNC45M2wtMS4yMywyLjIzbDAuMTksMS41N2wxLjM2LDAuODlsLTAuNDcsMy41bC0wLjc5LDEuMDhsMC4wNCwxLjM0bDIuMTMsMy4zMmwwLjQ3LDEuNTJsMi4wOCwxLjQ4bDAuNzcsMC4xM2wwLjgsMS4zMmwxLjQ2LDAuNzhsLTEuNDgsMS4xbC0xLjE1LDIuMDlsLTIuMTUsMC41NGwtNS44NiwwLjA3bC00LjUsMi4yMWwtMi41OCwwLjc4bC0xLjY5LDEuMjlsLTIuMTEsMC44N2wtMS41MSwxLjA3bC0zLjEsMC41MmwtNS4xNiwxLjcxbC01LjgxLDMuMjFsLTAuODIsLTAuMDJsLTMuNjQsLTEuOTNsLTcuMTgsLTEuNTRaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiR0hcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02NTguODIsNzgwLjY2bDAuMDcsLTQuMTNsMi42NiwtMy45MmwwLjY2LC0xLjQ4bDEuMzMsLTEuNjRsMS40LC0xLjAzbDAuNjMsLTAuMDlsNS4yOSwyLjkxbDEuMDMsLTAuMTlsMC45OSwwLjU1bC0wLjI0LDMuMDlsMC43NiwzLjA0bDAuMDcsMy4zNGwtMC43MSwtMC4xNGwtMC42NiwwLjRsLTAuNTcsNC41M2wwLjExLDEuMzJsLTUuMjMsLTAuMTRsLTIuMTksLTAuNjlsLTIuMzUsLTEuNTFsLTIuMDQsLTMuOWwtMS4wMiwtMC4zMVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJTWlwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTg1My42Nyw2MzMuNDVsMC4yNCwwLjg1bC0wLjc3LDIuMDlsMC4yOCwwLjQ1bDAuODMsMC4xNWwwLjc2LC0wLjRsMS42OCwtMi45NWwxLjAxLC0xLjA5bDIuMCwwLjRsMC40NiwtMC4xOWwtMC4wOSwtMC40OWwtMS42OSwtMS40NGwtMC4zOSwtMS44MWwyLjU0LC00Ljc5bC0wLjA2LC0wLjQ1bC0xLjA1LC0xLjE2bC0wLjAzLC0xLjE3bDAuODYsLTEuMTlsMC40LC0wLjEzbDEuNywxLjI3bDEuMTYsMC4wNGwxLjc3LC0yLjE3bDIuNTIsLTEuMzNsMi4wNSwtMS44OWwxLjQ0LC00LjEybDAuMTMsLTEuMjRsLTAuMzIsLTEuNTdsLTEuMTUsLTIuNzZsMC43NiwwLjE1bDAuNzYsLTAuMzdsMy4xMywtNC4xM2wwLjMsMC4wbDEuMDEsMS42OWwyLjAyLDIuM2wxLjE5LDIuNDdsMy40Niw1LjFsMC4zNCwyLjI4bDEuMjYsMy43MmwxLjE3LDUuNDdsMC43Miw4LjI4bDAuOTcsMi42bDEuNDYsMi40OWwwLjQ2LDIuNjdsLTAuODgsMi44bC0yLjA4LDMuN2wtMC45MSwtMC42MWwtMC44LC0xLjA3bC0xLjY4LC00LjNsLTAuNjcsLTAuMjZsLTEuMjksMC4xMmwtMS4yOCwxLjE0bC0wLjE4LDAuNzJsMC43Myw2LjA4bDEuMzksMi4yNGwwLjA5LDIuNjVsLTAuMjksMS4yN2wtMC45NCwxLjQxbDAuMzIsMS4yN2wtMS45LDEuMjZsLTEuNzYsMy44OGwtMC4xNCwxLjM5bDAuNjYsMy44NmwtMC4xOCwyLjY5bC0xLjM0LDUuMjZsLTUuMjEsMTQuNDlsLTUuMjgsMTYuNzRsLTEuMzgsNS41MWwtMi4wNCw2LjA0bC0zLjE0LDcuNjhsLTEuMjMsNi41M2wtMi4zNCw3LjkxbC0wLjU0LDIuOThsLTIuMTcsNC4yN2wtMS4xNyw0LjMxbC0xLjEsMi43MmwtMS42MSwyLjNsLTMuNDQsMi4wM2wtMy45OCwwLjI4bC0yLjY3LDAuNzJsLTYuNTksMy43NmwtMS4wMiwwLjM5bC0zLjQxLDAuMDlsLTAuOTMsLTAuM2wtMy42MSwtMi42M2wtNS4zNCwtMS4yOWwtMS4xMiwtMS4zOWwtMi40NSwtMS40MmwtMS40NSwtNC4zNmwtMi43NywtNC4xMmwtMC4yOCwtNi44NWwwLjIsLTEuMjdsMC42OCwtMS40NmwtMS44MSwtNS42M2wtMi4wNCwtMi40NmwtMC40NCwtMS4xbC0xLjA3LC00Ljk1bDAuMjksLTUuMzdsMC42MSwtMS43NWwxLjEyLC0xLjgxbDAuNzIsLTMuNDNsMC43OSwtMC42NWwxLjQ3LC0wLjVsMS4yMywtMS4wNWwwLjY4LC0xLjM0bDAuNjMsLTIuNTFsMy44NSwtNS45NWwxLjI5LC0yLjkxbDAuNjgsLTIuNzlsMC41MiwtNi4wN2wtMi40OCwtNC40MmwtMC4wNiwtMy45N2wtMS40OSwtMy4wbC0wLjc4LC0yLjUybC0wLjMxLC01Ljg1bC0wLjgsLTIuNjhsMC4zOCwtMi4xbDUuMTQsLTguMjVsMC4xMiwtNS4xMmwwLjM1LC0wLjU3bDUuMDgsLTAuNTNsMy41NywtMi42M2wxLjQ3LDAuOTlsMS42MywtMC41OWwxLjE4LDAuMDhsMC40MSwtMC4ybDAuOTgsLTEuOTVsMy40OSwtMC4zOGwxLjc0LC0wLjUxbDEuNjksMS45NmwxLjM3LDAuMTlsMC40OSwtMC4zNWwwLjAzLC0wLjYzbC0xLjIxLC0xLjI5bDAuNjIsLTEuNzNsNS42NiwtNC4zMWwwLjc5LDAuMDZsMC4zNiwyLjE3bDAuMzQsMC40NmwxLjA5LC0wLjI3bDAuNiwtMS4ybC0wLjQ3LC0yLjM5bDIuMTEsLTIuNGwwLjgzLC0yLjA5bDAuNzMsLTAuNTRaTTg2My42Nyw2MTUuNTlsMC4xOSwxLjMzbC0wLjc4LC0wLjA5bC0wLjEyLC0wLjc2bDAuNzIsLTAuNDhaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTUdcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0xMTEuNTUsMTc0LjA4bDAuODcsLTAuODJsMi4yOSwtMS41M2w0LjYxLC01LjBsMS44MywtMC45NmwxLjU4LC0yLjEzbDAuNjQsLTIuMTJsMC4xNSwtNC4zMWwwLjU0LC0yLjIxbDMuMjEsLTYuNmwwLjYsLTIuOTJsMC41NywtMC45N2wxLjE3LC0wLjU1bDEuNjMsLTEuNDRsMi41NSwtMC45NGw0LjU1LC0zLjI1bDAuOTcsLTEuODFsMS4wLC0zLjQybDEuNzksLTMuNjFsMC45MywtMi43NWwxLjUxLC0xLjM4bDEuMDksLTEuODFsMS42NSwtMC43NGwzLjgxLC0wLjRsNS42NiwtMS41Mmw1LjE5LC0yLjM1bDEuNTMsLTAuOTlsNC4wMywtNC4xNmw2Ljk3LC00LjQ4bDMuNDIsLTQuMWw1LjM5LC03LjQ0bDAuOTYsLTIuMWwwLjUxLC0zLjEzbC0wLjM1LC0xLjM5bC0xLjQ3LC0yLjEzbC0wLjkzLC0wLjU3bC0wLjE4LC0wLjY3bDAuNDksLTEuNjhsMC4yNywtNy4zN2wxLjUyLC0zLjZsMy44NywtNC45NWwwLjczLC0yLjA5bDAuNDgsLTQuMjFsNC42OSwtNC40NGwzLjc2LC00LjMybDIuNDMsLTEuNTZsOC42NiwtMy41bDQuOSwtMi41bDIuOTksLTEuOTRsMS43NCwtMi4yMmw0LjcyLC04LjUxbDQuOTksLTEzLjI5bDMuMzYsLTAuNTVsMi41NywtMS4yOWwwLjUxLDAuMTNsLTAuMjcsMC40MmwwLjA1LDEuNjlsMS4wNCwxLjgxbDEuNzgsMi4wMWwzLjI0LDIuNTRsMi41MywxLjAybDMuNSwwLjZsNC4yLC0xLjA4bDIuMjMsLTAuMDJsMS4wOCwtMC40MmwxLjE5LDAuNjRsMi4zLDAuMjJsMi4zMiwtMC4zN2wyLjQ2LC0xLjc5bDEuNDIsMy4wOGwyLjc1LDAuNGw0LjU3LDAuMDhsMS4wMywxLjY3bDMuODYsMi44NmwtMC42LDEuOWwxLjI5LDEuNmwtMC42NCwxLjUxbDAuOTcsMi40OGwtMC4wOCw1LjE3bDAuOTUsMi44MmwtMC41MiwzLjM1bDEuNSwzLjIybDAuNDYsMi40OWwwLjc1LDEuMzRsNC4wLDMuMDlsMC4zNSwwLjczbC0xLjkzLDEuNzFsLTAuMjUsMS4xbDAuNDEsMS43NWwtMTMuOTYsLTAuNDNsLTQuOTEsMC43MmwtMS4xLDAuNjhsLTAuOSwyLjVsLTQuNzksMS42M2wtMy45NSwwLjIzbC0wLjg3LDAuNTZsLTAuMjcsMC42OGwwLjY3LDMuM2wtMC41LDIuMTJsMC4zMSwwLjY5bDIuMTMsMS4yNWwtMC4zNCwwLjg0bC0zLjcxLDAuNjRsLTMuOTIsMi43NGwtNS4yOSwxLjg3bC0yLjI3LDEuMTRsLTIuNjIsMy45NWwtMy4wMiwyLjU4bC02LjM5LDEuNThsLTUuNzMsMC4xOWwtMC40MywwLjM5bC0wLjIzLDEuODZsLTAuOTksMC45MWwtNi4wNywtMC42MWwtNC4wMSwyLjg5bC0yLjQ0LDAuNjFsLTYuOCw0LjcxbC00LjU4LDMuMzFsLTAuNDMsMC43bC0wLjA2LDEyLjc0bC0xLjE4LC0wLjBsLTAuNCwwLjQzbDAuNSwyLjQxbC0wLjMyLDEuMzNsMC41NywyLjE3bC0wLjI1LDAuNDVsLTIuMjgsMC4zNmwtNC44NywwLjAzbC0zLjg4LDIuODhsLTAuODIsMC4xMmwtMC44NCwwLjBsLTEuNjgsLTAuNzZsLTIuNDYsMC42M2wtMy40MywtMS42bC0yLjY0LC0wLjRsLTIuMDEsMC4xNGwtNS40NywxLjU5bC0wLjI5LDAuNTFsMC44NywxLjc3bC0wLjE4LDEuMDJsLTIuMDIsMi4wNWwtMi4wNiwzLjI4bC0wLjM4LDEuMjhsLTMuNDUsMC44MWwtMC41NywwLjY1bC0yLjk5LDExLjEzbC0xLjM0LDMuMzZsLTIuMjYsMS44bC00LjI4LDIuNjdsLTAuODgsMC45NGwtMi44NSw1LjExbC01LjMzLDIuMzNsLTEuNTUsMS4zOWwtMS41NSwzLjUzbC0wLjk1LDMuODhsLTAuODMsNC4yNWwtMC41Nyw1LjQ1bC00LjcxLDUuNDFsMC4xMSwxLjU4bC0wLjY1LDEuNzFsLTAuODUsMS4xMWwtMC45MSwwLjUzbC0xLjQyLDAuMTFsLTUuNywtMC4xMmwtNi44MywtMC42MWwtOC4xMiwwLjM3bC0yLjY4LDAuNTFsMC43NiwtNS4yN2wxLjU2LC0zLjA5bDEuMTgsLTEuM2wyLjExLC0wLjg3bDEuODMsLTMuMjJsMC42NiwtMi45OGwxLjEzLC0xLjI5bDAuNDUsLTEuMmwtMC4zOCwtMC45M2w0LjY0LC03Ljk1bDAuMDYsLTEuMzhsLTAuNzMsLTAuMTRaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTUFcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02OTYuMTMsNDU2LjkxbDEuMiwtMS45NGwwLjksLTIuNTJsMS4yMywtMC44OWwxLjY5LC0yLjE4bDAuODcsLTIuMWwxLjMsLTEuMjNsMi4zOSwtMS4xMWwtMC4wNiwtMS43NmwyLjA2LC0yLjk4bDAuMiwtMS43MmwtMC4xNywtMy40MWwtMC45NCwtNC4xMWwwLjIzLC0wLjlsLTAuNDYsLTEuMjlsLTAuNjUsLTAuNDdsLTAuODYsLTIuMzNsLTEuNzgsLTEuMjdsLTAuNzMsLTIuMTZsLTAuOSwtMC42NGwtMC41MiwtMi42NmwwLjQ0LC0yLjg1bC0wLjY1LC0wLjc0bC0xLjU1LC0wLjU1bC0wLjg5LC0wLjdsMC4xMywtMC40NWwtMC43MywtMC42NWwtMS42NCwtMy40OGwxNC4yNCwtMTQuMDVsMC45MiwwLjg3bDEuODQsLTAuNTlsMy4wMywwLjgybDAuMzgsMC41NGwwLjA5LDEuMjhsLTAuNSwyLjRsMC4wOCwxLjc1bDMuMTgsNC4yOGwwLjk1LDAuMzFsOS41MSwwLjQybDEzLjkzLDguOThsNi4xNCwwLjU4bDcuMjIsMS40MmwzLjM2LDAuMjZsMC42OCwtMC4yNGwxLjQ0LC0xLjMzbDIuMTQsLTMuMTZsMTAuNDcsLTQuNzlsNC4zNywzLjU3bDIuMTksMC4yNWw1Ljg3LC0wLjQxbC01LjksOC40NmwtNC4yMyw0LjE5bC0wLjI5LDAuNjFsMC4xNyw0My4yM2w2LjQyLDguNDNsMC4wOSwxLjA5bC0xLjU5LDEuODdsLTEuMjksMC44NWwtMS43NCwwLjRsLTEuMTQsLTAuMzRsLTAuNDksMC4xN2wtMC40MywwLjlsLTAuMjQsLTAuMTdsLTAuNjMsMC4zOGwwLjM2LDEuOTRsLTAuMjEsMC42N2wtMC44MywwLjdsLTAuMiwwLjc2bC0xLjc3LDEuNTRsLTIuODUsMC4yM2wtMi4yMywxLjYzbC0wLjYxLDEuODRsMC4xNywyLjI1bC0wLjg5LDIuNTdsLTEuNDIsMS4xOWwtMS40OSwyLjZsLTAuNTcsMi42bC0xLjAxLDIuMzhsLTIuODEsNS42N2wtMS4xNiwxLjVsLTEuMTYsLTAuMDVsLTAuNzIsMC43MWwtMTYuMjMsLTExLjdsLTAuOTYsLTEuNTFsLTEuMTIsLTAuNDdsMC45MywtMi43bC0wLjM0LC0yLjE3bC0wLjM4LC0wLjU3bC00MS43NywtMjMuMzNsMC42LC0wLjRsMC41MywtMS4yMmwtMS4xLC0yLjA0bC0wLjA4LC0wLjc4bDEuMjEsLTEuNzlsMC44NSwtMC4ybDIuMjcsMC41OGwwLjQ3LC0wLjU0bC0wLjEsLTEuMTVsMy42NiwtMC42NWwwLjQyLC0wLjgxbC0xLjEyLC0yLjE2bC0wLjQ3LC0wLjJsLTMuNTUsMS4yNGwtMC43LDAuNjNsLTAuNSwxLjE2bC0xLjg0LC0yLjAzbC0wLjA3LC0xLjAybC0wLjg1LC0wLjEzbC0wLjQxLC0wLjQ1bC0wLjI5LC0yLjQ2Wk03NzkuMTQsNDgzLjY1bDAuMDUsLTAuMDRsMC4wMSwwLjBsLTAuMDcsMC4wM1pcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJLRVwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTU4MS4wNCwzNTcuMTNsMS4zNywtMS4xMmwyLjkzLC0xLjA2bDAuMjQsLTEuNDlsMS4xNSwtMi4wNGwwLjI5LC0yLjQybDEuMywtMS43NGwwLjA0LC0yLjg5bDIuNDksLTMuMjFsMC4yOCwtMi4xOGwwLjM5LC0wLjUzbDguMywtMS40MWwwLjQzLDAuMWwwLjIsMC40NWwwLjA4LDEuNjlsMC40MSwwLjU4bDIuOTgsMi40Nmw0LjQ0LDUuMTdsMS40MiwwLjYxbDEuNTMsLTAuMTlsMy41MiwtMS4zMmw5LjI0LDAuMThsMS4xOCwyLjM4bDAuOTcsMC44Mmw5LjMzLDAuMDNsMC4zOSwtMC40OWwtMC4wNywtMS4yOWwxLjUyLC0xLjQ4bDIuOTQsLTEuMzlsMi44NywtMC42OWwxLjYsLTEuODlsMC4wOCwtMS43Mmw0LjI2LC0yLjI0bDUuMjksMy4zOGwzLjQxLDMuMGw0Ljk1LC0wLjQ4bDAuOTYsLTAuNDJsNS4wNywtNS4wM2wyLjM2LC0zLjA5bDAuODksLTIuMTJsNS43OCwtNS4xNWwwLjA1LC0wLjY3bC0wLjk3LC0yLjI0bC0wLjAyLC00Ljc2bC0yLjYyLC0zLjAybDYuOTEsLTAuMDNsMC40LC0wLjM3bC0wLjE5LC0yLjE2bDQuNzksMC4wNmwtMC43MSwyLjc3bC0wLjE2LDIuOTlsLTAuNTgsMS4xMWwxLjE1LDguOTdsLTAuNDksMS4ybDAuMzksMC41MmwyLjYzLDAuOThsMC45OSwxLjE4bDUuMTYsNC4yOGwwLjUzLDEuMzdsMC4wNywyLjE4bC0wLjc5LDEuNjRsLTAuMjgsMi42MmwwLjQ3LDAuODVsMS45NSwwLjA0bDAuMjksOC44N2wtMC4yNiwxLjMybC0xLjIzLDEuMDZsLTguMCwwLjE2bC0wLjY1LDAuNjFsLTIuNTgsNS4yMmwtMC4xNywxLjBsMS4wOSwxLjA0bDEuNzcsMC43OGw1LjE1LDEuMDZsMi42OSwxLjg1bDEuMjYsMS41bDAuNjEsMS44MWwyLjUyLDIuNjNsMi40MiwxLjI2bDAuOTUsMS40MWwxLjY0LDEuMzNsMi44Niw3LjEzbDAuMzMsMi4yN2wxLjIsMi4yNWwxLjkyLDEuODVsLTIwLjQyLDIwLjAzbC0zLjY3LC0wLjIybC0yLjE3LC0xLjIxbC0xLjgzLDAuOTRsLTUuOTYsMS4xMmwtMS42OSwxLjJsLTAuNDksMC45MWwtMS45NCwtMC45MmwtMS43MywtMi4yOWwtMC40NSwtMC4wM2wtMi43OSwxLjQxbC0zLjYzLC0xLjI1bC0wLjk1LC0wLjAybC0yLjg2LDEuODZsLTAuOCwxLjE1bC0wLjg0LC0xLjA5bC0wLjg4LC0wLjI1bC0xLjExLDAuMmwtMC43MiwtMi4yNmwtMy43OCwtMS44NWwtMy43MywtMy45OGwtMS4wMywtMS43NmwtMS4yNywtMS4zMmwtMS42LC0wLjY3bC0xLjIzLDAuMjdsLTEuMTYsMS40MmwtMS43MywxLjE1bC0wLjYzLDAuMDNsLTIuNDYsLTEuMTNsLTIuNTksLTAuMjNsLTIuNjEsMS42MWwtMS41OSwwLjU3bC0xLjk4LC0wLjM2bC0yLjQxLC0yLjA5bC0xLjYxLC0wLjc3bC0xLjk4LC0yLjgybC0yLjA2LC0xLjQ3bC0yLjY1LC0zLjY2bC0wLjMyLC0zLjE2bC0xLjA3LC0yLjAzbC00Ljk3LC0zLjMxbC0xLjY1LC0wLjI5bC0wLjc4LC0wLjUxbC0xLjExLC0yLjRsLTEuMDQsLTEuMzFsLTAuMTUsLTAuNTRsMC41OSwtMi4wMWwtMC4xMywtMC40MmwtMi4yNCwtMS43MmwtMS41OSwtMi4wNmwtMS43MywtMS4yOWwtNS45NiwtMy4xN2wtMS4xNSwtMS4wN2wtMS4wLC0xLjE3bDAuNTksLTAuOTRsMC4xNiwtMS4wNmwtMC42LC0xLjIybC0yLjM0LC0xLjk1bC0xLjc4LC0yLjAxbC0xLjYsLTAuNzdsLTUuMDcsLTEuMTNsLTAuODQsLTAuNzlsLTAuMjcsLTAuODdsMC40NSwtMS42M2wtMC42NywtMS4wNVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJTU1wiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTE1OC41NSwzMDEuN2wtMC41NCwtMS4zMmwtMS43NSwtMi4xbDAuMDksLTAuODlsMC42OSwtMC42OGwwLjMsLTEuMTVsLTAuNjgsLTEuMzVsLTAuMDcsLTIuODlsLTIuMzYsLTIuODdsMC40NiwtMi4wOWwtMC42LC0xLjI3bDEuNDQsMC4zbDEuOTQsLTEuNzFsMC45LC0xLjQ5bDAuNTIsLTMuMGwwLjc1LC0yLjAybDIuNzYsLTIuMzNsNi40Miw1LjhsMC45NywtMC4xOWwyLjE1LC0zLjA5bDMuMTUsLTAuMTdsNS41MywwLjc3bDIuMjksLTAuMzRsMy42LC0wLjY4bDAuMzMsLTAuMzVsMC4wLC0xLjM5bDAuMzksLTAuNjVsMC4zMiwxLjUzbDIuMDMsMC40MWw0My4wLC0wLjBsMC4zOSwtMC4zM2wxLjc5LC05LjQ2bC0zLjE2LC0zLjY5bC0xMS4yNiwtMTAyLjY0bDIwLjIxLC0wLjAxbDY5Ljc4LDQ4LjBsMC4yNywzLjQ5bDEuNTQsMS4zNWwzLjcyLDEuOTJsMC43NywyLjAybDAuOTMsMC43M2wyLjE5LDAuNzhsMy4zOCwwLjMxbDIuMTYsMi4yMmw1LjQ0LDEuMzRsMi45OSwxLjI0bDAuNjgsMC41OGwtMC4wMiwyLjYxbDAuNjMsMi4wOWwtMC42NSwwLjY5bC0xLjA4LDIuMzNsMC4zNSwwLjgxbDEuNTYsMS4wN2wxLjk2LDAuMzhsOS4yOCwtMS43OWwwLjA4LDI1LjM2bC0wLjM3LDAuNTNsLTAuMjQsNC41NmwtMC42OSwyLjZsLTEuMjcsMi4wNWwtMS42LDUuMmwtMC41NiwwLjc4bC0xLjI5LDAuNDRsLTIuMjIsMS45bC0wLjI3LDEuMzZsLTQuOSwtMC43OWwtMC44MiwwLjMzbC0wLjE5LDAuNzJsLTE5LjYyLDAuODFsLTQuMTgsMy40OGwtMi42MywwLjMzbC01LjA2LC0wLjNsLTAuNzksMC4yMWwtMC4zMiwwLjQ4bC00LjksLTEuNjNsLTIuMDUsMC41MWwtMC41NSwtMC41MmwtMC45NiwtMC4yMmwtMS43MSwwLjFsLTEuMjUsMC4zNGwtMy4zNCwyLjdsLTUuMTksMi4zMWwtMi4zNCwxLjRsLTMuMjIsMC42MWwtMS4yMSwzLjIzbC0wLjM2LDAuMTdsLTMuODksLTEuMjJsLTEuODIsMC41OGwtMi4zMiwxLjg4bC0xLjE4LDEuNTRsLTAuNjcsMi4wOGwtMC4xMSwxLjQxbC0yLjgyLC0wLjMxbC0wLjg2LDAuNDZsLTAuNTcsNC4zMWwtMi4zMiwxLjA2bC0zLjYsLTIuMmwtMS40LC0wLjRsLTEuMzksMC4zMWwtMy4zMSwzLjE5bDAuMTMsMS4xNmwwLjk4LDIuMDJsLTAuMDEsMC43bC0yLjc1LDEuMzRsLTAuMTgsMC41NGwwLjY1LDEuMDRsLTAuMDcsMi42MWwtMS43OCwyLjA4bC0xLjE5LDAuODRsLTQuNzYsMS4yOWwtMS41MiwwLjk1bC0wLjg0LDAuOTlsLTAuMDMsMS44NmwwLjcxLDEuODhsLTAuMjMsMS42M2wtMS4wMywyLjdsLTEuNjIsMS4wMmwtMC4xNiwwLjRsMC4zOCwzLjEybC0wLjY0LDMuNTdsLTEuODUsMC4wN2wtMS44NiwwLjU3bC0yLjE2LDIuMjNsLTEuODIsLTAuNTdsMC41MiwtMS41OWwtMC41NCwtMS43NWwtMC4xNCwtMS45NWwtMC42NCwtMC4zOWwtMi4wMywwLjY2bC0wLjI1LDAuNWwwLjE4LDAuNzZsLTEuMTUsLTAuMjdsLTAuOTksLTAuNzhsLTAuNTQsMC4wNGwtMC40OSwxLjE3bDAuMSwyLjMxbC0zLjEzLDAuMjlsLTAuNTQsMS4ybDAuMywwLjc5bC0wLjI4LDAuMTlsLTAuODUsLTAuNjlsLTIuODIsLTAuNjJsLTAuMTksLTAuNzFsLTEuNzQsLTEuNDhsLTIuMTYsMC4yNmwtMS44MiwyLjI3bC0xLjI0LDAuNjdsLTAuMzYsLTEuNThsLTMuMDMsLTEuOTRsLTAuNjQsLTIuOThsMC4xMywtMi40bC0wLjM0LC0wLjY0bC0xLjg1LC0wLjg3bC0xLjk0LDAuNjlsMS41OCwtMi4yNGwxLjE2LC0wLjg3bDAuMzUsLTEuMTNsLTAuMzIsLTAuNDRsLTIuODUsLTEuNDNsLTAuNTksLTEuMjVsLTEuMTcsLTAuNTlsLTAuMCwtMi45MmwtMi4xLC01LjBsLTAuNjgsLTAuODZsLTIuMiwtMS4wMmwtMS4wOSwtMC4wOGwtMS4yMywwLjM0bC0wLjIsMC42NmwwLjY0LDEuMDRsLTAuMDYsMC43N2wtMS40NSwwLjM0bC0yLjA0LDEuMDNsLTAuOTUsMS4yOGwtNi4yMiwtMi4xNGwtMi40MiwxLjBsLTEuNzgsMi4zMmwtMC42NCwwLjM5bC0xLjgsLTIuOWwtMC42NywtMC42M2wtMS4xLC0wLjE0bC0wLjk0LDAuNDlsLTEuNjksMS43M2wtMC43MiwwLjA5bC0yLjA2LC0xLjc3bDEuMjksLTIuNDZsMC4wOCwtMC44OWwtMC44LC0wLjk3bDAuNjEsLTQuODVsLTEuNzgsLTIuNjFsLTAuMzgsLTEuNDFsLTAuNjcsLTEuMDRsLTEuNzIsLTAuNDdsLTAuODIsMC44NVpcIlxyXG4gICAgICAgICAgICBkYXRhLWNvZGU9XCJNTFwiIGZpbGw9XCIjNjQ5N2IxXCIgZmlsbE9wYWNpdHk9XCIxXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMFwiIHN0cm9rZU9wYWNpdHk9XCIxXCJcclxuICAgICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCIgY2xhc3NOYW1lPVwianZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50XCIvPlxyXG4gICAgICA8cGF0aCBkPVwiTTgxNy41LDYwMy4xMWwwLjYxLC0wLjI0bDAuNSwtMC44NmwwLjQ5LDEuMzdsLTAuMCwxLjA1bC0xLjU5LC0xLjNaTTgwOS40Niw2MDQuMDlsMC4yNiwwLjAzbDAuNiwwLjM3bC0wLjY5LC0wLjA5bC0wLjE3LC0wLjMxWk04MDYuOCw1OTkuMThsLTEuNDIsLTAuN2wtMC43MSwtMC44N2wwLjMyLC0zLjU1bDAuMjksLTAuNDNsMC41MSwwLjIxbC0wLjE1LDIuMjNsMS4xNSwzLjFaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiS01cIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk0zODMuOTksNDQwLjYybC0wLjMzLC0wLjA4bDAuNTMsLTAuN2wwLjA1LDAuMjNsLTAuMjUsMC41NVpNMzc1LjA3LDQ1Ny41N2wtMS4wNSwwLjYzbC0wLjUsLTEuNjFsMC41MiwtMS4wbDEuNDYsLTAuNjRsMC41MiwwLjY1bDAuMCwwLjY5bC0wLjk0LDEuMjhaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiU1RcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02ODEuMTMsNjE5Ljc2bDEuNzQsLTEuNDZsMS40NCwtMi45NmwwLjM4LC0zLjlsLTAuNjEsLTEuMmwwLjczLC0xLjcybDQuMzEsLTEuNjRsMS41NCwtMS44OGwtMC4zNSwtMC42OWwtMS43LC0wLjIybC0wLjkzLC0yLjExbDAuNTUsLTIuNjFsMC4wMywtMi4zN2wtMC4xOSwtMS4wMmwtMC43MSwtMC45MmwwLjA1LC0xLjAybDAuMzksLTAuMjdsMS4zMiwtMi45NmwtMS4yOSwtMy4yNGwwLjY4LC0wLjYybDEuNTIsLTAuNDRsMi4yOCwtMi4yOGwwLjE0LC0wLjdsLTEuMzEsLTIuMTRsLTAuMzMsLTEuOTFsLTIuNDEsLTIuMTlsMC4zMiwtMi4yMmwtMS4xNywtMS4yMWwtMC43OSwtMS42OWwtMS4yMywtMC4zMmwtMC41NSwwLjRsLTAuNDEsLTAuMDlsLTAuNjgsLTEuOTZsMS43MSwxLjExbDIuMzgsMC4zMWwxLjE1LDEuMDdsMy4zMiwtMC4xbDIuMiwwLjg0bC0wLjExLDEuMjhsMS4zLDMuNTZsMi43MiwzLjU3bC0wLjcsMi4wMmwwLjYzLDYuMThsLTAuMjQsMC44bDEuMTUsNS43MmwtMy4wMyw0LjUxbC0wLjM2LDIuMTVsMC42LDEuOTZsMS4xNiwwLjc3bDAuMTgsMi41NWwwLjgzLDEuMTVsMC43MiwyLjM5bDAuMTYsMi40NWwtMC4yNiwyLjczbDEuMTYsMi4wbDEuNiwwLjg0bDAuNTgsMC43bDAuMTUsMC43OWwtMC45NiwyLjc0bDAuMzksMS43MmwxLjg3LDIuMDVsMC41LDAuMDZsMS4zMSwtMC44OWwwLjQyLC0yLjA5bDAuNTEsMS40MmwxLjA5LDAuMzlsMi4xOCwyLjY1bDAuOCwwLjA3bDAuNDUsLTAuODdsLTIuMTcsLTYuNGw4LjAsMTAuMzJsMC40NiwyLjU5bC0wLjU2LDEuNTZsLTAuNDEsMi43N2wwLjI5LDEuOTJsLTAuMTIsMy4wOWwtMC43LDQuMzNsLTEuNTcsMC42NmwtMy4wMSwwLjUybC0wLjg2LDEuMTRsLTEuNDksMy44NGwwLjc1LDEuMjZsMC41NywxLjkxbDAuMDgsMy4zMmwtMS40MSwwLjA4bC0wLjQ2LC0wLjM5bC0wLjE0LC0wLjQybDAuNTIsLTAuNTZsMC4yMSwtMC45MWwtMC40MSwtMS4wNGwtMS44MSwtMS4wMWwtNC43LC01LjI2bC0xLjI5LC0wLjg1bC0wLjE0LC0xLjk2bC0xLjc4LC0yLjNsMC4zMiwtMC45N2wwLjk0LC0wLjkzbDAuOTEsLTIuNzRsMS4yNiwtMi4yN2wwLjIsLTMuNDRsLTAuNjksLTUuMjJsLTEuNTMsLTIuMDhsLTAuODcsLTAuMzVsLTIuNzUsMC41bC0wLjY1LDAuNDJsLTQuMDksMC41NGwtMC41MiwwLjM3bC0yLjY2LC0zLjA5bC0xLjcsLTIuOTJsLTEuMTQsLTEuMjZsLTAuNDgsLTAuMTNsLTEuNDgsMC45M2wtMS4zNSwtMi4yOGwtMC45NiwtMC41M2wwLjMsLTAuNjVsLTAuMTYsLTAuMzVsLTEuMSwtMC44MVpNNzA3Ljk0LDYyMC45bC0xLjM1LC0wLjE0bC0wLjA4LC0xLjE4bDEuMTMsMC45OWwwLjMsMC4zM1pNNzA0LjIyLDYwMS42NWwwLjAzLC0wLjMybDAuMTEsLTAuMmwwLjEzLDAuMTlsLTAuMjgsMC4zMlpNNzAzLjExLDYwMC44OWwtMC4wOCwwLjE4bC0wLjIsLTAuMjVsMC4xMSwtMC4wNmwwLjE3LDAuMTJaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTVdcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk03ODQuODEsNDc4LjA1bC02LjUyLC04LjdsLTAuMDcsLTQzLjE4bDQuMjYsLTQuMjNsNi43MiwtOS43MmwxLjE3LC0xLjE1bDIuMjYsLTAuNzFsNi43MSwtMS4xbDEuMzEsLTAuODhsMS40MywtMi4zOGwxLjIxLC0wLjlsNS4yNywtMi40M2w0LjY5LC0xLjExbDEwLjc2LDAuNmwwLjY2LC0wLjI3bDE3LjM4LC0xOC42NGwxOC4yNCwtMTcuNjhsMTEuMzEsLTE3LjI2bDAuMDcsLTIxLjI3bDQuOTYsLTAuOTdsMy4wLC0xLjI5bDUuNTcsLTAuOTdsNC4xOCwtMi4zNmwyLjAxLC0yLjU2bDEuNiwtMC40MWw0Ljk1LDEuNzJsLTAuMzIsMS42MWwtMS41NywzLjg0bDAuNDMsMy4yM2wwLjEyLDUuNTZsLTAuMzksMS4wOWwtMC43MSwwLjU5bDAuMTksMC41OGwtMS4yMiwwLjU4bC0wLjU3LDEuMmwtMC44LDYuNTZsLTAuMDksMy4yMmwtMS41NywyLjExbC0wLjU5LDEuNmwtMi40NSwzLjE0bC0xLjcsMy45OGwtMi4wOSwzLjU3bC0zLjAxLDIuOTRsLTEuMDYsMy41NWwtMS4wNCwyLjJsLTMuNzUsNS42bC0xLjM4LDIuNmwtMS42Nyw0LjM1bC0wLjUyLDIuNzZsLTQuNjUsNy45MWwtNC44NSw2LjM1bC0zLjA0LDUuMzdsLTEyLjgyLDE0LjE4bC05LjY4LDkuNDlsLTIuNTksMS45MWwtMTAuNjQsNS44OGwtNi44OSw0LjkybC0xMC4xOSw5LjA2bC0xMC42NCwxMS4wNmwtNC4wMyw0LjkxbC0yLjg0LDIuOGwtMi45Miw1LjM4bC0xLjU3LDIuMlpNODk3Ljg4LDMzNi4xMmwwLjEzLC0wLjQ1bDEuNTQsMC45bC0wLjg3LC0wLjEzbC0wLjgsLTAuMzJaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiU09cIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk05Mi44NCwyODUuMGwtMC4zNiwwLjQzbC0wLjIyLC0wLjI2bDAuNTgsLTAuMThaTTkzLjAyLDI4NC45NWwzLjQsLTEuNzJsMy41OSwtNC41bDMuMiwtNS4yOWwwLjgzLC0yLjI1bDAuNjcsLTMuMzNsMC40NSwtMC4zM2wxLjgyLC0zLjUybDAuNjIsLTAuMTRsMi4zNywwLjY1bDIuMzYsMC4wOWw0LjUzLC0xLjE2bDMuMDksLTAuMjdsMC4zNSwtMC41NWwwLjgsMC4wM2wwLjUyLC0wLjM2bDAuNDgsMC4zbDEuNjYsMC4wOWwyLjkzLC0wLjEybDIuNjEsMC44N2wzLjYyLDMuMDdsMC41NCwxLjMzbDAuODMsMC43NGwwLjg4LDAuMjFsMC45NiwtMC4zOGwwLjUyLDAuNTJsMC43MiwwLjFsMS4xMiwtMC4yNWwxLjE1LDAuODVsMC42NywwLjk0bDEuMDEsMy4xOWwwLjY1LDEuMTFsMC45MSwwLjMzbDAuNzYsMS4xMWwxLjA1LDAuMTNsMC41NSwwLjQ2bDAuNzMsMS4yNGwwLjI3LDEuNGwyLjI3LDEuODlsMS4zOCwwLjU0bDAuODcsMC42OWwwLjY4LDEuMDlsMS40NiwwLjk1bDAuOTUsMS42NmwtMC40LDIuNDNsMi40LDIuOTRsLTAuMDIsMi42bDAuNjgsMS4yOWwtMC4yLDAuNzRsLTAuNzcsMC44NGwtMC4wNCwxLjQ5bDEuNzgsMi4xNmwwLjIzLDAuOTVsMC42MiwwLjdsMC43OCwtMC4wNGwwLjYsLTAuNzNsMC45NiwwLjE5bDAuNTMsMC44bDAuNDEsMS40N2wxLjc1LDIuNjFsLTAuNjcsNC41bDAuNzYsMS4zMmwtMS43NywtMC4xOGwtMi43NywwLjQ2bC0yLjc3LC0wLjEybC0yLjk1LDAuODNsLTUuNzIsLTEuNDRsLTEuNjMsLTAuOTdsLTEuMzUsMC41NWwwLjEyLC0xLjFsLTAuNjIsLTAuNjdsLTcuNjEsLTAuNDhsLTE3LjIyLC0wLjA3bC00LjU4LDIuMjhsLTMuMCwwLjZsLTMuNiwtMC4yM2wtNC4zOCwxLjI5bC0yLjA1LC0wLjExbC0wLjU4LC0wLjk4bDAuMTQsLTAuMzFsMi4xMywtMC44MmwxLjIsMC4yNmwwLjQ4LC0wLjY1bC0wLjIyLC0wLjUybC0xLjcsLTEuMWwtMC41MywtMC4wNWwtMC45NCwxLjE1bC0wLjQ0LDAuMDVsMC4wOSwtNC44OWwxLjA1LC0wLjgzbDkuNDMsLTAuMDNsMC40LC0wLjM1bDAuMiwtMS43M2w1Ljg3LC0wLjc4bDAuOCwtMC42bDAuNzksLTEuMjlsOC4xOCwzLjM4bDIuMzIsMC40MWw0Ljg0LC0xLjE5bDAuNTMsLTEuMzlsLTAuNSwtMS4wNmwtMS40NiwtMC43N2wtMi4xOSwwLjA0bC0yLjA4LDAuNTZsLTAuOCwtMC4xNWwtMS45NiwtMS4zNWwtMi4yNCwtMC42MmwtMS45MywtMS4zNWwtMS4yNCwtMC4zMmwtMi45NiwwLjJsLTEuOTQsMC43N2wtMS4wNSwxLjY1bC0xMS44MSwtMC4wMmwtMC4yOSwtMS4wNGwtMS45OSwtMi4yOWwxLjY1LC0xLjQ1bC0wLjM4LC0wLjYxbC0xLjYyLDAuNDJsLTAuMTIsLTAuODhsLTIuMDMsLTMuNjVsLTEuMjksLTEuMDVsLTEuMCwtMS44MWwtMS4zMSwtMC45MWwtMS44OSwtMC4zWlwiXHJcbiAgICAgICAgICAgIGRhdGEtY29kZT1cIlNOXCIgZmlsbD1cIiM2NDk3YjFcIiBmaWxsT3BhY2l0eT1cIjFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIwXCIgc3Ryb2tlT3BhY2l0eT1cIjFcIlxyXG4gICAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIiBjbGFzc05hbWU9XCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNOTguMSwyMDcuOTVsMC40OCwtMi4yM2w0NS45OSwtMC4wNmwwLjQsLTAuNDNsLTAuOTIsLTE0LjI5bC0wLjczLC0yLjQ2bDAuMDMsLTEuMzlsMS4zMywtMi4wNmw0LjcyLC0zLjI4bDIuODgsLTAuNTdsMy40NCwtMS40N2wwLjksLTAuNzJsMC4wOCwtMzEuMTRsMzguNzEsLTAuMGwwLjQsLTAuNGwtMC4wMSwtMTUuNTJsNDMuNTQsMjcuNjNsLTE5LjQ0LDAuMDFsLTAuNCwwLjQ0bDExLjMyLDEwMy4yMWwzLjEyLDMuNTJsLTEuNjksOC45NGwtNDIuNjQsMC4wbC0xLjQ5LC0wLjJsLTAuMTYsLTEuNjFsLTAuNTEsLTAuMzVsLTEuMTUsMC44OGwtMC4yMywxLjc5bC01LjQ2LDAuOTZsLTUuNDksLTAuNzdsLTMuMzksMC4xOWwtMC43LDAuNWwtMi4wMiwyLjc2bC01Ljg2LC01LjU4bC0wLjc1LC0wLjI0bC0xLjQ1LDAuODRsLTEuOTYsMS44MWwtMC45LDIuMzNsLTAuNTEsMi45NmwtMC43NCwxLjJsLTEuNjksMS40OGwtMi4wNCwtMC43NmwtMS4xMywtMC43OGwtMC42NSwtMS4wNmwtMy4xOCwtMS44NWwtMS4zNSwtMS4zMmwtMC4wNSwtMC45OWwtMC45MywtMS41OGwtMC43NCwtMC42MmwtMC45OSwtMC4wOGwtMC4zLC0wLjcybC0xLjIsLTAuNTlsLTEuNTQsLTQuMDhsLTAuODYsLTEuMmwtMS4zMSwtMC45OWwtMS45MywwLjEybC0xLjA0LC0wLjU4bC0xLjE3LDAuMzJsLTAuOTYsLTEuMDhsLTAuMTgsLTAuNzlsLTEuMzQsLTEuMzNsLTIuNTIsLTEuOTRsLTIuODYsLTAuOThsLTMuMDksMC4xbC0yLjQyLC0wLjM3bC0wLjUzLDAuMzhsLTAuODEsLTAuMWwtMC41LDAuNjZsLTIuNzcsMC4ybC00LjUsMS4xNmwtMi4xOCwtMC4wOGwtMi40NCwtMC42NmwtMC45NywwLjJsLTAuOTcsMS4xMWwtMi4wMiw0LjAybC0wLjAsLTEuNzNsMC44NCwtMy43Nmw0LjUsLTExLjM2bDAuNTksLTQuMjJsLTAuNjQsLTcuNzhsLTEuNTEsLTUuODlsLTEuMTQsLTEuOTVsLTIuMDIsLTEuNjVsLTAuMjcsLTAuNTZsMS41MiwtMC41bDAuNzcsLTEuMjVsLTAuMDIsLTAuNDVsLTAuNDMsLTAuMTRsLTAuNzYsMC4yMmwxLjUyLC0zLjFsMC44NCwtNS4zNGwtMi43LC01LjYzbC0xLjI4LC0wLjc2bC0wLjU1LDAuMzRsLTAuMTUsMC43OGwtMC4yNSwtMC4xM2wtMi45LC01LjQxbC0wLjc3LC0wLjUybC0wLjc5LDAuMzVaTTEwNC40NiwyMjUuNTdsLTAuMDYsLTAuMzhsMC41NSwtMC45MmwtMC4xMywwLjc0bC0wLjM1LDAuNTZaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTVJcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiIGN1cnNvcj1cInBvaW50ZXJcIi8+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNjQ0LjU4LDQ3NS4xM2wtMC4yMSwtNC4zM2wwLjk4LC01LjQzbDIuNiwtMi40OGwwLjIyLC0xLjUzbC0wLjIyLC0wLjQybC0xLjIyLC0wLjZsLTAuODQsLTAuMDVsMC4yOCwtMi4wM2wwLjY5LC0wLjhsMS44LC0zLjgzbDAuMDYsLTMuNjZsMS4xNywtMC41MWwxLjU5LC0xLjI5bDAuNzYsLTEuNmwwLjgzLC0wLjg1bDEuMzgsLTAuNDdsMC4yNiwyLjA2bDAuNzksMC4zOGwwLjczLC0wLjI2bDMuNjMsLTQuODdsMC44MywtMC44NWwyLjI1LC0wLjg5bDEuMjcsLTEuMDFsMS42OCwtMi42M2wtMC4xNiwtNC4zMWwxLjA1LC0xLjY2bC0wLjUsLTAuNDdsLTAuNywwLjI3bC0xLjczLDIuMjdsLTAuNzgsLTAuOThsLTEuMTUsLTAuMjVsLTEuMjksLTEuMjZsLTEuNywtMC4wNmwtMC44OCwtMC40OGwxLjQzLC00Ljg3bC0wLjM5LC0xLjA5bC0wLjcxLC0wLjc4bDAuNzksLTIuNTRsMC45MSwtMS40N2wtMC4wOCwtMC45MmwtMC41LC0wLjQybDAuOCwtMS4yM2wyLjQzLC0xLjY2bDQuNSwxLjI3bDIuOTMsLTEuMzhsMS41NiwyLjE3bDIuMzQsMS4wNWwwLjQ5LC0wLjExbDAuNjUsLTEuMDZsMS40NiwtMS4wM2w1Ljg0LC0xLjA3bDEuNzQsLTAuODhsMS44MiwxLjE3bDMuOTgsMC4yM2wxLjIxLC0wLjc4bDQuMzgsLTQuMzlsMS41OSwzLjM3bDAuNSwwLjMxbC0wLjAsMC43M2wxLjIsMC45NGwxLjg2LDAuODVsLTAuNDYsMi42NmwwLjU3LDIuOTVsMC45NCwwLjdsMC45LDIuMzZsMS42NSwxLjExbDAuODMsMi4yOGwwLjY3LDAuNTNsMC4zNSwwLjk3bC0wLjI0LDAuNzlsMC45NSw0LjE4bDAuMTQsMy45MWwtMC4zNCwxLjIxbC0xLjg1LDIuNTdsMC4xMywxLjY1bC0yLjE0LDAuODhsLTEuNSwxLjQxbC0wLjg4LDIuMTFsLTEuNiwyLjA3bC0xLjM1LDEuMDRsLTAuOTYsMi42NWwtMS4wNCwxLjY5bC0xLjE5LDAuMzRsLTEuMSwtMC4yMWwtMC4yMSwtMC45bC0wLjY4LC0wLjRsLTAuODksMC4zM2wtMC42MiwwLjgybC0wLjczLDAuMDJsMC4yNSwtMC41MmwtMC4xNSwtMC41NWwtMS41NSwtMC40N2wwLjI3LC0xLjE1bC0wLjU0LC0wLjNsLTEuMDgsMC4xMWwtMS4wLDAuNGwtMC43MiwyLjA5bC0wLjUyLDAuMTFsLTAuMzcsMC43M2wtMS4xLDAuODNsLTEuMDcsLTAuNzVsLTEuNSwwLjcybC0wLjA0LC0wLjgxbC0wLjUzLC0wLjY3bC0wLjU1LC0wLjE2bC0wLjg0LDAuODNsLTAuNTIsMS4zMmwtMC40NywwLjEzbC0wLjc4LC0wLjQxbC0wLjg4LDAuODVsLTEuNzQsMC4ybC0yLjk0LDEuNThsLTAuNCwwLjc4bDAuNzYsMS4xbC0wLjA1LDAuNTNsLTEuNDYsMS44NGwtMS43MSwzLjY2bDAuNTYsMi4yNGwtMTAuOTgsLTAuMDhsLTIuNDMsMC44N2wtMi4yNCwtMC4wNmwtMC44LDAuMjRsLTIuNDgsMi45MWwtMS43NywxLjM5bC0wLjcxLDAuMmwtMC41NCwtMS4yOGwtMC41OSwtMC4yNmwtMi4zOSwwLjU3Wk02ODcuMTgsNDU3LjE4bDAuMTIsLTAuODJsMS4wNiwtMC4wMmwtMC41NSwwLjQ0bC0wLjE2LDAuNTlsLTAuNDcsLTAuMTlaTTY3My44Myw0NjIuNGwwLjQ2LDAuMDFsLTAuMDIsMC40NmwtMC4yMSwtMC4xMWwtMC4yNCwtMC4zNVpNNjc1LjI5LDQ2My4zOGwwLjU1LC0wLjA0bC0wLjQsMS4xN2wtMC42MSwwLjIzbDAuNTUsLTAuNzdsLTAuMDksLTAuNTlaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiVUdcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02MzYuOTIsMzQ2LjE0bC0xLjcxLDEuNThsLTAuMTcsMS40NmwtOC42NiwtMC4wM2wtMS43MiwtMi45OWwtMC40OCwtMC4yNGwtOS40OCwtMC4xNGwtNC43NCwxLjUxbC0xLjA3LC0wLjQybC00LjQxLC01LjEzbC0yLjk4LC0yLjQ2bC0wLjYxLC0yLjY2bC0xLjE1LC0wLjRsLTUuOTUsMS4xOWwtMi4xOCwwLjA5bC0wLjY5LDAuMzdsLTAuNTgsMC44N2wtMC4yMiwyLjA1bC0yLjUzLDMuMjlsLTAuMDYsMi45OGwtMS4yOCwxLjY4bC0wLjI4LDIuNDFsLTEuMTUsMi4wNGwtMC4xMywxLjI0bC0zLjYzLDEuMzhsLTAuODIsMS4wOWwtNi4xNiwtMS4wNWwtMC4zNSwtMC4zOGwwLjA2LC0xLjYzbC0wLjk0LC0xLjA2bDAuMDQsLTAuNTVsMS40MSwtMS42NGwwLjM5LC0xLjA3bDAuNDEsLTQuNDVsLTAuMTUsLTEuNTZsLTEuMjEsLTIuNDlsLTIuNzQsLTQuMjZsLTQuMTEsLTQuMzVsLTEuMDksLTEuNzdsMC44OCwtMy4xNmwtMC4xOSwtMS45NGwtMS4wLC0wLjkxbC0wLjgzLC0wLjE1bC0yLjA5LC0xLjgzbC0wLjM1LC0wLjkzbDAuMjYsLTMuOWwtMC41MSwtMC43NmwtMC43MywtMC4xNGwtMC45NSwtNC41OGwwLjIyLC0xLjE4bC0wLjczLC0xLjM2bC0xLjgsLTAuNzlsLTMuNDMsMC4zOGwtMC44OSwtMC45N2wwLjksLTIuMjhsMC45LC0xLjI0bDIuMCwtMS4yNmwwLjg4LC0xLjQ2bC0wLjA2LC0xLjk2bC0xLjMyLC0zLjA3bC0wLjAxLC0wLjY3bDAuNjcsLTEuMTJsNC4zMSwtMy4wM2wtMC4wNCwtMC44NGwtMC45NCwtMS4wN2wtMC43LC0yLjlsMC43NywtMC43NWwyLjQyLC0xLjFsMC4yNCwtMS43MmwwLjkyLC0xLjY3bDIuMDIsLTIuMDRsMC40NiwtMS44OWwtMC4zOSwtMi42bDEuNzIsLTEuNzRsNC4wMywtMC4xNGwxLjcyLC0wLjM4bDMuOSwwLjVsMC43NSwtMC41M2wwLjEyLC01MS40M2wxMS4xNywwLjAxbDAuNTUsLTAuNDlsMC4wMSwtMjQuMDJsNzIuNjYsMC4wMWwwLjk2LC0wLjMxbDEuMzEsLTIuMjNsMC41NSwwLjI5bC0wLjU2LDEuNzFsMC4zOCwwLjUzbDYzLjM5LC0wLjAxbDAuMTIsMi40OWwwLjU2LDIuMzVsMS44MSwzLjJsMS45MywyLjQxbC0wLjYyLC0wLjI1bC0wLjU1LDAuMzRsLTAuMTEsMS40OWwwLjM3LDMuMTNsMC42MywyLjEybC0wLjQ1LDEuOTdsMC4wNiwzLjM1bDAuODEsNC4wM2wtMC4xNSwyLjYybDEuMzMsNS45NmwxLjMxLDMuMzZsMC44OSwxLjAybDIuMzUsMC43NGwyLjE2LDEuNjFsMy4yNCwzLjY3bDEuMTcsLTAuMTVsMC40NiwwLjU5bDIuNzMsMS43MWwwLjIyLDAuNDNsLTEuOTksMi4wNGwtMC42MiwxLjM2bC0xLjM3LDEuNTJsLTUuMzQsMS40M2wtMi45LDEuNzFsLTAuNTQsMC42bC0wLjk3LDIuNDZsLTIuNjQsMC4yM2wtMS45LC0wLjJsLTAuMzYsMC4yN2wtMC4zOCwzLjE2bC0xLjA2LDIuMjVsMC4zLDMuODZsLTEuMTYsMy41N2wtMS41OCwzLjIzbC0xLjgyLDUuNjNsLTEuMTYsMS42NmwxLjE0LDEwLjQxbC0wLjkyLDMuMTNsMC4wMiwxLjgybC0wLjY0LDIuNWwtMi4wOCw0LjIxbC0wLjYzLDIuMTdsLTAuNCwzLjk4bC00LjM1LDAuOWwtMC45MSwwLjU3bC0wLjkxLDEuMDhsLTQuMDEsNi44N2wtMS42OSwxLjc2bC0xLjc5LDYuNDVsLTAuMzcsNC44N2wtMS40MSwxLjExbC0xLjg2LC0xLjMybC0wLjc0LC0wLjE4bC0xLjY4LDEuMTJsLTEuMTIsMS42M2wtMC44NiwxLjgzbDAuNDIsMy44N2wtMS43NywzLjk1bC0wLjk2LDQuMzZsLTEuNjQsLTAuMTlsMC4yNiwtMi4zbDAuODIsLTEuODRsLTAuMDksLTIuMzlsLTAuNjYsLTEuNjVsLTUuMjgsLTQuNDFsLTEuMDcsLTEuMjRsLTIuNTksLTAuOTlsMC40LC0xLjA5bC0xLjE2LC04Ljc3bDAuNTYsLTEuMDdsMC4xNywtMy4wMWwwLjY4LC0yLjMzbDAuMDcsLTAuOThsLTAuMzksLTAuNDNsLTUuNiwtMC4wN2wtMC40NCwwLjQybDAuMjIsMi4xMmwtNy40MSwwLjAzbC0wLjMsMC42N2wzLjA1LDMuNDJsLTAuMDEsNC42M2wwLjk3LDIuNDZsLTUuNiw0Ljg5bC0xLjcxLDMuMzZsLTYuNTYsNi44M2wtNS4xNiwwLjc0bC0zLjIsLTIuODdsLTUuNTMsLTMuNTRsLTAuNDIsLTAuMGwtNC43LDIuNTRsLTAuMTcsMS45bC0xLjMzLDEuNTZsLTQuMDYsMS4xbC0xLjc1LDEuMDZaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiU0RcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgICAgPHBhdGggZD1cIk02ODIuNjEsNzgxLjQ1bC01Ljg2LDAuMTVsLTIuNDYsLTAuMzFsLTAuMDcsLTMuNmwtMC43NSwtMi45NmwwLjIyLC0zLjM3bC0xLjM2LC0wLjk2bC0wLjI4LC0yLjBsMC43NSwtMS44NWwwLjAxLC0xNC43bC0yLjIsLTcuMTJsLTIuOTksLTUuMTJsLTAuMTQsLTIuNDJsLTIuODMsLTEwLjU2bDEuNTMsLTEuMThsMTEuNzEsLTEyLjI5bDAuMSwtMC40NmwtMC44LC0xLjc3bDEuMzgsLTIuMjlsMC4xNiwtMy40bDIuMDgsLTEuNzFsMy44MiwtNi42M2wwLjE0LC0xLjU5bC0yLjA2LC0zLjg0bC0wLjU3LC0xLjlsMC42LC0xLjcybDAuMTksLTEuOTNsLTAuNDMsLTAuNzJsLTEuMTUsLTAuNjNsLTAuMTQsLTAuNTFsMC4xNSwtMS4wMWwxLjQ0LC0wLjczbDAuNTUsLTAuNjRsMS4zLC00LjU5bC0wLjQ0LC0zLjRsMC4xNiwtMTAuMDZsLTEuMCwtMi42NGwtMC4wOSwtMS42OGwwLjgzLC0yLjFsLTAuMzIsLTAuNDVsLTIuMywtMC4zOGwtMS4yOSwtMS4wN2wtNC42MywtMS43MWwtMy41MiwtMC4yNWwtMi44NiwtMi41bC0yLjQ3LC0wLjVsLTMuMDgsLTEuODlsLTkuMzMsLTAuMzhsLTAuMTQsLTMuODRsLTAuNTQsLTMuNTVsLTEuMTcsLTIuMDZsLTAuMzMsLTEuODVsNS4wMSwtMS45OWwxMC4xMywtMi45bDE5LjM0LC02LjY4bDEuOTYsMy4xbDIuOTIsMy4zN2w1LjE0LC0wLjg3bDEuOTMsLTAuNzRsMS42MiwtMC4wNWwxLjQsMS45bDAuNiw0Ljg2bC0wLjE5LDMuMjRsLTEuMiwyLjA4bC0wLjg5LDIuNzFsLTEuMzEsMS41MWwtMC4wNCwwLjkzbDEuOCwyLjM2bC0wLjA3LDEuMzdsMC4zNCwwLjgzbDEuMzQsMC45Mmw0Ljc4LDUuMzNsMS42OCwwLjkxbDAuMDgsMS4xM2wtMC42MSwwLjg2bDAuMzIsMC44OGwwLjk5LDAuNzNsMS44MywtMC4xMWwwLjU0LC0wLjY3bC0wLjExLC0zLjQ5bC0wLjYyLC0yLjEzbC0wLjY3LC0wLjkzbDEuMzgsLTMuNTJsMC42LC0wLjgzbDQuMDQsLTAuNzdsMC44MSwtMC43bDAuNDQsLTEuMjlsMC4zNCwtMy4zN2wwLjEyLC0zLjE0bC0wLjI5LC0xLjg2bDAuMzksLTIuNjdsMC42MSwtMS42N2wtMC41OSwtMy4wMmwtNy4wNCwtOS4yN2wtMi43NiwtMy4wNWwtMS42OSwtMS4zOWwtMC4xOCwtMS43MWwtMC40MiwtMC41M2wtMC4xMSwtMy4yOWwtMC4zNSwtMS4wbDAuNDQsLTIuMzJsLTAuMjIsLTEuNThsLTEuMDcsLTIuNDdsMC4wOSwtMi42MmwxLjc0LC0xLjY1bDAuNDIsLTAuNzlsMC41MywtMS40NGwwLjI5LC0zLjE1bDYuNzIsMC4yOWwwLjk5LC0wLjMxbDEuNzUsLTEuNDZsMS4yMiwwLjAybDIuODQsMS42N2wwLjQyLDAuODhsMS40NCwwLjQ0bDIuNSwwLjEybDEuOTIsLTAuMzlsMS4yNiwtMC45MmwyLjE4LC0wLjQ2bDIuNzIsMS4zOWwyLjA0LDAuM2wyLjA4LC0wLjQ2bDIuMjQsLTEuMTlsMS4yMywtMS4xN2wwLjkzLC0yLjEzbDIuODIsLTAuMTdsMS41MiwwLjM2bDIuNDMsMS4xOGwzLjUxLC0yLjE2bDIuMTYsLTAuN2wyLjA5LC0wLjBsMS44OCwtMC41NGwyLjg0LC0xLjcxbDMuMDQsLTAuODJsMi4wNiwtMS4xMmw1LjE5LC0zLjk0bDEuMzEsMS43M2wtMS4xMywwLjkxbDAuMDMsMC42N2wwLjksMC41NGwtMC43NSwxLjAxbC0wLjEyLDAuODJsMC40MSwwLjg1bC0xLjYxLDMuMDZsMC43LDEuNTdsLTAuMzQsMi41MmwxLjEyLDQuMDJsLTAuMzQsMS4zN2wwLjI0LDMuMmwtMC4zOSwxLjA4bDAuNzYsMC44MWwwLjMyLDEuMDdsLTAuMjcsMS45N2wtMS4yNiwxLjA0bC0wLjE1LDEuMDlsMC4zOSwwLjM5bDEuMTgsMC4wMWwtMC4yMSwzLjJsMC4zMiwxLjA1bC0wLjQxLDEuMTRsMC41OSw3Ljg3bDAuMjUsMC44bDEuMTQsMC41NWwtMC44OCwxLjc2bDAuMDcsMS44NWwwLjMsMC4zNGwwLjQzLC0wLjE3bDEuMCwtMS4yM2wwLjI3LDAuM2wwLjMyLDIuOWwtMC4wOCwwLjY0bC0xLjUxLDEuNmwtMC4yMSwxLjYxbC0wLjc4LDAuNjRsMC4zMiwxLjg5bC0xLjAzLDIuNDNsLTUuMjQsNi4wM2wtMC4xOCwxLjEzbC0xLjIyLDEuNzRsLTIuMjQsMC44NWwtMC4xNiwwLjQ4bDAuNSwxLjM0bC02LjgxLDQuMjJsLTEuODMsMi4xM2wtMi4yMiwwLjc5bC0yLjQ0LDAuMWwtNi4yNCwyLjM0bC0xLjI1LDAuOTlsLTIuNDEsMC44NmwtMy44NiwyLjE2bC0zLjE0LDIuMDVsLTMuNjQsMy4xMmwtMC41MywxLjcybC00LjE5LDQuNjlsLTEuNSwyLjEybC0wLjE0LDAuODZsLTAuMzksMC4xMmwtMC41OCwtMC42OWwtMC43LDAuMTlsLTAuMjcsMS40NWwtMS4xMywtMC4yNWwtMy4yMiwxLjg2bC0yLjQ2LDIuMTVsLTMuMzMsMy45OWwtNC43OCwzLjc5bC0wLjgsMC4wOGwtMS42NSwtMS4zNWwtMS4yNCwwLjEybDAuMDYsMC40NWwxLjEzLDEuMzFsLTAuNTgsNy44N2wzLjI5LDQuMjNsMS41NSw0LjY1bDAuMTYsMi41N2wxLjYsMy4wNmwwLjcyLDQuNjhsLTAuMTYsNC4zNmwwLjkyLDEuMDRsMC42MywtMC4xM2wwLjI5LC0wLjY0bDAuMzIsLTMuMDlsMC4zNiwxLjE0bDAuMTMsMS40NGwtMC42LDMuNTVsMC45NywzLjcybC0wLjkyLDIuNjZsLTEuNDYsNy42NWwwLjQsMC43NGwwLjk5LDAuMzNsMC42MSwtMC42N2wtMC41OCwyLjgybC0yLjY5LDQuNDJsLTEuMTEsMS4zM2wtMS44NSwxLjMxbC00LjQ2LDIuMWwtOS4wMywzLjA3bC01Ljc2LDIuNDJsLTQuNTksMi45bC0yLjA1LDEuOThsLTAuODksMi4zbC0xLjU0LDIuMjlsMC4wLDAuNDFsMS4zNSwxLjk4bDEuOCwxLjQ3bDAuNiwtMC4yMmwwLjI4LC0wLjkybC0wLjU4LDcuNzJaXCJcclxuICAgICAgICAgICAgZGF0YS1jb2RlPVwiTVpcIiBmaWxsPVwiIzY0OTdiMVwiIGZpbGxPcGFjaXR5PVwiMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjBcIiBzdHJva2VPcGFjaXR5PVwiMVwiXHJcbiAgICAgICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiIGNsYXNzTmFtZT1cImp2ZWN0b3JtYXAtcmVnaW9uIGp2ZWN0b3JtYXAtZWxlbWVudFwiLz5cclxuICAgIDwvZz5cclxuICAgIDxnLz5cclxuICAgIDxnLz5cclxuICAgIDxnLz5cclxuICA8L3N2Zz5cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluL3Jlc291cmNlcy9zdGF0aWMvdmVjdG9ycy9hZnJpY2FNYXAuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRUFBQUFBd0NBWUFBQUNoUzN3ZkFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUFnWTBoU1RRQUFlaVlBQUlDRUFBRDZBQUFBZ09nQUFIVXdBQURxWUFBQU9wZ0FBQmR3bkxwUlBBQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBRHA5SlJFRlVhTjd0bW5sMFZGV2V4ei8zdmFwNmxUMEVFbHI2NlBUUnNWc1FSc1FGYVcwYmFSSGJIUlJVWkErQ21KQW9yc2R4NitQV1BiYk9rVTJJQ2NnT2lvemRMcmdpaDdhVlRidEZCR2UweDNabW1pMEJRa2lscXQ2N3kvenhLclhFaEVvZ2ZmcWM2Zm5sM1BOZVhyMTM3LzErNysvKzd1LzN1eGYremtWMDlzWFpzMmZqdWE1MThpbW5sRGlPazIrTUlkTGlrcHNUeExZRXhoakFZSXhCYTVQNC83dWl0TVlBMkhhYkh4UUNzQzJyZ3g3NDlXcXRNVWFqdGNIMUpKR1dPRGxGZVJqQUN3V2JqNTQvNkpBZGFkR3orcDNWZlFTc2Yrc3RYS09MdmwvV3U2Sm5TY25vVUNoVWJGbUNEN2QvUzgyYTdjVGlFbU1NUmh1MFNZQnZod0FoNFBieEYzQit2c3ZlMlhVWTEvV2ZoMEtjVkZYTzF1WVE4NWR0cG4zdURBWURSaWZhVWdRREZoTkdEZVNzRXNIK3VsVkVvOUZEc2ROT1h0MDBzTy96Z1paWWM4VWQxVm14QmJLOThPYjZONWsvWW9TNDQ4bG5Lb3A2SHZoRm4zRTNCSUs1dVFnaEdQN1RIbXpaZVlUNUs3Y1NkMVZpOUhVbStMUjd5eExjWmhkd1VrNk01cysrUkxkRS9lZTVPWnlVazRlT2h0bXk4d2hhbXc1Nms2amJhSUkyVEI0emlBdFBMYU5wemtMc2padkpkVUkvS0Q1N1FQOXdVYkc2NmRZeHp5cExVRlZWZFV4OEZsbEVTTVgwemIvdkZmN1RmMThmcVZrWmFGaTBHaFdMWTRDaWdqQVB6eHhLNWJqQmhFTTJRZ2lFc0VCWS9uQUxBWmFWVWZ4M09pNXQzMDhXSVJMMVFqQm9jK3ZZODducnVqT0l6RmxJNHpzYk1hRWd4V05IOHIyUlY0UUs4dk5IUC9IRUV6MDZtb1pkSXNBU0ZvR1lseGZLeXkzQjh6aTRlQTBOZFNzeHNUZ0FCWGtPRDFiOGxOdHZPWjlRSUd0MUtiQnQvMW9KT0pZWVE5QzJtRGIyUEdaZCt5T2FucDFQNHp1YndIRW9HWDhEUGNaZGp3a0ZzWVFvQ1lWQ3VkMURnQk1DWStnMTRRWUtMLzBKeHZOb1dMU2ErdG9WNkRRU0hxb2NTc1c0d1Q0SkJuenprbDZTRk5BZVR2OVo1bnR0SlJpd3VXM2NZTzY1N2d5T1BqT1h4cmMzZ2hPaTU4UXhsRXdjalFrRzBFcWh0VTZXRXliQWs1cG9VNFFkaHpWNU02WlFkT2xQTUs1TFErMUs2bC9JSk9IaG1VT3BISjlPUWdaRXZ5Ukh2eTFGaVNtVFFWamkzdmpnYng5L0FmZU42a3ZUMDNNNHZQNERoT1BRYy9LTmxFd2FBOEVnR0UzVDBTZzdkdThsSHZkd1hYbmlCQ2lseWMwSnN1YTFIU3g0KzA4VXpKeEcwZkNMMGE1SHd3c3JhS2habmtIQ0kxV1hVRGxoTU1GMlNUZ09NUkFLMkZST0hNSUROL1NsNlZmUDBiaCtBeUxzMEt2OFpucE51UmtSQ29IUk5FZmkxS3pleHJwM3ZpQXZONFFuVmRicXM2NENRZ2dDdG8xVW1oV3YvaEhMc3Fpb21vNHcwTGorQStwcmxtT01wblQ2Qkt5d1EwR2V3Nk5WdzhEQW5HVmI4S1R1Z3JmeFhmREJnRVhscENIODh3MTlPZlRZMHpTKzhUN0NjU2k5ZFN4RlUyNUNDZ0dlUzNQRVpjR0tyYXhkdjVNelQ4M0Zzc0NZN0ZNZ0t3R3RneWlFUUduRDBsZitBQWdxNzdnTnRLWngvUWJxRnl3RGJTaWRNZEVuSWQvaDBlcGh3SGRKRUNRTU9tMFVYYlRoS1FGKzVxUWhQRGk2SDQyUC9ackRyNzJIQ0R1VVRodEg4ZFN4U0VzZ0V1RG5MZC9NcXRkM0lKVVAycGlPbmJFdUVaRFNCSjhFcVRXTDEzNkNObEE5NjNhZmhEZmY1OER6UzN3U0tpWjFRSUtpMDZwZ0RNR0FuUVRmOU5pdk9memF1MWhoaDU0ekpsQThiUnpLRWdqUEk5TGlNbnZKeDZ6OFRScjRoRWZhTFFTa0c2Y2tDY3F3NktWUDBOcHc1MTJWb0RXSFgzK1BBL01XWTR5bXJISXlWamo4SFJLVTdvUlJTQmk4ZHNGWFRLTEhiUk9RdG9WMlhTSXRMdis2NkNPV3Yvb1pudElaQkhmZ2pCNkhCblNncmxKcWF0ZHNSeHZEckh0bVlyVG04Ry9mNWNDY1JhQTFaVlhsR1NRWVlQNktyY2ZzbEVtb2ZjV0VDNUxnRHlYQWwxV1ZVMUl4Q1dsWnZ0cTN1RHhUK3lGTDF2M0JCeTlJek5ldVdkNU9UNEcwQWZLSkVQNFMrY0txYldodHVQdmVhbENhUTc5OW0vMno2OEJBV1hXS2hGOVVEOE8yQktHUTNTNEp4a0FvWkRPejFkcW5nZTlkTlpXeXFuSlV3TWFTSHMwUmwzK3ArUjJMMW43YUJuelhwZE1FS0cyUVNxTjE0bDRhbE5KSXFabTNiRE91cDdqMzNpcU1VaHg2OVMzMlBic1FJeVc5NzV5R2xadERRYjdEUXpNdklhNE02dk1kN2RaL3laQlR1ZlFIT1J4NTVGZSsydWZsK3VDcnB5TENEbmdlalUweEhwKzdrZHBWMjVCUytzaU54bzhUTkdnL0tPczJBZ0syaFRhR2MvdjM0ZnNuOWNZZzBBYTBKaG1lS21Wb09oTGx5eWE0NFBIN0NaN2NCM2ZQZnJ3RERjUysvSnJjUVFNQUtNeDNBR2h1ZHg0WVNnc2RHdC9iaGNqTHBjZU4xNUEzYUFBOUo0N0JDanRKZy9iNWwvczQyaHpuMmhIOU1GcWh0VVFydnlqbG9hUkhhWkZHS29WdFpUZTZXUWtJQlcya2xOeDAxUUJLUzB1eExBc3JMYWhKZGQrQUFkdTI2UFBvM2RCSks1eFdBUUJGMTR5ZzZOckxFM2EzMVFBblhqR0dDODQraFhQNmZ3OVBlbml1aCt1NnlSS1B4NG5IWSt6ZHU1ZmR1M2NUQ29WT25JQldzV3dMT3hqd0NSQ2luUVV0N1lsb2RYazdrSTZEQVVUQTd2QWJFYkFKT0FHTU1HZ0IyaGhzbzVQRjBoSkxCUkMyVFdjbHV5TWtGUWhCWk11bkhISVZGZ24vMllCSXJEV21OUWVnamU5OUdkT3hVYklzNGwvOVo3TGUxamFPck45QTdPcy8rM09ydlg1Z2tFcmhTWVduSko1S1hLWEVUUmFQdU9jUnRVSGtCa0YxaHlmb2VZaXd3NUUzM2llMjQwdUUxZ2lsUVNtUUNwVENLT1VEa2pKMWZ5ejFiNk1CeHZPb3IxbCt6RzhNSURGSWs3aGk4SXpCSTFHTXdUVUd6MmlhKzUyR2RmMElUQ1I2NGdTMDZUbWtSMjBpUFlKTEE1WXRydThrTWUyMW5sUXRRK2J5ZDV4TlpzOWdITHMzWGZuaHJ5akgzK2J4RS9CL1JQNmZnTDkxQi83V2N2d0VtQzcvOEZlVTQyK3ppNnVBdi91RFNidTIza05xR2NzV2kzWms3Yk40anEzZVpydTRUVnJwVGdKRU1JaldtcUlyZjBiUjhLSGQ1Z2cxTEY2RDhieGtHNzBtMzRoeitxbmQ0Z2haTmh4eVhleE9lSVRaQ1FqWUlDVjVnd2RSMHJ2M01Wemh6a3Z6aDFzNXVHeHRhbXNzWUZQMDgySGtYM1IraDk4WVFHcUY1eVZpQU0vRFM0c0RYTmNsRm84Umo4VnAyYk1IczNNbmRHY3NvSlZHZVJKaldaZ3N3VkJtenhOYVl2eDdFYkRwTUNIUTlwSHlzN3JKZHBSR3hpWFM4Nk0rNWNtTW9qMkZUbmlqblpXc0JMaWVJbUFMVnIvK09Yc1BxZzdEWWNzU2pMdjJMQzQ2N3g5U3BFVmpIRnp5RXBGUFAwY0lRZEdJb1JTUHVxTFRma3YwczEwMExIa0ozUklsY0ZJWkpWUEhzdVhiWnBhOHZJMlk2eDR6SE81L2FnRFA2NFpZUUNwTktHQ3pmZWNldHUwNm5KRVFrWW1FQ0FKdUhYME9BODdvblFJZmkzRmdkaDM3bjZ0RlIxcm9jZlZ3OUpuOXFHK0trMFA3MFdEOWtSaU9MWko1Zy9BWi8waXdyQmY3WjllaFhZL29OLy9Gais2dXBLQW9oelhMLzRpVUhuNGlSQUhLdjJySmdCL21NL0QwazRuRnMyK01kSG9LMkpZZ1lGc29BWWpFV1FEOGhFbjU2RUhjUC8xaTh2TkNLZkRQMWJGL2RpMDZIcWRrNU9VVVBuUTNUNjdkelhrRG8xeGRJTnF0LzRQTjM3RHQwMjk1ZU9ZbEZPUTdXTGs1OUw1ck9pSVFZTi9zV2hyZmVKOThvN252cmdvRW10cFZtL0drQjFoSkk0d1FpRTRrUWxxbHkzNUFhOVhHK09CdkhYTk9HL0R4RlBoWW5KS3JoMVA0ME4wOC92SXU1aXo1R05kVkhhWURYRmN4WjlrV0hubHVBMGViL2QwbUt4eW1yTHFjM2xYbFdEa09qVzl1b09ucE9keDV6UStaTXVaY2d2YUo3VUJsMXdDVHVieWFOUENUUmczazdxa1haWUtmVThmK09YV1l0dUJmL0JpbHpURUR2dFpFNjl4bFd4REFvOVhEZkUwSWh5bXJtb3JVbXIvTXFhUHhyUS93dEthcWFocEtTWmE4dkMxdEc2eHI2MU1uZG9aU3pvNXYwQTBCV3pCeDVObk1tbkpoSnZoNWl6a3dkekVtRnFOSEcvQ2VWRmgySnhST2dDZDlUU0NkaEJ5SHNwbFQ4SlJpejd6RkhIbDdJMUpyS2l2SzBVcXk3Slh0ZURJMTU5dGswMDVBQTFxSmFBVnZXWXdmT1pBN0ovODRBM3o5L0JlcG4vY2lPaGFqeDlXWFVmamdYV25nZGRkeUJFTGdTWjFCUW41ZUNPRTRsRlZNd2xPS3ZRdVdjT1RkVFhoYU1lTzJ5U2d0V2JGdU8xS3F6cDgzNkF3QnFUbHZzQzNCK092T29ucnlFUEx6bkJUNEJVczU4UHdTZERSR2o2dUdVL2pBTEI1LytZczA4T2thbFhJVVRUdlBNalVoUmNJajFaZVE2OWcrQ1RNbUlMVmk3OEpsTkwzM0lWSnJwaytiZ0phU1ZiLzVKTUZoTnhGZ2pPK0NCbXlMVzY3NUo2b21EaUUvTitSM09oYW5mdUV5Nmhjc3hVVGo5TGpxVWdydXY2TkQ4RjJXTkp0Z2pPR2h5b3NKaHl4L2QzamFlS1RXN0gxaEJVMGJmayt1MWt3dHZ3VXBQYjc2K3M5b2pYOWM1MFFKc0cyTGxxakxqVmYwNThMQmZjbkxEYUlORUkvVFVMT2Mrb1hMME5FWXhWY09vL0MrYWg1L2VSZHp1d044R2dtdVZNeGR2Z1d0RlEvTXVJaXdZMkdGSFVxbjNvTFVtbjIxS3ptNjhTTnl0R0xLcExGc1A3MkF5TkU5T0k1ejRnUUVBeGFDQUFQNjk2RWd6L0hCdTNFT3ZyRFNQeHdSalZIODgyRVUzbHZGazJ0M01YZkp4N2hKOE8yN3ZJa0RiNWxUSUQzS2JQdGR3akRPWDdFVnJTWDNUMCtSVUZaK00wb3A5aTFlemRGTm04a0IrbDUzR2Y5dUZ4RHNscXh3WW9ORG04UlJ5RmljZzNXck9GaTdBaDJOMHVQeW9SVGNNNU9uWHRuRjNLVlp3Q2ZnZGh3S0hIdEI5NlJpd2NwdGFLMjViOXFGaEIwTEZRNVRXbjR6eWhqMnZiaWF5S1l0eEpRa2NOM1BFRTNOV1FuSU9rbTAxc1Jpc1diUDh3NnBhSXo2MnBYVTE2NUFSYU1Vai9EQi8zTGRibjkvVUxZeWZvejBkb0xRNy94MVppZEpDRHlscVZtOW5hY1diQ0xTNGhHd0xBSTVPWlJOdm9uU0NXTUk1SVRSVWpib29vS0laV1czQVowNEk2UVlOV3BVdzZIR3hqWC9zMnFkVzcvWVB5ZFllTmxRY3U2WXdaTnJ2MkRlMHMzRTNjUnAwV1Erb0xYb1ZORTZSWUJKVFlQMFoyaWQrVTNpdTJSZENVMm9YZk1KVHkzWVJGUEU5VW5JemFGczBoZ0t5bStPeWROT1dYM0ZqYmMwV3QwUkRsOTU1Wlc4dnU3ZitFdjlnUVdOQnh1VWMzYmZNY0ZRcU1TTUg4bnZ2dDdMenAxZmNWNi9ncVNmb0xYQm9OT21jbXBVaFNXd1ZCTjdvaDVIQi9YRHVJbUVTQ2pJbm1nRVM3bjgrS3ppTnJ1N3FlUi8rbEZaYlRTNy8rTWJObjFVeURuOSsrQkphYUxSNk1HajU1NjVLbEovb0c1VFhTMHp5NmRtSmFEVGRucnBrWHBVWG80byttUkhzZDBTemRXeHVJZ2VQa3BoZ1VQQXRqSkgxdWlNVEZtNnhGd1B6d2lzSENldGVZT094Z2tLUXpnVWJMZDlRK3RCYVpNOEEraDZrc2FtS01HQWhkYmF0TFMwUkxadDIzYWtvS0RBMU5UVWRCYmEzN2Y4TDNZcXE1N3AxSEtwQUFBQUpYUkZXSFJrWVhSbE9tTnlaV0YwWlFBeU1ERXlMVEExTFRJNVZERTNPakV4T2pRd0xUQTFPakF3eUJuTDZRQUFBQ1YwUlZoMFpHRjBaVHB0YjJScFpua0FNakF4TWkwd05TMHlPVlF4TnpveE1UbzBNQzB3TlRvd01MbEVjMVVBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9mbGFncy9lbmdsaXNoX2ZsYWcucG5nXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUF3Q0FZQUFBQ2hTM3dmQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRG9BQUJTQ0FBQkZWZ0FBRHFYQUFBWGI5ZGFINUFBQUFBR1lrdEhSQUQvQVA4QS82QzlwNU1BQUFBSmNFaFpjd0FBQ3hNQUFBc1RBUUNhbkJnQUFBemlTVVJCVkdqZTVacHJyQjNYVmNkL2E4L011ZWVlKy9MMUszYjhpSzhkSjZFRTdLUjFvZ3BJU1lrVFFVTUZBbFNpZkVtSktrQ0NELzFHaGVCREFBa1JBVkpWWGhLdFJGRkZWVUliQ1FpcTVCWm9TK1BTQ0tlT0hkY21qcDM0eHMvcis3NzN6Sm1adlJjZjlzeWNPZWVlZTMydWMvMkpMZTB6YzJiMjdGbnJ2eDU3cmJVSC9wODN1WjJIamlIRXFOd1REUS9YaDRiR3d6QWNOWUdwaTlPUXpKcHlvQkZvRENKRERhZ1BRQlJDTFlMSWQ0MUNDQU1JZkZkandFaCtOS2dSRkVFRkZJSEFxQXREYTlNMHliSnNxZGxzemJ3M2VYbjJrZDI3czRtWHZrSnlwd0U0WHF0ektvbmxzUVAzUDlqWXV1V1oydERRVHhnanU4VHBpS2lMVUF6cUJBVlFjSXBJOFFvRjYxQnJJWFBnbkI5bURBUW1COEdnWWVpQkN3STBEQ0FNMjhjb1JBZHFUbXVSZFdHd25JbVphaGx6YWlGSnZqcDU0WjJ2RDQyT05wLzR4NWZ1REFEZjI3NkxneDg3eXRTcE0wK08zbi92NStyRFF3Zmw1Z3lrcVpkcUVIakNSZnlzSXZuMENncW9nbk9RWldobUlVbkJXbkNLcWtKbVlibUp6aTNBM0FLYXBEbUZPWjRpWGp1Q0FPb0Q2TlpONkxiTlpFT0R4SnZHbG01YTk5bVQzL2pXQzJOYnh1TmZlZTIxdmdFSStoMzQyenZ1WnViMDJhMmJQbmo0TCt0Ynh4L2lCMmZRaFFWMHVPSDVzeG1hNVQzTjBEVE5lLzQveTFCblBiTWlFSVZvTFVJSGFwQ202TFVwM1BXYjZNSXltbGsvSjZCNGdGUVZkYzdQMDR6UjJYbC96MmJJOG5MTkRUVU9TeFNlMkxyenJuTVBicm1Mcjc5enNTKyt3bjRCR042K2xYVHorSkZ3ODlqRGV1azlkR29hdVc5ZnJ0bzJKN1ZicmRaV01BV1ltVVBQWDBLYmNjY2pxbDNqS3IrS2VIT2FYNFNSSVZoYXByYTRPRElvNXVPZitjby92Zkw4Z1lPdVg3NU1QNFArL2RFUHMvMG5IeVVjR3psa2pEVDArazIwWHZOT3lpbE9uWmVzVnFTbGl1YlhWKzJ0RnU3ZHkxNml0QzFGdFMxOTUrV01BazRMWVBKcldhNVJ6bUhpbU1qWkgvdTFnYUhSZWh6M3kzOS9BQXplbkdiNFQvNFVVNnZ0d1RsME9VYkRNQ2ZZVTFzUVhqMzN0N3FZcmpDazg0dm80aklWWVplTVZ6VUtyV3FFbG1CUkFWM1NESk9rMnhyMStsaVlaaHNMZ0szWCtaeUlJUWpHQ2tmbS9WdmJVdHU5cTJtUC80V29sNWE5V0R1R2F1ZGoycW44SFdCSnhWNmNRNUswRVFpTndQVnRBZjM1Z0RETDJBTkdqQXg0YVNpaVBka2x0MUJ1YmY4S3JkUVRYM2o2WGsxV2dsaitOYVlDbENKSkVwb2tyUmxkZGJiYkF5RElNbW9ncUpyeTllbzZxVm5CYjVXSUhtQW9mbG1rOTYwS1h6MnZlK3BONTF6TFRTTkJZREI5TDI3OXJ3S215b1o0TDh5dGdOYXE4VlppQktTWFlOZWFxUGZsb0VLK2MyZ3pSa1NRZFlSMy9RRWdWUXYzQVFuV0lSWHJGS1h0RjFRaGlwQ3hNV1IwRkdvMWFMWFF1VGwwZnFIdFEvcGxkTFVXQmY0WndRc2tTVmtYOS8wQ29BV3J6dVV2RkxCWlNXLzVTdWVnMFNBNGRJamcwVWNJSnZZaEk2TStCN0FXblp2RHZuVWUrK3B4N01rMzBJb0pDSVgzNkJNRThlRnlPVHpMSUVrUkkrdUs3L3ZUZ09JbGhUb2JnMXJYd2J5cUVreE1FUDN5THhFY1BnejF1aGVHdGVqME5PN2FkWFJ4RVRNMmh2bkZYeUE0OU9Na24vMGIzTlRzMms1d3RXYkVKMUxrcXRkS2tDenoxemNjZ080NWpZQ3piUSt1anVBREg2RDJxZWN4ZS9mbUVZdkR2WGVaN05nM3NTZE80RzdlOUhtRE1jalFNR2IvQk1GSFB3S0x5N2p6RjNxcjdscW9HSU1FZ1plSkFZMWp2eFFHNGJvc3FXOG5LT0NUbGR6UllCMlNCelptOTI1cW4zek9NMjhkaUdCUHZFNzY5MS9DdmZ0T1BvSEpiZFdpTXpOa3g2L0Q1U2xrODJab0RNSnk3QjFKa1N1czFWVHo1TXVVLzJVcExrTkZ1Uk1BQU9qU0Vzek1RWnExWDFZYklQcjVwekVURTU1NVkzQS9QRVB5dDU5SHIxN3pSSGJ6azJlTE9qT0xYcTZPRVIvYkx6ZjlYR3NJUThNOCsxUUhxVVdYbXdnNGsxWUxFcmR1ZlkxVkFYYnVScS9jUUM5ZGhsYmlRMUJyTVFmMkV4dzUwamFIeFFYU2w3NktYcjFha1ZCWEI4K2d5MU5rYS8wMTV3aVBQazd3eUllOGlSV0pWbGRnbytEdHZ3QnRxWWtrcWMrWSsyVnFQUnFnQU51M3dPUjE5RktybmY4RHdlRkR5T2lJWjhZWTNPazNzVysrNlZXK2h6RVdjYUt2QmRpS0EvUitRM2J1cFBic0o0Z3ZYRVRuRnpEM0h3Um5jU2RQZHdJUkJJQWdhUUl6ODE0YkVZemNBUk5Rd0RWanY1eGxEdUlFQm1yUVNqSDM3TXR0MWt2VG5qcU54aTBrS09RZ2JSQkxGUkFQZ0MyaVNtMDdWY0FjK1NBREwvNGhoQ0VNRDlINjNSZjhlRk9aczltQ1pveE96L2x6MmxIenhpK0RDUGJjRDVFamo2cUVJWnkvNUlPT3FWbG9OTXFrU0pNVWQrWXNYSnZ5OVQ1ajhrcU95YXRGK2RFWW4xSG1jWVdNaldBZS9GSE1oeDhoK05talhzQ1BQNFkyWTFxLzl3ZTRIN3hSWWQ1UHFjMFluYnptMS84T1N1OEFBRzV3a0JpVW9ZYVZlL2Q1ajMzbEJtenlRVTZwY2M2aFMwM3ZrTUxRWjJ0Rkx5Z1hJTFBvMUl4M1lLcXdiU3ZCRXo5TjhOR1BJSHQydGFQSnVUbmM2VE4rM3FBN3ZsZnZqTHNZN3dqWisyajkrWXN3eElMaW5CSUUzZ2NNUkxCdEhMS3NmTGxFRWViZ0JITFBMdGg3TjdKbko3SjdCK3k2eS9lN3Q4UE83VEEyWEJLdklyaTMzcWIxUnkvUy9OWG5TTC84a3RlUStRVVlHeVg2clYrSHplTXJIR0V2Tm1YVk8rOFRBRlhGK1JQSzZvUUl0RnE0SzFmYXJ3eEQ1TjREYUdCNlZBamFjYk9tV1Y0Y0tTZ1d5Q3p1M1VuY3U1UG96V2xhdi9QN3hMLzVhZlR5RmN5SEhscVRQc21YVlJIQklKaDE1QU45NXdMbHNTaG1pSGRrN3RScDlMR2ZBaE9BcUY4Vlh0bU9YcnRXc2RzeWx2Wnp0SkllaFJEOGVHdEpQdjkzWlAvOGIyaG15Yjc1bjBpOTd1OXBaN0drVW5CSGZFNmtKakJxMXJFSzlLY0I1QnBBeFdzYm54WGFOOTdBWGJqb0NYUU9zMnNYMFZOSHZRY3ZuR05WRzFUUlZsck9wZFdxVW1ESXZ2MWQwaTkrMlQ4YkJybGZXZXBoQXQxcUFDS2lRVlJ6Sm9vMkdnQncxWC9PNVo3ZG9OTXpwUC82Q2pTWFM0Y1hIajFLK09RVGZuUERkUkh1RkZvSjZuelJWTFp0Z2NGNisvYVpjekE3Mnk1M3dZclF1RmRnNlkvUzNwTFlhQUJzY1ZxWVFHQUsyTEhIditkQktKYWt3VUZxenp4RDlPd3ptSjA3L0RWcmZWMC9TWHcrTVRiaXZmNytmZDRrS3R6b09uUDZvc0J5Ty90OGZma0FVV1V4WndNb296NGsxOHcwSmZuYXkyaVNFajM5Y3pBNkNvMUJvcWMvUnZEd3c5aVRKN0Z2djQwdUxBQUdlZnhuTUx0M2tYM25WZHgvSGZmYlpldGtXdkJBU2NXWktqNXN2eU9Sb0sxS1gxMFpDbnRxQk9JVzZjc3Y0OTU2aS9DcEp6RVBQSUFNRDJIMjdzSHMzVU9ZRnl6YzdDejIxZjhtL2VJL1lGLzdIMjlPNjViNDZxaXNVcHQrbndDbzl3R2xTMVB5VUxkU3dSRUI1OGhlZjUzczdGblArUDREbUx1MlE2Mkd4akh1NmxYc3QxL0ZmZmY3YU54cVI0b2IxU3FiS2hzTFFCWFpZb3NtTWwwdmFsZUxhTFZ3Wjg5aHo1NXJSNExxTXp2OTMzZlFWdElSMmxabmVGOXdDRTZDd04xeXhWZ3ZBTTQ1RWtETGhkamxUbkFsQTJYclpsQUV6UndhSnl1NGJHZURQdGJvV3lsV01xcHFqSXJiWUFDaXVYbW1QQkpXSzNYQk5wMjZRdTIweDdrdUxrR1NsUHQ3cTNEVkkrcHRiN1ZVTjBLS1diUXoxbERkNkdWUXdvQS9BM1hHcEZxVXZ2TThYdW55d21XWHNvT2cxaWRBUlRGVisrd2xzL2tlWUhsT2wxbDZCY3BVeU54Rzd3c2tvOFBvbDc2Z2IvNzVYeTNhQzVNd3Y0ZzA2a2lXb2RWNE5OK2o4MStCV0RUTmZHeVFGbnY2Q3lzazMwc1BaTVg5MVRKOUxSMjBFM0JoRU51aGVyeWVVTGd2QUpiR056SDVxVStUYkIyL2xseWNwR1lWbWJ5S1RNMzQyaHprNVMyTFpzNFhONnp6K1g2eGUxeUo0UFZXZm5wRjVGZlJzWTVIdFl4U0xVb1dCak90ZW4wcDNPak4wWThmTzhiM2Qrd2lWVDFYVjAwTVdwTTBSWkowaFR5MWtxTDAzTWt0cit2cTR0ZjJjVlZ0N3ZBQmtBcTBqSngvKzhEZXhUMlRWemNXQUVTWW1kaVBOWElpakZzWHNlNCtvN2xrVnV6Y2F0ZXh3cml1Qktia29yM3hXSUpUWmI3N3ZFeXM4T0ZwYkl4ZGlzTC9lT3JZZDdMNzVtYzJHQURneHNnd1gzdnVFeGMvK2VKZmZLR1pwaThNT2xjTHlMMW9rU1JXR05XOFlsdjRDTzBZMHlsQkgwVGwxcjVLNHRPcjJPRUFLOUF5aHFXQjZGczNCdXYvY3RSL0cxVDFUR3ZMdG0rb2dML2V0NCswVmh0dXpNNzlSdFJLbm8rc25RaWREZ1NGVklxNFhDcmY5bEh4MXJLU0l1Mmg2bXVlNXdBNUlCT3hTUmhNdCtvRDM1Z1pIUHpqejV3L2Z6b2Y1dWhjU05iOC9HQmQ3ZGtmZVlCbWZjRHN1WDVqVHkxdVBVUm03eFBuZHFqcXFCcFRVekJXSkxCQzREZHB2QTVvTzBlUlV1b0ZXTldQNmxRcmhJbm1kOVZBSnY2L1ZhSHB4RXluUmk3TkJjR3BFMGw2NXR6MDlDSlVmR0liaE1JajlnVGhkaUxQQUJnQTZrQURHRUZrQkdFSXBBNUVlTk1LYWRjbzg2TldzOVl1NFpaL3RiTGhYdlNDS1F1a3FMWlFYUWFXZ1NZUTU3MEZKRUNXZDlkREd6cmF1cmJHY3FLam5QRk53RGl3R2RVeGxHSFFBb0RDUFZRTHRkMjlDd1R0T2xueEFWSUJRcFl6dWdUTUEzTjVMMVMvNkgwSjkzWTBRSExnYXBVZTVrd1hqSy9GUFBRR29kZkhBZHJqdUZJamZNOW9TNys0VjRBQkcyZ0N2ZVpZamNIVm5QaHFWYTN1YTZzbkRKMkE5TktXWGdEZUVRRFdDOWI3ZmU1V1M5dTZ2clg0UHh2UVRTTjM0bjVoQUFBQUpYUkZXSFJrWVhSbE9tTnlaV0YwWlFBeU1ERXlMVEEwTFRBelZERTFPalF6T2pBekxUQTFPakF3bnlpOENRQUFBQ1YwUlZoMFpHRjBaVHB0YjJScFpua0FNakF4TWkwd05DMHdNMVF4TlRvME16b3dNeTB3TlRvd01PNTFCTFVBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbWFpbi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9mbGFncy90dXJraXNoX2ZsYWcucG5nXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IEFwcCBmcm9tICcuL2FwcCc7XHJcblxyXG5SZWFjdERPTS5yZW5kZXIoXHJcbiAgICA8QXBwLz4sXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVhY3QnKVxyXG4pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluL2phdmFzY3JpcHQvaW5kZXguanN4IiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpLHA9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIikscT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0scj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsdD1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsdT1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSx2PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHc9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGM9MDtjPGI7YysrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7Yj1FcnJvcihlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31cbnZhciB6PXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiBBKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9QS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtBLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/eShcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0EucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gQihhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fWZ1bmN0aW9uIEMoKXt9Qy5wcm90b3R5cGU9QS5wcm90b3R5cGU7dmFyIEQ9Qi5wcm90b3R5cGU9bmV3IEM7RC5jb25zdHJ1Y3Rvcj1CO20oRCxBLnByb3RvdHlwZSk7RC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDtmdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEM7Ri5jb25zdHJ1Y3Rvcj1FO20oRixBLnByb3RvdHlwZSk7Ri51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ9ITA7Ri5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn07dmFyIEc9e2N1cnJlbnQ6bnVsbH0sSD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEk9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIEooYSxiLGUpe3ZhciBjLGQ9e30sZz1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSC5jYWxsKGIsYykmJiFJLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGg9QXJyYXkoZiksbD0wO2w8ZjtsKyspaFtsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWh9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbY10mJihkW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjpyLHR5cGU6YSxrZXk6ZyxyZWY6ayxwcm9wczpkLF9vd25lcjpHLmN1cnJlbnR9fWZ1bmN0aW9uIEsoYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PXJ9XG5mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiXFx4M2RcIjpcIlxceDNkMFwiLFwiOlwiOlwiXFx4M2QyXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBMPS9cXC8rL2csTT1bXTtmdW5jdGlvbiBOKGEsYixlLGMpe2lmKE0ubGVuZ3RoKXt2YXIgZD1NLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9ZTtkLmNvbnRleHQ9YztkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmMsY291bnQ6MH19ZnVuY3Rpb24gTyhhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPk0ubGVuZ3RoJiZNLnB1c2goYSl9XG5mdW5jdGlvbiBQKGEsYixlLGMpe3ZhciBkPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1kfHxcImJvb2xlYW5cIj09PWQpYT1udWxsO3ZhciBnPSExO2lmKG51bGw9PT1hKWc9ITA7ZWxzZSBzd2l0Y2goZCl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpnPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSByOmNhc2UgdDpjYXNlIHU6Y2FzZSB2Omc9ITB9fWlmKGcpcmV0dXJuIGUoYyxhLFwiXCI9PT1iP1wiLlwiK1EoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7ZD1hW2tdO3ZhciBmPWIrUShkLGspO2crPVAoZCxmLGUsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP2Y9bnVsbDooZj14JiZhW3hdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9XG5mLmNhbGwoYSksaz0wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitRKGQsaysrKSxnKz1QKGQsZixlLGMpO2Vsc2VcIm9iamVjdFwiPT09ZCYmKGU9XCJcIithLHkoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFEoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIFIoYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gUyhhLGIsZSl7dmFyIGM9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9UKGEsYyxlLHAudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKEsoYSkmJihiPWQrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksYy5wdXNoKGEpKX1mdW5jdGlvbiBUKGEsYixlLGMsZCl7dmFyIGc9XCJcIjtudWxsIT1lJiYoZz0oXCJcIitlKS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKTtiPU4oYixnLGMsZCk7bnVsbD09YXx8UChhLFwiXCIsUyxiKTtPKGIpfVxudmFyIFU9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VChhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9TihudWxsLG51bGwsYixlKTtudWxsPT1hfHxQKGEsXCJcIixSLGIpO08oYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UChhLFwiXCIscC50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VChhLGIsbnVsbCxwLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe0soYSk/dm9pZCAwOnkoXCIxNDNcIik7cmV0dXJuIGF9fSxDb21wb25lbnQ6QSxQdXJlQ29tcG9uZW50OkIsdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6RSxGcmFnbWVudDp3LGNyZWF0ZUVsZW1lbnQ6SixjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe3ZhciBjPW0oe30sYS5wcm9wcyksXG5kPWEua2V5LGc9YS5yZWYsaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGc9Yi5yZWYsaz1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoaCBpbiBiKUguY2FsbChiLGgpJiYhSS5oYXNPd25Qcm9wZXJ0eShoKSYmKGNbaF09dm9pZCAwPT09YltoXSYmdm9pZCAwIT09Zj9mW2hdOmJbaF0pfXZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09aCljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGgpe2Y9QXJyYXkoaCk7Zm9yKHZhciBsPTA7bDxoO2wrKylmW2xdPWFyZ3VtZW50c1tsKzJdO2MuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6ZCxyZWY6Zyxwcm9wczpjLF9vd25lcjprfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1KLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0sXG5pc1ZhbGlkRWxlbWVudDpLLHZlcnNpb246XCIxNi4yLjBcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6Ryxhc3NpZ246bX19LFY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpVfSksVz1WJiZVfHxWO21vZHVsZS5leHBvcnRzPVdbXCJkZWZhdWx0XCJdP1dbXCJkZWZhdWx0XCJdOlc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbmZ1bmN0aW9uIEFzeW5jQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgYXN5bmNDb21wb25lbnRQcm90b3R5cGUgPSBBc3luY0NvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oYXN5bmNDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXG57XG4gIC8vIENvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHdvcmtlZCBvblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHJldHVybiBpbXBsKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHtcbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbntcbiAgdmFyIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICB2YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICB2YXIgZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnI2VtcHR5JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnI3RleHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHJldHVybiAnUmVhY3QuRnJhZ21lbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIFZBTElEX0ZSQUdNRU5UX1BST1BTID0gbmV3IE1hcChbWydjaGlsZHJlbicsIHRydWVdLCBbJ2tleScsIHRydWVdXSk7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghVkFMSURfRlJBR01FTlRfUFJPUFMuaGFzKGtleSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4lcycsIGtleSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4lcycsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHR5cGUgPT09ICdudW1iZXInO1xuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICBpbmZvICs9IGdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnICYmIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuICB1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDogQXN5bmNDb21wb25lbnQsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgICBhc3NpZ246IF9hc3NpZ25cbiAgfVxufTtcblxue1xuICBfYXNzaWduKFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdCA9IFJlYWN0JDNbJ2RlZmF1bHQnXSA/IFJlYWN0JDNbJ2RlZmF1bHQnXSA6IFJlYWN0JDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3Q7XG4gIH0pKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksbD1yZXF1aXJlKFwiZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnRcIiksQj1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxDPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLGJhPXJlcXVpcmUoXCJmYmpzL2xpYi9FdmVudExpc3RlbmVyXCIpLGRhPXJlcXVpcmUoXCJmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50XCIpLGVhPXJlcXVpcmUoXCJmYmpzL2xpYi9zaGFsbG93RXF1YWxcIiksZmE9cmVxdWlyZShcImZianMvbGliL2NvbnRhaW5zTm9kZVwiKSxpYT1yZXF1aXJlKFwiZmJqcy9saWIvZm9jdXNOb2RlXCIpLEQ9cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpO1xuZnVuY3Rpb24gRShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGM9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsZD0wO2Q8YjtkKyspYys9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtiPUVycm9yKGMrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fWFhP3ZvaWQgMDpFKFwiMjI3XCIpO1xudmFyIG9hPXtjaGlsZHJlbjohMCxkYW5nZXJvdXNseVNldElubmVySFRNTDohMCxkZWZhdWx0VmFsdWU6ITAsZGVmYXVsdENoZWNrZWQ6ITAsaW5uZXJIVE1MOiEwLHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzohMCxzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6ITAsc3R5bGU6ITB9O2Z1bmN0aW9uIHBhKGEsYil7cmV0dXJuKGEmYik9PT1ifVxudmFyIHRhPXtNVVNUX1VTRV9QUk9QRVJUWToxLEhBU19CT09MRUFOX1ZBTFVFOjQsSEFTX05VTUVSSUNfVkFMVUU6OCxIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRToyNCxIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOjMyLEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTo2NCxpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzpmdW5jdGlvbihhKXt2YXIgYj10YSxjPWEuUHJvcGVydGllc3x8e30sZD1hLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXN8fHt9LGU9YS5ET01BdHRyaWJ1dGVOYW1lc3x8e307YT1hLkRPTU11dGF0aW9uTWV0aG9kc3x8e307Zm9yKHZhciBmIGluIGMpe3VhLmhhc093blByb3BlcnR5KGYpP0UoXCI0OFwiLGYpOnZvaWQgMDt2YXIgZz1mLnRvTG93ZXJDYXNlKCksaD1jW2ZdO2c9e2F0dHJpYnV0ZU5hbWU6ZyxhdHRyaWJ1dGVOYW1lc3BhY2U6bnVsbCxwcm9wZXJ0eU5hbWU6ZixtdXRhdGlvbk1ldGhvZDpudWxsLG11c3RVc2VQcm9wZXJ0eTpwYShoLGIuTVVTVF9VU0VfUFJPUEVSVFkpLFxuaGFzQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfQk9PTEVBTl9WQUxVRSksaGFzTnVtZXJpY1ZhbHVlOnBhKGgsYi5IQVNfTlVNRVJJQ19WQUxVRSksaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxoYXNTdHJpbmdCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSl9OzE+PWcuaGFzQm9vbGVhblZhbHVlK2cuaGFzTnVtZXJpY1ZhbHVlK2cuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZT92b2lkIDA6RShcIjUwXCIsZik7ZS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZT1lW2ZdKTtkLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lc3BhY2U9ZFtmXSk7YS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcubXV0YXRpb25NZXRob2Q9YVtmXSk7dWFbZl09Z319fSx1YT17fTtcbmZ1bmN0aW9uIHZhKGEsYil7aWYob2EuaGFzT3duUHJvcGVydHkoYSl8fDI8YS5sZW5ndGgmJihcIm9cIj09PWFbMF18fFwiT1wiPT09YVswXSkmJihcIm5cIj09PWFbMV18fFwiTlwiPT09YVsxXSkpcmV0dXJuITE7aWYobnVsbD09PWIpcmV0dXJuITA7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwiYm9vbGVhblwiOnJldHVybiBvYS5oYXNPd25Qcm9wZXJ0eShhKT9hPSEwOihiPXdhKGEpKT9hPWIuaGFzQm9vbGVhblZhbHVlfHxiLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZXx8Yi5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOihhPWEudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpLGE9XCJkYXRhLVwiPT09YXx8XCJhcmlhLVwiPT09YSksYTtjYXNlIFwidW5kZWZpbmVkXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwib2JqZWN0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gd2EoYSl7cmV0dXJuIHVhLmhhc093blByb3BlcnR5KGEpP3VhW2FdOm51bGx9XG52YXIgeGE9dGEseWE9eGEuTVVTVF9VU0VfUFJPUEVSVFksSz14YS5IQVNfQk9PTEVBTl9WQUxVRSx6YT14YS5IQVNfTlVNRVJJQ19WQUxVRSxBYT14YS5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxCYT14YS5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLENhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxEYT17UHJvcGVydGllczp7YWxsb3dGdWxsU2NyZWVuOkssYXN5bmM6SyxhdXRvRm9jdXM6SyxhdXRvUGxheTpLLGNhcHR1cmU6QmEsY2hlY2tlZDp5YXxLLGNvbHM6QWEsY29udGVudEVkaXRhYmxlOkNhLGNvbnRyb2xzOkssXCJkZWZhdWx0XCI6SyxkZWZlcjpLLGRpc2FibGVkOkssZG93bmxvYWQ6QmEsZHJhZ2dhYmxlOkNhLGZvcm1Ob1ZhbGlkYXRlOkssaGlkZGVuOkssbG9vcDpLLG11bHRpcGxlOnlhfEssbXV0ZWQ6eWF8Syxub1ZhbGlkYXRlOkssb3BlbjpLLHBsYXlzSW5saW5lOksscmVhZE9ubHk6SyxyZXF1aXJlZDpLLHJldmVyc2VkOksscm93czpBYSxyb3dTcGFuOnphLFxuc2NvcGVkOkssc2VhbWxlc3M6SyxzZWxlY3RlZDp5YXxLLHNpemU6QWEsc3RhcnQ6emEsc3BhbjpBYSxzcGVsbENoZWNrOkNhLHN0eWxlOjAsdGFiSW5kZXg6MCxpdGVtU2NvcGU6SyxhY2NlcHRDaGFyc2V0OjAsY2xhc3NOYW1lOjAsaHRtbEZvcjowLGh0dHBFcXVpdjowLHZhbHVlOkNhfSxET01BdHRyaWJ1dGVOYW1lczp7YWNjZXB0Q2hhcnNldDpcImFjY2VwdC1jaGFyc2V0XCIsY2xhc3NOYW1lOlwiY2xhc3NcIixodG1sRm9yOlwiZm9yXCIsaHR0cEVxdWl2OlwiaHR0cC1lcXVpdlwifSxET01NdXRhdGlvbk1ldGhvZHM6e3ZhbHVlOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09YilyZXR1cm4gYS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcIm51bWJlclwiIT09YS50eXBlfHwhMT09PWEuaGFzQXR0cmlidXRlKFwidmFsdWVcIik/YS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYik6YS52YWxpZGl0eSYmIWEudmFsaWRpdHkuYmFkSW5wdXQmJmEub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IT09YSYmXG5hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKX19fSxFYT14YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsTT17eGxpbms6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIseG1sOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJ9LEdhPXtQcm9wZXJ0aWVzOnthdXRvUmV2ZXJzZTpFYSxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOkVhLHByZXNlcnZlQWxwaGE6RWF9LERPTUF0dHJpYnV0ZU5hbWVzOnthdXRvUmV2ZXJzZTpcImF1dG9SZXZlcnNlXCIsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixwcmVzZXJ2ZUFscGhhOlwicHJlc2VydmVBbHBoYVwifSxET01BdHRyaWJ1dGVOYW1lc3BhY2VzOnt4bGlua0FjdHVhdGU6TS54bGluayx4bGlua0FyY3JvbGU6TS54bGluayx4bGlua0hyZWY6TS54bGluayx4bGlua1JvbGU6TS54bGluayx4bGlua1Nob3c6TS54bGluayx4bGlua1RpdGxlOk0ueGxpbmsseGxpbmtUeXBlOk0ueGxpbmssXG54bWxCYXNlOk0ueG1sLHhtbExhbmc6TS54bWwseG1sU3BhY2U6TS54bWx9fSxIYT0vW1xcLVxcOl0oW2Etel0pL2c7ZnVuY3Rpb24gSWEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeC1oZWlnaHQgeGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOmhyZWYgeGxpbms6cm9sZSB4bGluazpzaG93IHhsaW5rOnRpdGxlIHhsaW5rOnR5cGUgeG1sOmJhc2UgeG1sbnM6eGxpbmsgeG1sOmxhbmcgeG1sOnNwYWNlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEhhLFxuSWEpO0dhLlByb3BlcnRpZXNbYl09MDtHYS5ET01BdHRyaWJ1dGVOYW1lc1tiXT1hfSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoRGEpO3hhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEdhKTtcbnZhciBQPXtfY2F1Z2h0RXJyb3I6bnVsbCxfaGFzQ2F1Z2h0RXJyb3I6ITEsX3JldGhyb3dFcnJvcjpudWxsLF9oYXNSZXRocm93RXJyb3I6ITEsaW5qZWN0aW9uOntpbmplY3RFcnJvclV0aWxzOmZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhLmludm9rZUd1YXJkZWRDYWxsYmFjaz9FKFwiMTk3XCIpOnZvaWQgMDtKYT1hLmludm9rZUd1YXJkZWRDYWxsYmFja319LGludm9rZUd1YXJkZWRDYWxsYmFjazpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7SmEuYXBwbHkoUCxhcmd1bWVudHMpfSxpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe1AuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihQLmhhc0NhdWdodEVycm9yKCkpe3ZhciBxPVAuY2xlYXJDYXVnaHRFcnJvcigpO1AuX2hhc1JldGhyb3dFcnJvcnx8KFAuX2hhc1JldGhyb3dFcnJvcj0hMCxQLl9yZXRocm93RXJyb3I9XG5xKX19LHJldGhyb3dDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBLYS5hcHBseShQLGFyZ3VtZW50cyl9LGhhc0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIFAuX2hhc0NhdWdodEVycm9yfSxjbGVhckNhdWdodEVycm9yOmZ1bmN0aW9uKCl7aWYoUC5faGFzQ2F1Z2h0RXJyb3Ipe3ZhciBhPVAuX2NhdWdodEVycm9yO1AuX2NhdWdodEVycm9yPW51bGw7UC5faGFzQ2F1Z2h0RXJyb3I9ITE7cmV0dXJuIGF9RShcIjE5OFwiKX19O2Z1bmN0aW9uIEphKGEsYixjLGQsZSxmLGcsaCxrKXtQLl9oYXNDYXVnaHRFcnJvcj0hMTtQLl9jYXVnaHRFcnJvcj1udWxsO3ZhciBxPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7Yi5hcHBseShjLHEpfWNhdGNoKHYpe1AuX2NhdWdodEVycm9yPXYsUC5faGFzQ2F1Z2h0RXJyb3I9ITB9fVxuZnVuY3Rpb24gS2EoKXtpZihQLl9oYXNSZXRocm93RXJyb3Ipe3ZhciBhPVAuX3JldGhyb3dFcnJvcjtQLl9yZXRocm93RXJyb3I9bnVsbDtQLl9oYXNSZXRocm93RXJyb3I9ITE7dGhyb3cgYTt9fXZhciBMYT1udWxsLE1hPXt9O1xuZnVuY3Rpb24gTmEoKXtpZihMYSlmb3IodmFyIGEgaW4gTWEpe3ZhciBiPU1hW2FdLGM9TGEuaW5kZXhPZihhKTstMTxjP3ZvaWQgMDpFKFwiOTZcIixhKTtpZighT2FbY10pe2IuZXh0cmFjdEV2ZW50cz92b2lkIDA6RShcIjk3XCIsYSk7T2FbY109YjtjPWIuZXZlbnRUeXBlcztmb3IodmFyIGQgaW4gYyl7dmFyIGU9dm9pZCAwO3ZhciBmPWNbZF0sZz1iLGg9ZDtQYS5oYXNPd25Qcm9wZXJ0eShoKT9FKFwiOTlcIixoKTp2b2lkIDA7UGFbaF09Zjt2YXIgaz1mLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO2lmKGspe2ZvcihlIGluIGspay5oYXNPd25Qcm9wZXJ0eShlKSYmUWEoa1tlXSxnLGgpO2U9ITB9ZWxzZSBmLnJlZ2lzdHJhdGlvbk5hbWU/KFFhKGYucmVnaXN0cmF0aW9uTmFtZSxnLGgpLGU9ITApOmU9ITE7ZT92b2lkIDA6RShcIjk4XCIsZCxhKX19fX1cbmZ1bmN0aW9uIFFhKGEsYixjKXtSYVthXT9FKFwiMTAwXCIsYSk6dm9pZCAwO1JhW2FdPWI7U2FbYV09Yi5ldmVudFR5cGVzW2NdLmRlcGVuZGVuY2llc312YXIgT2E9W10sUGE9e30sUmE9e30sU2E9e307ZnVuY3Rpb24gVGEoYSl7TGE/RShcIjEwMVwiKTp2b2lkIDA7TGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7TmEoKX1mdW5jdGlvbiBVYShhKXt2YXIgYj0hMSxjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9YVtjXTtNYS5oYXNPd25Qcm9wZXJ0eShjKSYmTWFbY109PT1kfHwoTWFbY10/RShcIjEwMlwiLGMpOnZvaWQgMCxNYVtjXT1kLGI9ITApfWImJk5hKCl9XG52YXIgVmE9T2JqZWN0LmZyZWV6ZSh7cGx1Z2luczpPYSxldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6UGEscmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6UmEscmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpTYSxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOm51bGwsaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpUYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6VWF9KSxXYT1udWxsLFhhPW51bGwsWWE9bnVsbDtmdW5jdGlvbiBaYShhLGIsYyxkKXtiPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PVlhKGQpO1AuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKGIsYyx2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiAkYShhLGIpe251bGw9PWI/RShcIjMwXCIpOnZvaWQgMDtpZihudWxsPT1hKXJldHVybiBiO2lmKEFycmF5LmlzQXJyYXkoYSkpe2lmKEFycmF5LmlzQXJyYXkoYikpcmV0dXJuIGEucHVzaC5hcHBseShhLGIpLGE7YS5wdXNoKGIpO3JldHVybiBhfXJldHVybiBBcnJheS5pc0FycmF5KGIpP1thXS5jb25jYXQoYik6W2EsYl19ZnVuY3Rpb24gYWIoYSxiLGMpe0FycmF5LmlzQXJyYXkoYSk/YS5mb3JFYWNoKGIsYyk6YSYmYi5jYWxsKGMsYSl9dmFyIGJiPW51bGw7XG5mdW5jdGlvbiBjYihhLGIpe2lmKGEpe3ZhciBjPWEuX2Rpc3BhdGNoTGlzdGVuZXJzLGQ9YS5fZGlzcGF0Y2hJbnN0YW5jZXM7aWYoQXJyYXkuaXNBcnJheShjKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoJiYhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO2UrKylaYShhLGIsY1tlXSxkW2VdKTtlbHNlIGMmJlphKGEsYixjLGQpO2EuX2Rpc3BhdGNoTGlzdGVuZXJzPW51bGw7YS5fZGlzcGF0Y2hJbnN0YW5jZXM9bnVsbDthLmlzUGVyc2lzdGVudCgpfHxhLmNvbnN0cnVjdG9yLnJlbGVhc2UoYSl9fWZ1bmN0aW9uIGRiKGEpe3JldHVybiBjYihhLCEwKX1mdW5jdGlvbiBnYihhKXtyZXR1cm4gY2IoYSwhMSl9dmFyIGhiPXtpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX07XG5mdW5jdGlvbiBpYihhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKCFjKXJldHVybiBudWxsO3ZhciBkPVdhKGMpO2lmKCFkKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2MmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP0UoXCIyMzFcIixiLHR5cGVvZiBjKTp2b2lkIDA7XG5yZXR1cm4gY31mdW5jdGlvbiBqYihhLGIsYyxkKXtmb3IodmFyIGUsZj0wO2Y8T2EubGVuZ3RoO2YrKyl7dmFyIGc9T2FbZl07ZyYmKGc9Zy5leHRyYWN0RXZlbnRzKGEsYixjLGQpKSYmKGU9JGEoZSxnKSl9cmV0dXJuIGV9ZnVuY3Rpb24ga2IoYSl7YSYmKGJiPSRhKGJiLGEpKX1mdW5jdGlvbiBsYihhKXt2YXIgYj1iYjtiYj1udWxsO2ImJihhP2FiKGIsZGIpOmFiKGIsZ2IpLGJiP0UoXCI5NVwiKTp2b2lkIDAsUC5yZXRocm93Q2F1Z2h0RXJyb3IoKSl9dmFyIG1iPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpoYixnZXRMaXN0ZW5lcjppYixleHRyYWN0RXZlbnRzOmpiLGVucXVldWVFdmVudHM6a2IscHJvY2Vzc0V2ZW50UXVldWU6bGJ9KSxuYj1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxRPVwiX19yZWFjdEludGVybmFsSW5zdGFuY2UkXCIrbmIsb2I9XCJfX3JlYWN0RXZlbnRIYW5kbGVycyRcIituYjtcbmZ1bmN0aW9uIHBiKGEpe2lmKGFbUV0pcmV0dXJuIGFbUV07Zm9yKHZhciBiPVtdOyFhW1FdOylpZihiLnB1c2goYSksYS5wYXJlbnROb2RlKWE9YS5wYXJlbnROb2RlO2Vsc2UgcmV0dXJuIG51bGw7dmFyIGM9dm9pZCAwLGQ9YVtRXTtpZig1PT09ZC50YWd8fDY9PT1kLnRhZylyZXR1cm4gZDtmb3IoO2EmJihkPWFbUV0pO2E9Yi5wb3AoKSljPWQ7cmV0dXJuIGN9ZnVuY3Rpb24gcWIoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGEuc3RhdGVOb2RlO0UoXCIzM1wiKX1mdW5jdGlvbiByYihhKXtyZXR1cm4gYVtvYl18fG51bGx9XG52YXIgc2I9T2JqZWN0LmZyZWV6ZSh7cHJlY2FjaGVGaWJlck5vZGU6ZnVuY3Rpb24oYSxiKXtiW1FdPWF9LGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOnBiLGdldEluc3RhbmNlRnJvbU5vZGU6ZnVuY3Rpb24oYSl7YT1hW1FdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZz9udWxsOmF9LGdldE5vZGVGcm9tSW5zdGFuY2U6cWIsZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTpyYix1cGRhdGVGaWJlclByb3BzOmZ1bmN0aW9uKGEsYil7YVtvYl09Yn19KTtmdW5jdGlvbiB0YihhKXtkbyBhPWFbXCJyZXR1cm5cIl07d2hpbGUoYSYmNSE9PWEudGFnKTtyZXR1cm4gYT9hOm51bGx9ZnVuY3Rpb24gdWIoYSxiLGMpe2Zvcih2YXIgZD1bXTthOylkLnB1c2goYSksYT10YihhKTtmb3IoYT1kLmxlbmd0aDswPGEtLTspYihkW2FdLFwiY2FwdHVyZWRcIixjKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWIoZFthXSxcImJ1YmJsZWRcIixjKX1cbmZ1bmN0aW9uIHZiKGEsYixjKXtpZihiPWliKGEsYy5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1tiXSkpYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSl9ZnVuY3Rpb24gd2IoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyYmdWIoYS5fdGFyZ2V0SW5zdCx2YixhKX1mdW5jdGlvbiB4YihhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXt2YXIgYj1hLl90YXJnZXRJbnN0O2I9Yj90YihiKTpudWxsO3ViKGIsdmIsYSl9fVxuZnVuY3Rpb24geWIoYSxiLGMpe2EmJmMmJmMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpKSYmKGMuX2Rpc3BhdGNoTGlzdGVuZXJzPSRhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPSRhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpKX1mdW5jdGlvbiB6YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJnliKGEuX3RhcmdldEluc3QsbnVsbCxhKX1mdW5jdGlvbiBBYihhKXthYihhLHdiKX1cbmZ1bmN0aW9uIEJiKGEsYixjLGQpe2lmKGMmJmQpYTp7dmFyIGU9Yztmb3IodmFyIGY9ZCxnPTAsaD1lO2g7aD10YihoKSlnKys7aD0wO2Zvcih2YXIgaz1mO2s7az10YihrKSloKys7Zm9yKDswPGctaDspZT10YihlKSxnLS07Zm9yKDswPGgtZzspZj10YihmKSxoLS07Zm9yKDtnLS07KXtpZihlPT09Znx8ZT09PWYuYWx0ZXJuYXRlKWJyZWFrIGE7ZT10YihlKTtmPXRiKGYpfWU9bnVsbH1lbHNlIGU9bnVsbDtmPWU7Zm9yKGU9W107YyYmYyE9PWY7KXtnPWMuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztlLnB1c2goYyk7Yz10YihjKX1mb3IoYz1bXTtkJiZkIT09Zjspe2c9ZC5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2MucHVzaChkKTtkPXRiKGQpfWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspeWIoZVtkXSxcImJ1YmJsZWRcIixhKTtmb3IoYT1jLmxlbmd0aDswPGEtLTspeWIoY1thXSxcImNhcHR1cmVkXCIsYil9XG52YXIgQ2I9T2JqZWN0LmZyZWV6ZSh7YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczpBYixhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDpmdW5jdGlvbihhKXthYihhLHhiKX0sYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOkJiLGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOmZ1bmN0aW9uKGEpe2FiKGEsemIpfX0pLERiPW51bGw7ZnVuY3Rpb24gRWIoKXshRGImJmwuY2FuVXNlRE9NJiYoRGI9XCJ0ZXh0Q29udGVudFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50P1widGV4dENvbnRlbnRcIjpcImlubmVyVGV4dFwiKTtyZXR1cm4gRGJ9dmFyIFM9e19yb290Om51bGwsX3N0YXJ0VGV4dDpudWxsLF9mYWxsYmFja1RleHQ6bnVsbH07XG5mdW5jdGlvbiBGYigpe2lmKFMuX2ZhbGxiYWNrVGV4dClyZXR1cm4gUy5fZmFsbGJhY2tUZXh0O3ZhciBhLGI9Uy5fc3RhcnRUZXh0LGM9Yi5sZW5ndGgsZCxlPUdiKCksZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtTLl9mYWxsYmFja1RleHQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKTtyZXR1cm4gUy5fZmFsbGJhY2tUZXh0fWZ1bmN0aW9uIEdiKCl7cmV0dXJuXCJ2YWx1ZVwiaW4gUy5fcm9vdD9TLl9yb290LnZhbHVlOlMuX3Jvb3RbRWIoKV19XG52YXIgSGI9XCJkaXNwYXRjaENvbmZpZyBfdGFyZ2V0SW5zdCBuYXRpdmVFdmVudCBpc0RlZmF1bHRQcmV2ZW50ZWQgaXNQcm9wYWdhdGlvblN0b3BwZWQgX2Rpc3BhdGNoTGlzdGVuZXJzIF9kaXNwYXRjaEluc3RhbmNlc1wiLnNwbGl0KFwiIFwiKSxJYj17dHlwZTpudWxsLHRhcmdldDpudWxsLGN1cnJlbnRUYXJnZXQ6Qy50aGF0UmV0dXJuc051bGwsZXZlbnRQaGFzZTpudWxsLGJ1YmJsZXM6bnVsbCxjYW5jZWxhYmxlOm51bGwsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDpudWxsLGlzVHJ1c3RlZDpudWxsfTtcbmZ1bmN0aW9uIFQoYSxiLGMsZCl7dGhpcy5kaXNwYXRjaENvbmZpZz1hO3RoaXMuX3RhcmdldEluc3Q9Yjt0aGlzLm5hdGl2ZUV2ZW50PWM7YT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IodmFyIGUgaW4gYSlhLmhhc093blByb3BlcnR5KGUpJiYoKGI9YVtlXSk/dGhpc1tlXT1iKGMpOlwidGFyZ2V0XCI9PT1lP3RoaXMudGFyZ2V0PWQ6dGhpc1tlXT1jW2VdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Yy5kZWZhdWx0UHJldmVudGVkP2MuZGVmYXVsdFByZXZlbnRlZDohMT09PWMucmV0dXJuVmFsdWUpP0MudGhhdFJldHVybnNUcnVlOkMudGhhdFJldHVybnNGYWxzZTt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNGYWxzZTtyZXR1cm4gdGhpc31cbkIoVC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt0aGlzLmlzUGVyc2lzdGVudD1DLnRoYXRSZXR1cm5zVHJ1ZX0saXNQZXJzaXN0ZW50OkMudGhhdFJldHVybnNGYWxzZSxcbmRlc3RydWN0b3I6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSxiO2ZvcihiIGluIGEpdGhpc1tiXT1udWxsO2ZvcihhPTA7YTxIYi5sZW5ndGg7YSsrKXRoaXNbSGJbYV1dPW51bGx9fSk7VC5JbnRlcmZhY2U9SWI7VC5hdWdtZW50Q2xhc3M9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPXRoaXMucHJvdG90eXBlO3ZhciBkPW5ldyBjO0IoZCxhLnByb3RvdHlwZSk7YS5wcm90b3R5cGU9ZDthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuSW50ZXJmYWNlPUIoe30sdGhpcy5JbnRlcmZhY2UsYik7YS5hdWdtZW50Q2xhc3M9dGhpcy5hdWdtZW50Q2xhc3M7SmIoYSl9O0piKFQpO2Z1bmN0aW9uIEtiKGEsYixjLGQpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIGU9dGhpcy5ldmVudFBvb2wucG9wKCk7dGhpcy5jYWxsKGUsYSxiLGMsZCk7cmV0dXJuIGV9cmV0dXJuIG5ldyB0aGlzKGEsYixjLGQpfVxuZnVuY3Rpb24gTGIoYSl7YSBpbnN0YW5jZW9mIHRoaXM/dm9pZCAwOkUoXCIyMjNcIik7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfWZ1bmN0aW9uIEpiKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPUtiO2EucmVsZWFzZT1MYn1mdW5jdGlvbiBNYihhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoTWIse2RhdGE6bnVsbH0pO2Z1bmN0aW9uIE5iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhOYix7ZGF0YTpudWxsfSk7dmFyIFBiPVs5LDEzLDI3LDMyXSxWYj1sLmNhblVzZURPTSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csV2I9bnVsbDtsLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYoV2I9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgWGI7XG5pZihYYj1sLmNhblVzZURPTSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIVdiKXt2YXIgWWI9d2luZG93Lm9wZXJhO1hiPSEoXCJvYmplY3RcIj09PXR5cGVvZiBZYiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFliLnZlcnNpb24mJjEyPj1wYXJzZUludChZYi52ZXJzaW9uKCksMTApKX1cbnZhciBaYj1YYiwkYj1sLmNhblVzZURPTSYmKCFWYnx8V2ImJjg8V2ImJjExPj1XYiksYWM9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksYmM9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJ0b3BDb21wb3NpdGlvbkVuZFwiLFwidG9wS2V5UHJlc3NcIixcInRvcFRleHRJbnB1dFwiLFwidG9wUGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25FbmQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblN0YXJ0IHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uVXBkYXRlIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfX0sY2M9ITE7XG5mdW5jdGlvbiBkYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4tMSE9PVBiLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwidG9wS2V5RG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcInRvcEtleVByZXNzXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BCbHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZWMoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgZmM9ITE7ZnVuY3Rpb24gZ2MoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuIGVjKGIpO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtjYz0hMDtyZXR1cm4gYWM7Y2FzZSBcInRvcFRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09YWMmJmNjP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGhjKGEsYil7aWYoZmMpcmV0dXJuXCJ0b3BDb21wb3NpdGlvbkVuZFwiPT09YXx8IVZiJiZkYyhhLGIpPyhhPUZiKCksUy5fcm9vdD1udWxsLFMuX3N0YXJ0VGV4dD1udWxsLFMuX2ZhbGxiYWNrVGV4dD1udWxsLGZjPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BQYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiAkYj9udWxsOmIuZGF0YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciBpYz17ZXZlbnRUeXBlczpiYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2lmKFZiKWI6e3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25TdGFydFwiOnZhciBmPWJjLmNvbXBvc2l0aW9uU3RhcnQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpmPWJjLmNvbXBvc2l0aW9uRW5kO2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uVXBkYXRlXCI6Zj1iYy5jb21wb3NpdGlvblVwZGF0ZTticmVhayBifWY9dm9pZCAwfWVsc2UgZmM/ZGMoYSxjKSYmKGY9YmMuY29tcG9zaXRpb25FbmQpOlwidG9wS2V5RG93blwiPT09YSYmMjI5PT09Yy5rZXlDb2RlJiYoZj1iYy5jb21wb3NpdGlvblN0YXJ0KTtmPygkYiYmKGZjfHxmIT09YmMuY29tcG9zaXRpb25TdGFydD9mPT09YmMuY29tcG9zaXRpb25FbmQmJmZjJiYoZT1GYigpKTooUy5fcm9vdD1kLFMuX3N0YXJ0VGV4dD1HYigpLGZjPSEwKSksZj1NYi5nZXRQb29sZWQoZixiLGMsZCksZT9mLmRhdGE9XG5lOihlPWVjKGMpLG51bGwhPT1lJiYoZi5kYXRhPWUpKSxBYihmKSxlPWYpOmU9bnVsbDsoYT1aYj9nYyhhLGMpOmhjKGEsYykpPyhiPU5iLmdldFBvb2xlZChiYy5iZWZvcmVJbnB1dCxiLGMsZCksYi5kYXRhPWEsQWIoYikpOmI9bnVsbDtyZXR1cm5bZSxiXX19LGpjPW51bGwsa2M9bnVsbCxsYz1udWxsO2Z1bmN0aW9uIG1jKGEpe2lmKGE9WGEoYSkpe2pjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgamMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZT92b2lkIDA6RShcIjE5NFwiKTt2YXIgYj1XYShhLnN0YXRlTm9kZSk7amMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShhLnN0YXRlTm9kZSxhLnR5cGUsYil9fXZhciBuYz17aW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDpmdW5jdGlvbihhKXtqYz1hfX07ZnVuY3Rpb24gb2MoYSl7a2M/bGM/bGMucHVzaChhKTpsYz1bYV06a2M9YX1cbmZ1bmN0aW9uIHBjKCl7aWYoa2Mpe3ZhciBhPWtjLGI9bGM7bGM9a2M9bnVsbDttYyhhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspbWMoYlthXSl9fXZhciBxYz1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246bmMsZW5xdWV1ZVN0YXRlUmVzdG9yZTpvYyxyZXN0b3JlU3RhdGVJZk5lZWRlZDpwY30pO2Z1bmN0aW9uIHJjKGEsYil7cmV0dXJuIGEoYil9dmFyIHNjPSExO2Z1bmN0aW9uIHRjKGEsYil7aWYoc2MpcmV0dXJuIHJjKGEsYik7c2M9ITA7dHJ5e3JldHVybiByYyhhLGIpfWZpbmFsbHl7c2M9ITEscGMoKX19dmFyIHVjPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O1xuZnVuY3Rpb24gdmMoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISF1Y1thLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9ZnVuY3Rpb24gd2MoYSl7YT1hLnRhcmdldHx8YS5zcmNFbGVtZW50fHx3aW5kb3c7YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCYmKGE9YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCk7cmV0dXJuIDM9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphfXZhciB4YztsLmNhblVzZURPTSYmKHhjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uJiZkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlJiYhMCE9PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIixcIlwiKSk7XG5mdW5jdGlvbiB5YyhhLGIpe2lmKCFsLmNhblVzZURPTXx8YiYmIShcImFkZEV2ZW50TGlzdGVuZXJcImluIGRvY3VtZW50KSlyZXR1cm4hMTtiPVwib25cIithO3ZhciBjPWIgaW4gZG9jdW1lbnQ7Y3x8KGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxjLnNldEF0dHJpYnV0ZShiLFwicmV0dXJuO1wiKSxjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjW2JdKTshYyYmeGMmJlwid2hlZWxcIj09PWEmJihjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJFdmVudHMud2hlZWxcIixcIjMuMFwiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gemMoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIEFjKGEpe3ZhciBiPXpjKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0LmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtjLnNldC5jYWxsKHRoaXMsYSl9fSkse2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9bnVsbDtkZWxldGUgYVtiXX19fVxuZnVuY3Rpb24gQmMoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPUFjKGEpKX1mdW5jdGlvbiBDYyhhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9emMoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX12YXIgRGM9e2NoYW5nZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNoYW5nZVwiLGNhcHR1cmVkOlwib25DaGFuZ2VDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ2hhbmdlIHRvcENsaWNrIHRvcEZvY3VzIHRvcElucHV0IHRvcEtleURvd24gdG9wS2V5VXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX07XG5mdW5jdGlvbiBFYyhhLGIsYyl7YT1ULmdldFBvb2xlZChEYy5jaGFuZ2UsYSxiLGMpO2EudHlwZT1cImNoYW5nZVwiO29jKGMpO0FiKGEpO3JldHVybiBhfXZhciBGYz1udWxsLEdjPW51bGw7ZnVuY3Rpb24gSGMoYSl7a2IoYSk7bGIoITEpfWZ1bmN0aW9uIEljKGEpe3ZhciBiPXFiKGEpO2lmKENjKGIpKXJldHVybiBhfWZ1bmN0aW9uIEpjKGEsYil7aWYoXCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIEtjPSExO2wuY2FuVXNlRE9NJiYoS2M9eWMoXCJpbnB1dFwiKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7ZnVuY3Rpb24gTGMoKXtGYyYmKEZjLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLE1jKSxHYz1GYz1udWxsKX1mdW5jdGlvbiBNYyhhKXtcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmSWMoR2MpJiYoYT1FYyhHYyxhLHdjKGEpKSx0YyhIYyxhKSl9XG5mdW5jdGlvbiBOYyhhLGIsYyl7XCJ0b3BGb2N1c1wiPT09YT8oTGMoKSxGYz1iLEdjPWMsRmMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpKTpcInRvcEJsdXJcIj09PWEmJkxjKCl9ZnVuY3Rpb24gT2MoYSl7aWYoXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIj09PWF8fFwidG9wS2V5VXBcIj09PWF8fFwidG9wS2V5RG93blwiPT09YSlyZXR1cm4gSWMoR2MpfWZ1bmN0aW9uIFBjKGEsYil7aWYoXCJ0b3BDbGlja1wiPT09YSlyZXR1cm4gSWMoYil9ZnVuY3Rpb24gJGMoYSxiKXtpZihcInRvcElucHV0XCI9PT1hfHxcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gSWMoYil9XG52YXIgYWQ9e2V2ZW50VHlwZXM6RGMsX2lzSW5wdXRFdmVudFN1cHBvcnRlZDpLYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWI/cWIoYik6d2luZG93LGY9ZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1mfHxcImlucHV0XCI9PT1mJiZcImZpbGVcIj09PWUudHlwZSl2YXIgZz1KYztlbHNlIGlmKHZjKGUpKWlmKEtjKWc9JGM7ZWxzZXtnPU9jO3ZhciBoPU5jfWVsc2UgZj1lLm5vZGVOYW1lLCFmfHxcImlucHV0XCIhPT1mLnRvTG93ZXJDYXNlKCl8fFwiY2hlY2tib3hcIiE9PWUudHlwZSYmXCJyYWRpb1wiIT09ZS50eXBlfHwoZz1QYyk7aWYoZyYmKGc9ZyhhLGIpKSlyZXR1cm4gRWMoZyxjLGQpO2gmJmgoYSxlLGIpO1widG9wQmx1clwiPT09YSYmbnVsbCE9YiYmKGE9Yi5fd3JhcHBlclN0YXRlfHxlLl93cmFwcGVyU3RhdGUpJiZhLmNvbnRyb2xsZWQmJlwibnVtYmVyXCI9PT1lLnR5cGUmJihhPVwiXCIrZS52YWx1ZSxlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIT09XG5hJiZlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYSkpfX07ZnVuY3Rpb24gYmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJkLHt2aWV3Om51bGwsZGV0YWlsOm51bGx9KTt2YXIgY2Q9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIGRkKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9Y2RbYV0pPyEhYlthXTohMX1mdW5jdGlvbiBlZCgpe3JldHVybiBkZH1mdW5jdGlvbiBmZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoZmQse3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWQsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVsYXRlZFRhcmdldHx8KGEuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudCl9fSk7XG52YXIgZ2Q9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfX0saGQ9e2V2ZW50VHlwZXM6Z2QsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXtpZihcInRvcE1vdXNlT3ZlclwiPT09YSYmKGMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCl8fFwidG9wTW91c2VPdXRcIiE9PWEmJlwidG9wTW91c2VPdmVyXCIhPT1hKXJldHVybiBudWxsO3ZhciBlPWQud2luZG93PT09ZD9kOihlPWQub3duZXJEb2N1bWVudCk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6d2luZG93O1widG9wTW91c2VPdXRcIj09PWE/KGE9YixiPShiPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQpP3BiKGIpOm51bGwpOmE9bnVsbDtpZihhPT09XG5iKXJldHVybiBudWxsO3ZhciBmPW51bGw9PWE/ZTpxYihhKTtlPW51bGw9PWI/ZTpxYihiKTt2YXIgZz1mZC5nZXRQb29sZWQoZ2QubW91c2VMZWF2ZSxhLGMsZCk7Zy50eXBlPVwibW91c2VsZWF2ZVwiO2cudGFyZ2V0PWY7Zy5yZWxhdGVkVGFyZ2V0PWU7Yz1mZC5nZXRQb29sZWQoZ2QubW91c2VFbnRlcixiLGMsZCk7Yy50eXBlPVwibW91c2VlbnRlclwiO2MudGFyZ2V0PWU7Yy5yZWxhdGVkVGFyZ2V0PWY7QmIoZyxjLGEsYik7cmV0dXJuW2csY119fSxpZD1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcjtmdW5jdGlvbiBqZChhKXthPWEudHlwZTtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGE/YTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmRpc3BsYXlOYW1lfHxhLm5hbWU6bnVsbH1cbmZ1bmN0aW9uIGtkKGEpe3ZhciBiPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiW1wicmV0dXJuXCJdOyliPWJbXCJyZXR1cm5cIl07ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7YltcInJldHVyblwiXTspaWYoYj1iW1wicmV0dXJuXCJdLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDM9PT1iLnRhZz8yOjN9ZnVuY3Rpb24gbGQoYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09a2QoYSk6ITF9ZnVuY3Rpb24gbWQoYSl7MiE9PWtkKGEpP0UoXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gbmQoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9a2QoYSksMz09PWI/RShcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jW1wicmV0dXJuXCJdLGY9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhZilicmVhaztpZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1jKXJldHVybiBtZChlKSxhO2lmKGc9PT1kKXJldHVybiBtZChlKSxiO2c9Zy5zaWJsaW5nfUUoXCIxODhcIil9aWYoY1tcInJldHVyblwiXSE9PWRbXCJyZXR1cm5cIl0pYz1lLGQ9ZjtlbHNle2c9ITE7Zm9yKHZhciBoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihoPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWg9aC5zaWJsaW5nfWc/XG52b2lkIDA6RShcIjE4OVwiKX19Yy5hbHRlcm5hdGUhPT1kP0UoXCIxOTBcIik6dm9pZCAwfTMhPT1jLnRhZz9FKFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIG9kKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBwZChhKXthPW5kKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQmJjQhPT1iLnRhZyliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9dmFyIHFkPVtdO1xuZnVuY3Rpb24gcmQoYSl7dmFyIGI9YS50YXJnZXRJbnN0O2Rve2lmKCFiKXthLmFuY2VzdG9ycy5wdXNoKGIpO2JyZWFrfXZhciBjO2ZvcihjPWI7Y1tcInJldHVyblwiXTspYz1jW1wicmV0dXJuXCJdO2M9MyE9PWMudGFnP251bGw6Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZighYylicmVhazthLmFuY2VzdG9ycy5wdXNoKGIpO2I9cGIoYyl9d2hpbGUoYik7Zm9yKGM9MDtjPGEuYW5jZXN0b3JzLmxlbmd0aDtjKyspYj1hLmFuY2VzdG9yc1tjXSxzZChhLnRvcExldmVsVHlwZSxiLGEubmF0aXZlRXZlbnQsd2MoYS5uYXRpdmVFdmVudCkpfXZhciB0ZD0hMCxzZD12b2lkIDA7ZnVuY3Rpb24gdWQoYSl7dGQ9ISFhfWZ1bmN0aW9uIFUoYSxiLGMpe3JldHVybiBjP2JhLmxpc3RlbihjLGIsdmQuYmluZChudWxsLGEpKTpudWxsfWZ1bmN0aW9uIHdkKGEsYixjKXtyZXR1cm4gYz9iYS5jYXB0dXJlKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9XG5mdW5jdGlvbiB2ZChhLGIpe2lmKHRkKXt2YXIgYz13YyhiKTtjPXBiKGMpO251bGw9PT1jfHxcIm51bWJlclwiIT09dHlwZW9mIGMudGFnfHwyPT09a2QoYyl8fChjPW51bGwpO2lmKHFkLmxlbmd0aCl7dmFyIGQ9cWQucG9wKCk7ZC50b3BMZXZlbFR5cGU9YTtkLm5hdGl2ZUV2ZW50PWI7ZC50YXJnZXRJbnN0PWM7YT1kfWVsc2UgYT17dG9wTGV2ZWxUeXBlOmEsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfTt0cnl7dGMocmQsYSl9ZmluYWxseXthLnRvcExldmVsVHlwZT1udWxsLGEubmF0aXZlRXZlbnQ9bnVsbCxhLnRhcmdldEluc3Q9bnVsbCxhLmFuY2VzdG9ycy5sZW5ndGg9MCwxMD5xZC5sZW5ndGgmJnFkLnB1c2goYSl9fX1cbnZhciB4ZD1PYmplY3QuZnJlZXplKHtnZXQgX2VuYWJsZWQoKXtyZXR1cm4gdGR9LGdldCBfaGFuZGxlVG9wTGV2ZWwoKXtyZXR1cm4gc2R9LHNldEhhbmRsZVRvcExldmVsOmZ1bmN0aW9uKGEpe3NkPWF9LHNldEVuYWJsZWQ6dWQsaXNFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRkfSx0cmFwQnViYmxlZEV2ZW50OlUsdHJhcENhcHR1cmVkRXZlbnQ6d2QsZGlzcGF0Y2hFdmVudDp2ZH0pO2Z1bmN0aW9uIHlkKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7Y1tcIm1zXCIrYV09XCJNU1wiK2I7Y1tcIk9cIithXT1cIm9cIitiLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGN9XG52YXIgemQ9e2FuaW1hdGlvbmVuZDp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOnlkKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sQWQ9e30sQmQ9e307bC5jYW5Vc2VET00mJihCZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSB6ZC5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSB6ZC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24gQ2QoYSl7aWYoQWRbYV0pcmV0dXJuIEFkW2FdO2lmKCF6ZFthXSlyZXR1cm4gYTt2YXIgYj16ZFthXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBCZClyZXR1cm4gQWRbYV09YltjXTtyZXR1cm5cIlwifVxudmFyIERkPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQW5pbWF0aW9uRW5kOkNkKFwiYW5pbWF0aW9uZW5kXCIpfHxcImFuaW1hdGlvbmVuZFwiLHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjpDZChcImFuaW1hdGlvbml0ZXJhdGlvblwiKXx8XCJhbmltYXRpb25pdGVyYXRpb25cIix0b3BBbmltYXRpb25TdGFydDpDZChcImFuaW1hdGlvbnN0YXJ0XCIpfHxcImFuaW1hdGlvbnN0YXJ0XCIsdG9wQmx1cjpcImJsdXJcIix0b3BDYW5jZWw6XCJjYW5jZWxcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BDaGFuZ2U6XCJjaGFuZ2VcIix0b3BDbGljazpcImNsaWNrXCIsdG9wQ2xvc2U6XCJjbG9zZVwiLHRvcENvbXBvc2l0aW9uRW5kOlwiY29tcG9zaXRpb25lbmRcIix0b3BDb21wb3NpdGlvblN0YXJ0OlwiY29tcG9zaXRpb25zdGFydFwiLHRvcENvbXBvc2l0aW9uVXBkYXRlOlwiY29tcG9zaXRpb251cGRhdGVcIix0b3BDb250ZXh0TWVudTpcImNvbnRleHRtZW51XCIsdG9wQ29weTpcImNvcHlcIixcbnRvcEN1dDpcImN1dFwiLHRvcERvdWJsZUNsaWNrOlwiZGJsY2xpY2tcIix0b3BEcmFnOlwiZHJhZ1wiLHRvcERyYWdFbmQ6XCJkcmFnZW5kXCIsdG9wRHJhZ0VudGVyOlwiZHJhZ2VudGVyXCIsdG9wRHJhZ0V4aXQ6XCJkcmFnZXhpdFwiLHRvcERyYWdMZWF2ZTpcImRyYWdsZWF2ZVwiLHRvcERyYWdPdmVyOlwiZHJhZ292ZXJcIix0b3BEcmFnU3RhcnQ6XCJkcmFnc3RhcnRcIix0b3BEcm9wOlwiZHJvcFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wRm9jdXM6XCJmb2N1c1wiLHRvcElucHV0OlwiaW5wdXRcIix0b3BLZXlEb3duOlwia2V5ZG93blwiLHRvcEtleVByZXNzOlwia2V5cHJlc3NcIix0b3BLZXlVcDpcImtleXVwXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkOlwibG9hZFwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIixcbnRvcE1vdXNlRG93bjpcIm1vdXNlZG93blwiLHRvcE1vdXNlTW92ZTpcIm1vdXNlbW92ZVwiLHRvcE1vdXNlT3V0OlwibW91c2VvdXRcIix0b3BNb3VzZU92ZXI6XCJtb3VzZW92ZXJcIix0b3BNb3VzZVVwOlwibW91c2V1cFwiLHRvcFBhc3RlOlwicGFzdGVcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNjcm9sbDpcInNjcm9sbFwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU2VsZWN0aW9uQ2hhbmdlOlwic2VsZWN0aW9uY2hhbmdlXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRleHRJbnB1dDpcInRleHRJbnB1dFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVG9nZ2xlOlwidG9nZ2xlXCIsdG9wVG91Y2hDYW5jZWw6XCJ0b3VjaGNhbmNlbFwiLHRvcFRvdWNoRW5kOlwidG91Y2hlbmRcIix0b3BUb3VjaE1vdmU6XCJ0b3VjaG1vdmVcIixcbnRvcFRvdWNoU3RhcnQ6XCJ0b3VjaHN0YXJ0XCIsdG9wVHJhbnNpdGlvbkVuZDpDZChcInRyYW5zaXRpb25lbmRcIil8fFwidHJhbnNpdGlvbmVuZFwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLHRvcFdhaXRpbmc6XCJ3YWl0aW5nXCIsdG9wV2hlZWw6XCJ3aGVlbFwifSxFZD17fSxGZD0wLEdkPVwiX3JlYWN0TGlzdGVuZXJzSURcIisoXCJcIitNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtmdW5jdGlvbiBIZChhKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxHZCl8fChhW0dkXT1GZCsrLEVkW2FbR2RdXT17fSk7cmV0dXJuIEVkW2FbR2RdXX1mdW5jdGlvbiBJZChhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBKZChhLGIpe3ZhciBjPUlkKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPUlkKGMpfX1mdW5jdGlvbiBLZChhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiZcInRleHRcIj09PWEudHlwZXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG52YXIgTGQ9bC5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxNZD17c2VsZWN0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uU2VsZWN0XCIsY2FwdHVyZWQ6XCJvblNlbGVjdENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb250ZXh0TWVudSB0b3BGb2N1cyB0b3BLZXlEb3duIHRvcEtleVVwIHRvcE1vdXNlRG93biB0b3BNb3VzZVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LE5kPW51bGwsT2Q9bnVsbCxQZD1udWxsLFFkPSExO1xuZnVuY3Rpb24gUmQoYSxiKXtpZihRZHx8bnVsbD09TmR8fE5kIT09ZGEoKSlyZXR1cm4gbnVsbDt2YXIgYz1OZDtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZLZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06d2luZG93LmdldFNlbGVjdGlvbj8oYz13aW5kb3cuZ2V0U2VsZWN0aW9uKCksYz17YW5jaG9yTm9kZTpjLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmMuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpjLmZvY3VzTm9kZSxmb2N1c09mZnNldDpjLmZvY3VzT2Zmc2V0fSk6Yz12b2lkIDA7cmV0dXJuIFBkJiZlYShQZCxjKT9udWxsOihQZD1jLGE9VC5nZXRQb29sZWQoTWQuc2VsZWN0LE9kLGEsYiksYS50eXBlPVwic2VsZWN0XCIsYS50YXJnZXQ9TmQsQWIoYSksYSl9XG52YXIgU2Q9e2V2ZW50VHlwZXM6TWQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLndpbmRvdz09PWQ/ZC5kb2N1bWVudDo5PT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudCxmO2lmKCEoZj0hZSkpe2E6e2U9SGQoZSk7Zj1TYS5vblNlbGVjdDtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtpZighZS5oYXNPd25Qcm9wZXJ0eShoKXx8IWVbaF0pe2U9ITE7YnJlYWsgYX19ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP3FiKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcInRvcEZvY3VzXCI6aWYodmMoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpTmQ9ZSxPZD1iLFBkPW51bGw7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpQZD1PZD1OZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BNb3VzZURvd25cIjpRZD0hMDticmVhaztjYXNlIFwidG9wQ29udGV4dE1lbnVcIjpjYXNlIFwidG9wTW91c2VVcFwiOnJldHVybiBRZD0hMSxSZChjLGQpO2Nhc2UgXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIjppZihMZClicmVhaztcbmNhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuIFJkKGMsZCl9cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBUZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoVGQse2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO2Z1bmN0aW9uIFVkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhVZCx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pO2Z1bmN0aW9uIFZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1iZC5hdWdtZW50Q2xhc3MoVmQse3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO1xuZnVuY3Rpb24gV2QoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9XG52YXIgWGQ9e0VzYzpcIkVzY2FwZVwiLFNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LFlkPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLFxuMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifTtmdW5jdGlvbiBaZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoWmQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9WGRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9V2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP1lkW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/V2QoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9XZChhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pO2Z1bmN0aW9uICRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1mZC5hdWdtZW50Q2xhc3MoJGQse2RhdGFUcmFuc2ZlcjpudWxsfSk7ZnVuY3Rpb24gYWUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhhZSx7dG91Y2hlczpudWxsLHRhcmdldFRvdWNoZXM6bnVsbCxjaGFuZ2VkVG91Y2hlczpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkfSk7ZnVuY3Rpb24gYmUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJlLHtwcm9wZXJ0eU5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO1xuZnVuY3Rpb24gY2UoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcyhjZSx7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluIGE/LWEud2hlZWxEZWx0YVg6MH0sZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOm51bGwsZGVsdGFNb2RlOm51bGx9KTt2YXIgZGU9e30sZWU9e307XG5cImFib3J0IGFuaW1hdGlvbkVuZCBhbmltYXRpb25JdGVyYXRpb24gYW5pbWF0aW9uU3RhcnQgYmx1ciBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkb3VibGVDbGljayBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBmb2N1cyBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHNjcm9sbCBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG9nZ2xlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoTW92ZSB0b3VjaFN0YXJ0IHRyYW5zaXRpb25FbmQgdm9sdW1lQ2hhbmdlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hWzBdLnRvVXBwZXJDYXNlKCkrXG5hLnNsaWNlKDEpLGM9XCJvblwiK2I7Yj1cInRvcFwiK2I7Yz17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6YyxjYXB0dXJlZDpjK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2JdfTtkZVthXT1jO2VlW2JdPWN9KTtcbnZhciBmZT17ZXZlbnRUeXBlczpkZSxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWVlW2FdO2lmKCFlKXJldHVybiBudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigwPT09V2QoYykpcmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjphPVpkO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6Y2FzZSBcInRvcEZvY3VzXCI6YT1WZDticmVhaztjYXNlIFwidG9wQ2xpY2tcIjppZigyPT09Yy5idXR0b24pcmV0dXJuIG51bGw7Y2FzZSBcInRvcERvdWJsZUNsaWNrXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BNb3VzZU1vdmVcIjpjYXNlIFwidG9wTW91c2VVcFwiOmNhc2UgXCJ0b3BNb3VzZU91dFwiOmNhc2UgXCJ0b3BNb3VzZU92ZXJcIjpjYXNlIFwidG9wQ29udGV4dE1lbnVcIjphPWZkO2JyZWFrO2Nhc2UgXCJ0b3BEcmFnXCI6Y2FzZSBcInRvcERyYWdFbmRcIjpjYXNlIFwidG9wRHJhZ0VudGVyXCI6Y2FzZSBcInRvcERyYWdFeGl0XCI6Y2FzZSBcInRvcERyYWdMZWF2ZVwiOmNhc2UgXCJ0b3BEcmFnT3ZlclwiOmNhc2UgXCJ0b3BEcmFnU3RhcnRcIjpjYXNlIFwidG9wRHJvcFwiOmE9XG4kZDticmVhaztjYXNlIFwidG9wVG91Y2hDYW5jZWxcIjpjYXNlIFwidG9wVG91Y2hFbmRcIjpjYXNlIFwidG9wVG91Y2hNb3ZlXCI6Y2FzZSBcInRvcFRvdWNoU3RhcnRcIjphPWFlO2JyZWFrO2Nhc2UgXCJ0b3BBbmltYXRpb25FbmRcIjpjYXNlIFwidG9wQW5pbWF0aW9uSXRlcmF0aW9uXCI6Y2FzZSBcInRvcEFuaW1hdGlvblN0YXJ0XCI6YT1UZDticmVhaztjYXNlIFwidG9wVHJhbnNpdGlvbkVuZFwiOmE9YmU7YnJlYWs7Y2FzZSBcInRvcFNjcm9sbFwiOmE9YmQ7YnJlYWs7Y2FzZSBcInRvcFdoZWVsXCI6YT1jZTticmVhaztjYXNlIFwidG9wQ29weVwiOmNhc2UgXCJ0b3BDdXRcIjpjYXNlIFwidG9wUGFzdGVcIjphPVVkO2JyZWFrO2RlZmF1bHQ6YT1UfWI9YS5nZXRQb29sZWQoZSxiLGMsZCk7QWIoYik7cmV0dXJuIGJ9fTtzZD1mdW5jdGlvbihhLGIsYyxkKXthPWpiKGEsYixjLGQpO2tiKGEpO2xiKCExKX07aGIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihcIlJlc3BvbmRlckV2ZW50UGx1Z2luIFNpbXBsZUV2ZW50UGx1Z2luIFRhcEV2ZW50UGx1Z2luIEVudGVyTGVhdmVFdmVudFBsdWdpbiBDaGFuZ2VFdmVudFBsdWdpbiBTZWxlY3RFdmVudFBsdWdpbiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIuc3BsaXQoXCIgXCIpKTtcbldhPXNiLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7WGE9c2IuZ2V0SW5zdGFuY2VGcm9tTm9kZTtZYT1zYi5nZXROb2RlRnJvbUluc3RhbmNlO2hiLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7U2ltcGxlRXZlbnRQbHVnaW46ZmUsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOmhkLENoYW5nZUV2ZW50UGx1Z2luOmFkLFNlbGVjdEV2ZW50UGx1Z2luOlNkLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46aWN9KTt2YXIgZ2U9W10saGU9LTE7ZnVuY3Rpb24gVihhKXswPmhlfHwoYS5jdXJyZW50PWdlW2hlXSxnZVtoZV09bnVsbCxoZS0tKX1mdW5jdGlvbiBXKGEsYil7aGUrKztnZVtoZV09YS5jdXJyZW50O2EuY3VycmVudD1ifW5ldyBTZXQ7dmFyIGllPXtjdXJyZW50OkR9LFg9e2N1cnJlbnQ6ITF9LGplPUQ7ZnVuY3Rpb24ga2UoYSl7cmV0dXJuIGxlKGEpP2plOmllLmN1cnJlbnR9XG5mdW5jdGlvbiBtZShhLGIpe3ZhciBjPWEudHlwZS5jb250ZXh0VHlwZXM7aWYoIWMpcmV0dXJuIEQ7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoZCYmZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09YilyZXR1cm4gZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgZT17fSxmO2ZvcihmIGluIGMpZVtmXT1iW2ZdO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1iLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ZSk7cmV0dXJuIGV9ZnVuY3Rpb24gbGUoYSl7cmV0dXJuIDI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzfWZ1bmN0aW9uIG5lKGEpe2xlKGEpJiYoVihYLGEpLFYoaWUsYSkpfVxuZnVuY3Rpb24gb2UoYSxiLGMpe251bGwhPWllLmN1cnNvcj9FKFwiMTY4XCIpOnZvaWQgMDtXKGllLGIsYSk7VyhYLGMsYSl9ZnVuY3Rpb24gcGUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZSxkPWEudHlwZS5jaGlsZENvbnRleHRUeXBlcztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXRDaGlsZENvbnRleHQpcmV0dXJuIGI7Yz1jLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgZSBpbiBjKWUgaW4gZD92b2lkIDA6RShcIjEwOFwiLGpkKGEpfHxcIlVua25vd25cIixlKTtyZXR1cm4gQih7fSxiLGMpfWZ1bmN0aW9uIHFlKGEpe2lmKCFsZShhKSlyZXR1cm4hMTt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fEQ7amU9aWUuY3VycmVudDtXKGllLGIsYSk7VyhYLFguY3VycmVudCxhKTtyZXR1cm4hMH1cbmZ1bmN0aW9uIHJlKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7Yz92b2lkIDA6RShcIjE2OVwiKTtpZihiKXt2YXIgZD1wZShhLGplKTtjLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWQ7VihYLGEpO1YoaWUsYSk7VyhpZSxkLGEpfWVsc2UgVihYLGEpO1coWCxiLGEpfVxuZnVuY3Rpb24gWShhLGIsYyl7dGhpcy50YWc9YTt0aGlzLmtleT1iO3RoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT1udWxsO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXNbXCJyZXR1cm5cIl09bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPXRoaXMucGVuZGluZ1Byb3BzPXRoaXMucmVmPW51bGw7dGhpcy5pbnRlcm5hbENvbnRleHRUYWc9Yzt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfVxuZnVuY3Rpb24gc2UoYSxiLGMpe3ZhciBkPWEuYWx0ZXJuYXRlO251bGw9PT1kPyhkPW5ldyBZKGEudGFnLGEua2V5LGEuaW50ZXJuYWxDb250ZXh0VGFnKSxkLnR5cGU9YS50eXBlLGQuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGQuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9ZCk6KGQuZWZmZWN0VGFnPTAsZC5uZXh0RWZmZWN0PW51bGwsZC5maXJzdEVmZmVjdD1udWxsLGQubGFzdEVmZmVjdD1udWxsKTtkLmV4cGlyYXRpb25UaW1lPWM7ZC5wZW5kaW5nUHJvcHM9YjtkLmNoaWxkPWEuY2hpbGQ7ZC5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztkLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2QudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtkLnNpYmxpbmc9YS5zaWJsaW5nO2QuaW5kZXg9YS5pbmRleDtkLnJlZj1hLnJlZjtyZXR1cm4gZH1cbmZ1bmN0aW9uIHRlKGEsYixjKXt2YXIgZD12b2lkIDAsZT1hLnR5cGUsZj1hLmtleTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZT8oZD1lLnByb3RvdHlwZSYmZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD9uZXcgWSgyLGYsYik6bmV3IFkoMCxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwic3RyaW5nXCI9PT10eXBlb2YgZT8oZD1uZXcgWSg1LGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJudW1iZXJcIj09PXR5cGVvZiBlLnRhZz8oZD1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOkUoXCIxMzBcIixudWxsPT1lP2U6dHlwZW9mIGUsXCJcIik7ZC5leHBpcmF0aW9uVGltZT1jO3JldHVybiBkfWZ1bmN0aW9uIHVlKGEsYixjLGQpe2I9bmV3IFkoMTAsZCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1cbmZ1bmN0aW9uIHZlKGEsYixjKXtiPW5ldyBZKDYsbnVsbCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB3ZShhLGIsYyl7Yj1uZXcgWSg3LGEua2V5LGIpO2IudHlwZT1hLmhhbmRsZXI7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24geGUoYSxiLGMpe2E9bmV3IFkoOSxudWxsLGIpO2EuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYX1mdW5jdGlvbiB5ZShhLGIsYyl7Yj1uZXcgWSg0LGEua2V5LGIpO2IucGVuZGluZ1Byb3BzPWEuY2hpbGRyZW58fFtdO2IuZXhwaXJhdGlvblRpbWU9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9dmFyIHplPW51bGwsQWU9bnVsbDtcbmZ1bmN0aW9uIEJlKGEpe3JldHVybiBmdW5jdGlvbihiKXt0cnl7cmV0dXJuIGEoYil9Y2F0Y2goYyl7fX19ZnVuY3Rpb24gQ2UoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7emU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO0FlPUJlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9ZnVuY3Rpb24gRGUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIHplJiZ6ZShhKX1mdW5jdGlvbiBFZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgQWUmJkFlKGEpfVxuZnVuY3Rpb24gRmUoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGV4cGlyYXRpb25UaW1lOjAsZmlyc3Q6bnVsbCxsYXN0Om51bGwsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITEsaXNJbml0aWFsaXplZDohMX19ZnVuY3Rpb24gR2UoYSxiKXtudWxsPT09YS5sYXN0P2EuZmlyc3Q9YS5sYXN0PWI6KGEubGFzdC5uZXh0PWIsYS5sYXN0PWIpO2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIuZXhwaXJhdGlvblRpbWUpYS5leHBpcmF0aW9uVGltZT1iLmV4cGlyYXRpb25UaW1lfVxuZnVuY3Rpb24gSGUoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEudXBkYXRlUXVldWU7bnVsbD09PWQmJihkPWEudXBkYXRlUXVldWU9RmUobnVsbCkpO251bGwhPT1jPyhhPWMudXBkYXRlUXVldWUsbnVsbD09PWEmJihhPWMudXBkYXRlUXVldWU9RmUobnVsbCkpKTphPW51bGw7YT1hIT09ZD9hOm51bGw7bnVsbD09PWE/R2UoZCxiKTpudWxsPT09ZC5sYXN0fHxudWxsPT09YS5sYXN0PyhHZShkLGIpLEdlKGEsYikpOihHZShkLGIpLGEubGFzdD1iKX1mdW5jdGlvbiBJZShhLGIsYyxkKXthPWEucGFydGlhbFN0YXRlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChiLGMsZCk6YX1cbmZ1bmN0aW9uIEplKGEsYixjLGQsZSxmKXtudWxsIT09YSYmYS51cGRhdGVRdWV1ZT09PWMmJihjPWIudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTpjLmJhc2VTdGF0ZSxleHBpcmF0aW9uVGltZTpjLmV4cGlyYXRpb25UaW1lLGZpcnN0OmMuZmlyc3QsbGFzdDpjLmxhc3QsaXNJbml0aWFsaXplZDpjLmlzSW5pdGlhbGl6ZWQsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITF9KTtjLmV4cGlyYXRpb25UaW1lPTA7Yy5pc0luaXRpYWxpemVkP2E9Yy5iYXNlU3RhdGU6KGE9Yy5iYXNlU3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuaXNJbml0aWFsaXplZD0hMCk7Zm9yKHZhciBnPSEwLGg9Yy5maXJzdCxrPSExO251bGwhPT1oOyl7dmFyIHE9aC5leHBpcmF0aW9uVGltZTtpZihxPmYpe3ZhciB2PWMuZXhwaXJhdGlvblRpbWU7aWYoMD09PXZ8fHY+cSljLmV4cGlyYXRpb25UaW1lPXE7a3x8KGs9ITAsYy5iYXNlU3RhdGU9YSl9ZWxzZXtrfHwoYy5maXJzdD1oLm5leHQsbnVsbD09PVxuYy5maXJzdCYmKGMubGFzdD1udWxsKSk7aWYoaC5pc1JlcGxhY2UpYT1JZShoLGQsYSxlKSxnPSEwO2Vsc2UgaWYocT1JZShoLGQsYSxlKSlhPWc/Qih7fSxhLHEpOkIoYSxxKSxnPSExO2guaXNGb3JjZWQmJihjLmhhc0ZvcmNlVXBkYXRlPSEwKTtudWxsIT09aC5jYWxsYmFjayYmKHE9Yy5jYWxsYmFja0xpc3QsbnVsbD09PXEmJihxPWMuY2FsbGJhY2tMaXN0PVtdKSxxLnB1c2goaCkpfWg9aC5uZXh0fW51bGwhPT1jLmNhbGxiYWNrTGlzdD9iLmVmZmVjdFRhZ3w9MzI6bnVsbCE9PWMuZmlyc3R8fGMuaGFzRm9yY2VVcGRhdGV8fChiLnVwZGF0ZVF1ZXVlPW51bGwpO2t8fChjLmJhc2VTdGF0ZT1hKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIEtlKGEsYil7dmFyIGM9YS5jYWxsYmFja0xpc3Q7aWYobnVsbCE9PWMpZm9yKGEuY2FsbGJhY2tMaXN0PW51bGwsYT0wO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdLGU9ZC5jYWxsYmFjaztkLmNhbGxiYWNrPW51bGw7XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/RShcIjE5MVwiLGUpOnZvaWQgMDtlLmNhbGwoYil9fVxuZnVuY3Rpb24gTGUoYSxiLGMsZCl7ZnVuY3Rpb24gZShhLGIpe2IudXBkYXRlcj1mO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWF9dmFyIGY9e2lzTW91bnRlZDpsZCxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxnKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITAsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7XG5hKGMsZyl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihjLGQpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGU9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTplLHBhcnRpYWxTdGF0ZTpudWxsLGNhbGxiYWNrOmQsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiEwLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxlKX19O3JldHVybnthZG9wdENsYXNzSW5zdGFuY2U6ZSxjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50eXBlLGQ9a2UoYSksZj0yPT09YS50YWcmJm51bGwhPWEudHlwZS5jb250ZXh0VHlwZXMsZz1mP21lKGEsZCk6RDtiPW5ldyBjKGIsZyk7ZShhLGIpO2YmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1kLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9Zyk7cmV0dXJuIGJ9LG1vdW50Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnN0YXRlTm9kZSxlPWQuc3RhdGV8fG51bGwsZz1hLnBlbmRpbmdQcm9wcztnP3ZvaWQgMDpFKFwiMTU4XCIpO3ZhciBoPWtlKGEpO2QucHJvcHM9ZztkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZT1lO2QucmVmcz1EO2QuY29udGV4dD1tZShhLGgpO251bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCYmKGEuaW50ZXJuYWxDb250ZXh0VGFnfD0xKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsTW91bnQmJihlPWQuc3RhdGUsZC5jb21wb25lbnRXaWxsTW91bnQoKSxlIT09ZC5zdGF0ZSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGQsZC5zdGF0ZSxudWxsKSxlPWEudXBkYXRlUXVldWUsbnVsbCE9PWUmJihkLnN0YXRlPUplKGMsYSxlLGQsZyxiKSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PVxuNCl9LHVwZGF0ZUNsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPWIuc3RhdGVOb2RlO2cucHJvcHM9Yi5tZW1vaXplZFByb3BzO2cuc3RhdGU9Yi5tZW1vaXplZFN0YXRlO3ZhciBoPWIubWVtb2l6ZWRQcm9wcyxrPWIucGVuZGluZ1Byb3BzO2t8fChrPWgsbnVsbD09az9FKFwiMTU5XCIpOnZvaWQgMCk7dmFyIHU9Zy5jb250ZXh0LHo9a2UoYik7ej1tZShiLHopO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fGg9PT1rJiZ1PT09enx8KHU9Zy5zdGF0ZSxnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoayx6KSxnLnN0YXRlIT09dSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGcsZy5zdGF0ZSxudWxsKSk7dT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09Yi51cGRhdGVRdWV1ZT9KZShhLGIsYi51cGRhdGVRdWV1ZSxnLGssZSk6dTtpZighKGghPT1rfHx1IT09ZXx8WC5jdXJyZW50fHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpcmV0dXJuXCJmdW5jdGlvblwiIT09XG50eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksITE7dmFyIEc9aztpZihudWxsPT09aHx8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpRz0hMDtlbHNle3ZhciBJPWIuc3RhdGVOb2RlLEw9Yi50eXBlO0c9XCJmdW5jdGlvblwiPT09dHlwZW9mIEkuc2hvdWxkQ29tcG9uZW50VXBkYXRlP0kuc2hvdWxkQ29tcG9uZW50VXBkYXRlKEcsZSx6KTpMLnByb3RvdHlwZSYmTC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWVhKGgsRyl8fCFlYSh1LGUpOiEwfUc/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShrLGUseiksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksYyhiLGspLGQoYixlKSk7Zy5wcm9wcz1rO2cuc3RhdGU9ZTtnLmNvbnRleHQ9ejtyZXR1cm4gR319fXZhciBRZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0sUmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxTZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LFRlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSxVZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsVmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsV2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24gWGUoYSl7aWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPVdlJiZhW1dlXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfXZhciBZZT1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gWmUoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsIT09YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpe2lmKGIuX293bmVyKXtiPWIuX293bmVyO3ZhciBkPXZvaWQgMDtiJiYoMiE9PWIudGFnP0UoXCIxMTBcIik6dm9pZCAwLGQ9Yi5zdGF0ZU5vZGUpO2Q/dm9pZCAwOkUoXCIxNDdcIixjKTt2YXIgZT1cIlwiK2M7aWYobnVsbCE9PWEmJm51bGwhPT1hLnJlZiYmYS5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGEucmVmO2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzPT09RD9kLnJlZnM9e306ZC5yZWZzO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07YS5fc3RyaW5nUmVmPWU7cmV0dXJuIGF9XCJzdHJpbmdcIiE9PXR5cGVvZiBjP0UoXCIxNDhcIik6dm9pZCAwO2IuX293bmVyP3ZvaWQgMDpFKFwiMTQ5XCIsYyl9cmV0dXJuIGN9XG5mdW5jdGlvbiAkZShhLGIpe1widGV4dGFyZWFcIiE9PWEudHlwZSYmRShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjpiLFwiXCIpfVxuZnVuY3Rpb24gYWYoYSl7ZnVuY3Rpb24gYihiLGMpe2lmKGEpe3ZhciBkPWIubGFzdEVmZmVjdDtudWxsIT09ZD8oZC5uZXh0RWZmZWN0PWMsYi5sYXN0RWZmZWN0PWMpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PWM7Yy5uZXh0RWZmZWN0PW51bGw7Yy5lZmZlY3RUYWc9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIsYyl7YT1zZShhLGIsYyk7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmVmZmVjdFRhZz1cbjIsYyk6ZDtiLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5lZmZlY3RUYWc9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPXZlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi50eXBlPT09Yy50eXBlKXJldHVybiBkPWUoYixjLnByb3BzLGQpLGQucmVmPVplKGIsYyksZFtcInJldHVyblwiXT1hLGQ7ZD10ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpO2QucmVmPVplKGIsYyk7ZFtcInJldHVyblwiXT1hO3JldHVybiBkfWZ1bmN0aW9uIHEoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDchPT1iLnRhZylyZXR1cm4gYj13ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7XG5iW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdihhLGIsYyxkKXtpZihudWxsPT09Ynx8OSE9PWIudGFnKXJldHVybiBiPXhlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYi50eXBlPWMudmFsdWUsYltcInJldHVyblwiXT1hLGI7Yj1lKGIsbnVsbCxkKTtiLnR5cGU9Yy52YWx1ZTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geShhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9eWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLmNoaWxkcmVufHxbXSxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyxkLGYpe2lmKG51bGw9PT1ifHwxMCE9PWIudGFnKXJldHVybiBiPXVlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5kLGYpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHooYSxiLGMpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPXZlKFwiXCIrYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKXtzd2l0Y2goYi4kJHR5cGVvZil7Y2FzZSBSZTppZihiLnR5cGU9PT1WZSlyZXR1cm4gYj11ZShiLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsYi5rZXkpLGJbXCJyZXR1cm5cIl09YSxiO2M9dGUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKTtjLnJlZj1aZShudWxsLGIpO2NbXCJyZXR1cm5cIl09YTtyZXR1cm4gYztjYXNlIFNlOnJldHVybiBiPXdlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGI7Y2FzZSBUZTpyZXR1cm4gYz14ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuYyksYy50eXBlPWIudmFsdWUsY1tcInJldHVyblwiXT1hLGM7Y2FzZSBVZTpyZXR1cm4gYj15ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxifWlmKFllKGIpfHxYZShiKSlyZXR1cm4gYj11ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsbnVsbCksYltcInJldHVyblwiXT1hLGI7JGUoYSxiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBHKGEsYixjLGQpe3ZhciBlPW51bGwhPT1iP2Iua2V5Om51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBjLmtleT09PWU/Yy50eXBlPT09VmU/dShhLGIsYy5wcm9wcy5jaGlsZHJlbixkLGUpOmsoYSxiLGMsZCk6bnVsbDtjYXNlIFNlOnJldHVybiBjLmtleT09PWU/cShhLGIsYyxkKTpudWxsO2Nhc2UgVGU6cmV0dXJuIG51bGw9PT1cbmU/dihhLGIsYyxkKTpudWxsO2Nhc2UgVWU6cmV0dXJuIGMua2V5PT09ZT95KGEsYixjLGQpOm51bGx9aWYoWWUoYyl8fFhlKGMpKXJldHVybiBudWxsIT09ZT9udWxsOnUoYSxiLGMsZCxudWxsKTskZShhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGQudHlwZT09PVZlP3UoYixhLGQucHJvcHMuY2hpbGRyZW4sZSxkLmtleSk6ayhiLGEsZCxlKTtjYXNlIFNlOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxxKGIsYSxkLGUpO2Nhc2UgVGU6cmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdihiLGEsZCxlKTtjYXNlIFVlOnJldHVybiBhPVxuYS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHkoYixhLGQsZSl9aWYoWWUoZCl8fFhlKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHUoYixhLGQsZSxudWxsKTskZShiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIEwoZSxnLG0sQSl7Zm9yKHZhciBoPW51bGwscj1udWxsLG49Zyx3PWc9MCxrPW51bGw7bnVsbCE9PW4mJnc8bS5sZW5ndGg7dysrKXtuLmluZGV4Pnc/KGs9bixuPW51bGwpOms9bi5zaWJsaW5nO3ZhciB4PUcoZSxuLG1bd10sQSk7aWYobnVsbD09PXgpe251bGw9PT1uJiYobj1rKTticmVha31hJiZuJiZudWxsPT09eC5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoeCxnLHcpO251bGw9PT1yP2g9eDpyLnNpYmxpbmc9eDtyPXg7bj1rfWlmKHc9PT1tLmxlbmd0aClyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7dzxtLmxlbmd0aDt3KyspaWYobj16KGUsbVt3XSxBKSlnPWYobixnLHcpLG51bGw9PT1yP2g9bjpyLnNpYmxpbmc9bixyPW47cmV0dXJuIGh9Zm9yKG49XG5kKGUsbik7dzxtLmxlbmd0aDt3KyspaWYoaz1JKG4sZSx3LG1bd10sQSkpe2lmKGEmJm51bGwhPT1rLmFsdGVybmF0ZSluW1wiZGVsZXRlXCJdKG51bGw9PT1rLmtleT93Omsua2V5KTtnPWYoayxnLHcpO251bGw9PT1yP2g9azpyLnNpYmxpbmc9aztyPWt9YSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gaH1mdW5jdGlvbiBOKGUsZyxtLEEpe3ZhciBoPVhlKG0pO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBoP0UoXCIxNTBcIik6dm9pZCAwO209aC5jYWxsKG0pO251bGw9PW0/RShcIjE1MVwiKTp2b2lkIDA7Zm9yKHZhciByPWg9bnVsbCxuPWcsdz1nPTAsaz1udWxsLHg9bS5uZXh0KCk7bnVsbCE9PW4mJiF4LmRvbmU7dysrLHg9bS5uZXh0KCkpe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIEo9RyhlLG4seC52YWx1ZSxBKTtpZihudWxsPT09Sil7bnx8KG49ayk7YnJlYWt9YSYmbiYmbnVsbD09PUouYWx0ZXJuYXRlJiZiKGUsbik7Zz1mKEosXG5nLHcpO251bGw9PT1yP2g9SjpyLnNpYmxpbmc9SjtyPUo7bj1rfWlmKHguZG9uZSlyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7IXguZG9uZTt3KysseD1tLm5leHQoKSl4PXooZSx4LnZhbHVlLEEpLG51bGwhPT14JiYoZz1mKHgsZyx3KSxudWxsPT09cj9oPXg6ci5zaWJsaW5nPXgscj14KTtyZXR1cm4gaH1mb3Iobj1kKGUsbik7IXguZG9uZTt3KysseD1tLm5leHQoKSlpZih4PUkobixlLHcseC52YWx1ZSxBKSxudWxsIT09eCl7aWYoYSYmbnVsbCE9PXguYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PXgua2V5P3c6eC5rZXkpO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eH1hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofXJldHVybiBmdW5jdGlvbihhLGQsZixoKXtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT1WZSYmbnVsbD09PWYua2V5JiYoZj1mLnByb3BzLmNoaWxkcmVuKTtcbnZhciBtPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobSlzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBSZTphOnt2YXIgcj1mLmtleTtmb3IobT1kO251bGwhPT1tOyl7aWYobS5rZXk9PT1yKWlmKDEwPT09bS50YWc/Zi50eXBlPT09VmU6bS50eXBlPT09Zi50eXBlKXtjKGEsbS5zaWJsaW5nKTtkPWUobSxmLnR5cGU9PT1WZT9mLnByb3BzLmNoaWxkcmVuOmYucHJvcHMsaCk7ZC5yZWY9WmUobSxmKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsbSk7YnJlYWt9ZWxzZSBiKGEsbSk7bT1tLnNpYmxpbmd9Zi50eXBlPT09VmU/KGQ9dWUoZi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxoLGYua2V5KSxkW1wicmV0dXJuXCJdPWEsYT1kKTooaD10ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpLGgucmVmPVplKGQsZiksaFtcInJldHVyblwiXT1hLGE9aCl9cmV0dXJuIGcoYSk7Y2FzZSBTZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09XG5tKWlmKDc9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsZixoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD13ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBUZTphOntpZihudWxsIT09ZClpZig5PT09ZC50YWcpe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLG51bGwsaCk7ZC50eXBlPWYudmFsdWU7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2UgYyhhLGQpO2Q9eGUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgVWU6YTp7Zm9yKG09Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PW0paWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PVxuZi5pbXBsZW1lbnRhdGlvbil7YyhhLGQuc2libGluZyk7ZD1lKGQsZi5jaGlsZHJlbnx8W10saCk7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9eWUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpfWlmKFwic3RyaW5nXCI9PT10eXBlb2YgZnx8XCJudW1iZXJcIj09PXR5cGVvZiBmKXJldHVybiBmPVwiXCIrZixudWxsIT09ZCYmNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmLGgpKTooYyhhLGQpLGQ9dmUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSksZFtcInJldHVyblwiXT1hLGE9ZCxnKGEpO2lmKFllKGYpKXJldHVybiBMKGEsZCxmLGgpO2lmKFhlKGYpKXJldHVybiBOKGEsZCxmLGgpO20mJiRlKGEsZik7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBmKXN3aXRjaChhLnRhZyl7Y2FzZSAyOmNhc2UgMTpoPWEudHlwZSxFKFwiMTUyXCIsaC5kaXNwbGF5TmFtZXx8XG5oLm5hbWV8fFwiQ29tcG9uZW50XCIpfXJldHVybiBjKGEsZCl9fXZhciBiZj1hZighMCksY2Y9YWYoITEpO1xuZnVuY3Rpb24gZGYoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGEsYixjKXt2YXIgZD1iLmV4cGlyYXRpb25UaW1lO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLGMsZCk6YmYoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZyhhLGIpe3ZhciBjPWIucmVmO251bGw9PT1jfHxhJiZhLnJlZj09PWN8fChiLmVmZmVjdFRhZ3w9MTI4KX1mdW5jdGlvbiBoKGEsYixjLGQpe2coYSxiKTtpZighYylyZXR1cm4gZCYmcmUoYiwhMSkscShhLGIpO2M9Yi5zdGF0ZU5vZGU7aWQuY3VycmVudD1iO3ZhciBlPWMucmVuZGVyKCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFN0YXRlPWMuc3RhdGU7Yi5tZW1vaXplZFByb3BzPWMucHJvcHM7ZCYmcmUoYiwhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gayhhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P29lKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJm9lKGEsXG5iLmNvbnRleHQsITEpO0koYSxiLmNvbnRhaW5lckluZm8pfWZ1bmN0aW9uIHEoYSxiKXtudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQ/RShcIjE1M1wiKTp2b2lkIDA7aWYobnVsbCE9PWIuY2hpbGQpe2E9Yi5jaGlsZDt2YXIgYz1zZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpO2IuY2hpbGQ9Yztmb3IoY1tcInJldHVyblwiXT1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSksY1tcInJldHVyblwiXT1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfWZ1bmN0aW9uIHYoYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMzprKGIpO2JyZWFrO2Nhc2UgMjpxZShiKTticmVhaztjYXNlIDQ6SShiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pfXJldHVybiBudWxsfXZhciB5PWEuc2hvdWxkU2V0VGV4dENvbnRlbnQsdT1hLnVzZVN5bmNTY2hlZHVsaW5nLHo9YS5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlLFxuRz1iLnB1c2hIb3N0Q29udGV4dCxJPWIucHVzaEhvc3RDb250YWluZXIsTD1jLmVudGVySHlkcmF0aW9uU3RhdGUsTj1jLnJlc2V0SHlkcmF0aW9uU3RhdGUsSj1jLnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO2E9TGUoZCxlLGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFByb3BzPWJ9LGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFN0YXRlPWJ9KTt2YXIgdz1hLmFkb3B0Q2xhc3NJbnN0YW5jZSxtPWEuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxBPWEubW91bnRDbGFzc0luc3RhbmNlLE9iPWEudXBkYXRlQ2xhc3NJbnN0YW5jZTtyZXR1cm57YmVnaW5Xb3JrOmZ1bmN0aW9uKGEsYixjKXtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7c3dpdGNoKGIudGFnKXtjYXNlIDA6bnVsbCE9PWE/RShcIjE1NVwiKTp2b2lkIDA7dmFyIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMscj1rZShiKTtyPW1lKGIscik7ZD1kKGUscik7Yi5lZmZlY3RUYWd8PVxuMTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5yZW5kZXI/KGIudGFnPTIsZT1xZShiKSx3KGIsZCksQShiLGMpLGI9aChhLGIsITAsZSkpOihiLnRhZz0xLGYoYSxiLGQpLGIubWVtb2l6ZWRQcm9wcz1lLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxOmE6e2U9Yi50eXBlO2M9Yi5wZW5kaW5nUHJvcHM7ZD1iLm1lbW9pemVkUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1kKTtlbHNlIGlmKG51bGw9PT1jfHxkPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1kPWtlKGIpO2Q9bWUoYixkKTtlPWUoYyxkKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAyOnJldHVybiBlPXFlKGIpLGQ9dm9pZCAwLG51bGw9PT1hP2Iuc3RhdGVOb2RlP0UoXCIxNTNcIik6KG0oYixiLnBlbmRpbmdQcm9wcyksQShiLGMpLGQ9ITApOmQ9T2IoYSxiLGMpLGgoYSxiLGQsZSk7Y2FzZSAzOnJldHVybiBrKGIpLFxuZT1iLnVwZGF0ZVF1ZXVlLG51bGwhPT1lPyhkPWIubWVtb2l6ZWRTdGF0ZSxlPUplKGEsYixlLG51bGwsbnVsbCxjKSxkPT09ZT8oTigpLGI9cShhLGIpKTooZD1lLmVsZW1lbnQscj1iLnN0YXRlTm9kZSwobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKSYmci5oeWRyYXRlJiZMKGIpPyhiLmVmZmVjdFRhZ3w9MixiLmNoaWxkPWNmKGIsbnVsbCxkLGMpKTooTigpLGYoYSxiLGQpKSxiLm1lbW9pemVkU3RhdGU9ZSxiPWIuY2hpbGQpKTooTigpLGI9cShhLGIpKSxiO2Nhc2UgNTpHKGIpO251bGw9PT1hJiZKKGIpO2U9Yi50eXBlO3ZhciBuPWIubWVtb2l6ZWRQcm9wcztkPWIucGVuZGluZ1Byb3BzO251bGw9PT1kJiYoZD1uLG51bGw9PT1kP0UoXCIxNTRcIik6dm9pZCAwKTtyPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpudWxsO1guY3VycmVudHx8bnVsbCE9PWQmJm4hPT1kPyhuPWQuY2hpbGRyZW4seShlLGQpP249bnVsbDpyJiZ5KGUscikmJihiLmVmZmVjdFRhZ3w9MTYpLGcoYSxiKSxcbjIxNDc0ODM2NDchPT1jJiYhdSYmeihlLGQpPyhiLmV4cGlyYXRpb25UaW1lPTIxNDc0ODM2NDcsYj1udWxsKTooZihhLGIsbiksYi5tZW1vaXplZFByb3BzPWQsYj1iLmNoaWxkKSk6Yj1xKGEsYik7cmV0dXJuIGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmSihiKSxhPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hJiYoYT1iLm1lbW9pemVkUHJvcHMpLGIubWVtb2l6ZWRQcm9wcz1hLG51bGw7Y2FzZSA4OmIudGFnPTc7Y2FzZSA3OmU9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpZT1iLm1lbW9pemVkUHJvcHM7ZD1lLmNoaWxkcmVuO2Iuc3RhdGVOb2RlPW51bGw9PT1hP2NmKGIsYi5zdGF0ZU5vZGUsZCxjKTpiZihiLGIuc3RhdGVOb2RlLGQsYyk7Yi5tZW1vaXplZFByb3BzPWU7cmV0dXJuIGIuc3RhdGVOb2RlO1xuY2FzZSA5OnJldHVybiBudWxsO2Nhc2UgNDphOntJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT1lP0UoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKXtiPXEoYSxiKTticmVhayBhfW51bGw9PT1hP2IuY2hpbGQ9YmYoYixudWxsLGUsYyk6ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWU7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMTA6YTp7Yz1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWIubWVtb2l6ZWRQcm9wcyk7ZWxzZSBpZihudWxsPT09Y3x8Yi5tZW1vaXplZFByb3BzPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1mKGEsYixjKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7ZGVmYXVsdDpFKFwiMTU2XCIpfX0sYmVnaW5GYWlsZWRXb3JrOmZ1bmN0aW9uKGEsYixcbmMpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgMzprKGIpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX1iLmVmZmVjdFRhZ3w9NjQ7bnVsbD09PWE/Yi5jaGlsZD1udWxsOmIuY2hpbGQhPT1hLmNoaWxkJiYoYi5jaGlsZD1hLmNoaWxkKTtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7Yi5maXJzdEVmZmVjdD1udWxsO2IubGFzdEVmZmVjdD1udWxsO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLG51bGwsYyk6YmYoYixhLmNoaWxkLG51bGwsYyk7Mj09PWIudGFnJiYoYT1iLnN0YXRlTm9kZSxiLm1lbW9pemVkUHJvcHM9YS5wcm9wcyxiLm1lbW9pemVkU3RhdGU9YS5zdGF0ZSk7cmV0dXJuIGIuY2hpbGR9fX1cbmZ1bmN0aW9uIGVmKGEsYixjKXtmdW5jdGlvbiBkKGEpe2EuZWZmZWN0VGFnfD00fXZhciBlPWEuY3JlYXRlSW5zdGFuY2UsZj1hLmNyZWF0ZVRleHRJbnN0YW5jZSxnPWEuYXBwZW5kSW5pdGlhbENoaWxkLGg9YS5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixrPWEucHJlcGFyZVVwZGF0ZSxxPWEucGVyc2lzdGVuY2Usdj1iLmdldFJvb3RIb3N0Q29udGFpbmVyLHk9Yi5wb3BIb3N0Q29udGV4dCx1PWIuZ2V0SG9zdENvbnRleHQsej1iLnBvcEhvc3RDb250YWluZXIsRz1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsST1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLEw9Yy5wb3BIeWRyYXRpb25TdGF0ZSxOPXZvaWQgMCxKPXZvaWQgMCx3PXZvaWQgMDthLm11dGF0aW9uPyhOPWZ1bmN0aW9uKCl7fSxKPWZ1bmN0aW9uKGEsYixjKXsoYi51cGRhdGVRdWV1ZT1jKSYmZChiKX0sdz1mdW5jdGlvbihhLGIsYyxlKXtjIT09ZSYmZChiKX0pOnE/RShcIjIzNVwiKTpFKFwiMjM2XCIpO1xucmV0dXJue2NvbXBsZXRlV29yazpmdW5jdGlvbihhLGIsYyl7dmFyIG09Yi5wZW5kaW5nUHJvcHM7aWYobnVsbD09PW0pbT1iLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigyMTQ3NDgzNjQ3IT09Yi5leHBpcmF0aW9uVGltZXx8MjE0NzQ4MzY0Nz09PWMpYi5wZW5kaW5nUHJvcHM9bnVsbDtzd2l0Y2goYi50YWcpe2Nhc2UgMTpyZXR1cm4gbnVsbDtjYXNlIDI6cmV0dXJuIG5lKGIpLG51bGw7Y2FzZSAzOnooYik7VihYLGIpO1YoaWUsYik7bT1iLnN0YXRlTm9kZTttLnBlbmRpbmdDb250ZXh0JiYobS5jb250ZXh0PW0ucGVuZGluZ0NvbnRleHQsbS5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpTChiKSxiLmVmZmVjdFRhZyY9LTM7TihiKTtyZXR1cm4gbnVsbDtjYXNlIDU6eShiKTtjPXYoKTt2YXIgQT1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKXt2YXIgcD1hLm1lbW9pemVkUHJvcHMscT1iLnN0YXRlTm9kZSx4PXUoKTtxPVxuayhxLEEscCxtLGMseCk7SihhLGIscSxBLHAsbSxjKTthLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZXtpZighbSlyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjZcIik6dm9pZCAwLG51bGw7YT11KCk7aWYoTChiKSlHKGIsYyxhKSYmZChiKTtlbHNle2E9ZShBLG0sYyxhLGIpO2E6Zm9yKHA9Yi5jaGlsZDtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnKWcoYSxwLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09cC50YWcmJm51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWlmKHA9PT1iKWJyZWFrO2Zvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1wW1wicmV0dXJuXCJdfHxwW1wicmV0dXJuXCJdPT09YilicmVhayBhO3A9cFtcInJldHVyblwiXX1wLnNpYmxpbmdbXCJyZXR1cm5cIl09cFtcInJldHVyblwiXTtwPXAuc2libGluZ31oKGEsQSxtLGMpJiZkKGIpO2Iuc3RhdGVOb2RlPWF9bnVsbCE9PWIucmVmJiZcbihiLmVmZmVjdFRhZ3w9MTI4KX1yZXR1cm4gbnVsbDtjYXNlIDY6aWYoYSYmbnVsbCE9Yi5zdGF0ZU5vZGUpdyhhLGIsYS5tZW1vaXplZFByb3BzLG0pO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXYoKTtjPXUoKTtMKGIpP0koYikmJmQoYik6Yi5zdGF0ZU5vZGU9ZihtLGEsYyxiKX1yZXR1cm4gbnVsbDtjYXNlIDc6KG09Yi5tZW1vaXplZFByb3BzKT92b2lkIDA6RShcIjE2NVwiKTtiLnRhZz04O0E9W107YTpmb3IoKHA9Yi5zdGF0ZU5vZGUpJiYocFtcInJldHVyblwiXT1iKTtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnfHw0PT09cC50YWcpRShcIjI0N1wiKTtlbHNlIGlmKDk9PT1wLnRhZylBLnB1c2gocC50eXBlKTtlbHNlIGlmKG51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWZvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1cbnBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfXA9bS5oYW5kbGVyO209cChtLnByb3BzLEEpO2IuY2hpbGQ9YmYoYixudWxsIT09YT9hLmNoaWxkOm51bGwsbSxjKTtyZXR1cm4gYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGIudGFnPTcsbnVsbDtjYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSAxMDpyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIHooYiksTihiKSxudWxsO2Nhc2UgMDpFKFwiMTY3XCIpO2RlZmF1bHQ6RShcIjE1NlwiKX19fX1cbmZ1bmN0aW9uIGZmKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYz1hLnJlZjtpZihudWxsIT09Yyl0cnl7YyhudWxsKX1jYXRjaChBKXtiKGEsQSl9fWZ1bmN0aW9uIGQoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIEVlJiZFZShhKTtzd2l0Y2goYS50YWcpe2Nhc2UgMjpjKGEpO3ZhciBkPWEuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtkLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxkLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goQSl7YihhLEEpfWJyZWFrO2Nhc2UgNTpjKGEpO2JyZWFrO2Nhc2UgNzplKGEuc3RhdGVOb2RlKTticmVhaztjYXNlIDQ6ayYmZyhhKX19ZnVuY3Rpb24gZShhKXtmb3IodmFyIGI9YTs7KWlmKGQoYiksbnVsbD09PWIuY2hpbGR8fGsmJjQ9PT1iLnRhZyl7aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fFxuYltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ31lbHNlIGIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGR9ZnVuY3Rpb24gZihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYj1hLGM9ITEsZj12b2lkIDAsZz12b2lkIDA7Oyl7aWYoIWMpe2M9YltcInJldHVyblwiXTthOmZvcig7Oyl7bnVsbD09PWM/RShcIjE2MFwiKTp2b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Zj1jLnN0YXRlTm9kZTtnPSExO2JyZWFrIGE7Y2FzZSAzOmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGE7Y2FzZSA0OmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWM9ITB9aWYoNT09PWIudGFnfHw2PT09Yi50YWcpZShiKSxnP0ooZixiLnN0YXRlTm9kZSk6TihmLGIuc3RhdGVOb2RlKTtcbmVsc2UgaWYoND09PWIudGFnP2Y9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpkKGIpLG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkW1wicmV0dXJuXCJdPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdOzQ9PT1iLnRhZyYmKGM9ITEpfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX12YXIgaD1hLmdldFB1YmxpY0luc3RhbmNlLGs9YS5tdXRhdGlvbjthPWEucGVyc2lzdGVuY2U7a3x8KGE/RShcIjIzNVwiKTpFKFwiMjM2XCIpKTt2YXIgcT1rLmNvbW1pdE1vdW50LHY9ay5jb21taXRVcGRhdGUseT1rLnJlc2V0VGV4dENvbnRlbnQsdT1rLmNvbW1pdFRleHRVcGRhdGUsej1rLmFwcGVuZENoaWxkLEc9ay5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLEk9ay5pbnNlcnRCZWZvcmUsTD1rLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuTj1rLnJlbW92ZUNoaWxkLEo9ay5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7cmV0dXJue2NvbW1pdFJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7eShhLnN0YXRlTm9kZSl9LGNvbW1pdFBsYWNlbWVudDpmdW5jdGlvbihhKXthOntmb3IodmFyIGI9YVtcInJldHVyblwiXTtudWxsIT09Yjspe2lmKGYoYikpe3ZhciBjPWI7YnJlYWsgYX1iPWJbXCJyZXR1cm5cIl19RShcIjE2MFwiKTtjPXZvaWQgMH12YXIgZD1iPXZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpiPWMuc3RhdGVOb2RlO2Q9ITE7YnJlYWs7Y2FzZSAzOmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztkZWZhdWx0OkUoXCIxNjFcIil9Yy5lZmZlY3RUYWcmMTYmJih5KGIpLGMuZWZmZWN0VGFnJj0tMTcpO2E6Yjpmb3IoYz1hOzspe2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jW1wicmV0dXJuXCJdfHxmKGNbXCJyZXR1cm5cIl0pKXtjPVxubnVsbDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jLnNpYmxpbmdbXCJyZXR1cm5cIl09Y1tcInJldHVyblwiXTtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7aWYobnVsbD09PWMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZFtcInJldHVyblwiXT1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDU9PT1lLnRhZ3x8Nj09PWUudGFnKWM/ZD9MKGIsZS5zdGF0ZU5vZGUsYyk6SShiLGUuc3RhdGVOb2RlLGMpOmQ/RyhiLGUuc3RhdGVOb2RlKTp6KGIsZS5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZFtcInJldHVyblwiXT1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YSlicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZVtcInJldHVyblwiXXx8ZVtcInJldHVyblwiXT09PVxuYSlyZXR1cm47ZT1lW1wicmV0dXJuXCJdfWUuc2libGluZ1tcInJldHVyblwiXT1lW1wicmV0dXJuXCJdO2U9ZS5zaWJsaW5nfX0sY29tbWl0RGVsZXRpb246ZnVuY3Rpb24oYSl7ZyhhKTthW1wicmV0dXJuXCJdPW51bGw7YS5jaGlsZD1udWxsO2EuYWx0ZXJuYXRlJiYoYS5hbHRlcm5hdGUuY2hpbGQ9bnVsbCxhLmFsdGVybmF0ZVtcInJldHVyblwiXT1udWxsKX0sY29tbWl0V29yazpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmJyZWFrO2Nhc2UgNTp2YXIgYz1iLnN0YXRlTm9kZTtpZihudWxsIT1jKXt2YXIgZD1iLm1lbW9pemVkUHJvcHM7YT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6ZDt2YXIgZT1iLnR5cGUsZj1iLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9bnVsbDtudWxsIT09ZiYmdihjLGYsZSxhLGQsYil9YnJlYWs7Y2FzZSA2Om51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTYyXCIpOnZvaWQgMDtjPWIubWVtb2l6ZWRQcm9wczt1KGIuc3RhdGVOb2RlLG51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbmMsYyk7YnJlYWs7Y2FzZSAzOmJyZWFrO2RlZmF1bHQ6RShcIjE2M1wiKX19LGNvbW1pdExpZmVDeWNsZXM6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjp2YXIgYz1iLnN0YXRlTm9kZTtpZihiLmVmZmVjdFRhZyY0KWlmKG51bGw9PT1hKWMucHJvcHM9Yi5tZW1vaXplZFByb3BzLGMuc3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBkPWEubWVtb2l6ZWRQcm9wczthPWEubWVtb2l6ZWRTdGF0ZTtjLnByb3BzPWIubWVtb2l6ZWRQcm9wcztjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTtjLmNvbXBvbmVudERpZFVwZGF0ZShkLGEpfWI9Yi51cGRhdGVRdWV1ZTtudWxsIT09YiYmS2UoYixjKTticmVhaztjYXNlIDM6Yz1iLnVwZGF0ZVF1ZXVlO251bGwhPT1jJiZLZShjLG51bGwhPT1iLmNoaWxkP2IuY2hpbGQuc3RhdGVOb2RlOm51bGwpO2JyZWFrO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO251bGw9PT1hJiZiLmVmZmVjdFRhZyY0JiZxKGMsXG5iLnR5cGUsYi5tZW1vaXplZFByb3BzLGIpO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0QXR0YWNoUmVmOmZ1bmN0aW9uKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTpiKGgoYykpO2JyZWFrO2RlZmF1bHQ6YihjKX19fSxjb21taXREZXRhY2hSZWY6ZnVuY3Rpb24oYSl7YT1hLnJlZjtudWxsIT09YSYmYShudWxsKX19fXZhciBnZj17fTtcbmZ1bmN0aW9uIGhmKGEpe2Z1bmN0aW9uIGIoYSl7YT09PWdmP0UoXCIxNzRcIik6dm9pZCAwO3JldHVybiBhfXZhciBjPWEuZ2V0Q2hpbGRIb3N0Q29udGV4dCxkPWEuZ2V0Um9vdEhvc3RDb250ZXh0LGU9e2N1cnJlbnQ6Z2Z9LGY9e2N1cnJlbnQ6Z2Z9LGc9e2N1cnJlbnQ6Z2Z9O3JldHVybntnZXRIb3N0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiBiKGUuY3VycmVudCl9LGdldFJvb3RIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIGIoZy5jdXJyZW50KX0scG9wSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhKXtWKGUsYSk7VihmLGEpO1YoZyxhKX0scG9wSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7Zi5jdXJyZW50PT09YSYmKFYoZSxhKSxWKGYsYSkpfSxwdXNoSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhLGIpe1coZyxiLGEpO2I9ZChiKTtXKGYsYSxhKTtXKGUsYixhKX0scHVzaEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBkPWIoZy5jdXJyZW50KSxoPWIoZS5jdXJyZW50KTtcbmQ9YyhoLGEudHlwZSxkKTtoIT09ZCYmKFcoZixhLGEpLFcoZSxkLGEpKX0scmVzZXRIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7ZS5jdXJyZW50PWdmO2cuY3VycmVudD1nZn19fVxuZnVuY3Rpb24gamYoYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPW5ldyBZKDUsbnVsbCwwKTtjLnR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjW1wicmV0dXJuXCJdPWE7Yy5lZmZlY3RUYWc9ODtudWxsIT09YS5sYXN0RWZmZWN0PyhhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1jLGEubGFzdEVmZmVjdD1jKTphLmZpcnN0RWZmZWN0PWEubGFzdEVmZmVjdD1jfWZ1bmN0aW9uIGMoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gYj1mKGIsYS50eXBlLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSA2OnJldHVybiBiPWcoYixhLnBlbmRpbmdQcm9wcyksbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGQoYSl7Zm9yKGE9YVtcInJldHVyblwiXTtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWc7KWE9YVtcInJldHVyblwiXTt5PWF9dmFyIGU9YS5zaG91bGRTZXRUZXh0Q29udGVudDtcbmE9YS5oeWRyYXRpb247aWYoIWEpcmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe30sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oKXtFKFwiMTc1XCIpfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzZcIil9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fTt2YXIgZj1hLmNhbkh5ZHJhdGVJbnN0YW5jZSxnPWEuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxoPWEuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLGs9YS5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxxPWEuaHlkcmF0ZUluc3RhbmNlLHY9YS5oeWRyYXRlVGV4dEluc3RhbmNlLHk9bnVsbCx1PW51bGwsej0hMTtyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXt1PVxuayhhLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTt5PWE7cmV0dXJuIHo9ITB9LHJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt1PXk9bnVsbDt6PSExfSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbihhKXtpZih6KXt2YXIgZD11O2lmKGQpe2lmKCFjKGEsZCkpe2Q9aChkKTtpZighZHx8IWMoYSxkKSl7YS5lZmZlY3RUYWd8PTI7ej0hMTt5PWE7cmV0dXJufWIoeSx1KX15PWE7dT1rKGQpfWVsc2UgYS5lZmZlY3RUYWd8PTIsej0hMSx5PWF9fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXtiPXEoYS5zdGF0ZU5vZGUsYS50eXBlLGEubWVtb2l6ZWRQcm9wcyxiLGMsYSk7YS51cGRhdGVRdWV1ZT1iO3JldHVybiBudWxsIT09Yj8hMDohMX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYS5zdGF0ZU5vZGUsYS5tZW1vaXplZFByb3BzLGEpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXtpZihhIT09XG55KXJldHVybiExO2lmKCF6KXJldHVybiBkKGEpLHo9ITAsITE7dmFyIGM9YS50eXBlO2lmKDUhPT1hLnRhZ3x8XCJoZWFkXCIhPT1jJiZcImJvZHlcIiE9PWMmJiFlKGMsYS5tZW1vaXplZFByb3BzKSlmb3IoYz11O2M7KWIoYSxjKSxjPWgoYyk7ZChhKTt1PXk/aChhLnN0YXRlTm9kZSk6bnVsbDtyZXR1cm4hMH19fVxuZnVuY3Rpb24ga2YoYSl7ZnVuY3Rpb24gYihhKXtRYj1qYT0hMDt2YXIgYj1hLnN0YXRlTm9kZTtiLmN1cnJlbnQ9PT1hP0UoXCIxNzdcIik6dm9pZCAwO2IuaXNSZWFkeUZvckNvbW1pdD0hMTtpZC5jdXJyZW50PW51bGw7aWYoMTxhLmVmZmVjdFRhZylpZihudWxsIT09YS5sYXN0RWZmZWN0KXthLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hO3ZhciBjPWEuZmlyc3RFZmZlY3R9ZWxzZSBjPWE7ZWxzZSBjPWEuZmlyc3RFZmZlY3Q7eWcoKTtmb3IodD1jO251bGwhPT10Oyl7dmFyIGQ9ITEsZT12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXQ7KXt2YXIgZj10LmVmZmVjdFRhZztmJjE2JiZ6Zyh0KTtpZihmJjEyOCl7dmFyIGc9dC5hbHRlcm5hdGU7bnVsbCE9PWcmJkFnKGcpfXN3aXRjaChmJi0yNDIpe2Nhc2UgMjpOZSh0KTt0LmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2Ok5lKHQpO3QuZWZmZWN0VGFnJj0tMztPZSh0LmFsdGVybmF0ZSx0KTticmVhaztjYXNlIDQ6T2UodC5hbHRlcm5hdGUsXG50KTticmVhaztjYXNlIDg6U2M9ITAsQmcodCksU2M9ITF9dD10Lm5leHRFZmZlY3R9fWNhdGNoKFRjKXtkPSEwLGU9VGN9ZCYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxlKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9Q2coKTtiLmN1cnJlbnQ9YTtmb3IodD1jO251bGwhPT10Oyl7Yz0hMTtkPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBrPXQuZWZmZWN0VGFnO2smMzYmJkRnKHQuYWx0ZXJuYXRlLHQpO2smMTI4JiZFZyh0KTtpZihrJjY0KXN3aXRjaChlPXQsZj12b2lkIDAsbnVsbCE9PVImJihmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSksbnVsbD09ZiYmbnVsbCE9PWUuYWx0ZXJuYXRlJiYoZT1lLmFsdGVybmF0ZSxmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSkpKSxudWxsPT1mP0UoXCIxODRcIik6dm9pZCAwLGUudGFnKXtjYXNlIDI6ZS5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2goZi5lcnJvcix7Y29tcG9uZW50U3RhY2s6Zi5jb21wb25lbnRTdGFja30pO1xuYnJlYWs7Y2FzZSAzOm51bGw9PT1jYSYmKGNhPWYuZXJyb3IpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX12YXIgUWM9dC5uZXh0RWZmZWN0O3QubmV4dEVmZmVjdD1udWxsO3Q9UWN9fWNhdGNoKFRjKXtjPSEwLGQ9VGN9YyYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxkKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9amE9UWI9ITE7XCJmdW5jdGlvblwiPT09dHlwZW9mIERlJiZEZShhLnN0YXRlTm9kZSk7aGEmJihoYS5mb3JFYWNoKEcpLGhhPW51bGwpO251bGwhPT1jYSYmKGE9Y2EsY2E9bnVsbCxPYihhKSk7Yj1iLmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7MD09PWImJihxYT1SPW51bGwpO3JldHVybiBifWZ1bmN0aW9uIGMoYSl7Zm9yKDs7KXt2YXIgYj1GZyhhLmFsdGVybmF0ZSxhLEgpLGM9YVtcInJldHVyblwiXSxkPWEuc2libGluZzt2YXIgZT1hO2lmKDIxNDc0ODM2NDc9PT1IfHwyMTQ3NDgzNjQ3IT09ZS5leHBpcmF0aW9uVGltZSl7aWYoMiE9PWUudGFnJiYzIT09XG5lLnRhZyl2YXIgZj0wO2Vsc2UgZj1lLnVwZGF0ZVF1ZXVlLGY9bnVsbD09PWY/MDpmLmV4cGlyYXRpb25UaW1lO2Zvcih2YXIgZz1lLmNoaWxkO251bGwhPT1nOykwIT09Zy5leHBpcmF0aW9uVGltZSYmKDA9PT1mfHxmPmcuZXhwaXJhdGlvblRpbWUpJiYoZj1nLmV4cGlyYXRpb25UaW1lKSxnPWcuc2libGluZztlLmV4cGlyYXRpb25UaW1lPWZ9aWYobnVsbCE9PWIpcmV0dXJuIGI7bnVsbCE9PWMmJihudWxsPT09Yy5maXJzdEVmZmVjdCYmKGMuZmlyc3RFZmZlY3Q9YS5maXJzdEVmZmVjdCksbnVsbCE9PWEubGFzdEVmZmVjdCYmKG51bGwhPT1jLmxhc3RFZmZlY3QmJihjLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxjLmxhc3RFZmZlY3Q9YS5sYXN0RWZmZWN0KSwxPGEuZWZmZWN0VGFnJiYobnVsbCE9PWMubGFzdEVmZmVjdD9jLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hOmMuZmlyc3RFZmZlY3Q9YSxjLmxhc3RFZmZlY3Q9YSkpO2lmKG51bGwhPT1kKXJldHVybiBkO1xuaWYobnVsbCE9PWMpYT1jO2Vsc2V7YS5zdGF0ZU5vZGUuaXNSZWFkeUZvckNvbW1pdD0hMDticmVha319cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhKXt2YXIgYj1yZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZShhKXt2YXIgYj1HZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZihhKXtpZihudWxsIT09Uil7aWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWsoRik/ZShGKTpkKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1rKEYpP2UoRik6ZChGKX1lbHNlIGlmKCEoMD09PUh8fEg+YSkpaWYoSDw9VWMpZm9yKDtudWxsIT09RjspRj1kKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1kKEYpfWZ1bmN0aW9uIGcoYSxiKXtqYT9FKFwiMjQzXCIpOnZvaWQgMDtqYT0hMDthLmlzUmVhZHlGb3JDb21taXQ9XG4hMTtpZihhIT09cmF8fGIhPT1IfHxudWxsPT09Ril7Zm9yKDstMTxoZTspZ2VbaGVdPW51bGwsaGUtLTtqZT1EO2llLmN1cnJlbnQ9RDtYLmN1cnJlbnQ9ITE7eCgpO3JhPWE7SD1iO0Y9c2UocmEuY3VycmVudCxudWxsLGIpfXZhciBjPSExLGQ9bnVsbDt0cnl7ZihiKX1jYXRjaChSYyl7Yz0hMCxkPVJjfWZvcig7Yzspe2lmKGViKXtjYT1kO2JyZWFrfXZhciBnPUY7aWYobnVsbD09PWcpZWI9ITA7ZWxzZXt2YXIgaz1oKGcsZCk7bnVsbD09PWs/RShcIjE4M1wiKTp2b2lkIDA7aWYoIWViKXt0cnl7Yz1rO2Q9Yjtmb3Ioaz1jO251bGwhPT1nOyl7c3dpdGNoKGcudGFnKXtjYXNlIDI6bmUoZyk7YnJlYWs7Y2FzZSA1OnFnKGcpO2JyZWFrO2Nhc2UgMzpwKGcpO2JyZWFrO2Nhc2UgNDpwKGcpfWlmKGc9PT1rfHxnLmFsdGVybmF0ZT09PWspYnJlYWs7Zz1nW1wicmV0dXJuXCJdfUY9ZShjKTtmKGQpfWNhdGNoKFJjKXtjPSEwO2Q9UmM7Y29udGludWV9YnJlYWt9fX1iPWNhO2ViPWphPSExO2NhPVxubnVsbDtudWxsIT09YiYmT2IoYik7cmV0dXJuIGEuaXNSZWFkeUZvckNvbW1pdD9hLmN1cnJlbnQuYWx0ZXJuYXRlOm51bGx9ZnVuY3Rpb24gaChhLGIpe3ZhciBjPWlkLmN1cnJlbnQ9bnVsbCxkPSExLGU9ITEsZj1udWxsO2lmKDM9PT1hLnRhZyljPWEscShhKSYmKGViPSEwKTtlbHNlIGZvcih2YXIgZz1hW1wicmV0dXJuXCJdO251bGwhPT1nJiZudWxsPT09YzspezI9PT1nLnRhZz9cImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2gmJihkPSEwLGY9amQoZyksYz1nLGU9ITApOjM9PT1nLnRhZyYmKGM9Zyk7aWYocShnKSl7aWYoU2N8fG51bGwhPT1oYSYmKGhhLmhhcyhnKXx8bnVsbCE9PWcuYWx0ZXJuYXRlJiZoYS5oYXMoZy5hbHRlcm5hdGUpKSlyZXR1cm4gbnVsbDtjPW51bGw7ZT0hMX1nPWdbXCJyZXR1cm5cIl19aWYobnVsbCE9PWMpe251bGw9PT1xYSYmKHFhPW5ldyBTZXQpO3FhLmFkZChjKTt2YXIgaD1cIlwiO2c9YTtkb3thOnN3aXRjaChnLnRhZyl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSA1OnZhciBrPVxuZy5fZGVidWdPd25lcixRYz1nLl9kZWJ1Z1NvdXJjZTt2YXIgbT1qZChnKTt2YXIgbj1udWxsO2smJihuPWpkKGspKTtrPVFjO209XCJcXG4gICAgaW4gXCIrKG18fFwiVW5rbm93blwiKSsoaz9cIiAoYXQgXCIray5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLFwiXCIpK1wiOlwiK2subGluZU51bWJlcitcIilcIjpuP1wiIChjcmVhdGVkIGJ5IFwiK24rXCIpXCI6XCJcIik7YnJlYWsgYTtkZWZhdWx0Om09XCJcIn1oKz1tO2c9Z1tcInJldHVyblwiXX13aGlsZShnKTtnPWg7YT1qZChhKTtudWxsPT09UiYmKFI9bmV3IE1hcCk7Yj17Y29tcG9uZW50TmFtZTphLGNvbXBvbmVudFN0YWNrOmcsZXJyb3I6YixlcnJvckJvdW5kYXJ5OmQ/Yy5zdGF0ZU5vZGU6bnVsbCxlcnJvckJvdW5kYXJ5Rm91bmQ6ZCxlcnJvckJvdW5kYXJ5TmFtZTpmLHdpbGxSZXRyeTplfTtSLnNldChjLGIpO3RyeXt2YXIgcD1iLmVycm9yO3AmJnAuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihwKX1jYXRjaChWYyl7VmMmJlxuVmMuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihWYyl9UWI/KG51bGw9PT1oYSYmKGhhPW5ldyBTZXQpLGhhLmFkZChjKSk6RyhjKTtyZXR1cm4gY31udWxsPT09Y2EmJihjYT1iKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBrKGEpe3JldHVybiBudWxsIT09UiYmKFIuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJlIuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gcShhKXtyZXR1cm4gbnVsbCE9PXFhJiYocWEuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJnFhLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHYoKXtyZXR1cm4gMjAqKCgoSSgpKzEwMCkvMjB8MCkrMSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gMCE9PWthP2thOmphP1FiPzE6SDohSGd8fGEuaW50ZXJuYWxDb250ZXh0VGFnJjE/digpOjF9ZnVuY3Rpb24gdShhLGIpe3JldHVybiB6KGEsYiwhMSl9ZnVuY3Rpb24geihhLGIpe2Zvcig7bnVsbCE9PWE7KXtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8XG5hLmV4cGlyYXRpb25UaW1lPmIpYS5leHBpcmF0aW9uVGltZT1iO251bGwhPT1hLmFsdGVybmF0ZSYmKDA9PT1hLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZXx8YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU+YikmJihhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09YVtcInJldHVyblwiXSlpZigzPT09YS50YWcpe3ZhciBjPWEuc3RhdGVOb2RlOyFqYSYmYz09PXJhJiZiPEgmJihGPXJhPW51bGwsSD0wKTt2YXIgZD1jLGU9YjtSYj5JZyYmRShcIjE4NVwiKTtpZihudWxsPT09ZC5uZXh0U2NoZWR1bGVkUm9vdClkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWUsbnVsbD09PU8/KHNhPU89ZCxkLm5leHRTY2hlZHVsZWRSb290PWQpOihPPU8ubmV4dFNjaGVkdWxlZFJvb3Q9ZCxPLm5leHRTY2hlZHVsZWRSb290PXNhKTtlbHNle3ZhciBmPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWZ8fGU8ZilkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWV9RmF8fChsYT9cblNiJiYobWE9ZCxuYT0xLG0obWEsbmEpKToxPT09ZT93KDEsbnVsbCk6TChlKSk7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApfWVsc2UgYnJlYWs7YT1hW1wicmV0dXJuXCJdfX1mdW5jdGlvbiBHKGEpe3ooYSwxLCEwKX1mdW5jdGlvbiBJKCl7cmV0dXJuIFVjPSgoV2MoKS1QZSkvMTB8MCkrMn1mdW5jdGlvbiBMKGEpe2lmKDAhPT1UYil7aWYoYT5UYilyZXR1cm47SmcoWGMpfXZhciBiPVdjKCktUGU7VGI9YTtYYz1LZyhKLHt0aW1lb3V0OjEwKihhLTIpLWJ9KX1mdW5jdGlvbiBOKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PU8pZm9yKHZhciBjPU8sZD1zYTtudWxsIT09ZDspe3ZhciBlPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09Tz9FKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7c2E9Tz1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09c2Epc2E9ZT1kLm5leHRTY2hlZHVsZWRSb290LFxuTy5uZXh0U2NoZWR1bGVkUm9vdD1lLGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtlbHNlIGlmKGQ9PT1PKXtPPWM7Ty5uZXh0U2NoZWR1bGVkUm9vdD1zYTtkLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBjLm5leHRTY2hlZHVsZWRSb290PWQubmV4dFNjaGVkdWxlZFJvb3QsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Q9Yy5uZXh0U2NoZWR1bGVkUm9vdH1lbHNle2lmKDA9PT1hfHxlPGEpYT1lLGI9ZDtpZihkPT09TylicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1jPW1hO251bGwhPT1jJiZjPT09Yj9SYisrOlJiPTA7bWE9YjtuYT1hfWZ1bmN0aW9uIEooYSl7dygwLGEpfWZ1bmN0aW9uIHcoYSxiKXtmYj1iO2ZvcihOKCk7bnVsbCE9PW1hJiYwIT09bmEmJigwPT09YXx8bmE8PWEpJiYhWWM7KW0obWEsbmEpLE4oKTtudWxsIT09ZmImJihUYj0wLFhjPS0xKTswIT09bmEmJkwobmEpO2ZiPW51bGw7WWM9ITE7UmI9MDtpZihVYil0aHJvdyBhPVpjLFpjPVxubnVsbCxVYj0hMSxhO31mdW5jdGlvbiBtKGEsYyl7RmE/RShcIjI0NVwiKTp2b2lkIDA7RmE9ITA7aWYoYzw9SSgpKXt2YXIgZD1hLmZpbmlzaGVkV29yaztudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSl9ZWxzZSBkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihBKCk/YS5maW5pc2hlZFdvcms9ZDphLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKTtGYT0hMX1mdW5jdGlvbiBBKCl7cmV0dXJuIG51bGw9PT1mYnx8ZmIudGltZVJlbWFpbmluZygpPkxnPyExOlljPSEwfWZ1bmN0aW9uIE9iKGEpe251bGw9PT1tYT9FKFwiMjQ2XCIpOlxudm9pZCAwO21hLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPTA7VWJ8fChVYj0hMCxaYz1hKX12YXIgcj1oZihhKSxuPWpmKGEpLHA9ci5wb3BIb3N0Q29udGFpbmVyLHFnPXIucG9wSG9zdENvbnRleHQseD1yLnJlc2V0SG9zdENvbnRhaW5lcixNZT1kZihhLHIsbix1LHkpLHJnPU1lLmJlZ2luV29yayxHZz1NZS5iZWdpbkZhaWxlZFdvcmssRmc9ZWYoYSxyLG4pLmNvbXBsZXRlV29yaztyPWZmKGEsaCk7dmFyIHpnPXIuY29tbWl0UmVzZXRUZXh0Q29udGVudCxOZT1yLmNvbW1pdFBsYWNlbWVudCxCZz1yLmNvbW1pdERlbGV0aW9uLE9lPXIuY29tbWl0V29yayxEZz1yLmNvbW1pdExpZmVDeWNsZXMsRWc9ci5jb21taXRBdHRhY2hSZWYsQWc9ci5jb21taXREZXRhY2hSZWYsV2M9YS5ub3csS2c9YS5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssSmc9YS5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLEhnPWEudXNlU3luY1NjaGVkdWxpbmcseWc9YS5wcmVwYXJlRm9yQ29tbWl0LENnPWEucmVzZXRBZnRlckNvbW1pdCxcblBlPVdjKCksVWM9MixrYT0wLGphPSExLEY9bnVsbCxyYT1udWxsLEg9MCx0PW51bGwsUj1udWxsLHFhPW51bGwsaGE9bnVsbCxjYT1udWxsLGViPSExLFFiPSExLFNjPSExLHNhPW51bGwsTz1udWxsLFRiPTAsWGM9LTEsRmE9ITEsbWE9bnVsbCxuYT0wLFljPSExLFViPSExLFpjPW51bGwsZmI9bnVsbCxsYT0hMSxTYj0hMSxJZz0xRTMsUmI9MCxMZz0xO3JldHVybntjb21wdXRlQXN5bmNFeHBpcmF0aW9uOnYsY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjp5LHNjaGVkdWxlV29yazp1LGJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEsYil7dmFyIGM9bGE7bGE9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KGxhPWMpfHxGYXx8dygxLG51bGwpfX0sdW5iYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhKXtpZihsYSYmIVNiKXtTYj0hMDt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e1NiPSExfX1yZXR1cm4gYSgpfSxmbHVzaFN5bmM6ZnVuY3Rpb24oYSl7dmFyIGI9bGE7bGE9ITA7dHJ5e2E6e3ZhciBjPVxua2E7a2E9MTt0cnl7dmFyIGQ9YSgpO2JyZWFrIGF9ZmluYWxseXtrYT1jfWQ9dm9pZCAwfXJldHVybiBkfWZpbmFsbHl7bGE9YixGYT9FKFwiMTg3XCIpOnZvaWQgMCx3KDEsbnVsbCl9fSxkZWZlcnJlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9a2E7a2E9digpO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7a2E9Yn19fX1cbmZ1bmN0aW9uIGxmKGEpe2Z1bmN0aW9uIGIoYSl7YT1vZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX12YXIgYz1hLmdldFB1YmxpY0luc3RhbmNlO2E9a2YoYSk7dmFyIGQ9YS5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLGU9YS5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLGY9YS5zY2hlZHVsZVdvcms7cmV0dXJue2NyZWF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBZKDMsbnVsbCwwKTthPXtjdXJyZW50OmMsY29udGFpbmVySW5mbzphLHBlbmRpbmdDaGlsZHJlbjpudWxsLHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOjAsaXNSZWFkeUZvckNvbW1pdDohMSxmaW5pc2hlZFdvcms6bnVsbCxjb250ZXh0Om51bGwscGVuZGluZ0NvbnRleHQ6bnVsbCxoeWRyYXRlOmIsbmV4dFNjaGVkdWxlZFJvb3Q6bnVsbH07cmV0dXJuIGMuc3RhdGVOb2RlPWF9LHVwZGF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxxKXt2YXIgZz1iLmN1cnJlbnQ7aWYoYyl7Yz1cbmMuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgaDtiOnsyPT09a2QoYykmJjI9PT1jLnRhZz92b2lkIDA6RShcIjE3MFwiKTtmb3IoaD1jOzMhPT1oLnRhZzspe2lmKGxlKGgpKXtoPWguc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGJ9KGg9aFtcInJldHVyblwiXSk/dm9pZCAwOkUoXCIxNzFcIil9aD1oLnN0YXRlTm9kZS5jb250ZXh0fWM9bGUoYyk/cGUoYyxoKTpofWVsc2UgYz1EO251bGw9PT1iLmNvbnRleHQ/Yi5jb250ZXh0PWM6Yi5wZW5kaW5nQ29udGV4dD1jO2I9cTtiPXZvaWQgMD09PWI/bnVsbDpiO3E9bnVsbCE9YSYmbnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50P2QoKTplKGcpO0hlKGcse2V4cGlyYXRpb25UaW1lOnEscGFydGlhbFN0YXRlOntlbGVtZW50OmF9LGNhbGxiYWNrOmIsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLFxubmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7ZihnLHEpfSxiYXRjaGVkVXBkYXRlczphLmJhdGNoZWRVcGRhdGVzLHVuYmF0Y2hlZFVwZGF0ZXM6YS51bmJhdGNoZWRVcGRhdGVzLGRlZmVycmVkVXBkYXRlczphLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6YS5mbHVzaFN5bmMsZ2V0UHVibGljUm9vdEluc3RhbmNlOmZ1bmN0aW9uKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBjKGEuY2hpbGQuc3RhdGVOb2RlKTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19LGZpbmRIb3N0SW5zdGFuY2U6YixmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczpmdW5jdGlvbihhKXthPXBkKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfSxpbmplY3RJbnRvRGV2VG9vbHM6ZnVuY3Rpb24oYSl7dmFyIGM9YS5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtyZXR1cm4gQ2UoQih7fSxcbmEse2ZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGEpe3JldHVybiBiKGEpfSxmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYz9jKGEpOm51bGx9fSkpfX19dmFyIG1mPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6bGZ9KSxuZj1tZiYmbGZ8fG1mLG9mPW5mW1wiZGVmYXVsdFwiXT9uZltcImRlZmF1bHRcIl06bmY7ZnVuY3Rpb24gcGYoYSxiLGMpe3ZhciBkPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpudWxsO3JldHVybnskJHR5cGVvZjpVZSxrZXk6bnVsbD09ZD9udWxsOlwiXCIrZCxjaGlsZHJlbjphLGNvbnRhaW5lckluZm86YixpbXBsZW1lbnRhdGlvbjpjfX12YXIgcWY9XCJvYmplY3RcIj09PXR5cGVvZiBwZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHBlcmZvcm1hbmNlLm5vdyxyZj12b2lkIDA7cmY9cWY/ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9O1xudmFyIHNmPXZvaWQgMCx0Zj12b2lkIDA7XG5pZihsLmNhblVzZURPTSlpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFja3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayl7dmFyIHVmPW51bGwsdmY9ITEsd2Y9LTEseGY9ITEseWY9MCx6Zj0zMyxBZj0zMyxCZjtCZj1xZj97ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtcGVyZm9ybWFuY2Uubm93KCk7cmV0dXJuIDA8YT9hOjB9fTp7ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtRGF0ZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19O3ZhciBDZj1cIl9fcmVhY3RJZGxlQ2FsbGJhY2skXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oYSl7aWYoYS5zb3VyY2U9PT13aW5kb3cmJmEuZGF0YT09PUNmKXt2Zj0hMTthPXJmKCk7aWYoMD49eWYtYSlpZigtMSE9PXdmJiZ3Zjw9XG5hKUJmLmRpZFRpbWVvdXQ9ITA7ZWxzZXt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybn1lbHNlIEJmLmRpZFRpbWVvdXQ9ITE7d2Y9LTE7YT11Zjt1Zj1udWxsO251bGwhPT1hJiZhKEJmKX19LCExKTt2YXIgRGY9ZnVuY3Rpb24oYSl7eGY9ITE7dmFyIGI9YS15ZitBZjtiPEFmJiZ6ZjxBZj8oOD5iJiYoYj04KSxBZj1iPHpmP3pmOmIpOnpmPWI7eWY9YStBZjt2Znx8KHZmPSEwLHdpbmRvdy5wb3N0TWVzc2FnZShDZixcIipcIikpfTtzZj1mdW5jdGlvbihhLGIpe3VmPWE7bnVsbCE9YiYmXCJudW1iZXJcIj09PXR5cGVvZiBiLnRpbWVvdXQmJih3Zj1yZigpK2IudGltZW91dCk7eGZ8fCh4Zj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoRGYpKTtyZXR1cm4gMH07dGY9ZnVuY3Rpb24oKXt1Zj1udWxsO3ZmPSExO3dmPS0xfX1lbHNlIHNmPXdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrLHRmPXdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2s7ZWxzZSBzZj1mdW5jdGlvbihhKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe2Eoe3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gSW5maW5pdHl9fSl9KX0sXG50Zj1mdW5jdGlvbihhKXtjbGVhclRpbWVvdXQoYSl9O3ZhciBFZj0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8sRmY9e30sR2Y9e307XG5mdW5jdGlvbiBIZihhKXtpZihHZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMDtpZihGZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMTtpZihFZi50ZXN0KGEpKXJldHVybiBHZlthXT0hMDtGZlthXT0hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIElmKGEsYixjKXt2YXIgZD13YShiKTtpZihkJiZ2YShiLGMpKXt2YXIgZT1kLm11dGF0aW9uTWV0aG9kO2U/ZShhLGMpOm51bGw9PWN8fGQuaGFzQm9vbGVhblZhbHVlJiYhY3x8ZC5oYXNOdW1lcmljVmFsdWUmJmlzTmFOKGMpfHxkLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlJiYxPmN8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITE9PT1jP0pmKGEsYik6ZC5tdXN0VXNlUHJvcGVydHk/YVtkLnByb3BlcnR5TmFtZV09YzooYj1kLmF0dHJpYnV0ZU5hbWUsKGU9ZC5hdHRyaWJ1dGVOYW1lc3BhY2UpP2Euc2V0QXR0cmlidXRlTlMoZSxiLFwiXCIrYyk6ZC5oYXNCb29sZWFuVmFsdWV8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITA9PT1jP2Euc2V0QXR0cmlidXRlKGIsXCJcIik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1lbHNlIEtmKGEsYix2YShiLGMpP2M6bnVsbCl9XG5mdW5jdGlvbiBLZihhLGIsYyl7SGYoYikmJihudWxsPT1jP2EucmVtb3ZlQXR0cmlidXRlKGIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZnVuY3Rpb24gSmYoYSxiKXt2YXIgYz13YShiKTtjPyhiPWMubXV0YXRpb25NZXRob2QpP2IoYSx2b2lkIDApOmMubXVzdFVzZVByb3BlcnR5P2FbYy5wcm9wZXJ0eU5hbWVdPWMuaGFzQm9vbGVhblZhbHVlPyExOlwiXCI6YS5yZW1vdmVBdHRyaWJ1dGUoYy5hdHRyaWJ1dGVOYW1lKTphLnJlbW92ZUF0dHJpYnV0ZShiKX1cbmZ1bmN0aW9uIExmKGEsYil7dmFyIGM9Yi52YWx1ZSxkPWIuY2hlY2tlZDtyZXR1cm4gQih7dHlwZTp2b2lkIDAsc3RlcDp2b2lkIDAsbWluOnZvaWQgMCxtYXg6dm9pZCAwfSxiLHtkZWZhdWx0Q2hlY2tlZDp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCx2YWx1ZTpudWxsIT1jP2M6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxjaGVja2VkOm51bGwhPWQ/ZDphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBNZihhLGIpe3ZhciBjPWIuZGVmYXVsdFZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkLGluaXRpYWxWYWx1ZTpudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1cbmZ1bmN0aW9uIE5mKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmSWYoYSxcImNoZWNrZWRcIixiKX1mdW5jdGlvbiBPZihhLGIpe05mKGEsYik7dmFyIGM9Yi52YWx1ZTtpZihudWxsIT1jKWlmKDA9PT1jJiZcIlwiPT09YS52YWx1ZSlhLnZhbHVlPVwiMFwiO2Vsc2UgaWYoXCJudW1iZXJcIj09PWIudHlwZSl7aWYoYj1wYXJzZUZsb2F0KGEudmFsdWUpfHwwLGMhPWJ8fGM9PWImJmEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgbnVsbD09Yi52YWx1ZSYmbnVsbCE9Yi5kZWZhdWx0VmFsdWUmJmEuZGVmYXVsdFZhbHVlIT09XCJcIitiLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrYi5kZWZhdWx0VmFsdWUpLG51bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIFBmKGEsYil7c3dpdGNoKGIudHlwZSl7Y2FzZSBcInN1Ym1pdFwiOmNhc2UgXCJyZXNldFwiOmJyZWFrO2Nhc2UgXCJjb2xvclwiOmNhc2UgXCJkYXRlXCI6Y2FzZSBcImRhdGV0aW1lXCI6Y2FzZSBcImRhdGV0aW1lLWxvY2FsXCI6Y2FzZSBcIm1vbnRoXCI6Y2FzZSBcInRpbWVcIjpjYXNlIFwid2Vla1wiOmEudmFsdWU9XCJcIjthLnZhbHVlPWEuZGVmYXVsdFZhbHVlO2JyZWFrO2RlZmF1bHQ6YS52YWx1ZT1hLnZhbHVlfWI9YS5uYW1lO1wiXCIhPT1iJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDtcIlwiIT09YiYmKGEubmFtZT1iKX1mdW5jdGlvbiBRZihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsPT1hfHxcInN0cmluZ1wiIT09dHlwZW9mIGEmJlwibnVtYmVyXCIhPT10eXBlb2YgYXx8KGIrPWEpfSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBSZihhLGIpe2E9Qih7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPVFmKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1mdW5jdGlvbiBTZihhLGIsYyxkKXthPWEub3B0aW9ucztpZihiKXtiPXt9O2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKWJbXCIkXCIrY1tlXV09ITA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllPWIuaGFzT3duUHJvcGVydHkoXCIkXCIrYVtjXS52YWx1ZSksYVtjXS5zZWxlY3RlZCE9PWUmJihhW2NdLnNlbGVjdGVkPWUpLGUmJmQmJihhW2NdLmRlZmF1bHRTZWxlY3RlZD0hMCl9ZWxzZXtjPVwiXCIrYztiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gVGYoYSxiKXt2YXIgYz1iLnZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOm51bGwhPWM/YzpiLmRlZmF1bHRWYWx1ZSx3YXNNdWx0aXBsZTohIWIubXVsdGlwbGV9fWZ1bmN0aW9uIFVmKGEsYil7bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiOTFcIik6dm9pZCAwO3JldHVybiBCKHt9LGIse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOlwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIFZmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsPT1jJiYoYz1iLmRlZmF1bHRWYWx1ZSxiPWIuY2hpbGRyZW4sbnVsbCE9YiYmKG51bGwhPWM/RShcIjkyXCIpOnZvaWQgMCxBcnJheS5pc0FycmF5KGIpJiYoMT49Yi5sZW5ndGg/dm9pZCAwOkUoXCI5M1wiKSxiPWJbMF0pLGM9XCJcIitiKSxudWxsPT1jJiYoYz1cIlwiKSk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6XCJcIitjfX1cbmZ1bmN0aW9uIFdmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9Yi5kZWZhdWx0VmFsdWUpfWZ1bmN0aW9uIFhmKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJihhLnZhbHVlPWIpfXZhciBZZj17aHRtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixtYXRobWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsc3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn07XG5mdW5jdGlvbiBaZihhKXtzd2l0Y2goYSl7Y2FzZSBcInN2Z1wiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjYXNlIFwibWF0aFwiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO2RlZmF1bHQ6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9fWZ1bmN0aW9uICRmKGEsYil7cmV0dXJuIG51bGw9PWF8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YT9aZihiKTpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT1hJiZcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6YX1cbnZhciBhZz12b2lkIDAsYmc9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKGEubmFtZXNwYWNlVVJJIT09WWYuc3ZnfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7YWc9YWd8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YWcuaW5uZXJIVE1MPVwiXFx4M2NzdmdcXHgzZVwiK2IrXCJcXHgzYy9zdmdcXHgzZVwiO2ZvcihiPWFnLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIGNnKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgZGc9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLGZsb29kT3BhY2l0eTohMCxcbnN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0sZWc9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKGRnKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2VnLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7ZGdbYl09ZGdbYV19KX0pO1xuZnVuY3Rpb24gZmcoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpO3ZhciBlPWM7dmFyIGY9YltjXTtlPW51bGw9PWZ8fFwiYm9vbGVhblwiPT09dHlwZW9mIGZ8fFwiXCI9PT1mP1wiXCI6ZHx8XCJudW1iZXJcIiE9PXR5cGVvZiBmfHwwPT09Znx8ZGcuaGFzT3duUHJvcGVydHkoZSkmJmRnW2VdPyhcIlwiK2YpLnRyaW0oKTpmK1wicHhcIjtcImZsb2F0XCI9PT1jJiYoYz1cImNzc0Zsb2F0XCIpO2Q/YS5zZXRQcm9wZXJ0eShjLGUpOmFbY109ZX19dmFyIGdnPUIoe21lbnVpdGVtOiEwfSx7YXJlYTohMCxiYXNlOiEwLGJyOiEwLGNvbDohMCxlbWJlZDohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSk7XG5mdW5jdGlvbiBoZyhhLGIsYyl7YiYmKGdnW2FdJiYobnVsbCE9Yi5jaGlsZHJlbnx8bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiMTM3XCIsYSxjKCkpOnZvaWQgMCksbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmKG51bGwhPWIuY2hpbGRyZW4/RShcIjYwXCIpOnZvaWQgMCxcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3ZvaWQgMDpFKFwiNjFcIikpLG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZT9FKFwiNjJcIixjKCkpOnZvaWQgMCl9XG5mdW5jdGlvbiBpZyhhLGIpe2lmKC0xPT09YS5pbmRleE9mKFwiLVwiKSlyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM7c3dpdGNoKGEpe2Nhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOmNhc2UgXCJjb2xvci1wcm9maWxlXCI6Y2FzZSBcImZvbnQtZmFjZVwiOmNhc2UgXCJmb250LWZhY2Utc3JjXCI6Y2FzZSBcImZvbnQtZmFjZS11cmlcIjpjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOmNhc2UgXCJmb250LWZhY2UtbmFtZVwiOmNhc2UgXCJtaXNzaW5nLWdseXBoXCI6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMH19dmFyIGpnPVlmLmh0bWwsa2c9Qy50aGF0UmV0dXJucyhcIlwiKTtcbmZ1bmN0aW9uIGxnKGEsYil7YT05PT09YS5ub2RlVHlwZXx8MTE9PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50O3ZhciBjPUhkKGEpO2I9U2FbYl07Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF07Yy5oYXNPd25Qcm9wZXJ0eShlKSYmY1tlXXx8KFwidG9wU2Nyb2xsXCI9PT1lP3dkKFwidG9wU2Nyb2xsXCIsXCJzY3JvbGxcIixhKTpcInRvcEZvY3VzXCI9PT1lfHxcInRvcEJsdXJcIj09PWU/KHdkKFwidG9wRm9jdXNcIixcImZvY3VzXCIsYSksd2QoXCJ0b3BCbHVyXCIsXCJibHVyXCIsYSksYy50b3BCbHVyPSEwLGMudG9wRm9jdXM9ITApOlwidG9wQ2FuY2VsXCI9PT1lPyh5YyhcImNhbmNlbFwiLCEwKSYmd2QoXCJ0b3BDYW5jZWxcIixcImNhbmNlbFwiLGEpLGMudG9wQ2FuY2VsPSEwKTpcInRvcENsb3NlXCI9PT1lPyh5YyhcImNsb3NlXCIsITApJiZ3ZChcInRvcENsb3NlXCIsXCJjbG9zZVwiLGEpLGMudG9wQ2xvc2U9ITApOkRkLmhhc093blByb3BlcnR5KGUpJiZVKGUsRGRbZV0sYSksY1tlXT0hMCl9fVxudmFyIG1nPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQ2FuUGxheTpcImNhbnBsYXlcIix0b3BDYW5QbGF5VGhyb3VnaDpcImNhbnBsYXl0aHJvdWdoXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsXG50b3BXYWl0aW5nOlwid2FpdGluZ1wifTtmdW5jdGlvbiBuZyhhLGIsYyxkKXtjPTk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50O2Q9PT1qZyYmKGQ9WmYoYSkpO2Q9PT1qZz9cInNjcmlwdFwiPT09YT8oYT1jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5pbm5lckhUTUw9XCJcXHgzY3NjcmlwdFxceDNlXFx4M2Mvc2NyaXB0XFx4M2VcIixhPWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKSk6YT1cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM/Yy5jcmVhdGVFbGVtZW50KGEse2lzOmIuaXN9KTpjLmNyZWF0ZUVsZW1lbnQoYSk6YT1jLmNyZWF0ZUVsZW1lbnROUyhkLGEpO3JldHVybiBhfWZ1bmN0aW9uIG9nKGEsYil7cmV0dXJuKDk9PT1iLm5vZGVUeXBlP2I6Yi5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShhKX1cbmZ1bmN0aW9uIHBnKGEsYixjLGQpe3ZhciBlPWlnKGIsYyk7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTt2YXIgZj1jO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7Zj1jO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk1mKGEsYyk7Zj1MZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7XG5sZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmY9UmYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtmPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKTtmPVVmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7ZGVmYXVsdDpmPWN9aGcoYixmLGtnKTt2YXIgZz1mLGg7Zm9yKGggaW4gZylpZihnLmhhc093blByb3BlcnR5KGgpKXt2YXIgaz1nW2hdO1wic3R5bGVcIj09PWg/ZmcoYSxrLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1oPyhrPWs/ay5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJmJnKGEsaykpOlwiY2hpbGRyZW5cIj09PWg/XCJzdHJpbmdcIj09PXR5cGVvZiBrPyhcInRleHRhcmVhXCIhPT1ifHxcIlwiIT09aykmJmNnKGEsayk6XCJudW1iZXJcIj09PXR5cGVvZiBrJiZjZyhhLFxuXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09aCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWgmJlwiYXV0b0ZvY3VzXCIhPT1oJiYoUmEuaGFzT3duUHJvcGVydHkoaCk/bnVsbCE9ayYmbGcoZCxoKTplP0tmKGEsaCxrKTpudWxsIT1rJiZJZihhLGgsaykpfXN3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWMudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixjLnZhbHVlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWMubXVsdGlwbGU7Yj1jLnZhbHVlO251bGwhPWI/U2YoYSwhIWMubXVsdGlwbGUsYiwhMSk6bnVsbCE9Yy5kZWZhdWx0VmFsdWUmJlNmKGEsISFjLm11bHRpcGxlLGMuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihhLm9uY2xpY2s9XG5DKX19XG5mdW5jdGlvbiBzZyhhLGIsYyxkLGUpe3ZhciBmPW51bGw7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOmM9TGYoYSxjKTtkPUxmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwib3B0aW9uXCI6Yz1SZihhLGMpO2Q9UmYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7ZD1CKHt9LGQse3ZhbHVlOnZvaWQgMH0pO2Y9W107YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Yz1VZihhLGMpO2Q9VWYoYSxkKTtmPVtdO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiIT09dHlwZW9mIGMub25DbGljayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQub25DbGljayYmKGEub25jbGljaz1DKX1oZyhiLGQsa2cpO3ZhciBnLGg7YT1udWxsO2ZvcihnIGluIGMpaWYoIWQuaGFzT3duUHJvcGVydHkoZykmJmMuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWNbZ10paWYoXCJzdHlsZVwiPT09Zylmb3IoaCBpbiBiPWNbZ10sYiliLmhhc093blByb3BlcnR5KGgpJiYoYXx8KGE9e30pLGFbaF09XG5cIlwiKTtlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09ZyYmXCJjaGlsZHJlblwiIT09ZyYmXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiZcImF1dG9Gb2N1c1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpP2Z8fChmPVtdKTooZj1mfHxbXSkucHVzaChnLG51bGwpKTtmb3IoZyBpbiBkKXt2YXIgaz1kW2ddO2I9bnVsbCE9Yz9jW2ddOnZvaWQgMDtpZihkLmhhc093blByb3BlcnR5KGcpJiZrIT09YiYmKG51bGwhPWt8fG51bGwhPWIpKWlmKFwic3R5bGVcIj09PWcpaWYoYil7Zm9yKGggaW4gYikhYi5oYXNPd25Qcm9wZXJ0eShoKXx8ayYmay5oYXNPd25Qcm9wZXJ0eShoKXx8KGF8fChhPXt9KSxhW2hdPVwiXCIpO2ZvcihoIGluIGspay5oYXNPd25Qcm9wZXJ0eShoKSYmYltoXSE9PWtbaF0mJihhfHwoYT17fSksYVtoXT1rW2hdKX1lbHNlIGF8fChmfHwoZj1bXSksZi5wdXNoKGcsYSkpLGE9aztlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09XG5nPyhrPWs/ay5fX2h0bWw6dm9pZCAwLGI9Yj9iLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYiE9PWsmJihmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKSk6XCJjaGlsZHJlblwiPT09Zz9iPT09a3x8XCJzdHJpbmdcIiE9PXR5cGVvZiBrJiZcIm51bWJlclwiIT09dHlwZW9mIGt8fChmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJihSYS5oYXNPd25Qcm9wZXJ0eShnKT8obnVsbCE9ayYmbGcoZSxnKSxmfHxiPT09a3x8KGY9W10pKTooZj1mfHxbXSkucHVzaChnLGspKX1hJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsYSk7cmV0dXJuIGZ9XG5mdW5jdGlvbiB0ZyhhLGIsYyxkLGUpe1wiaW5wdXRcIj09PWMmJlwicmFkaW9cIj09PWUudHlwZSYmbnVsbCE9ZS5uYW1lJiZOZihhLGUpO2lnKGMsZCk7ZD1pZyhjLGUpO2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7Zis9Mil7dmFyIGc9YltmXSxoPWJbZisxXTtcInN0eWxlXCI9PT1nP2ZnKGEsaCxrZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zz9iZyhhLGgpOlwiY2hpbGRyZW5cIj09PWc/Y2coYSxoKTpkP251bGwhPWg/S2YoYSxnLGgpOmEucmVtb3ZlQXR0cmlidXRlKGcpOm51bGwhPWg/SWYoYSxnLGgpOkpmKGEsZyl9c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOk9mKGEsZSk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZT12b2lkIDAsYj1hLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZS5tdWx0aXBsZSxjPWUudmFsdWUsbnVsbCE9Yz9TZihhLFxuISFlLm11bHRpcGxlLGMsITEpOmIhPT0hIWUubXVsdGlwbGUmJihudWxsIT1lLmRlZmF1bHRWYWx1ZT9TZihhLCEhZS5tdWx0aXBsZSxlLmRlZmF1bHRWYWx1ZSwhMCk6U2YoYSwhIWUubXVsdGlwbGUsZS5tdWx0aXBsZT9bXTpcIlwiLCExKSl9fVxuZnVuY3Rpb24gdWcoYSxiLGMsZCxlKXtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcih2YXIgZiBpbiBtZyltZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLG1nW2ZdLGEpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtcblUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlZmKGEsYyksVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKSxsZyhlLFwib25DaGFuZ2VcIil9aGcoYixjLGtnKTtkPW51bGw7Zm9yKHZhciBnIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShnKSYmKGY9Y1tnXSxcImNoaWxkcmVuXCI9PT1nP1wic3RyaW5nXCI9PT10eXBlb2YgZj9hLnRleHRDb250ZW50IT09ZiYmKGQ9W1wiY2hpbGRyZW5cIixmXSk6XCJudW1iZXJcIj09PXR5cGVvZiBmJiZhLnRleHRDb250ZW50IT09XCJcIitmJiYoZD1bXCJjaGlsZHJlblwiLFwiXCIrZl0pOlJhLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1mJiZsZyhlLGcpKTtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QmMoYSk7UGYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpCYyhhKTtYZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjYXNlIFwib3B0aW9uXCI6YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5vbkNsaWNrJiZcbihhLm9uY2xpY2s9Qyl9cmV0dXJuIGR9ZnVuY3Rpb24gdmcoYSxiKXtyZXR1cm4gYS5ub2RlVmFsdWUhPT1ifVxudmFyIHdnPU9iamVjdC5mcmVlemUoe2NyZWF0ZUVsZW1lbnQ6bmcsY3JlYXRlVGV4dE5vZGU6b2csc2V0SW5pdGlhbFByb3BlcnRpZXM6cGcsZGlmZlByb3BlcnRpZXM6c2csdXBkYXRlUHJvcGVydGllczp0ZyxkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOnVnLGRpZmZIeWRyYXRlZFRleHQ6dmcsd2FybkZvclVubWF0Y2hlZFRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0OmZ1bmN0aW9uKCl7fSxyZXN0b3JlQ29udHJvbGxlZFN0YXRlOmZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6T2YoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPVxuYy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZVxceDNkXCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlXFx4M2RcInJhZGlvXCJdJyk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTtpZihkIT09YSYmZC5mb3JtPT09YS5mb3JtKXt2YXIgZT1yYihkKTtlP3ZvaWQgMDpFKFwiOTBcIik7Q2MoZCk7T2YoZCxlKX19fWJyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOldmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmI9Yy52YWx1ZSxudWxsIT1iJiZTZihhLCEhYy5tdWx0aXBsZSxiLCExKX19fSk7bmMuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudCh3Zyk7dmFyIHhnPW51bGwsTWc9bnVsbDtmdW5jdGlvbiBOZyhhKXtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZSYmOSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZSYmKDghPT1hLm5vZGVUeXBlfHxcIiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSBcIiE9PWEubm9kZVZhbHVlKSl9XG5mdW5jdGlvbiBPZyhhKXthPWE/OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkOm51bGw7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGV8fCFhLmhhc0F0dHJpYnV0ZShcImRhdGEtcmVhY3Ryb290XCIpKX1cbnZhciBaPW9mKHtnZXRSb290SG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlVHlwZTtzd2l0Y2goYil7Y2FzZSA5OmNhc2UgMTE6YT0oYT1hLmRvY3VtZW50RWxlbWVudCk/YS5uYW1lc3BhY2VVUkk6JGYobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmI9OD09PWI/YS5wYXJlbnROb2RlOmEsYT1iLm5hbWVzcGFjZVVSSXx8bnVsbCxiPWIudGFnTmFtZSxhPSRmKGEsYil9cmV0dXJuIGF9LGdldENoaWxkSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gJGYoYSxiKX0sZ2V0UHVibGljSW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHByZXBhcmVGb3JDb21taXQ6ZnVuY3Rpb24oKXt4Zz10ZDt2YXIgYT1kYSgpO2lmKEtkKGEpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBhKXZhciBiPXtzdGFydDphLnNlbGVjdGlvblN0YXJ0LGVuZDphLnNlbGVjdGlvbkVuZH07ZWxzZSBhOnt2YXIgYz13aW5kb3cuZ2V0U2VsZWN0aW9uJiZ3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5pZihjJiYwIT09Yy5yYW5nZUNvdW50KXtiPWMuYW5jaG9yTm9kZTt2YXIgZD1jLmFuY2hvck9mZnNldCxlPWMuZm9jdXNOb2RlO2M9Yy5mb2N1c09mZnNldDt0cnl7Yi5ub2RlVHlwZSxlLm5vZGVUeXBlfWNhdGNoKHope2I9bnVsbDticmVhayBhfXZhciBmPTAsZz0tMSxoPS0xLGs9MCxxPTAsdj1hLHk9bnVsbDtiOmZvcig7Oyl7Zm9yKHZhciB1Ozspe3YhPT1ifHwwIT09ZCYmMyE9PXYubm9kZVR5cGV8fChnPWYrZCk7diE9PWV8fDAhPT1jJiYzIT09di5ub2RlVHlwZXx8KGg9ZitjKTszPT09di5ub2RlVHlwZSYmKGYrPXYubm9kZVZhbHVlLmxlbmd0aCk7aWYobnVsbD09PSh1PXYuZmlyc3RDaGlsZCkpYnJlYWs7eT12O3Y9dX1mb3IoOzspe2lmKHY9PT1hKWJyZWFrIGI7eT09PWImJisraz09PWQmJihnPWYpO3k9PT1lJiYrK3E9PT1jJiYoaD1mKTtpZihudWxsIT09KHU9di5uZXh0U2libGluZykpYnJlYWs7dj15O3k9di5wYXJlbnROb2RlfXY9dX1iPS0xPT09Z3x8LTE9PT1oP251bGw6XG57c3RhcnQ6ZyxlbmQ6aH19ZWxzZSBiPW51bGx9Yj1ifHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBiPW51bGw7TWc9e2ZvY3VzZWRFbGVtOmEsc2VsZWN0aW9uUmFuZ2U6Yn07dWQoITEpfSxyZXNldEFmdGVyQ29tbWl0OmZ1bmN0aW9uKCl7dmFyIGE9TWcsYj1kYSgpLGM9YS5mb2N1c2VkRWxlbSxkPWEuc2VsZWN0aW9uUmFuZ2U7aWYoYiE9PWMmJmZhKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjKSl7aWYoS2QoYykpaWYoYj1kLnN0YXJ0LGE9ZC5lbmQsdm9pZCAwPT09YSYmKGE9YiksXCJzZWxlY3Rpb25TdGFydFwiaW4gYyljLnNlbGVjdGlvblN0YXJ0PWIsYy5zZWxlY3Rpb25FbmQ9TWF0aC5taW4oYSxjLnZhbHVlLmxlbmd0aCk7ZWxzZSBpZih3aW5kb3cuZ2V0U2VsZWN0aW9uKXtiPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTt2YXIgZT1jW0ViKCldLmxlbmd0aDthPU1hdGgubWluKGQuc3RhcnQsZSk7ZD12b2lkIDA9PT1kLmVuZD9hOk1hdGgubWluKGQuZW5kLGUpOyFiLmV4dGVuZCYmYT5cbmQmJihlPWQsZD1hLGE9ZSk7ZT1KZChjLGEpO3ZhciBmPUpkKGMsZCk7aWYoZSYmZiYmKDEhPT1iLnJhbmdlQ291bnR8fGIuYW5jaG9yTm9kZSE9PWUubm9kZXx8Yi5hbmNob3JPZmZzZXQhPT1lLm9mZnNldHx8Yi5mb2N1c05vZGUhPT1mLm5vZGV8fGIuZm9jdXNPZmZzZXQhPT1mLm9mZnNldCkpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7Zy5zZXRTdGFydChlLm5vZGUsZS5vZmZzZXQpO2IucmVtb3ZlQWxsUmFuZ2VzKCk7YT5kPyhiLmFkZFJhbmdlKGcpLGIuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihnLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLGIuYWRkUmFuZ2UoZykpfX1iPVtdO2ZvcihhPWM7YT1hLnBhcmVudE5vZGU7KTE9PT1hLm5vZGVUeXBlJiZiLnB1c2goe2VsZW1lbnQ6YSxsZWZ0OmEuc2Nyb2xsTGVmdCx0b3A6YS5zY3JvbGxUb3B9KTtpYShjKTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWE9YltjXSxhLmVsZW1lbnQuc2Nyb2xsTGVmdD1hLmxlZnQsYS5lbGVtZW50LnNjcm9sbFRvcD1cbmEudG9wfU1nPW51bGw7dWQoeGcpO3hnPW51bGx9LGNyZWF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YT1uZyhhLGIsYyxkKTthW1FdPWU7YVtvYl09YjtyZXR1cm4gYX0sYXBwZW5kSW5pdGlhbENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sZmluYWxpemVJbml0aWFsQ2hpbGRyZW46ZnVuY3Rpb24oYSxiLGMsZCl7cGcoYSxiLGMsZCk7YTp7c3dpdGNoKGIpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6YT0hIWMuYXV0b0ZvY3VzO2JyZWFrIGF9YT0hMX1yZXR1cm4gYX0scHJlcGFyZVVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBzZyhhLGIsYyxkLGUpfSxzaG91bGRTZXRUZXh0Q29udGVudDpmdW5jdGlvbihhLGIpe3JldHVyblwidGV4dGFyZWFcIj09PWF8fFwic3RyaW5nXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJudW1iZXJcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm9iamVjdFwiPT09XG50eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwic3RyaW5nXCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9LHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWIuaGlkZGVufSxjcmVhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCl7YT1vZyhhLGIpO2FbUV09ZDtyZXR1cm4gYX0sbm93OnJmLG11dGF0aW9uOntjb21taXRNb3VudDpmdW5jdGlvbihhKXthLmZvY3VzKCl9LGNvbW1pdFVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe2Fbb2JdPWU7dGcoYSxiLGMsZCxlKX0scmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXthLnRleHRDb250ZW50PVwiXCJ9LGNvbW1pdFRleHRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMpe2Eubm9kZVZhbHVlPWN9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjpmdW5jdGlvbihhLFxuYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEpOmEuYXBwZW5kQ2hpbGQoYil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihhLGIsYyl7YS5pbnNlcnRCZWZvcmUoYixjKX0saW5zZXJ0SW5Db250YWluZXJCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixjKTphLmluc2VydEJlZm9yZShiLGMpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihhLGIpe2EucmVtb3ZlQ2hpbGQoYil9LHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTphLnJlbW92ZUNoaWxkKGIpfX0saHlkcmF0aW9uOntjYW5IeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMSE9PWEubm9kZVR5cGV8fGIudG9Mb3dlckNhc2UoKSE9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT9udWxsOmF9LGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3JldHVyblwiXCI9PT1ifHwzIT09YS5ub2RlVHlwZT9udWxsOmF9LGdldE5leHRIeWRyYXRhYmxlU2libGluZzpmdW5jdGlvbihhKXtmb3IoYT1hLm5leHRTaWJsaW5nO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7YVtRXT1mO2Fbb2JdPWM7cmV0dXJuIHVnKGEsYixjLGUsZCl9LGh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2FbUV09YztyZXR1cm4gdmcoYSxiKX0sZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sXG5kaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fX0sc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOnNmLGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6dGYsdXNlU3luY1NjaGVkdWxpbmc6ITB9KTtyYz1aLmJhdGNoZWRVcGRhdGVzO1xuZnVuY3Rpb24gUGcoYSxiLGMsZCxlKXtOZyhjKT92b2lkIDA6RShcIjIwMFwiKTt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZilaLnVwZGF0ZUNvbnRhaW5lcihiLGYsYSxlKTtlbHNle2Q9ZHx8T2coYyk7aWYoIWQpZm9yKGY9dm9pZCAwO2Y9Yy5sYXN0Q2hpbGQ7KWMucmVtb3ZlQ2hpbGQoZik7dmFyIGc9Wi5jcmVhdGVDb250YWluZXIoYyxkKTtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1nO1oudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1oudXBkYXRlQ29udGFpbmVyKGIsZyxhLGUpfSl9cmV0dXJuIFouZ2V0UHVibGljUm9vdEluc3RhbmNlKGYpfWZ1bmN0aW9uIFFnKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7TmcoYik/dm9pZCAwOkUoXCIyMDBcIik7cmV0dXJuIHBmKGEsYixudWxsLGMpfVxuZnVuY3Rpb24gUmcoYSxiKXt0aGlzLl9yZWFjdFJvb3RDb250YWluZXI9Wi5jcmVhdGVDb250YWluZXIoYSxiKX1SZy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsYil7Wi51cGRhdGVDb250YWluZXIoYSx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxiKX07UmcucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oYSl7Wi51cGRhdGVDb250YWluZXIobnVsbCx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxhKX07XG52YXIgU2c9e2NyZWF0ZVBvcnRhbDpRZyxmaW5kRE9NTm9kZTpmdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjtpZihiKXJldHVybiBaLmZpbmRIb3N0SW5zdGFuY2UoYik7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyP0UoXCIxODhcIik6RShcIjIxM1wiLE9iamVjdC5rZXlzKGEpKX0saHlkcmF0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCEwLGMpfSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQZyhudWxsLGEsYiwhMSxjKX0sdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbD09YXx8dm9pZCAwPT09YS5fcmVhY3RJbnRlcm5hbEZpYmVyP0UoXCIzOFwiKTp2b2lkIDA7cmV0dXJuIFBnKGEsYixjLCExLGQpfSx1bm1vdW50Q29tcG9uZW50QXROb2RlOmZ1bmN0aW9uKGEpe05nKGEpP3ZvaWQgMDpcbkUoXCI0MFwiKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtQZyhudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsfSl9KSwhMCk6ITF9LHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDpRZyx1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczp0Yyx1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6Wi5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOlouZmx1c2hTeW5jLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntFdmVudFBsdWdpbkh1YjptYixFdmVudFBsdWdpblJlZ2lzdHJ5OlZhLEV2ZW50UHJvcGFnYXRvcnM6Q2IsUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OnFjLFJlYWN0RE9NQ29tcG9uZW50VHJlZTpzYixSZWFjdERPTUV2ZW50TGlzdGVuZXI6eGR9fTtcblouaW5qZWN0SW50b0RldlRvb2xzKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpwYixidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE2LjIuMFwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn0pO3ZhciBUZz1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlNnfSksVWc9VGcmJlNnfHxUZzttb2R1bGUuZXhwb3J0cz1VZ1tcImRlZmF1bHRcIl0/VWdbXCJkZWZhdWx0XCJdOlVnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7QnJvd3NlclJvdXRlciwgUm91dGUsIFN3aXRjaH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCBcIi4uL3N0eWxlcy9tYWluLnNjc3NcIjtcclxuXHJcbmltcG9ydCBIb21lIGZyb20gXCIuL2NvbXBvbmVudHMvaG9tZVwiO1xyXG5pbXBvcnQgTmF2QmFyIGZyb20gXCIuL2NvbXBvbmVudHMvbmF2YmFyXCJcclxuaW1wb3J0IFRhaWwgZnJvbSBcIi4vY29tcG9uZW50cy90YWlsXCJcclxuaW1wb3J0IFNjaGVkdWxlIGZyb20gXCIuL2NvbXBvbmVudHMvc2NoZWR1bGVcIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGlzRW5nbGlzaDogdHJ1ZVxyXG4gICAgfTtcclxuICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UgPSB0aGlzLmNoYW5nZUxhbmd1YWdlLmJpbmQodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgZ2V0RW5nbGlzaEhvbWUoKSB7XHJcbiAgICByZXR1cm4gPEhvbWUgaXNFbmdsaXNoPXt0cnVlfS8+O1xyXG4gIH1cclxuXHJcbiAgZ2V0VHVya2lzaEhvbWUoKSB7XHJcbiAgICByZXR1cm4gPEhvbWUgaXNFbmdsaXNoPXtmYWxzZX0vPjtcclxuICB9XHJcblxyXG4gIGdldEVuZ2xpc2hTY2hlZHVsZSgpIHtcclxuICAgIHJldHVybiA8U2NoZWR1bGUgaXNFbmdsaXNoPXt0cnVlfS8+O1xyXG4gIH1cclxuXHJcbiAgZ2V0VHVya2lzaFNjaGVkdWxlKCkge1xyXG4gICAgcmV0dXJuIDxTY2hlZHVsZSBpc0VuZ2xpc2g9e2ZhbHNlfS8+O1xyXG4gIH1cclxuXHJcbiAgY2hhbmdlTGFuZ3VhZ2UoaXNFbmdsaXNoKXtcclxuICAgIHRoaXMuc2V0U3RhdGUoe2lzRW5nbGlzaH0pO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuIDxCcm93c2VyUm91dGVyPlxyXG4gICAgICA8ZGl2IGlkPVwiYXBwbGljYXRpb24tY29udGFpbmVyXCI+XHJcbiAgICAgICAgPE5hdkJhciBpc0VuZ2xpc2g9e3RoaXMuc3RhdGUuaXNFbmdsaXNofSBjaGFuZ2VMYW5ndWFnZT17dGhpcy5jaGFuZ2VMYW5ndWFnZX0vPlxyXG4gICAgICAgIDxTd2l0Y2g+XHJcbiAgICAgICAgICA8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiBjb21wb25lbnQ9e3RoaXMuZ2V0RW5nbGlzaEhvbWV9Lz5cclxuICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL3RyXCIgY29tcG9uZW50PXt0aGlzLmdldFR1cmtpc2hIb21lfS8+XHJcbiAgICAgICAgICA8Um91dGUgcGF0aD1cIi9lblwiIGNvbXBvbmVudD17dGhpcy5nZXRFbmdsaXNoSG9tZX0vPlxyXG4gICAgICAgICAgPFJvdXRlIHBhdGg9XCIvZW4vc2NoZWR1bGVcIiBjb21wb25lbnQ9e3RoaXMuZ2V0RW5nbGlzaFNjaGVkdWxlfS8+XHJcbiAgICAgICAgICA8Um91dGUgcGF0aD1cIi90ci9zY2hlZHVsZVwiIGNvbXBvbmVudD17dGhpcy5nZXRUdXJraXNoU2NoZWR1bGV9Lz5cclxuICAgICAgICA8L1N3aXRjaD5cclxuICAgICAgICA8VGFpbCBpc0VuZ2xpc2g9e3RoaXMuc3RhdGUuaXNFbmdsaXNofSBjaGFuZ2VMYW5ndWFnZT17dGhpcy5jaGFuZ2VMYW5ndWFnZX0vPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvQnJvd3NlclJvdXRlcj5cclxuICB9XHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4vamF2YXNjcmlwdC9hcHAuanN4IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJvd3NlclJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkpKCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UpKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/ICgwLCBfUGF0aFV0aWxzLnN0cmlwVHJhaWxpbmdTbGFzaCkoKDAsIF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoKShwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoKDAsIF9ET01VdGlscy5pc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KShldmVudCkpIHJldHVybjtcblxuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaGFzaGJhbmcnLCAnbm9zbGFzaCcsICdzbGFzaCddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArICgwLCBfUGF0aFV0aWxzLnN0cmlwTGVhZGluZ1NsYXNoKShwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKSgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFsoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgbG9jYXRpb24gaW4gbWVtb3J5LlxuICovXG5cbnZhciBNZW1vcnlSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTWVtb3J5Um91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW1vcnlSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8TWVtb3J5Um91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IE1lbW9yeVJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbW9yeVJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTWVtb3J5Um91dGVyLnByb3BUeXBlcyA9IHtcbiAgaW5pdGlhbEVudHJpZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5pbXBvcnQgTGluayBmcm9tICcuL0xpbmsnO1xuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG52YXIgTmF2TGluayA9IGZ1bmN0aW9uIE5hdkxpbmsoX3JlZikge1xuICB2YXIgdG8gPSBfcmVmLnRvLFxuICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgZ2V0SXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxuICAgICAgYXJpYUN1cnJlbnQgPSBfcmVmLmFyaWFDdXJyZW50LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvJywgJ2V4YWN0JywgJ3N0cmljdCcsICdsb2NhdGlvbicsICdhY3RpdmVDbGFzc05hbWUnLCAnY2xhc3NOYW1lJywgJ2FjdGl2ZVN0eWxlJywgJ3N0eWxlJywgJ2lzQWN0aXZlJywgJ2FyaWFDdXJyZW50J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgcGF0aDogKHR5cGVvZiB0byA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodG8pKSA9PT0gJ29iamVjdCcgPyB0by5wYXRobmFtZSA6IHRvLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKF9yZWYyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfcmVmMi5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaCA9IF9yZWYyLm1hdGNoO1xuXG4gICAgICB2YXIgaXNBY3RpdmUgPSAhIShnZXRJc0FjdGl2ZSA/IGdldElzQWN0aXZlKG1hdGNoLCBsb2NhdGlvbikgOiBtYXRjaCk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHtcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBjbGFzc05hbWU6IGlzQWN0aXZlID8gW2NsYXNzTmFtZSwgYWN0aXZlQ2xhc3NOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkuam9pbignICcpIDogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogaXNBY3RpdmUgPyBfZXh0ZW5kcyh7fSwgc3R5bGUsIGFjdGl2ZVN0eWxlKSA6IHN0eWxlLFxuICAgICAgICAnYXJpYS1jdXJyZW50JzogaXNBY3RpdmUgJiYgYXJpYUN1cnJlbnRcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICBhcmlhQ3VycmVudDogUHJvcFR5cGVzLm9uZU9mKFsncGFnZScsICdzdGVwJywgJ2xvY2F0aW9uJywgJ3RydWUnXSlcbn07XG5cbk5hdkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICBhY3RpdmVDbGFzc05hbWU6ICdhY3RpdmUnLFxuICBhcmlhQ3VycmVudDogJ3RydWUnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOYXZMaW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzYXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUHJvbXB0IGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQnO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHByb21wdGluZyB0aGUgdXNlciBiZWZvcmUgbmF2aWdhdGluZyBhd2F5XG4gKiBmcm9tIGEgc2NyZWVuIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFByb21wdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm9tcHQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFByb21wdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvbXB0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHRoaXMudW5ibG9jaygpO1xuXG4gICAgdGhpcy51bmJsb2NrID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmJsb2NrKG1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykge1xuICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICB0aGlzLnVuYmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8UHJvbXB0PiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIGlmICh0aGlzLnByb3BzLndoZW4pIHRoaXMuZW5hYmxlKHRoaXMucHJvcHMubWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLndoZW4pIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy53aGVuIHx8IHRoaXMucHJvcHMubWVzc2FnZSAhPT0gbmV4dFByb3BzLm1lc3NhZ2UpIHRoaXMuZW5hYmxlKG5leHRQcm9wcy5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJvbXB0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qcm9tcHQucHJvcFR5cGVzID0ge1xuICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgbWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKS5pc1JlcXVpcmVkXG59O1xuUHJvbXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgd2hlbjogdHJ1ZVxufTtcblByb21wdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgYmxvY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUmVkaXJlY3QgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnaGlzdG9yeSc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHVwZGF0aW5nIHRoZSBsb2NhdGlvbiBwcm9ncmFtbWF0aWNhbGx5XG4gKiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBSZWRpcmVjdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSZWRpcmVjdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVkaXJlY3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZGlyZWN0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24gaXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZXIgJiYgdGhpcy5jb250ZXh0LnJvdXRlci5zdGF0aWNDb250ZXh0O1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJlZGlyZWN0PiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIGlmICh0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBwcmV2VG8gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuICAgIHZhciBuZXh0VG8gPSBjcmVhdGVMb2NhdGlvbih0aGlzLnByb3BzLnRvKTtcblxuICAgIGlmIChsb2NhdGlvbnNBcmVFcXVhbChwcmV2VG8sIG5leHRUbykpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdZb3UgdHJpZWQgdG8gcmVkaXJlY3QgdG8gdGhlIHNhbWUgcm91dGUgeW91XFwncmUgY3VycmVudGx5IG9uOiAnICsgKCdcIicgKyBuZXh0VG8ucGF0aG5hbWUgKyBuZXh0VG8uc2VhcmNoICsgJ1wiJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gcGVyZm9ybSgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcHVzaCA9IF9wcm9wcy5wdXNoLFxuICAgICAgICB0byA9IF9wcm9wcy50bztcblxuXG4gICAgaWYgKHB1c2gpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgfVxuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlZGlyZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gIHB1c2g6IFByb3BUeXBlcy5ib29sLFxuICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWRcbn07XG5SZWRpcmVjdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHB1c2g6IGZhbHNlXG59O1xuUmVkaXJlY3QuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGZyb20gJy4vY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGFzIGNyZWF0ZUJyb3dzZXJIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZUhhc2hIaXN0b3J5IGZyb20gJy4vY3JlYXRlSGFzaEhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUhhc2hIaXN0b3J5IGFzIGNyZWF0ZUhhc2hIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgZnJvbSAnLi9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGFzIGNyZWF0ZU1lbW9yeUhpc3RvcnkgfTtcblxuZXhwb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmV4cG9ydCB7IHBhcnNlUGF0aCwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgY3JlYXRlUGF0aCwgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeS9QYXRoVXRpbHMnO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbnZhciBub3JtYWxpemVMb2NhdGlvbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uKG9iamVjdCkge1xuICB2YXIgX29iamVjdCRwYXRobmFtZSA9IG9iamVjdC5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lID0gX29iamVjdCRwYXRobmFtZSA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29iamVjdCRwYXRobmFtZSxcbiAgICAgIF9vYmplY3Qkc2VhcmNoID0gb2JqZWN0LnNlYXJjaCxcbiAgICAgIHNlYXJjaCA9IF9vYmplY3Qkc2VhcmNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3Qkc2VhcmNoLFxuICAgICAgX29iamVjdCRoYXNoID0gb2JqZWN0Lmhhc2gsXG4gICAgICBoYXNoID0gX29iamVjdCRoYXNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3QkaGFzaDtcblxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG5cbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aChsb2NhdGlvbikgOiBub3JtYWxpemVMb2NhdGlvbihsb2NhdGlvbik7XG59O1xuXG52YXIgY3JlYXRlVVJMID0gZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn07XG5cbnZhciBzdGF0aWNIYW5kbGVyID0gZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+JywgbWV0aG9kTmFtZSk7XG4gIH07XG59O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiBUaGUgcHVibGljIHRvcC1sZXZlbCBBUEkgZm9yIGEgXCJzdGF0aWNcIiA8Um91dGVyPiwgc28tY2FsbGVkIGJlY2F1c2UgaXRcbiAqIGNhbid0IGFjdHVhbGx5IGNoYW5nZSB0aGUgY3VycmVudCBsb2NhdGlvbi4gSW5zdGVhZCwgaXQganVzdCByZWNvcmRzXG4gKiBsb2NhdGlvbiBjaGFuZ2VzIGluIGEgY29udGV4dCBvYmplY3QuIFVzZWZ1bCBtYWlubHkgaW4gdGVzdGluZyBhbmRcbiAqIHNlcnZlci1yZW5kZXJpbmcgc2NlbmFyaW9zLlxuICovXG5cbnZhciBTdGF0aWNSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhdGljUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGF0aWNSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0aWNSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdTbGFzaChfdGhpcy5wcm9wcy5iYXNlbmFtZSArIGNyZWF0ZVVSTChwYXRoKSk7XG4gICAgfSwgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUFVTSCc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZUxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiB7XG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuY29udGV4dFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBTdGF0aWNSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBiYXNlbmFtZSA9IF9wcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgY29udGV4dCA9IF9wcm9wcy5jb250ZXh0LFxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2Jhc2VuYW1lJywgJ2NvbnRleHQnLCAnbG9jYXRpb24nXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IHRoaXMuY3JlYXRlSHJlZixcbiAgICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgICBsb2NhdGlvbjogc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKSxcbiAgICAgIHB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIHJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGdvOiBzdGF0aWNIYW5kbGVyKCdnbycpLFxuICAgICAgZ29CYWNrOiBzdGF0aWNIYW5kbGVyKCdnb0JhY2snKSxcbiAgICAgIGdvRm9yd2FyZDogc3RhdGljSGFuZGxlcignZ29Gb3J3YXJkJyksXG4gICAgICBsaXN0ZW46IHRoaXMuaGFuZGxlTGlzdGVuLFxuICAgICAgYmxvY2s6IHRoaXMuaGFuZGxlQmxvY2tcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgaGlzdG9yeTogaGlzdG9yeSB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY1JvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3RhdGljUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxufTtcblN0YXRpY1JvdXRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGJhc2VuYW1lOiAnJyxcbiAgbG9jYXRpb246ICcvJ1xufTtcblN0YXRpY1JvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgU3dpdGNoIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Td2l0Y2gnO1xuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgZXhhY3QgPSBfZWxlbWVudCRwcm9wcy5leGFjdCxcbiAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgc2Vuc2l0aXZlID0gX2VsZW1lbnQkcHJvcHMuc2Vuc2l0aXZlLFxuICAgICAgICAgIGZyb20gPSBfZWxlbWVudCRwcm9wcy5mcm9tO1xuXG4gICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIGV4YWN0OiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGgnO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgd2l0aFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluL3N0eWxlcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IGN1bHR1cmVQaWMgZnJvbSAnLi4vLi4vcmVzb3VyY2VzL3N0YXRpYy9pbWFnZXMvc2l4R3JpZC9jdWx0dXJlLmpwZyc7XHJcbmltcG9ydCBsYW5kc2NhcGVQaWMgZnJvbSAnLi4vLi4vcmVzb3VyY2VzL3N0YXRpYy9pbWFnZXMvc2l4R3JpZC9sYW5kc2NhcGUuanBnJztcclxuaW1wb3J0IGxvZGdlUGljIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvbG9kZ2VQYXJhZGlzZS5qcGcnO1xyXG5pbXBvcnQgc2FmYXJpUGljIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvc2FmYXJpLmpwZyc7XHJcbmltcG9ydCB7TGlua30gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCBhZnJpY2FNYXAgZnJvbSAnLi4vLi4vcmVzb3VyY2VzL3N0YXRpYy92ZWN0b3JzL2FmcmljYU1hcCc7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9tZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcblxyXG4gIGdldExhbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJsYW5kaW5nLWltYWdlLWNvbnRhaW5lclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImxhbmRpbmctaW1hZ2VcIiBpZD1cImxhbmRpbmctaW1hZ2UtbW9iaWxlXCIvPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImxhbmRpbmctY2FwdGlvblwiPnt0aGlzLnByb3BzLmlzRW5nbGlzaCA/IFwiTmFtaWJpYVwiIDogXCJOYW1pYnlhXCJ9PC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmFja2dyb3VuZC1sYXllclwiLz5cclxuICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtY2FyZXQtZG93blwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiLz5cclxuICAgIDwvZGl2PlxyXG4gIH07XHJcblxyXG4gIGdldE5hbWliaWFEZXNjKCkge1xyXG4gICAgbGV0IGlzRW5nbGlzaCA9IHRoaXMucHJvcHMuaXNFbmdsaXNoO1xyXG4gICAgbGV0IG5hbWliaWFEZXNjID0ge1xyXG4gICAgICB0cnVlOiB7XHJcbiAgICAgICAgMDogXCJXZSB0cmF2ZWwgbG9va2luZyBmb3Igb3Vyc2VsdmVzLlwiLFxyXG4gICAgICAgIDE6IFwiV2UgbG9uZyBmb3Igd2hlcmUgd2UgY2FtZSBmcm9tLlwiLFxyXG4gICAgICAgIDI6IFwiTmFtaWJpYSBpcyBub3QganVzdCBhIHBsYWNlIGJ1dCBpdCdzIGEgc2Vuc2F0aW9uXCIsXHJcbiAgICAgICAgMzogXCJUaGUgdG91Y2ggb2Ygd2lsZGVybmVzcyByZWtpbmRsZXNcIixcclxuICAgICAgICA0OiBcIm91ciBzZW5zZSBvZiBiZWxvbmdpbmcgdG8gbmF0dXJlLlwiLFxyXG4gICAgICAgIDU6IFwiVGhlIE5hbWliIGRlc2VydCxcIixcclxuICAgICAgICA2OiBcInRoZSByaWNoIGVjb3N5c3RlbSB3aXRoIHVudXN1YWwgcGxhbnRzLFwiLFxyXG4gICAgICAgIDc6IFwibW9ub2xpdGhzLCBjYXZlcywgc2lua2hvbGVzLCB3YXRlcmZhbGxzLFwiLFxyXG4gICAgICAgIDg6IFwibGFrZXMgbW9ycGggaW50byBhIHVuaXF1ZSBzZW5zZSBvZiBOYW1pYmlhbiBpZGVudGl0eS5cIixcclxuICAgICAgICA5OiBcIlRoaW5rIGFib3V0IGl0LiBUaGluZ3Mgd2lsbCBub3QgYmUgc2FtZSBhcyBiZWZvcmUuXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGZhbHNlOiB7XHJcbiAgICAgICAgMDogXCJLZW5kaW1pemUgYmFrbWFrIGnDp2luIHNleWFoYXQgZWRpeW9ydXouXCIsXHJcbiAgICAgICAgMTogXCJOZXJlZGVuIGdlbGRpxJ9pbWl6aSB1enVuIHPDvHJlIGJla2xpeW9ydXouXCIsXHJcbiAgICAgICAgMjogXCJOYW1pYnlhIHNhZGVjZSBiaXIgeWVyIGRlxJ9pbCwgYXluxLEgemFtYW5kYSBiaXIgc2Fuc2FzeW9uXCIsXHJcbiAgICAgICAgMzogXCJWYWjFn2kgZG/En2FuxLFuIGRva3VudcWfbGFyxLEgeWVuaWRlbiBjYW5sYW7EsXJcIixcclxuICAgICAgICA0OiBcImRvxJ9heWEgYWlkIG9sbWEgZHV5Z3VtdXouXCIsXHJcbiAgICAgICAgNTogXCJOYW1pYiDDp8O2bMO8bsO8biBlbmdpbmxpxJ9pLFwiLFxyXG4gICAgICAgIDY6IFwib2xhxJ9hbmTEscWfxLEgYml0a2lsZXJsZSB6ZW5naW4gZWtvc2lzdGVtLFwiLFxyXG4gICAgICAgIDc6IFwibW9ub2xpdGxlciwgbWHEn2FyYWxhciwgZMO8ZGVuc2xlciwgxZ9lbGFsZWxlcixcIixcclxuICAgICAgICA4OiBcImfDtmxsZXIsIE5hbWlieWEga2ltbGnEn2luaW4gZcWfc2l6IGJpciBhbmxhbWRhIG1vcnBoLlwiLFxyXG4gICAgICAgIDk6IFwiQnVudSBkw7zFn8O8bi4gSGVyIMWfZXkgZXNraXNpIGdpYmkgb2xtYXlhY2FrLlwiLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJuYW1pYmlhLWRlc2NyaXB0aW9uLWNvbnRhaW5lclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hbWliaWEtZGVzY3JpcHRpb25cIj5cclxuICAgICAgICB7bmFtaWJpYURlc2NbaXNFbmdsaXNoXVswXX08YnIvPlxyXG4gICAgICAgIHtuYW1pYmlhRGVzY1tpc0VuZ2xpc2hdWzFdfTxici8+XHJcbiAgICAgICAgPGI+e25hbWliaWFEZXNjW2lzRW5nbGlzaF1bMl19PC9iPjxici8+XHJcbiAgICAgICAge25hbWliaWFEZXNjW2lzRW5nbGlzaF1bM119PGJyLz5cclxuICAgICAgICB7bmFtaWJpYURlc2NbaXNFbmdsaXNoXVs0XX08YnIvPlxyXG4gICAgICAgIDxiPntuYW1pYmlhRGVzY1tpc0VuZ2xpc2hdWzldfTwvYj48YnIvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXAtY29udGFpbmVyXCI+XHJcbiAgICAgICAge2FmcmljYU1hcCgpfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIH1cclxuXHJcbiAgZ2V0UXVvdGUoKSB7XHJcbiAgICBsZXQgaXNFbmdsaXNoID0gdGhpcy5wcm9wcy5pc0VuZ2xpc2g7XHJcbiAgICBsZXQgcXVvdGVIZWxwZXIgPSB7XHJcbiAgICAgIHRydWU6IHtcclxuICAgICAgICAwOiBcIkkgbmV2ZXIga25ldyBvZiBhIG1vcm5pbmcgaW4gQWZyaWNhXCIsXHJcbiAgICAgICAgMTogXCJ3aGVuIEkgd29rZSB1cCB0aGF0IEkgd2FzIG5vdCBoYXBweS5cIixcclxuICAgICAgICAyOiBcIlRydWUgYXQgRmlyc3QgTGlnaHRcIixcclxuICAgICAgICAzOiBcImJ5IEVybmVzdCBIZW1pbmd3YXlcIlxyXG4gICAgICB9LFxyXG4gICAgICBmYWxzZToge1xyXG4gICAgICAgIDA6IFwiQmlyIHNhYmFoIGJpbG1lZGltIGtpXCIsXHJcbiAgICAgICAgMTogXCJBZnJpa2EnZGEgaHV6dXJsYSB1eWFubWFkxLHEn8SxbS5cIixcclxuICAgICAgICAyOiBcIkfDvG7DvG4gxLBsayBJxZ/EscSfxLFuZGEgR2Vyw6dla1wiLFxyXG4gICAgICAgIDM6IFwiRXJuZXN0IEhlbWluZ3dheVwiXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInF1b3RlLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicXVvdGUtY292ZXJcIj5cclxuICAgICAgICAgIHtxdW90ZUhlbHBlcltpc0VuZ2xpc2hdWzBdfSA8YnIvPiB7cXVvdGVIZWxwZXJbaXNFbmdsaXNoXVsxXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicXVvdGUtYXV0aG9yXCI+XHJcbiAgICAgICAgICA8aT57cXVvdGVIZWxwZXJbaXNFbmdsaXNoXVsyXX08L2k+IHtxdW90ZUhlbHBlcltpc0VuZ2xpc2hdWzNdfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgfTtcclxuXHJcbiAgZ2V0T25seUluTmFtaWJpYSgpIHtcclxuICAgIGxldCBpc0VuZ2xpc2ggPSB0aGlzLnByb3BzLmlzRW5nbGlzaDtcclxuICAgIGxldCBvbmx5SW5OYW1pYmlhUXVvdGUgPSB7XHJcbiAgICAgIHRydWU6IHtcclxuICAgICAgICAwOiBcIlRyaXAgSW5zcGlyYXRpb25zXCIsXHJcbiAgICAgICAgMTogXCJPdXIgU2NoZWR1bGVcIixcclxuICAgICAgfSxcclxuICAgICAgZmFsc2U6IHtcclxuICAgICAgICAwOiBcIkdlemkgxLBsaGFtbGFyxLFcIixcclxuICAgICAgICAxOiBcIlByb2dyYW3EsW3EsXpcIixcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBsaW5rUHJlZml4ID0gaXNFbmdsaXNoID8gXCJlblwiIDogXCJ0clwiO1xyXG5cclxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cIm5hbWliaWEtYWN0aXZpdGllcy1oZWFkZXJcIj5cclxuICAgICAge29ubHlJbk5hbWliaWFRdW90ZVtpc0VuZ2xpc2hdWzBdfVxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdvLXRvLXJlY29tbWVuZGF0aW9uXCI+XHJcbiAgICAgICAgPExpbmsgY2xhc3NOYW1lPVwiZ28tdG8tcmVjb21tZW5kYXRpb24tdGV4dFwiIHRvPXtcIi9cIiArIGxpbmtQcmVmaXggKyBcIi9zY2hlZHVsZVwifT5cclxuICAgICAgICAgIHtvbmx5SW5OYW1pYmlhUXVvdGVbaXNFbmdsaXNoXVsxXX1cclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgfVxyXG5cclxuICBnZXRHcmlkKCkge1xyXG4gICAgbGV0IGlzRW5nbGlzaCA9IHRoaXMucHJvcHMuaXNFbmdsaXNoO1xyXG4gICAgbGV0IGFjdGl2aXRpZXNIZWFkZXIgPSB7XHJcbiAgICAgIHRydWU6IHtcclxuICAgICAgICAwOiBcIkN1bHR1cmFsIEV4Y3Vyc2lvbnNcIixcclxuICAgICAgICAxOiBcIldpbGRlcm5lc3NcIixcclxuICAgICAgICAyOiBcIlNhZmFyaVwiLFxyXG4gICAgICAgIDM6IFwiTG9kZ2UgUGFyYWRpc2VcIixcclxuICAgICAgfSxcclxuICAgICAgZmFsc2U6IHtcclxuICAgICAgICAwOiBcIkvDvGx0w7xyIEdlemludGlsZXJpXCIsXHJcbiAgICAgICAgMTogXCJEb8SfYSDDp8O2bFwiLFxyXG4gICAgICAgIDI6IFwiU2FmYXJpXCIsXHJcbiAgICAgICAgMzogXCJMb2RnZSBQYXJhZGlzZVwiLFxyXG4gICAgICB9LFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInNpeC1ncmlkXCI+XHJcbiAgICAgIDxmaWd1cmU+XHJcbiAgICAgICAgPGltZyBzcmM9e2N1bHR1cmVQaWN9IGFsdD1cIlRoZSBQdWxwaXQgUm9ja1wiLz5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBpY0NhcHRpb25cIj5DdWx0dXJhbCBFeGN1cnNpb25zPC9kaXY+XHJcbiAgICAgIDwvZmlndXJlPlxyXG5cclxuICAgICAgPGZpZ3VyZT5cclxuICAgICAgICA8aW1nIHNyYz17bGFuZHNjYXBlUGljfSBhbHQ9XCJUaGUgUHVscGl0IFJvY2tcIi8+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwaWNDYXB0aW9uXCI+V2lsZGVybmVzczwvZGl2PlxyXG4gICAgICA8L2ZpZ3VyZT5cclxuXHJcbiAgICAgIDxmaWd1cmU+XHJcbiAgICAgICAgPGltZyBzcmM9e3NhZmFyaVBpY30gYWx0PVwiVGhlIFB1bHBpdCBSb2NrXCIvPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGljQ2FwdGlvblwiPlNhZmFyaTwvZGl2PlxyXG4gICAgICA8L2ZpZ3VyZT5cclxuXHJcbiAgICAgIDxmaWd1cmU+XHJcbiAgICAgICAgPGltZyBzcmM9e2xvZGdlUGljfSBhbHQ9XCJUaGUgUHVscGl0IFJvY2tcIi8+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwaWNDYXB0aW9uXCI+TG9kZ2UgUGFyYWRpc2U8L2Rpdj5cclxuICAgICAgPC9maWd1cmU+XHJcblxyXG4gICAgPC9kaXY+XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJob21lLWNvbnRhaW5lclwiPlxyXG4gICAgICB7dGhpcy5nZXRMYW5kaW5nKCl9XHJcbiAgICAgIHt0aGlzLmdldFF1b3RlKCl9XHJcbiAgICAgIHt0aGlzLmdldE5hbWliaWFEZXNjKCl9XHJcbiAgICAgIHt0aGlzLmdldE9ubHlJbk5hbWliaWEoKX1cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkQ29udGFpbmVyXCI+XHJcbiAgICAgICAge3RoaXMuZ2V0R3JpZCgpfVxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZENvdmVyXCI+PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+O1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluL2phdmFzY3JpcHQvY29tcG9uZW50cy9ob21lLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7TGlua30gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCBlbmdsaXNoRmxhZyBmcm9tICcuLi8uLi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9mbGFncy9lbmdsaXNoX2ZsYWcucG5nJztcclxuaW1wb3J0IHR1cmtpc2hGbGFnIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL2ZsYWdzL3R1cmtpc2hfZmxhZy5wbmcnO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5hdkJhcih7aXNFbmdsaXNoLCBjaGFuZ2VMYW5ndWFnZX0pIHtcclxuXHJcbiAgbGV0IGxpbmtQcmVmaXggPSBpc0VuZ2xpc2ggPyBcImVuXCIgOiBcInRyXCI7XHJcblxyXG4gIGNvbnN0IGdldExvZ28gPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItbG9nb1wiPlxyXG4gICAgICA8c3Bhbj48c3BhbiBjbGFzc05hbWU9XCJuYXZiYXItbG9nby1ib2xkXCI+RVVSQVNJQTwvc3Bhbj4gVE9VUklTTSA8L3NwYW4+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF2YmFyLWRhdGVcIj5zaW5jZSAxOTkxPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXROYXZiYXJUb3AgPSAoKSA9PiB7XHJcbiAgICBsZXQgYWJvdXRVc0hlbHBlciA9IE9iamVjdC5hc3NpZ24oe30sXHJcbiAgICAgIHt0cnVlOiB7MDogXCJBYm91dCBVc1wiLCAxOiBcIkNvbnRhY3QgVXNcIn19LFxyXG4gICAgICB7ZmFsc2U6IHswOiBcIkhha2vEsW3EsXpkYVwiLCAxOiBcIklsZXRpxZ9pbVwifX0pO1xyXG5cclxuICAgIHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJuYXZiYXItYWJvdXQtdXNcIj48dWw+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9iaWxlLXRvcC1sZWZ0XCI+XHJcbiAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2YmFyLXVzLWNvbnRhaW5lclwiPjxMaW5rIHRvPXtgJHtsaW5rUHJlZml4fS9hYm91dC11c2B9IGNsYXNzTmFtZT1cIm5hdmJhci11c1wiPnthYm91dFVzSGVscGVyW2lzRW5nbGlzaF1bMF19PC9MaW5rPjwvbGk+XHJcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdmJhci11cy1jb250YWluZXJcIj48TGluayB0bz17YCR7bGlua1ByZWZpeH0vY29udGFjdC11c2B9IGNsYXNzTmFtZT1cIm5hdmJhci11c1wiPnthYm91dFVzSGVscGVyW2lzRW5nbGlzaF1bMV19PC9MaW5rPjwvbGk+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vYmlsZS10b3AtcmlnaHRcIj5cclxuICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2YmFyLWZsYWctY29udGFpbmVyXCI+PExpbmsgdG89XCIvdHJcIiBvbkNsaWNrPXsoKSA9PiBjaGFuZ2VMYW5ndWFnZShmYWxzZSl9PjxpbWcgY2xhc3NOYW1lPVwibmF2YmFyLWZsYWdcIiBzcmM9e3R1cmtpc2hGbGFnfS8+PC9MaW5rPjwvbGk+XHJcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdmJhci1mbGFnLWNvbnRhaW5lclwiPjxMaW5rIHRvPVwiL2VuXCIgb25DbGljaz17KCkgPT4gY2hhbmdlTGFuZ3VhZ2UodHJ1ZSl9PjxpbWcgY2xhc3NOYW1lPVwibmF2YmFyLWZsYWdcIiBzcmM9e2VuZ2xpc2hGbGFnfS8+PC9MaW5rPjwvbGk+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC91bD48L3NwYW4+XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0TWVudUl0ZW1zID0gKCkgPT4ge1xyXG4gICAgbGV0IG1lbnVJdGVtc0hlbHBlciA9IE9iamVjdC5hc3NpZ24oe30sXHJcbiAgICAgIHt0cnVlOiB7MDogXCJQbGFjZXMgdG8gR29cIiwgMTogXCJUaGluZ3MgdG8gRG9cIiwgMjogXCJUcmF2ZWwgQmxvZ1wifX0sXHJcbiAgICAgIHtmYWxzZTogezA6IFwiR2lkZWNla2xlcmltaXpcIiwgMTogXCJZYXBhY2FrbGFyxLFtxLF6XCIsIDI6IFwiWW9sY3VsdWtsYXLEsW3EsXpcIn19KTtcclxuXHJcbiAgICByZXR1cm4gPHNwYW4gY2xhc3NOYW1lPVwibmF2YmFyLXRvZ28taXRlbXNcIj48dWw+XHJcbiAgICAgIDxsaT48TGluayB0bz17YCR7bGlua1ByZWZpeH0vcGxhY2VzLXRvLWdvYH0+e21lbnVJdGVtc0hlbHBlcltpc0VuZ2xpc2hdWzBdfTwvTGluaz48L2xpPlxyXG4gICAgICA8bGk+PExpbmsgdG89e2Ake2xpbmtQcmVmaXh9L3RoaW5ncy10by1kb2B9PnttZW51SXRlbXNIZWxwZXJbaXNFbmdsaXNoXVsxXX08L0xpbms+PC9saT5cclxuICAgICAgPGxpPjxMaW5rIHRvPXtgJHtsaW5rUHJlZml4fS90cmF2ZWwtYmxvZ2B9PnttZW51SXRlbXNIZWxwZXJbaXNFbmdsaXNoXVsyXX08L0xpbms+PC9saT5cclxuICAgIDwvdWw+PC9zcGFuPlxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoPGRpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItbGVmdFwiPlxyXG4gICAgICAgICAge2dldExvZ28oKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdmJhci1yaWdodFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItdG9wXCI+XHJcbiAgICAgICAgICAgIHtnZXROYXZiYXJUb3AoKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAge2dldE1lbnVJdGVtcygpfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibmF2YmFyLWNvbnRhaW5lclwiIGlkPVwiZGlzcGxheS1jaGFuZ2VzLWZvci1tb2JpbGVcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2JpbGUtbmF2XCIgaWQ9XCJtb2JpbGUtbmF2LXdlYi1kaXNhcHBlYXJcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdmJhci1sZWZ0XCI+XHJcbiAgICAgICAgICB7Z2V0TG9nbygpfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF2YmFyLXJpZ2h0XCIgaWQ9XCJuYXZiYXItcmlnaHQtbW9iaWxlLWRpc2FwcGVhclwiPlxyXG4gICAgICAgICAge2dldE5hdmJhclRvcCgpfVxyXG4gICAgICAgICAge2dldE1lbnVJdGVtcygpfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4vamF2YXNjcmlwdC9jb21wb25lbnRzL25hdmJhci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge0xpbmt9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQgZW5nbGlzaEZsYWcgZnJvbSAnLi4vLi4vcmVzb3VyY2VzL3N0YXRpYy9pbWFnZXMvZmxhZ3MvZW5nbGlzaF9mbGFnLnBuZyc7XHJcbmltcG9ydCB0dXJraXNoRmxhZyBmcm9tICcuLi8uLi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9mbGFncy90dXJraXNoX2ZsYWcucG5nJztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWlsKHtpc0VuZ2xpc2gsIGNoYW5nZUxhbmd1YWdlfSkge1xyXG5cclxuICBsZXQgbGlua1ByZWZpeCA9IGlzRW5nbGlzaCA/IFwiZW5cIiA6IFwidHJcIjtcclxuXHJcbiAgY29uc3QgZ2V0TG9nbyA9ICgpID0+IHtcclxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cIm5hdmJhci1sb2dvXCI+XHJcbiAgICAgIDxzcGFuPjxzcGFuIGNsYXNzTmFtZT1cIm5hdmJhci1sb2dvLWJvbGRcIj5FVVJBU0lBPC9zcGFuPiBUT1VSSVNNIDwvc3Bhbj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItZGF0ZVwiPnNpbmNlIDE5OTE8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldFRhaWxJdGVtcyA9ICgpID0+IHtcclxuICAgIGxldCB0YWlsSXRlbXNIZWxwZXIgPSBPYmplY3QuYXNzaWduKHt9LFxyXG4gICAgICB7dHJ1ZTogezA6IFwiRGVzdGluYXRpb25zXCIsIDE6IFwiRXhwZXJ0c1wiLCAyOiBcIk5ld3MgTGV0dGVyXCIsIDM6IFwiQ29udGFjdCBVc1wifX0sXHJcbiAgICAgIHtmYWxzZTogezA6IFwiR2lkaWxlY2VrXCIsIDE6IFwiVXptYW5sYXJcIiwgMjogXCJCw7xsdGVuZVwiLCAzOiBcIklsZXRpxZ9pbVwifX0pO1xyXG5cclxuICAgIHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJuYXZiYXItbWVudS1pdGVtc1wiPlxyXG4gICAgPHVsIGNsYXNzTmFtZT1cIm5hdmJhci1tZW51LWNvbnRhaW5lclwiPlxyXG4gICAgICA8bGkgY2xhc3NOYW1lPVwidGFpbC1taWRkbGUtbWVudVwiPnt0YWlsSXRlbXNIZWxwZXJbaXNFbmdsaXNoXVswXX08L2xpPlxyXG4gICAgICA8bGkgY2xhc3NOYW1lPVwidGFpbC1taWRkbGUtbWVudVwiPnt0YWlsSXRlbXNIZWxwZXJbaXNFbmdsaXNoXVsxXX08L2xpPlxyXG4gICAgICA8bGkgY2xhc3NOYW1lPVwidGFpbC1taWRkbGUtbWVudVwiPnt0YWlsSXRlbXNIZWxwZXJbaXNFbmdsaXNoXVsyXX08L2xpPlxyXG4gICAgICA8bGkgY2xhc3NOYW1lPVwidGFpbC1taWRkbGUtbWVudVwiPnt0YWlsSXRlbXNIZWxwZXJbaXNFbmdsaXNoXVszXX08L2xpPlxyXG4gICAgPC91bD5cclxuICAgIDwvc3Bhbj5cclxuICB9O1xyXG5cclxuICBjb25zdCBzb2NpYWxGYXZpY29ucyA9ICgpID0+IHtcclxuICAgIGxldCBmYXZpY29uTGlua0hlbHBlciA9IE9iamVjdC5hc3NpZ24oe30sXHJcbiAgICAgIHtpbnN0YWdyYW1MaW5rOiBcImh0dHBzOi8vd3d3Lmluc3RhZ3JhbS5jb20vZXVyYXNpYV90b3VyaXNtL1wiLFxyXG4gICAgICBmYWNlYm9vazogXCJodHRwczovL3d3dy5mYWNlYm9vay5jb20vZXVyYXNpYS50b3VyaXNtXCIsXHJcbiAgICAgIHdoYXRzQXBwOiBcImh0dHBzOi8vYXBpLndoYXRzYXBwLmNvbS9zZW5kP3Bob25lPTkwNTUzNjA5OTA0M1wiLFxyXG4gICAgICBwaG9uZU51bWJlcjogXCJ0ZWw6KzkwMjEyMzY5MzY0MFwiLH1cclxuICAgIClcclxuICAgIGxldCBmYXZpY29uSXRlbXNIZWxwZXIgPSBPYmplY3QuYXNzaWduKHt9LFxyXG4gICAgICB7aW5zdGFncmFtRmF2aWNvbjogXCJmYSBmYS1pbnN0YWdyYW1cIixcclxuICAgICAgZmFjZWJvb2tGYXZpY29uOiBcImZhIGZhLWZhY2Vib29rLXNxdWFyZVwiLFxyXG4gICAgICB3aGF0c0FwcEZhdmljb246IFwiZmEgZmEtd2hhdHNhcHBcIixcclxuICAgICAgcGhvbmVOdW1iZXJGYXZpY29uOiBcImZhIGZhLXBob25lLXNxdWFyZVwiLH0sXHJcbiAgICApXHJcblxyXG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibmF2YmFyLWJvdHRvbS1jb250YWluZXJcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYXZpY29uLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9e2Ake2Zhdmljb25MaW5rSGVscGVyW1wiaW5zdGFncmFtTGlua1wiXX1gfSBjbGFzc05hbWU9XCJmYXZpY29uXCI+XHJcbiAgICAgICAgICA8aSBjbGFzc05hbWU9e2Zhdmljb25JdGVtc0hlbHBlcltcImluc3RhZ3JhbUZhdmljb25cIl19YXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cclxuICAgICAgICA8L2E+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZhdmljb24tY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17YCR7ZmF2aWNvbkxpbmtIZWxwZXJbXCJmYWNlYm9va0Zhdmljb25cIl19YH0gY2xhc3NOYW1lPVwiZmF2aWNvblwiPlxyXG4gICAgICAgICAgPGkgY2xhc3NOYW1lPXtmYXZpY29uSXRlbXNIZWxwZXJbXCJmYWNlYm9va0Zhdmljb25cIl19YXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cclxuICAgICAgICA8L2E+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZhdmljb24tY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17YCR7ZmF2aWNvbkxpbmtIZWxwZXJbXCJ3aGF0c0FwcFwiXX1gfSBjbGFzc05hbWU9XCJmYXZpY29uXCI+XHJcbiAgICAgICAgICA8aSBjbGFzc05hbWU9e2Zhdmljb25JdGVtc0hlbHBlcltcIndoYXRzQXBwRmF2aWNvblwiXX1hcmlhLWhpZGRlbj1cInRydWVcIiAvPlxyXG4gICAgICAgIDwvYT5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmF2aWNvbi1jb250YWluZXJcIj5cclxuICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPXtgJHtmYXZpY29uTGlua0hlbHBlcltcInBob25lTnVtYmVyXCJdfWB9IGNsYXNzTmFtZT1cImZhdmljb25cIj5cclxuICAgICAgICAgIDxpIGNsYXNzTmFtZT17ZmF2aWNvbkl0ZW1zSGVscGVyW1wicGhvbmVOdW1iZXJGYXZpY29uXCJdfWFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XHJcbiAgICAgICAgPC9hPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwidGFpbC1jb250YWluZXJcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0YWlsLXRvcFwiPlxyXG4gICAgICAgIHtnZXRMb2dvKCl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhaWwtbWlkZGxlXCI+XHJcbiAgICAgICAge2dldFRhaWxJdGVtcygpfVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAge3NvY2lhbEZhdmljb25zKCl9XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi9qYXZhc2NyaXB0L2NvbXBvbmVudHMvdGFpbC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBjdWx0dXJlUGljIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvY3VsdHVyZS5qcGcnO1xyXG5pbXBvcnQgbGFuZHNjYXBlUGljIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvaW1hZ2VzL3NpeEdyaWQvbGFuZHNjYXBlLmpwZyc7XHJcbmltcG9ydCBsb2RnZVBpYyBmcm9tICcuLi8uLi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9zaXhHcmlkL2xvZGdlUGFyYWRpc2UuanBnJztcclxuaW1wb3J0IHNhZmFyaVBpYyBmcm9tICcuLi8uLi9yZXNvdXJjZXMvc3RhdGljL2ltYWdlcy9zaXhHcmlkL3NhZmFyaS5qcGcnO1xyXG5pbXBvcnQge0xpbmt9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQgYWZyaWNhTWFwIGZyb20gJy4uLy4uL3Jlc291cmNlcy9zdGF0aWMvdmVjdG9ycy9hZnJpY2FNYXAnO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjaGVkdWxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgZ2V0UXVvdGUoKSB7XHJcbiAgICBsZXQgaXNFbmdsaXNoID0gdGhpcy5wcm9wcy5pc0VuZ2xpc2g7XHJcbiAgICBsZXQgcXVvdGVIZWxwZXIgPSB7XHJcbiAgICAgIHRydWU6IHtcclxuICAgICAgICAwOiBcIkkgbmV2ZXIga25ldyBvZiBhIG1vcm5pbmcgaW4gQWZyaWNhXCIsXHJcbiAgICAgICAgMTogXCJ3aGVuIEkgd29rZSB1cCB0aGF0IEkgd2FzIG5vdCBoYXBweS5cIixcclxuICAgICAgICAyOiBcIlRydWUgYXQgRmlyc3QgTGlnaHRcIixcclxuICAgICAgICAzOiBcImJ5IEVybmVzdCBIZW1pbmd3YXlcIlxyXG4gICAgICB9LFxyXG4gICAgICBmYWxzZToge1xyXG4gICAgICAgIDA6IFwiQmlyIHNhYmFoIGJpbG1lZGltIGtpXCIsXHJcbiAgICAgICAgMTogXCJBZnJpa2EnZGEgaHV6dXJsYSB1eWFubWFkxLHEn8SxbS5cIixcclxuICAgICAgICAyOiBcIkfDvG7DvG4gxLBsayBJxZ/EscSfxLFuZGEgR2Vyw6dla1wiLFxyXG4gICAgICAgIDM6IFwiRXJuZXN0IEhlbWluZ3dheVwiXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInF1b3RlLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicXVvdGUtY292ZXJcIj5cclxuICAgICAgICAgIHtxdW90ZUhlbHBlcltpc0VuZ2xpc2hdWzBdfSA8YnIvPiB7cXVvdGVIZWxwZXJbaXNFbmdsaXNoXVsxXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicXVvdGUtYXV0aG9yXCI+XHJcbiAgICAgICAgICA8aT57cXVvdGVIZWxwZXJbaXNFbmdsaXNoXVsyXX08L2k+IHtxdW90ZUhlbHBlcltpc0VuZ2xpc2hdWzNdfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwiaG9tZS1jb250YWluZXJcIj5cclxuICAgICAgXCJIZWxsbyBXb3JsZFwiXHJcbiAgICAgIHt0aGlzLmdldFF1b3RlKCl9XHJcbiAgICA8L2Rpdj47XHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4vamF2YXNjcmlwdC9jb21wb25lbnRzL3NjaGVkdWxlLmpzeCJdLCJzb3VyY2VSb290IjoiIn0=